(function () {
  (window["webpackJsonp"] = window["webpackJsonp"] || []).push([["echarts"], {
    /***/
    "+lIL":
    /*!***************************************************!*\
      !*** ./node_modules/echarts/lib/chart/boxplot.js ***!
      \***************************************************/

    /*! no static exports found */

    /***/
    function lIL(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ./boxplot/BoxplotSeries */
      "/ry/");

      __webpack_require__(
      /*! ./boxplot/BoxplotView */
      "3OrL");

      var boxplotVisual = __webpack_require__(
      /*! ./boxplot/boxplotVisual */
      "L5E0");

      var boxplotLayout = __webpack_require__(
      /*! ./boxplot/boxplotLayout */
      "7Phj");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      echarts.registerVisual(boxplotVisual);
      echarts.registerLayout(boxplotLayout);
      /***/
    },

    /***/
    "+rIm":
    /*!****************************************************************!*\
      !*** ./node_modules/echarts/lib/component/axis/AxisBuilder.js ***!
      \****************************************************************/

    /*! no static exports found */

    /***/
    function rIm(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _util = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var retrieve = _util.retrieve;
      var defaults = _util.defaults;
      var extend = _util.extend;
      var each = _util.each;

      var formatUtil = __webpack_require__(
      /*! ../../util/format */
      "7aKB");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var Model = __webpack_require__(
      /*! ../../model/Model */
      "Qxkt");

      var _number = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var isRadianAroundZero = _number.isRadianAroundZero;
      var remRadian = _number.remRadian;

      var _symbol = __webpack_require__(
      /*! ../../util/symbol */
      "oVpE");

      var createSymbol = _symbol.createSymbol;

      var matrixUtil = __webpack_require__(
      /*! zrender/lib/core/matrix */
      "Fofx");

      var _vector = __webpack_require__(
      /*! zrender/lib/core/vector */
      "QBsz");

      var v2ApplyTransform = _vector.applyTransform;

      var _axisHelper = __webpack_require__(
      /*! ../../coord/axisHelper */
      "aX7z");

      var shouldShowAllLabels = _axisHelper.shouldShowAllLabels;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var PI = Math.PI;
      /**
       * A final axis is translated and rotated from a "standard axis".
       * So opt.position and opt.rotation is required.
       *
       * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],
       * for example: (0, 0) ------------> (0, 50)
       *
       * nameDirection or tickDirection or labelDirection is 1 means tick
       * or label is below the standard axis, whereas is -1 means above
       * the standard axis. labelOffset means offset between label and axis,
       * which is useful when 'onZero', where axisLabel is in the grid and
       * label in outside grid.
       *
       * Tips: like always,
       * positive rotation represents anticlockwise, and negative rotation
       * represents clockwise.
       * The direction of position coordinate is the same as the direction
       * of screen coordinate.
       *
       * Do not need to consider axis 'inverse', which is auto processed by
       * axis extent.
       *
       * @param {module:zrender/container/Group} group
       * @param {Object} axisModel
       * @param {Object} opt Standard axis parameters.
       * @param {Array.<number>} opt.position [x, y]
       * @param {number} opt.rotation by radian
       * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.
       * @param {number} [opt.tickDirection=1] 1 or -1
       * @param {number} [opt.labelDirection=1] 1 or -1
       * @param {number} [opt.labelOffset=0] Usefull when onZero.
       * @param {string} [opt.axisLabelShow] default get from axisModel.
       * @param {string} [opt.axisName] default get from axisModel.
       * @param {number} [opt.axisNameAvailableWidth]
       * @param {number} [opt.labelRotate] by degree, default get from axisModel.
       * @param {number} [opt.strokeContainThreshold] Default label interval when label
       * @param {number} [opt.nameTruncateMaxWidth]
       */

      var AxisBuilder = function AxisBuilder(axisModel, opt) {
        /**
         * @readOnly
         */
        this.opt = opt;
        /**
         * @readOnly
         */

        this.axisModel = axisModel; // Default value

        defaults(opt, {
          labelOffset: 0,
          nameDirection: 1,
          tickDirection: 1,
          labelDirection: 1,
          silent: true
        });
        /**
         * @readOnly
         */

        this.group = new graphic.Group(); // FIXME Not use a seperate text group?

        var dumbGroup = new graphic.Group({
          position: opt.position.slice(),
          rotation: opt.rotation
        }); // this.group.add(dumbGroup);
        // this._dumbGroup = dumbGroup;

        dumbGroup.updateTransform();
        this._transform = dumbGroup.transform;
        this._dumbGroup = dumbGroup;
      };

      AxisBuilder.prototype = {
        constructor: AxisBuilder,
        hasBuilder: function hasBuilder(name) {
          return !!builders[name];
        },
        add: function add(name) {
          builders[name].call(this);
        },
        getGroup: function getGroup() {
          return this.group;
        }
      };
      var builders = {
        /**
         * @private
         */
        axisLine: function axisLine() {
          var opt = this.opt;
          var axisModel = this.axisModel;

          if (!axisModel.get('axisLine.show')) {
            return;
          }

          var extent = this.axisModel.axis.getExtent();
          var matrix = this._transform;
          var pt1 = [extent[0], 0];
          var pt2 = [extent[1], 0];

          if (matrix) {
            v2ApplyTransform(pt1, pt1, matrix);
            v2ApplyTransform(pt2, pt2, matrix);
          }

          var lineStyle = extend({
            lineCap: 'round'
          }, axisModel.getModel('axisLine.lineStyle').getLineStyle());
          this.group.add(new graphic.Line({
            // Id for animation
            anid: 'line',
            subPixelOptimize: true,
            shape: {
              x1: pt1[0],
              y1: pt1[1],
              x2: pt2[0],
              y2: pt2[1]
            },
            style: lineStyle,
            strokeContainThreshold: opt.strokeContainThreshold || 5,
            silent: true,
            z2: 1
          }));
          var arrows = axisModel.get('axisLine.symbol');
          var arrowSize = axisModel.get('axisLine.symbolSize');
          var arrowOffset = axisModel.get('axisLine.symbolOffset') || 0;

          if (typeof arrowOffset === 'number') {
            arrowOffset = [arrowOffset, arrowOffset];
          }

          if (arrows != null) {
            if (typeof arrows === 'string') {
              // Use the same arrow for start and end point
              arrows = [arrows, arrows];
            }

            if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {
              // Use the same size for width and height
              arrowSize = [arrowSize, arrowSize];
            }

            var symbolWidth = arrowSize[0];
            var symbolHeight = arrowSize[1];
            each([{
              rotate: opt.rotation + Math.PI / 2,
              offset: arrowOffset[0],
              r: 0
            }, {
              rotate: opt.rotation - Math.PI / 2,
              offset: arrowOffset[1],
              r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))
            }], function (point, index) {
              if (arrows[index] !== 'none' && arrows[index] != null) {
                var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true); // Calculate arrow position with offset

                var r = point.r + point.offset;
                var pos = [pt1[0] + r * Math.cos(opt.rotation), pt1[1] - r * Math.sin(opt.rotation)];
                symbol.attr({
                  rotation: point.rotate,
                  position: pos,
                  silent: true,
                  z2: 11
                });
                this.group.add(symbol);
              }
            }, this);
          }
        },

        /**
         * @private
         */
        axisTickLabel: function axisTickLabel() {
          var axisModel = this.axisModel;
          var opt = this.opt;
          var ticksEls = buildAxisMajorTicks(this, axisModel, opt);
          var labelEls = buildAxisLabel(this, axisModel, opt);
          fixMinMaxLabelShow(axisModel, labelEls, ticksEls);
          buildAxisMinorTicks(this, axisModel, opt);
        },

        /**
         * @private
         */
        axisName: function axisName() {
          var opt = this.opt;
          var axisModel = this.axisModel;
          var name = retrieve(opt.axisName, axisModel.get('name'));

          if (!name) {
            return;
          }

          var nameLocation = axisModel.get('nameLocation');
          var nameDirection = opt.nameDirection;
          var textStyleModel = axisModel.getModel('nameTextStyle');
          var gap = axisModel.get('nameGap') || 0;
          var extent = this.axisModel.axis.getExtent();
          var gapSignal = extent[0] > extent[1] ? -1 : 1;
          var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // 'middle'
          // Reuse labelOffset.
          isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];
          var labelLayout;
          var nameRotation = axisModel.get('nameRotate');

          if (nameRotation != null) {
            nameRotation = nameRotation * PI / 180; // To radian.
          }

          var axisNameAvailableWidth;

          if (isNameLocationCenter(nameLocation)) {
            labelLayout = innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.
            nameDirection);
          } else {
            labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);
            axisNameAvailableWidth = opt.axisNameAvailableWidth;

            if (axisNameAvailableWidth != null) {
              axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));
              !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
            }
          }

          var textFont = textStyleModel.getFont();
          var truncateOpt = axisModel.get('nameTruncate', true) || {};
          var ellipsis = truncateOpt.ellipsis;
          var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth); // FIXME
          // truncate rich text? (consider performance)

          var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {
            minChar: 2,
            placeholder: truncateOpt.placeholder
          }) : name;
          var tooltipOpt = axisModel.get('tooltip', true);
          var mainType = axisModel.mainType;
          var formatterParams = {
            componentType: mainType,
            name: name,
            $vars: ['name']
          };
          formatterParams[mainType + 'Index'] = axisModel.componentIndex;
          var textEl = new graphic.Text({
            // Id for animation
            anid: 'name',
            __fullText: name,
            __truncatedText: truncatedText,
            position: pos,
            rotation: labelLayout.rotation,
            silent: isLabelSilent(axisModel),
            z2: 1,
            tooltip: tooltipOpt && tooltipOpt.show ? extend({
              content: name,
              formatter: function formatter() {
                return name;
              },
              formatterParams: formatterParams
            }, tooltipOpt) : null
          });
          graphic.setTextStyle(textEl.style, textStyleModel, {
            text: truncatedText,
            textFont: textFont,
            textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),
            textAlign: textStyleModel.get('align') || labelLayout.textAlign,
            textVerticalAlign: textStyleModel.get('verticalAlign') || labelLayout.textVerticalAlign
          });

          if (axisModel.get('triggerEvent')) {
            textEl.eventData = makeAxisEventDataBase(axisModel);
            textEl.eventData.targetType = 'axisName';
            textEl.eventData.name = name;
          } // FIXME


          this._dumbGroup.add(textEl);

          textEl.updateTransform();
          this.group.add(textEl);
          textEl.decomposeTransform();
        }
      };

      var makeAxisEventDataBase = AxisBuilder.makeAxisEventDataBase = function (axisModel) {
        var eventData = {
          componentType: axisModel.mainType,
          componentIndex: axisModel.componentIndex
        };
        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;
        return eventData;
      };
      /**
       * @public
       * @static
       * @param {Object} opt
       * @param {number} axisRotation in radian
       * @param {number} textRotation in radian
       * @param {number} direction
       * @return {Object} {
       *  rotation, // according to axis
       *  textAlign,
       *  textVerticalAlign
       * }
       */


      var innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {
        var rotationDiff = remRadian(textRotation - axisRotation);
        var textAlign;
        var textVerticalAlign;

        if (isRadianAroundZero(rotationDiff)) {
          // Label is parallel with axis line.
          textVerticalAlign = direction > 0 ? 'top' : 'bottom';
          textAlign = 'center';
        } else if (isRadianAroundZero(rotationDiff - PI)) {
          // Label is inverse parallel with axis line.
          textVerticalAlign = direction > 0 ? 'bottom' : 'top';
          textAlign = 'center';
        } else {
          textVerticalAlign = 'middle';

          if (rotationDiff > 0 && rotationDiff < PI) {
            textAlign = direction > 0 ? 'right' : 'left';
          } else {
            textAlign = direction > 0 ? 'left' : 'right';
          }
        }

        return {
          rotation: rotationDiff,
          textAlign: textAlign,
          textVerticalAlign: textVerticalAlign
        };
      };

      function endTextLayout(opt, textPosition, textRotate, extent) {
        var rotationDiff = remRadian(textRotate - opt.rotation);
        var textAlign;
        var textVerticalAlign;
        var inverse = extent[0] > extent[1];
        var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;

        if (isRadianAroundZero(rotationDiff - PI / 2)) {
          textVerticalAlign = onLeft ? 'bottom' : 'top';
          textAlign = 'center';
        } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {
          textVerticalAlign = onLeft ? 'top' : 'bottom';
          textAlign = 'center';
        } else {
          textVerticalAlign = 'middle';

          if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {
            textAlign = onLeft ? 'left' : 'right';
          } else {
            textAlign = onLeft ? 'right' : 'left';
          }
        }

        return {
          rotation: rotationDiff,
          textAlign: textAlign,
          textVerticalAlign: textVerticalAlign
        };
      }

      var isLabelSilent = AxisBuilder.isLabelSilent = function (axisModel) {
        var tooltipOpt = axisModel.get('tooltip');
        return axisModel.get('silent') // Consider mouse cursor, add these restrictions.
        || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);
      };

      function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
        if (shouldShowAllLabels(axisModel.axis)) {
          return;
        } // If min or max are user set, we need to check
        // If the tick on min(max) are overlap on their neighbour tick
        // If they are overlapped, we need to hide the min(max) tick label


        var showMinLabel = axisModel.get('axisLabel.showMinLabel');
        var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); // FIXME
        // Have not consider onBand yet, where tick els is more than label els.

        labelEls = labelEls || [];
        tickEls = tickEls || [];
        var firstLabel = labelEls[0];
        var nextLabel = labelEls[1];
        var lastLabel = labelEls[labelEls.length - 1];
        var prevLabel = labelEls[labelEls.length - 2];
        var firstTick = tickEls[0];
        var nextTick = tickEls[1];
        var lastTick = tickEls[tickEls.length - 1];
        var prevTick = tickEls[tickEls.length - 2];

        if (showMinLabel === false) {
          ignoreEl(firstLabel);
          ignoreEl(firstTick);
        } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
          if (showMinLabel) {
            ignoreEl(nextLabel);
            ignoreEl(nextTick);
          } else {
            ignoreEl(firstLabel);
            ignoreEl(firstTick);
          }
        }

        if (showMaxLabel === false) {
          ignoreEl(lastLabel);
          ignoreEl(lastTick);
        } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
          if (showMaxLabel) {
            ignoreEl(prevLabel);
            ignoreEl(prevTick);
          } else {
            ignoreEl(lastLabel);
            ignoreEl(lastTick);
          }
        }
      }

      function ignoreEl(el) {
        el && (el.ignore = true);
      }

      function isTwoLabelOverlapped(current, next, labelLayout) {
        // current and next has the same rotation.
        var firstRect = current && current.getBoundingRect().clone();
        var nextRect = next && next.getBoundingRect().clone();

        if (!firstRect || !nextRect) {
          return;
        } // When checking intersect of two rotated labels, we use mRotationBack
        // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.


        var mRotationBack = matrixUtil.identity([]);
        matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);
        firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));
        nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));
        return firstRect.intersect(nextRect);
      }

      function isNameLocationCenter(nameLocation) {
        return nameLocation === 'middle' || nameLocation === 'center';
      }

      function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, aniid) {
        var tickEls = [];
        var pt1 = [];
        var pt2 = [];

        for (var i = 0; i < ticksCoords.length; i++) {
          var tickCoord = ticksCoords[i].coord;
          pt1[0] = tickCoord;
          pt1[1] = 0;
          pt2[0] = tickCoord;
          pt2[1] = tickEndCoord;

          if (tickTransform) {
            v2ApplyTransform(pt1, pt1, tickTransform);
            v2ApplyTransform(pt2, pt2, tickTransform);
          } // Tick line, Not use group transform to have better line draw


          var tickEl = new graphic.Line({
            // Id for animation
            anid: aniid + '_' + ticksCoords[i].tickValue,
            subPixelOptimize: true,
            shape: {
              x1: pt1[0],
              y1: pt1[1],
              x2: pt2[0],
              y2: pt2[1]
            },
            style: tickLineStyle,
            z2: 2,
            silent: true
          });
          tickEls.push(tickEl);
        }

        return tickEls;
      }

      function buildAxisMajorTicks(axisBuilder, axisModel, opt) {
        var axis = axisModel.axis;
        var tickModel = axisModel.getModel('axisTick');

        if (!tickModel.get('show') || axis.scale.isBlank()) {
          return;
        }

        var lineStyleModel = tickModel.getModel('lineStyle');
        var tickEndCoord = opt.tickDirection * tickModel.get('length');
        var ticksCoords = axis.getTicksCoords();
        var ticksEls = createTicks(ticksCoords, axisBuilder._transform, tickEndCoord, defaults(lineStyleModel.getLineStyle(), {
          stroke: axisModel.get('axisLine.lineStyle.color')
        }), 'ticks');

        for (var i = 0; i < ticksEls.length; i++) {
          axisBuilder.group.add(ticksEls[i]);
        }

        return ticksEls;
      }

      function buildAxisMinorTicks(axisBuilder, axisModel, opt) {
        var axis = axisModel.axis;
        var minorTickModel = axisModel.getModel('minorTick');

        if (!minorTickModel.get('show') || axis.scale.isBlank()) {
          return;
        }

        var minorTicksCoords = axis.getMinorTicksCoords();

        if (!minorTicksCoords.length) {
          return;
        }

        var lineStyleModel = minorTickModel.getModel('lineStyle');
        var tickEndCoord = opt.tickDirection * minorTickModel.get('length');
        var minorTickLineStyle = defaults(lineStyleModel.getLineStyle(), defaults(axisModel.getModel('axisTick').getLineStyle(), {
          stroke: axisModel.get('axisLine.lineStyle.color')
        }));

        for (var i = 0; i < minorTicksCoords.length; i++) {
          var minorTicksEls = createTicks(minorTicksCoords[i], axisBuilder._transform, tickEndCoord, minorTickLineStyle, 'minorticks_' + i);

          for (var k = 0; k < minorTicksEls.length; k++) {
            axisBuilder.group.add(minorTicksEls[k]);
          }
        }
      }

      function buildAxisLabel(axisBuilder, axisModel, opt) {
        var axis = axisModel.axis;
        var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));

        if (!show || axis.scale.isBlank()) {
          return;
        }

        var labelModel = axisModel.getModel('axisLabel');
        var labelMargin = labelModel.get('margin');
        var labels = axis.getViewLabels(); // Special label rotate.

        var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;
        var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
        var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);
        var labelEls = [];
        var silent = isLabelSilent(axisModel);
        var triggerEvent = axisModel.get('triggerEvent');
        each(labels, function (labelItem, index) {
          var tickValue = labelItem.tickValue;
          var formattedLabel = labelItem.formattedLabel;
          var rawLabel = labelItem.rawLabel;
          var itemLabelModel = labelModel;

          if (rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle) {
            itemLabelModel = new Model(rawCategoryData[tickValue].textStyle, labelModel, axisModel.ecModel);
          }

          var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');
          var tickCoord = axis.dataToCoord(tickValue);
          var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];
          var textEl = new graphic.Text({
            // Id for animation
            anid: 'label_' + tickValue,
            position: pos,
            rotation: labelLayout.rotation,
            silent: silent,
            z2: 10
          });
          graphic.setTextStyle(textEl.style, itemLabelModel, {
            text: formattedLabel,
            textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,
            textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,
            textFill: typeof textColor === 'function' ? textColor( // (1) In category axis with data zoom, tick is not the original
            // index of axis.data. So tick should not be exposed to user
            // in category axis.
            // (2) Compatible with previous version, which always use formatted label as
            // input. But in interval scale the formatted label is like '223,445', which
            // maked user repalce ','. So we modify it to return original val but remain
            // it as 'string' to avoid error in replacing.
            axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor
          }); // Pack data for mouse event

          if (triggerEvent) {
            textEl.eventData = makeAxisEventDataBase(axisModel);
            textEl.eventData.targetType = 'axisLabel';
            textEl.eventData.value = rawLabel;
          } // FIXME


          axisBuilder._dumbGroup.add(textEl);

          textEl.updateTransform();
          labelEls.push(textEl);
          axisBuilder.group.add(textEl);
          textEl.decomposeTransform();
        });
        return labelEls;
      }

      var _default = AxisBuilder;
      module.exports = _default;
      /***/
    },

    /***/
    "/IIm":
    /*!**********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/helper/BrushController.js ***!
      \**********************************************************************/

    /*! no static exports found */

    /***/
    function IIm(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var Eventful = __webpack_require__(
      /*! zrender/lib/mixin/Eventful */
      "H6uX");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var interactionMutex = __webpack_require__(
      /*! ./interactionMutex */
      "pP6R");

      var DataDiffer = __webpack_require__(
      /*! ../../data/DataDiffer */
      "gPAo");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var curry = zrUtil.curry;
      var each = zrUtil.each;
      var map = zrUtil.map;
      var mathMin = Math.min;
      var mathMax = Math.max;
      var mathPow = Math.pow;
      var COVER_Z = 10000;
      var UNSELECT_THRESHOLD = 6;
      var MIN_RESIZE_LINE_WIDTH = 6;
      var MUTEX_RESOURCE_KEY = 'globalPan';
      var DIRECTION_MAP = {
        w: [0, 0],
        e: [0, 1],
        n: [1, 0],
        s: [1, 1]
      };
      var CURSOR_MAP = {
        w: 'ew',
        e: 'ew',
        n: 'ns',
        s: 'ns',
        ne: 'nesw',
        sw: 'nesw',
        nw: 'nwse',
        se: 'nwse'
      };
      var DEFAULT_BRUSH_OPT = {
        brushStyle: {
          lineWidth: 2,
          stroke: 'rgba(0,0,0,0.3)',
          fill: 'rgba(0,0,0,0.1)'
        },
        transformable: true,
        brushMode: 'single',
        removeOnClick: false
      };
      var baseUID = 0;
      /**
       * @alias module:echarts/component/helper/BrushController
       * @constructor
       * @mixin {module:zrender/mixin/Eventful}
       * @event module:echarts/component/helper/BrushController#brush
       *        params:
       *            areas: Array.<Array>, coord relates to container group,
       *                                    If no container specified, to global.
       *            opt {
       *                isEnd: boolean,
       *                removeOnClick: boolean
       *            }
       *
       * @param {module:zrender/zrender~ZRender} zr
       */

      function BrushController(zr) {
        Eventful.call(this);
        /**
         * @type {module:zrender/zrender~ZRender}
         * @private
         */

        this._zr = zr;
        /**
         * @type {module:zrender/container/Group}
         * @readOnly
         */

        this.group = new graphic.Group();
        /**
         * Only for drawing (after enabledBrush).
         *     'line', 'rect', 'polygon' or false
         *     If passing false/null/undefined, disable brush.
         *     If passing 'auto', determined by panel.defaultBrushType
         * @private
         * @type {string}
         */

        this._brushType;
        /**
         * Only for drawing (after enabledBrush).
         *
         * @private
         * @type {Object}
         */

        this._brushOption;
        /**
         * @private
         * @type {Object}
         */

        this._panels;
        /**
         * @private
         * @type {Array.<nubmer>}
         */

        this._track = [];
        /**
         * @private
         * @type {boolean}
         */

        this._dragging;
        /**
         * @private
         * @type {Array}
         */

        this._covers = [];
        /**
         * @private
         * @type {moudule:zrender/container/Group}
         */

        this._creatingCover;
        /**
         * `true` means global panel
         * @private
         * @type {module:zrender/container/Group|boolean}
         */

        this._creatingPanel;
        /**
         * @private
         * @type {boolean}
         */

        this._enableGlobalPan;
        /**
         * @private
         * @type {boolean}
         */

        /**
         * @private
         * @type {string}
         */

        this._uid = 'brushController_' + baseUID++;
        /**
         * @private
         * @type {Object}
         */

        this._handlers = {};
        each(pointerHandlers, function (handler, eventName) {
          this._handlers[eventName] = zrUtil.bind(handler, this);
        }, this);
      }

      BrushController.prototype = {
        constructor: BrushController,

        /**
         * If set to null/undefined/false, select disabled.
         * @param {Object} brushOption
         * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false
         *                          If passing false/null/undefined, disable brush.
         *                          If passing 'auto', determined by panel.defaultBrushType.
         *                              ('auto' can not be used in global panel)
         * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'
         * @param {boolean} [brushOption.transformable=true]
         * @param {boolean} [brushOption.removeOnClick=false]
         * @param {Object} [brushOption.brushStyle]
         * @param {number} [brushOption.brushStyle.width]
         * @param {number} [brushOption.brushStyle.lineWidth]
         * @param {string} [brushOption.brushStyle.stroke]
         * @param {string} [brushOption.brushStyle.fill]
         * @param {number} [brushOption.z]
         */
        enableBrush: function enableBrush(brushOption) {
          this._brushType && doDisableBrush(this);
          brushOption.brushType && doEnableBrush(this, brushOption);
          return this;
        },

        /**
         * @param {Array.<Object>} panelOpts If not pass, it is global brush.
         *        Each items: {
         *            panelId, // mandatory.
         *            clipPath, // mandatory. function.
         *            isTargetByCursor, // mandatory. function.
         *            defaultBrushType, // optional, only used when brushType is 'auto'.
         *            getLinearBrushOtherExtent, // optional. function.
         *        }
         */
        setPanels: function setPanels(panelOpts) {
          if (panelOpts && panelOpts.length) {
            var panels = this._panels = {};
            zrUtil.each(panelOpts, function (panelOpts) {
              panels[panelOpts.panelId] = zrUtil.clone(panelOpts);
            });
          } else {
            this._panels = null;
          }

          return this;
        },

        /**
         * @param {Object} [opt]
         * @return {boolean} [opt.enableGlobalPan=false]
         */
        mount: function mount(opt) {
          opt = opt || {};
          this._enableGlobalPan = opt.enableGlobalPan;
          var thisGroup = this.group;

          this._zr.add(thisGroup);

          thisGroup.attr({
            position: opt.position || [0, 0],
            rotation: opt.rotation || 0,
            scale: opt.scale || [1, 1]
          });
          this._transform = thisGroup.getLocalTransform();
          return this;
        },
        eachCover: function eachCover(cb, context) {
          each(this._covers, cb, context);
        },

        /**
         * Update covers.
         * @param {Array.<Object>} brushOptionList Like:
         *        [
         *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},
         *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},
         *            ...
         *        ]
         *        `brushType` is required in each cover info. (can not be 'auto')
         *        `id` is not mandatory.
         *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.
         *        If brushOptionList is null/undefined, all covers removed.
         */
        updateCovers: function updateCovers(brushOptionList) {
          brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {
            return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);
          });
          var tmpIdPrefix = '\0-brush-index-';
          var oldCovers = this._covers;
          var newCovers = this._covers = [];
          var controller = this;
          var creatingCover = this._creatingCover;
          new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();
          return this;

          function getKey(brushOption, index) {
            return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;
          }

          function oldGetKey(cover, index) {
            return getKey(cover.__brushOption, index);
          }

          function addOrUpdate(newIndex, oldIndex) {
            var newBrushOption = brushOptionList[newIndex]; // Consider setOption in event listener of brushSelect,
            // where updating cover when creating should be forbiden.

            if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {
              newCovers[newIndex] = oldCovers[oldIndex];
            } else {
              var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushOption, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushOption));
              updateCoverAfterCreation(controller, cover);
            }
          }

          function remove(oldIndex) {
            if (oldCovers[oldIndex] !== creatingCover) {
              controller.group.remove(oldCovers[oldIndex]);
            }
          }
        },
        unmount: function unmount() {
          this.enableBrush(false); // container may 'removeAll' outside.

          clearCovers(this);

          this._zr.remove(this.group);

          return this;
        },
        dispose: function dispose() {
          this.unmount();
          this.off();
        }
      };
      zrUtil.mixin(BrushController, Eventful);

      function doEnableBrush(controller, brushOption) {
        var zr = controller._zr; // Consider roam, which takes globalPan too.

        if (!controller._enableGlobalPan) {
          interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);
        }

        mountHandlers(zr, controller._handlers);
        controller._brushType = brushOption.brushType;
        controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);
      }

      function doDisableBrush(controller) {
        var zr = controller._zr;
        interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);
        unmountHandlers(zr, controller._handlers);
        controller._brushType = controller._brushOption = null;
      }

      function mountHandlers(zr, handlers) {
        each(handlers, function (handler, eventName) {
          zr.on(eventName, handler);
        });
      }

      function unmountHandlers(zr, handlers) {
        each(handlers, function (handler, eventName) {
          zr.off(eventName, handler);
        });
      }

      function createCover(controller, brushOption) {
        var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);
        cover.__brushOption = brushOption;
        updateZ(cover, brushOption);
        controller.group.add(cover);
        return cover;
      }

      function endCreating(controller, creatingCover) {
        var coverRenderer = getCoverRenderer(creatingCover);

        if (coverRenderer.endCreating) {
          coverRenderer.endCreating(controller, creatingCover);
          updateZ(creatingCover, creatingCover.__brushOption);
        }

        return creatingCover;
      }

      function updateCoverShape(controller, cover) {
        var brushOption = cover.__brushOption;
        getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);
      }

      function updateZ(cover, brushOption) {
        var z = brushOption.z;
        z == null && (z = COVER_Z);
        cover.traverse(function (el) {
          el.z = z;
          el.z2 = z; // Consider in given container.
        });
      }

      function updateCoverAfterCreation(controller, cover) {
        getCoverRenderer(cover).updateCommon(controller, cover);
        updateCoverShape(controller, cover);
      }

      function getCoverRenderer(cover) {
        return coverRenderers[cover.__brushOption.brushType];
      } // return target panel or `true` (means global panel)


      function getPanelByPoint(controller, e, localCursorPoint) {
        var panels = controller._panels;

        if (!panels) {
          return true; // Global panel
        }

        var panel;
        var transform = controller._transform;
        each(panels, function (pn) {
          pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);
        });
        return panel;
      } // Return a panel or true


      function getPanelByCover(controller, cover) {
        var panels = controller._panels;

        if (!panels) {
          return true; // Global panel
        }

        var panelId = cover.__brushOption.panelId; // User may give cover without coord sys info,
        // which is then treated as global panel.

        return panelId != null ? panels[panelId] : true;
      }

      function clearCovers(controller) {
        var covers = controller._covers;
        var originalLength = covers.length;
        each(covers, function (cover) {
          controller.group.remove(cover);
        }, controller);
        covers.length = 0;
        return !!originalLength;
      }

      function trigger(controller, opt) {
        var areas = map(controller._covers, function (cover) {
          var brushOption = cover.__brushOption;
          var range = zrUtil.clone(brushOption.range);
          return {
            brushType: brushOption.brushType,
            panelId: brushOption.panelId,
            range: range
          };
        });
        controller.trigger('brush', areas, {
          isEnd: !!opt.isEnd,
          removeOnClick: !!opt.removeOnClick
        });
      }

      function shouldShowCover(controller) {
        var track = controller._track;

        if (!track.length) {
          return false;
        }

        var p2 = track[track.length - 1];
        var p1 = track[0];
        var dx = p2[0] - p1[0];
        var dy = p2[1] - p1[1];
        var dist = mathPow(dx * dx + dy * dy, 0.5);
        return dist > UNSELECT_THRESHOLD;
      }

      function getTrackEnds(track) {
        var tail = track.length - 1;
        tail < 0 && (tail = 0);
        return [track[0], track[tail]];
      }

      function createBaseRectCover(doDrift, controller, brushOption, edgeNames) {
        var cover = new graphic.Group();
        cover.add(new graphic.Rect({
          name: 'main',
          style: makeStyle(brushOption),
          silent: true,
          draggable: true,
          cursor: 'move',
          drift: curry(doDrift, controller, cover, 'nswe'),
          ondragend: curry(trigger, controller, {
            isEnd: true
          })
        }));
        each(edgeNames, function (name) {
          cover.add(new graphic.Rect({
            name: name,
            style: {
              opacity: 0
            },
            draggable: true,
            silent: true,
            invisible: true,
            drift: curry(doDrift, controller, cover, name),
            ondragend: curry(trigger, controller, {
              isEnd: true
            })
          }));
        });
        return cover;
      }

      function updateBaseRect(controller, cover, localRange, brushOption) {
        var lineWidth = brushOption.brushStyle.lineWidth || 0;
        var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);
        var x = localRange[0][0];
        var y = localRange[1][0];
        var xa = x - lineWidth / 2;
        var ya = y - lineWidth / 2;
        var x2 = localRange[0][1];
        var y2 = localRange[1][1];
        var x2a = x2 - handleSize + lineWidth / 2;
        var y2a = y2 - handleSize + lineWidth / 2;
        var width = x2 - x;
        var height = y2 - y;
        var widtha = width + lineWidth;
        var heighta = height + lineWidth;
        updateRectShape(controller, cover, 'main', x, y, width, height);

        if (brushOption.transformable) {
          updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);
          updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);
          updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);
          updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);
          updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);
          updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);
          updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);
          updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);
        }
      }

      function updateCommon(controller, cover) {
        var brushOption = cover.__brushOption;
        var transformable = brushOption.transformable;
        var mainEl = cover.childAt(0);
        mainEl.useStyle(makeStyle(brushOption));
        mainEl.attr({
          silent: !transformable,
          cursor: transformable ? 'move' : 'default'
        });
        each(['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'], function (name) {
          var el = cover.childOfName(name);
          var globalDir = getGlobalDirection(controller, name);
          el && el.attr({
            silent: !transformable,
            invisible: !transformable,
            cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null
          });
        });
      }

      function updateRectShape(controller, cover, name, x, y, w, h) {
        var el = cover.childOfName(name);
        el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));
      }

      function makeStyle(brushOption) {
        return zrUtil.defaults({
          strokeNoScale: true
        }, brushOption.brushStyle);
      }

      function formatRectRange(x, y, x2, y2) {
        var min = [mathMin(x, x2), mathMin(y, y2)];
        var max = [mathMax(x, x2), mathMax(y, y2)];
        return [[min[0], max[0]], // x range
        [min[1], max[1]] // y range
        ];
      }

      function getTransform(controller) {
        return graphic.getTransform(controller.group);
      }

      function getGlobalDirection(controller, localDirection) {
        if (localDirection.length > 1) {
          localDirection = localDirection.split('');
          var globalDir = [getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1])];
          (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();
          return globalDir.join('');
        } else {
          var map = {
            w: 'left',
            e: 'right',
            n: 'top',
            s: 'bottom'
          };
          var inverseMap = {
            left: 'w',
            right: 'e',
            top: 'n',
            bottom: 's'
          };
          var globalDir = graphic.transformDirection(map[localDirection], getTransform(controller));
          return inverseMap[globalDir];
        }
      }

      function driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {
        var brushOption = cover.__brushOption;
        var rectRange = toRectRange(brushOption.range);
        var localDelta = toLocalDelta(controller, dx, dy);
        each(name.split(''), function (namePart) {
          var ind = DIRECTION_MAP[namePart];
          rectRange[ind[0]][ind[1]] += localDelta[ind[0]];
        });
        brushOption.range = fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));
        updateCoverAfterCreation(controller, cover);
        trigger(controller, {
          isEnd: false
        });
      }

      function driftPolygon(controller, cover, dx, dy, e) {
        var range = cover.__brushOption.range;
        var localDelta = toLocalDelta(controller, dx, dy);
        each(range, function (point) {
          point[0] += localDelta[0];
          point[1] += localDelta[1];
        });
        updateCoverAfterCreation(controller, cover);
        trigger(controller, {
          isEnd: false
        });
      }

      function toLocalDelta(controller, dx, dy) {
        var thisGroup = controller.group;
        var localD = thisGroup.transformCoordToLocal(dx, dy);
        var localZero = thisGroup.transformCoordToLocal(0, 0);
        return [localD[0] - localZero[0], localD[1] - localZero[1]];
      }

      function clipByPanel(controller, cover, data) {
        var panel = getPanelByCover(controller, cover);
        return panel && panel !== true ? panel.clipPath(data, controller._transform) : zrUtil.clone(data);
      }

      function pointsToRect(points) {
        var xmin = mathMin(points[0][0], points[1][0]);
        var ymin = mathMin(points[0][1], points[1][1]);
        var xmax = mathMax(points[0][0], points[1][0]);
        var ymax = mathMax(points[0][1], points[1][1]);
        return {
          x: xmin,
          y: ymin,
          width: xmax - xmin,
          height: ymax - ymin
        };
      }

      function resetCursor(controller, e, localCursorPoint) {
        if ( // Check active
        !controller._brushType // resetCursor should be always called when mouse is in zr area,
        // but not called when mouse is out of zr area to avoid bad influence
        // if `mousemove`, `mouseup` are triggered from `document` event.
        || isOutsideZrArea(controller, e)) {
          return;
        }

        var zr = controller._zr;
        var covers = controller._covers;
        var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers.

        if (!controller._dragging) {
          for (var i = 0; i < covers.length; i++) {
            var brushOption = covers[i].__brushOption;

            if (currPanel && (currPanel === true || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {
              // Use cursor style set on cover.
              return;
            }
          }
        }

        currPanel && zr.setCursorStyle('crosshair');
      }

      function preventDefault(e) {
        var rawE = e.event;
        rawE.preventDefault && rawE.preventDefault();
      }

      function mainShapeContain(cover, x, y) {
        return cover.childOfName('main').contain(x, y);
      }

      function updateCoverByMouse(controller, e, localCursorPoint, isEnd) {
        var creatingCover = controller._creatingCover;
        var panel = controller._creatingPanel;
        var thisBrushOption = controller._brushOption;
        var eventParams;

        controller._track.push(localCursorPoint.slice());

        if (shouldShowCover(controller) || creatingCover) {
          if (panel && !creatingCover) {
            thisBrushOption.brushMode === 'single' && clearCovers(controller);
            var brushOption = zrUtil.clone(thisBrushOption);
            brushOption.brushType = determineBrushType(brushOption.brushType, panel);
            brushOption.panelId = panel === true ? null : panel.panelId;
            creatingCover = controller._creatingCover = createCover(controller, brushOption);

            controller._covers.push(creatingCover);
          }

          if (creatingCover) {
            var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];
            var coverBrushOption = creatingCover.__brushOption;
            coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));

            if (isEnd) {
              endCreating(controller, creatingCover);
              coverRenderer.updateCommon(controller, creatingCover);
            }

            updateCoverShape(controller, creatingCover);
            eventParams = {
              isEnd: isEnd
            };
          }
        } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {
          // Help user to remove covers easily, only by a tiny drag, in 'single' mode.
          // But a single click do not clear covers, because user may have casual
          // clicks (for example, click on other component and do not expect covers
          // disappear).
          // Only some cover removed, trigger action, but not every click trigger action.
          if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {
            eventParams = {
              isEnd: isEnd,
              removeOnClick: true
            };
          }
        }

        return eventParams;
      }

      function determineBrushType(brushType, panel) {
        if (brushType === 'auto') {
          return panel.defaultBrushType;
        }

        return brushType;
      }

      var pointerHandlers = {
        mousedown: function mousedown(e) {
          if (this._dragging) {
            // In case some browser do not support globalOut,
            // and release mose out side the browser.
            handleDragEnd(this, e);
          } else if (!e.target || !e.target.draggable) {
            preventDefault(e);
            var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);
            this._creatingCover = null;
            var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);

            if (panel) {
              this._dragging = true;
              this._track = [localCursorPoint.slice()];
            }
          }
        },
        mousemove: function mousemove(e) {
          var x = e.offsetX;
          var y = e.offsetY;
          var localCursorPoint = this.group.transformCoordToLocal(x, y);
          resetCursor(this, e, localCursorPoint);

          if (this._dragging) {
            preventDefault(e);
            var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);
            eventParams && trigger(this, eventParams);
          }
        },
        mouseup: function mouseup(e) {
          handleDragEnd(this, e);
        }
      };

      function handleDragEnd(controller, e) {
        if (controller._dragging) {
          preventDefault(e);
          var x = e.offsetX;
          var y = e.offsetY;
          var localCursorPoint = controller.group.transformCoordToLocal(x, y);
          var eventParams = updateCoverByMouse(controller, e, localCursorPoint, true);
          controller._dragging = false;
          controller._track = [];
          controller._creatingCover = null; // trigger event shoule be at final, after procedure will be nested.

          eventParams && trigger(controller, eventParams);
        }
      }

      function isOutsideZrArea(controller, x, y) {
        var zr = controller._zr;
        return x < 0 || x > zr.getWidth() || y < 0 || y > zr.getHeight();
      }
      /**
       * key: brushType
       * @type {Object}
       */


      var coverRenderers = {
        lineX: getLineRenderer(0),
        lineY: getLineRenderer(1),
        rect: {
          createCover: function createCover(controller, brushOption) {
            return createBaseRectCover(curry(driftRect, function (range) {
              return range;
            }, function (range) {
              return range;
            }), controller, brushOption, ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']);
          },
          getCreatingRange: function getCreatingRange(localTrack) {
            var ends = getTrackEnds(localTrack);
            return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);
          },
          updateCoverShape: function updateCoverShape(controller, cover, localRange, brushOption) {
            updateBaseRect(controller, cover, localRange, brushOption);
          },
          updateCommon: updateCommon,
          contain: mainShapeContain
        },
        polygon: {
          createCover: function createCover(controller, brushOption) {
            var cover = new graphic.Group(); // Do not use graphic.Polygon because graphic.Polyline do not close the
            // border of the shape when drawing, which is a better experience for user.

            cover.add(new graphic.Polyline({
              name: 'main',
              style: makeStyle(brushOption),
              silent: true
            }));
            return cover;
          },
          getCreatingRange: function getCreatingRange(localTrack) {
            return localTrack;
          },
          endCreating: function endCreating(controller, cover) {
            cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape.

            cover.add(new graphic.Polygon({
              name: 'main',
              draggable: true,
              drift: curry(driftPolygon, controller, cover),
              ondragend: curry(trigger, controller, {
                isEnd: true
              })
            }));
          },
          updateCoverShape: function updateCoverShape(controller, cover, localRange, brushOption) {
            cover.childAt(0).setShape({
              points: clipByPanel(controller, cover, localRange)
            });
          },
          updateCommon: updateCommon,
          contain: mainShapeContain
        }
      };

      function getLineRenderer(xyIndex) {
        return {
          createCover: function createCover(controller, brushOption) {
            return createBaseRectCover(curry(driftRect, function (range) {
              var rectRange = [range, [0, 100]];
              xyIndex && rectRange.reverse();
              return rectRange;
            }, function (rectRange) {
              return rectRange[xyIndex];
            }), controller, brushOption, [['w', 'e'], ['n', 's']][xyIndex]);
          },
          getCreatingRange: function getCreatingRange(localTrack) {
            var ends = getTrackEnds(localTrack);
            var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);
            var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);
            return [min, max];
          },
          updateCoverShape: function updateCoverShape(controller, cover, localRange, brushOption) {
            var otherExtent; // If brushWidth not specified, fit the panel.

            var panel = getPanelByCover(controller, cover);

            if (panel !== true && panel.getLinearBrushOtherExtent) {
              otherExtent = panel.getLinearBrushOtherExtent(xyIndex, controller._transform);
            } else {
              var zr = controller._zr;
              otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];
            }

            var rectRange = [localRange, otherExtent];
            xyIndex && rectRange.reverse();
            updateBaseRect(controller, cover, rectRange, brushOption);
          },
          updateCommon: updateCommon,
          contain: mainShapeContain
        };
      }

      var _default = BrushController;
      module.exports = _default;
      /***/
    },

    /***/
    "/SeX":
    /*!*******************************************************!*\
      !*** ./node_modules/echarts/lib/coord/polar/Polar.js ***!
      \*******************************************************/

    /*! no static exports found */

    /***/
    function SeX(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var RadiusAxis = __webpack_require__(
      /*! ./RadiusAxis */
      "knOB");

      var AngleAxis = __webpack_require__(
      /*! ./AngleAxis */
      "qZFw");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @module echarts/coord/polar/Polar
       */

      /**
       * @alias {module:echarts/coord/polar/Polar}
       * @constructor
       * @param {string} name
       */


      var Polar = function Polar(name) {
        /**
         * @type {string}
         */
        this.name = name || '';
        /**
         * x of polar center
         * @type {number}
         */

        this.cx = 0;
        /**
         * y of polar center
         * @type {number}
         */

        this.cy = 0;
        /**
         * @type {module:echarts/coord/polar/RadiusAxis}
         * @private
         */

        this._radiusAxis = new RadiusAxis();
        /**
         * @type {module:echarts/coord/polar/AngleAxis}
         * @private
         */

        this._angleAxis = new AngleAxis();
        this._radiusAxis.polar = this._angleAxis.polar = this;
      };

      Polar.prototype = {
        type: 'polar',
        axisPointerEnabled: true,
        constructor: Polar,

        /**
         * @param {Array.<string>}
         * @readOnly
         */
        dimensions: ['radius', 'angle'],

        /**
         * @type {module:echarts/coord/PolarModel}
         */
        model: null,

        /**
         * If contain coord
         * @param {Array.<number>} point
         * @return {boolean}
         */
        containPoint: function containPoint(point) {
          var coord = this.pointToCoord(point);
          return this._radiusAxis.contain(coord[0]) && this._angleAxis.contain(coord[1]);
        },

        /**
         * If contain data
         * @param {Array.<number>} data
         * @return {boolean}
         */
        containData: function containData(data) {
          return this._radiusAxis.containData(data[0]) && this._angleAxis.containData(data[1]);
        },

        /**
         * @param {string} dim
         * @return {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}
         */
        getAxis: function getAxis(dim) {
          return this['_' + dim + 'Axis'];
        },

        /**
         * @return {Array.<module:echarts/coord/Axis>}
         */
        getAxes: function getAxes() {
          return [this._radiusAxis, this._angleAxis];
        },

        /**
         * Get axes by type of scale
         * @param {string} scaleType
         * @return {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}
         */
        getAxesByScale: function getAxesByScale(scaleType) {
          var axes = [];
          var angleAxis = this._angleAxis;
          var radiusAxis = this._radiusAxis;
          angleAxis.scale.type === scaleType && axes.push(angleAxis);
          radiusAxis.scale.type === scaleType && axes.push(radiusAxis);
          return axes;
        },

        /**
         * @return {module:echarts/coord/polar/AngleAxis}
         */
        getAngleAxis: function getAngleAxis() {
          return this._angleAxis;
        },

        /**
         * @return {module:echarts/coord/polar/RadiusAxis}
         */
        getRadiusAxis: function getRadiusAxis() {
          return this._radiusAxis;
        },

        /**
         * @param {module:echarts/coord/polar/Axis}
         * @return {module:echarts/coord/polar/Axis}
         */
        getOtherAxis: function getOtherAxis(axis) {
          var angleAxis = this._angleAxis;
          return axis === angleAxis ? this._radiusAxis : angleAxis;
        },

        /**
         * Base axis will be used on stacking.
         *
         * @return {module:echarts/coord/polar/Axis}
         */
        getBaseAxis: function getBaseAxis() {
          return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAngleAxis();
        },

        /**
         * @param {string} [dim] 'radius' or 'angle' or 'auto' or null/undefined
         * @return {Object} {baseAxes: [], otherAxes: []}
         */
        getTooltipAxes: function getTooltipAxes(dim) {
          var baseAxis = dim != null && dim !== 'auto' ? this.getAxis(dim) : this.getBaseAxis();
          return {
            baseAxes: [baseAxis],
            otherAxes: [this.getOtherAxis(baseAxis)]
          };
        },

        /**
         * Convert a single data item to (x, y) point.
         * Parameter data is an array which the first element is radius and the second is angle
         * @param {Array.<number>} data
         * @param {boolean} [clamp=false]
         * @return {Array.<number>}
         */
        dataToPoint: function dataToPoint(data, clamp) {
          return this.coordToPoint([this._radiusAxis.dataToRadius(data[0], clamp), this._angleAxis.dataToAngle(data[1], clamp)]);
        },

        /**
         * Convert a (x, y) point to data
         * @param {Array.<number>} point
         * @param {boolean} [clamp=false]
         * @return {Array.<number>}
         */
        pointToData: function pointToData(point, clamp) {
          var coord = this.pointToCoord(point);
          return [this._radiusAxis.radiusToData(coord[0], clamp), this._angleAxis.angleToData(coord[1], clamp)];
        },

        /**
         * Convert a (x, y) point to (radius, angle) coord
         * @param {Array.<number>} point
         * @return {Array.<number>}
         */
        pointToCoord: function pointToCoord(point) {
          var dx = point[0] - this.cx;
          var dy = point[1] - this.cy;
          var angleAxis = this.getAngleAxis();
          var extent = angleAxis.getExtent();
          var minAngle = Math.min(extent[0], extent[1]);
          var maxAngle = Math.max(extent[0], extent[1]); // Fix fixed extent in polarCreator
          // FIXME

          angleAxis.inverse ? minAngle = maxAngle - 360 : maxAngle = minAngle + 360;
          var radius = Math.sqrt(dx * dx + dy * dy);
          dx /= radius;
          dy /= radius;
          var radian = Math.atan2(-dy, dx) / Math.PI * 180; // move to angleExtent

          var dir = radian < minAngle ? 1 : -1;

          while (radian < minAngle || radian > maxAngle) {
            radian += dir * 360;
          }

          return [radius, radian];
        },

        /**
         * Convert a (radius, angle) coord to (x, y) point
         * @param {Array.<number>} coord
         * @return {Array.<number>}
         */
        coordToPoint: function coordToPoint(coord) {
          var radius = coord[0];
          var radian = coord[1] / 180 * Math.PI;
          var x = Math.cos(radian) * radius + this.cx; // Inverse the y

          var y = -Math.sin(radian) * radius + this.cy;
          return [x, y];
        },

        /**
         * Get ring area of cartesian.
         * Area will have a contain function to determine if a point is in the coordinate system.
         * @return {Ring}
         */
        getArea: function getArea() {
          var angleAxis = this.getAngleAxis();
          var radiusAxis = this.getRadiusAxis();
          var radiusExtent = radiusAxis.getExtent().slice();
          radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();
          var angleExtent = angleAxis.getExtent();
          var RADIAN = Math.PI / 180;
          return {
            cx: this.cx,
            cy: this.cy,
            r0: radiusExtent[0],
            r: radiusExtent[1],
            startAngle: -angleExtent[0] * RADIAN,
            endAngle: -angleExtent[1] * RADIAN,
            clockwise: angleAxis.inverse,
            contain: function contain(x, y) {
              // It's a ring shape.
              // Start angle and end angle don't matter
              var dx = x - this.cx;
              var dy = y - this.cy;
              var d2 = dx * dx + dy * dy;
              var r = this.r;
              var r0 = this.r0;
              return d2 <= r * r && d2 >= r0 * r0;
            }
          };
        }
      };
      var _default = Polar;
      module.exports = _default;
      /***/
    },

    /***/
    "/d5a":
    /*!**********************************************************!*\
      !*** ./node_modules/echarts/lib/processor/dataSample.js ***!
      \**********************************************************/

    /*! no static exports found */

    /***/
    function d5a(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var samplers = {
        average: function average(frame) {
          var sum = 0;
          var count = 0;

          for (var i = 0; i < frame.length; i++) {
            if (!isNaN(frame[i])) {
              sum += frame[i];
              count++;
            }
          } // Return NaN if count is 0


          return count === 0 ? NaN : sum / count;
        },
        sum: function sum(frame) {
          var sum = 0;

          for (var i = 0; i < frame.length; i++) {
            // Ignore NaN
            sum += frame[i] || 0;
          }

          return sum;
        },
        max: function max(frame) {
          var max = -Infinity;

          for (var i = 0; i < frame.length; i++) {
            frame[i] > max && (max = frame[i]);
          } // NaN will cause illegal axis extent.


          return isFinite(max) ? max : NaN;
        },
        min: function min(frame) {
          var min = Infinity;

          for (var i = 0; i < frame.length; i++) {
            frame[i] < min && (min = frame[i]);
          } // NaN will cause illegal axis extent.


          return isFinite(min) ? min : NaN;
        },
        // TODO
        // Median
        nearest: function nearest(frame) {
          return frame[0];
        }
      };

      var indexSampler = function indexSampler(frame, value) {
        return Math.round(frame.length / 2);
      };

      function _default(seriesType) {
        return {
          seriesType: seriesType,
          modifyOutputEnd: true,
          reset: function reset(seriesModel, ecModel, api) {
            var data = seriesModel.getData();
            var sampling = seriesModel.get('sampling');
            var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling

            if (coordSys.type === 'cartesian2d' && sampling) {
              var baseAxis = coordSys.getBaseAxis();
              var valueAxis = coordSys.getOtherAxis(baseAxis);
              var extent = baseAxis.getExtent(); // Coordinste system has been resized

              var size = Math.abs(extent[1] - extent[0]);
              var rate = Math.round(data.count() / size);

              if (rate > 1) {
                var sampler;

                if (typeof sampling === 'string') {
                  sampler = samplers[sampling];
                } else if (typeof sampling === 'function') {
                  sampler = sampling;
                }

                if (sampler) {
                  // Only support sample the first dim mapped from value axis.
                  seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler));
                }
              }
            }
          }
        };
      }

      module.exports = _default;
      /***/
    },

    /***/
    "/ry/":
    /*!*****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/boxplot/BoxplotSeries.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function ry(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var SeriesModel = __webpack_require__(
      /*! ../../model/Series */
      "T4UG");

      var _whiskerBoxCommon = __webpack_require__(
      /*! ../helper/whiskerBoxCommon */
      "5GhG");

      var seriesModelMixin = _whiskerBoxCommon.seriesModelMixin;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var BoxplotSeries = SeriesModel.extend({
        type: 'series.boxplot',
        dependencies: ['xAxis', 'yAxis', 'grid'],
        // TODO
        // box width represents group size, so dimension should have 'size'.

        /**
         * @see <https://en.wikipedia.org/wiki/Box_plot>
         * The meanings of 'min' and 'max' depend on user,
         * and echarts do not need to know it.
         * @readOnly
         */
        defaultValueDimensions: [{
          name: 'min',
          defaultTooltip: true
        }, {
          name: 'Q1',
          defaultTooltip: true
        }, {
          name: 'median',
          defaultTooltip: true
        }, {
          name: 'Q3',
          defaultTooltip: true
        }, {
          name: 'max',
          defaultTooltip: true
        }],

        /**
         * @type {Array.<string>}
         * @readOnly
         */
        dimensions: null,

        /**
         * @override
         */
        defaultOption: {
          zlevel: 0,
          // 
          z: 2,
          // 
          coordinateSystem: 'cartesian2d',
          legendHoverLink: true,
          hoverAnimation: true,
          // xAxisIndex: 0,
          // yAxisIndex: 0,
          layout: null,
          // 'horizontal' or 'vertical'
          boxWidth: [7, 50],
          // [min, max] can be percent of band width.
          itemStyle: {
            color: '#fff',
            borderWidth: 1
          },
          emphasis: {
            itemStyle: {
              borderWidth: 2,
              shadowBlur: 5,
              shadowOffsetX: 2,
              shadowOffsetY: 2,
              shadowColor: 'rgba(0,0,0,0.4)'
            }
          },
          animationEasing: 'elasticOut',
          animationDuration: 800
        }
      });
      zrUtil.mixin(BoxplotSeries, seriesModelMixin, true);
      var _default = BoxplotSeries;
      module.exports = _default;
      /***/
    },

    /***/
    "/stD":
    /*!*********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/toolbox/feature/Brush.js ***!
      \*********************************************************************/

    /*! no static exports found */

    /***/
    function stD(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var featureManager = __webpack_require__(
      /*! ../featureManager */
      "IUWy");

      var lang = __webpack_require__(
      /*! ../../../lang */
      "Kagy");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var brushLang = lang.toolbox.brush;

      function Brush(model, ecModel, api) {
        this.model = model;
        this.ecModel = ecModel;
        this.api = api;
        /**
         * @private
         * @type {string}
         */

        this._brushType;
        /**
         * @private
         * @type {string}
         */

        this._brushMode;
      }

      Brush.defaultOption = {
        show: true,
        type: ['rect', 'polygon', 'lineX', 'lineY', 'keep', 'clear'],
        icon: {
          /* eslint-disable */
          rect: 'M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13',
          // jshint ignore:line
          polygon: 'M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2',
          // jshint ignore:line
          lineX: 'M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4',
          // jshint ignore:line
          lineY: 'M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4',
          // jshint ignore:line
          keep: 'M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z',
          // jshint ignore:line
          clear: 'M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2' // jshint ignore:line

          /* eslint-enable */

        },
        // `rect`, `polygon`, `lineX`, `lineY`, `keep`, `clear`
        title: zrUtil.clone(brushLang.title)
      };
      var proto = Brush.prototype; // proto.updateLayout = function (featureModel, ecModel, api) {

      /* eslint-disable */

      proto.render =
      /* eslint-enable */
      proto.updateView = function (featureModel, ecModel, api) {
        var brushType;
        var brushMode;
        var isBrushed;
        ecModel.eachComponent({
          mainType: 'brush'
        }, function (brushModel) {
          brushType = brushModel.brushType;
          brushMode = brushModel.brushOption.brushMode || 'single';
          isBrushed |= brushModel.areas.length;
        });
        this._brushType = brushType;
        this._brushMode = brushMode;
        zrUtil.each(featureModel.get('type', true), function (type) {
          featureModel.setIconStatus(type, (type === 'keep' ? brushMode === 'multiple' : type === 'clear' ? isBrushed : type === brushType) ? 'emphasis' : 'normal');
        });
      };

      proto.getIcons = function () {
        var model = this.model;
        var availableIcons = model.get('icon', true);
        var icons = {};
        zrUtil.each(model.get('type', true), function (type) {
          if (availableIcons[type]) {
            icons[type] = availableIcons[type];
          }
        });
        return icons;
      };

      proto.onclick = function (ecModel, api, type) {
        var brushType = this._brushType;
        var brushMode = this._brushMode;

        if (type === 'clear') {
          // Trigger parallel action firstly
          api.dispatchAction({
            type: 'axisAreaSelect',
            intervals: []
          });
          api.dispatchAction({
            type: 'brush',
            command: 'clear',
            // Clear all areas of all brush components.
            areas: []
          });
        } else {
          api.dispatchAction({
            type: 'takeGlobalCursor',
            key: 'brush',
            brushOption: {
              brushType: type === 'keep' ? brushType : brushType === type ? false : type,
              brushMode: type === 'keep' ? brushMode === 'multiple' ? 'single' : 'multiple' : brushMode
            }
          });
        }
      };

      featureManager.register('brush', Brush);
      var _default = Brush;
      module.exports = _default;
      /***/
    },

    /***/
    "/y7N":
    /*!**********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/axisPointer/viewHelper.js ***!
      \**********************************************************************/

    /*! no static exports found */

    /***/
    function y7N(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var textContain = __webpack_require__(
      /*! zrender/lib/contain/text */
      "6GrX");

      var formatUtil = __webpack_require__(
      /*! ../../util/format */
      "7aKB");

      var matrix = __webpack_require__(
      /*! zrender/lib/core/matrix */
      "Fofx");

      var axisHelper = __webpack_require__(
      /*! ../../coord/axisHelper */
      "aX7z");

      var AxisBuilder = __webpack_require__(
      /*! ../axis/AxisBuilder */
      "+rIm");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @param {module:echarts/model/Model} axisPointerModel
       */


      function buildElStyle(axisPointerModel) {
        var axisPointerType = axisPointerModel.get('type');
        var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');
        var style;

        if (axisPointerType === 'line') {
          style = styleModel.getLineStyle();
          style.fill = null;
        } else if (axisPointerType === 'shadow') {
          style = styleModel.getAreaStyle();
          style.stroke = null;
        }

        return style;
      }
      /**
       * @param {Function} labelPos {align, verticalAlign, position}
       */


      function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
        var value = axisPointerModel.get('value');
        var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {
          precision: axisPointerModel.get('label.precision'),
          formatter: axisPointerModel.get('label.formatter')
        });
        var labelModel = axisPointerModel.getModel('label');
        var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);
        var font = labelModel.getFont();
        var textRect = textContain.getBoundingRect(text, font);
        var position = labelPos.position;
        var width = textRect.width + paddings[1] + paddings[3];
        var height = textRect.height + paddings[0] + paddings[2]; // Adjust by align.

        var align = labelPos.align;
        align === 'right' && (position[0] -= width);
        align === 'center' && (position[0] -= width / 2);
        var verticalAlign = labelPos.verticalAlign;
        verticalAlign === 'bottom' && (position[1] -= height);
        verticalAlign === 'middle' && (position[1] -= height / 2); // Not overflow ec container

        confineInContainer(position, width, height, api);
        var bgColor = labelModel.get('backgroundColor');

        if (!bgColor || bgColor === 'auto') {
          bgColor = axisModel.get('axisLine.lineStyle.color');
        }

        elOption.label = {
          shape: {
            x: 0,
            y: 0,
            width: width,
            height: height,
            r: labelModel.get('borderRadius')
          },
          position: position.slice(),
          // TODO: rich
          style: {
            text: text,
            textFont: font,
            textFill: labelModel.getTextColor(),
            textPosition: 'inside',
            textPadding: paddings,
            fill: bgColor,
            stroke: labelModel.get('borderColor') || 'transparent',
            lineWidth: labelModel.get('borderWidth') || 0,
            shadowBlur: labelModel.get('shadowBlur'),
            shadowColor: labelModel.get('shadowColor'),
            shadowOffsetX: labelModel.get('shadowOffsetX'),
            shadowOffsetY: labelModel.get('shadowOffsetY')
          },
          // Lable should be over axisPointer.
          z2: 10
        };
      } // Do not overflow ec container


      function confineInContainer(position, width, height, api) {
        var viewWidth = api.getWidth();
        var viewHeight = api.getHeight();
        position[0] = Math.min(position[0] + width, viewWidth) - width;
        position[1] = Math.min(position[1] + height, viewHeight) - height;
        position[0] = Math.max(position[0], 0);
        position[1] = Math.max(position[1], 0);
      }
      /**
       * @param {number} value
       * @param {module:echarts/coord/Axis} axis
       * @param {module:echarts/model/Global} ecModel
       * @param {Object} opt
       * @param {Array.<Object>} seriesDataIndices
       * @param {number|string} opt.precision 'auto' or a number
       * @param {string|Function} opt.formatter label formatter
       */


      function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
        value = axis.scale.parse(value);
        var text = axis.scale.getLabel( // If `precision` is set, width can be fixed (like '12.00500'), which
        // helps to debounce when when moving label.
        value, {
          precision: opt.precision
        });
        var formatter = opt.formatter;

        if (formatter) {
          var params = {
            value: axisHelper.getAxisRawValue(axis, value),
            axisDimension: axis.dim,
            axisIndex: axis.index,
            seriesData: []
          };
          zrUtil.each(seriesDataIndices, function (idxItem) {
            var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
            var dataIndex = idxItem.dataIndexInside;
            var dataParams = series && series.getDataParams(dataIndex);
            dataParams && params.seriesData.push(dataParams);
          });

          if (zrUtil.isString(formatter)) {
            text = formatter.replace('{value}', text);
          } else if (zrUtil.isFunction(formatter)) {
            text = formatter(params);
          }
        }

        return text;
      }
      /**
       * @param {module:echarts/coord/Axis} axis
       * @param {number} value
       * @param {Object} layoutInfo {
       *  rotation, position, labelOffset, labelDirection, labelMargin
       * }
       */


      function getTransformedPosition(axis, value, layoutInfo) {
        var transform = matrix.create();
        matrix.rotate(transform, transform, layoutInfo.rotation);
        matrix.translate(transform, transform, layoutInfo.position);
        return graphic.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);
      }

      function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
        var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
        layoutInfo.labelMargin = axisPointerModel.get('label.margin');
        buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
          position: getTransformedPosition(axisModel.axis, value, layoutInfo),
          align: textLayout.textAlign,
          verticalAlign: textLayout.textVerticalAlign
        });
      }
      /**
       * @param {Array.<number>} p1
       * @param {Array.<number>} p2
       * @param {number} [xDimIndex=0] or 1
       */


      function makeLineShape(p1, p2, xDimIndex) {
        xDimIndex = xDimIndex || 0;
        return {
          x1: p1[xDimIndex],
          y1: p1[1 - xDimIndex],
          x2: p2[xDimIndex],
          y2: p2[1 - xDimIndex]
        };
      }
      /**
       * @param {Array.<number>} xy
       * @param {Array.<number>} wh
       * @param {number} [xDimIndex=0] or 1
       */


      function makeRectShape(xy, wh, xDimIndex) {
        xDimIndex = xDimIndex || 0;
        return {
          x: xy[xDimIndex],
          y: xy[1 - xDimIndex],
          width: wh[xDimIndex],
          height: wh[1 - xDimIndex]
        };
      }

      function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
        return {
          cx: cx,
          cy: cy,
          r0: r0,
          r: r,
          startAngle: startAngle,
          endAngle: endAngle,
          clockwise: true
        };
      }

      exports.buildElStyle = buildElStyle;
      exports.buildLabelElOption = buildLabelElOption;
      exports.getValueLabel = getValueLabel;
      exports.getTransformedPosition = getTransformedPosition;
      exports.buildCartesianSingleLabelElOption = buildCartesianSingleLabelElOption;
      exports.makeLineShape = makeLineShape;
      exports.makeRectShape = makeRectShape;
      exports.makeSectorShape = makeSectorShape;
      /***/
    },

    /***/
    "0/Rx":
    /*!**********************************************************!*\
      !*** ./node_modules/echarts/lib/processor/dataFilter.js ***!
      \**********************************************************/

    /*! no static exports found */

    /***/
    function Rx(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      function _default(seriesType) {
        return {
          seriesType: seriesType,
          reset: function reset(seriesModel, ecModel) {
            var legendModels = ecModel.findComponents({
              mainType: 'legend'
            });

            if (!legendModels || !legendModels.length) {
              return;
            }

            var data = seriesModel.getData();
            data.filterSelf(function (idx) {
              var name = data.getName(idx); // If in any legend component the status is not selected.

              for (var i = 0; i < legendModels.length; i++) {
                if (!legendModels[i].isSelected(name)) {
                  return false;
                }
              }

              return true;
            });
          }
        };
      }

      module.exports = _default;
      /***/
    },

    /***/
    "01d+":
    /*!**************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/graph/simpleLayout.js ***!
      \**************************************************************/

    /*! no static exports found */

    /***/
    function d(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _util = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var each = _util.each;

      var _simpleLayoutHelper = __webpack_require__(
      /*! ./simpleLayoutHelper */
      "HF/U");

      var simpleLayout = _simpleLayoutHelper.simpleLayout;
      var simpleLayoutEdge = _simpleLayoutHelper.simpleLayoutEdge;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      function _default(ecModel, api) {
        ecModel.eachSeriesByType('graph', function (seriesModel) {
          var layout = seriesModel.get('layout');
          var coordSys = seriesModel.coordinateSystem;

          if (coordSys && coordSys.type !== 'view') {
            var data = seriesModel.getData();
            var dimensions = [];
            each(coordSys.dimensions, function (coordDim) {
              dimensions = dimensions.concat(data.mapDimension(coordDim, true));
            });

            for (var dataIndex = 0; dataIndex < data.count(); dataIndex++) {
              var value = [];
              var hasValue = false;

              for (var i = 0; i < dimensions.length; i++) {
                var val = data.get(dimensions[i], dataIndex);

                if (!isNaN(val)) {
                  hasValue = true;
                }

                value.push(val);
              }

              if (hasValue) {
                data.setItemLayout(dataIndex, coordSys.dataToPoint(value));
              } else {
                // Also {Array.<number>}, not undefined to avoid if...else... statement
                data.setItemLayout(dataIndex, [NaN, NaN]);
              }
            }

            simpleLayoutEdge(data.graph, seriesModel);
          } else if (!layout || layout === 'none') {
            simpleLayout(seriesModel);
          }
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "06DH":
    /*!*************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/toolbox/feature/MagicType.js ***!
      \*************************************************************************/

    /*! no static exports found */

    /***/
    function DH(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var lang = __webpack_require__(
      /*! ../../../lang */
      "Kagy");

      var featureManager = __webpack_require__(
      /*! ../featureManager */
      "IUWy");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var magicTypeLang = lang.toolbox.magicType;
      var INNER_STACK_KEYWORD = '__ec_magicType_stack__';

      function MagicType(model) {
        this.model = model;
      }

      MagicType.defaultOption = {
        show: true,
        type: [],
        // Icon group
        icon: {
          /* eslint-disable */
          line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',
          bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',
          stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z' // jshint ignore:line

          /* eslint-enable */

        },
        // `line`, `bar`, `stack`, `tiled`
        title: zrUtil.clone(magicTypeLang.title),
        option: {},
        seriesIndex: {}
      };
      var proto = MagicType.prototype;

      proto.getIcons = function () {
        var model = this.model;
        var availableIcons = model.get('icon');
        var icons = {};
        zrUtil.each(model.get('type'), function (type) {
          if (availableIcons[type]) {
            icons[type] = availableIcons[type];
          }
        });
        return icons;
      };

      var seriesOptGenreator = {
        'line': function line(seriesType, seriesId, seriesModel, model) {
          if (seriesType === 'bar') {
            return zrUtil.merge({
              id: seriesId,
              type: 'line',
              // Preserve data related option
              data: seriesModel.get('data'),
              stack: seriesModel.get('stack'),
              markPoint: seriesModel.get('markPoint'),
              markLine: seriesModel.get('markLine')
            }, model.get('option.line') || {}, true);
          }
        },
        'bar': function bar(seriesType, seriesId, seriesModel, model) {
          if (seriesType === 'line') {
            return zrUtil.merge({
              id: seriesId,
              type: 'bar',
              // Preserve data related option
              data: seriesModel.get('data'),
              stack: seriesModel.get('stack'),
              markPoint: seriesModel.get('markPoint'),
              markLine: seriesModel.get('markLine')
            }, model.get('option.bar') || {}, true);
          }
        },
        'stack': function stack(seriesType, seriesId, seriesModel, model) {
          var isStack = seriesModel.get('stack') === INNER_STACK_KEYWORD;

          if (seriesType === 'line' || seriesType === 'bar') {
            model.setIconStatus('stack', isStack ? 'normal' : 'emphasis');
            return zrUtil.merge({
              id: seriesId,
              stack: isStack ? '' : INNER_STACK_KEYWORD
            }, model.get('option.stack') || {}, true);
          }
        }
      };
      var radioTypes = [['line', 'bar'], ['stack']];

      proto.onclick = function (ecModel, api, type) {
        var model = this.model;
        var seriesIndex = model.get('seriesIndex.' + type); // Not supported magicType

        if (!seriesOptGenreator[type]) {
          return;
        }

        var newOption = {
          series: []
        };

        var generateNewSeriesTypes = function generateNewSeriesTypes(seriesModel) {
          var seriesType = seriesModel.subType;
          var seriesId = seriesModel.id;
          var newSeriesOpt = seriesOptGenreator[type](seriesType, seriesId, seriesModel, model);

          if (newSeriesOpt) {
            // PENDING If merge original option?
            zrUtil.defaults(newSeriesOpt, seriesModel.option);
            newOption.series.push(newSeriesOpt);
          } // Modify boundaryGap


          var coordSys = seriesModel.coordinateSystem;

          if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {
            var categoryAxis = coordSys.getAxesByScale('ordinal')[0];

            if (categoryAxis) {
              var axisDim = categoryAxis.dim;
              var axisType = axisDim + 'Axis';
              var axisModel = ecModel.queryComponents({
                mainType: axisType,
                index: seriesModel.get(name + 'Index'),
                id: seriesModel.get(name + 'Id')
              })[0];
              var axisIndex = axisModel.componentIndex;
              newOption[axisType] = newOption[axisType] || [];

              for (var i = 0; i <= axisIndex; i++) {
                newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};
              }

              newOption[axisType][axisIndex].boundaryGap = type === 'bar';
            }
          }
        };

        zrUtil.each(radioTypes, function (radio) {
          if (zrUtil.indexOf(radio, type) >= 0) {
            zrUtil.each(radio, function (item) {
              model.setIconStatus(item, 'normal');
            });
          }
        });
        model.setIconStatus(type, 'emphasis');
        ecModel.eachComponent({
          mainType: 'series',
          query: seriesIndex == null ? null : {
            seriesIndex: seriesIndex
          }
        }, generateNewSeriesTypes);
        var newTitle; // Change title of stack

        if (type === 'stack') {
          var isStack = newOption.series && newOption.series[0] && newOption.series[0].stack === INNER_STACK_KEYWORD;
          newTitle = isStack ? zrUtil.merge({
            stack: magicTypeLang.title.tiled
          }, magicTypeLang.title) : zrUtil.clone(magicTypeLang.title);
        }

        api.dispatchAction({
          type: 'changeMagicType',
          currentType: type,
          newOption: newOption,
          newTitle: newTitle,
          featureName: 'magicType'
        });
      };

      echarts.registerAction({
        type: 'changeMagicType',
        event: 'magicTypeChanged',
        update: 'prepareAndUpdate'
      }, function (payload, ecModel) {
        ecModel.mergeOption(payload.newOption);
      });
      featureManager.register('magicType', MagicType);
      var _default = MagicType;
      module.exports = _default;
      /***/
    },

    /***/
    "06Qe":
    /*!**********************************************!*\
      !*** ./node_modules/zrender/lib/vml/core.js ***!
      \**********************************************/

    /*! no static exports found */

    /***/
    function Qe(module, exports, __webpack_require__) {
      var env = __webpack_require__(
      /*! ../core/env */
      "ItGF");

      var urn = 'urn:schemas-microsoft-com:vml';
      var win = typeof window === 'undefined' ? null : window;
      var vmlInited = false;
      var doc = win && win.document;

      function createNode(tagName) {
        return doCreateNode(tagName);
      } // Avoid assign to an exported variable, for transforming to cjs.


      var doCreateNode;

      if (doc && !env.canvasSupported) {
        try {
          !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);

          doCreateNode = function doCreateNode(tagName) {
            return doc.createElement('<zrvml:' + tagName + ' class="zrvml">');
          };
        } catch (e) {
          doCreateNode = function doCreateNode(tagName) {
            return doc.createElement('<' + tagName + ' xmlns="' + urn + '" class="zrvml">');
          };
        }
      } // From raphael


      function initVML() {
        if (vmlInited || !doc) {
          return;
        }

        vmlInited = true;
        var styleSheets = doc.styleSheets;

        if (styleSheets.length < 31) {
          doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');
        } else {
          // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
          styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');
        }
      }

      exports.doc = doc;
      exports.createNode = createNode;
      exports.initVML = initVML;
      /***/
    },

    /***/
    "0Bwj":
    /*!***************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/sankey/SankeySeries.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function Bwj(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var SeriesModel = __webpack_require__(
      /*! ../../model/Series */
      "T4UG");

      var createGraphFromNodeEdge = __webpack_require__(
      /*! ../helper/createGraphFromNodeEdge */
      "I3/A");

      var _format = __webpack_require__(
      /*! ../../util/format */
      "7aKB");

      var encodeHTML = _format.encodeHTML;

      var Model = __webpack_require__(
      /*! ../../model/Model */
      "Qxkt");

      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var SankeySeries = SeriesModel.extend({
        type: 'series.sankey',
        layoutInfo: null,
        levelModels: null,

        /**
         * Init a graph data structure from data in option series
         *
         * @param  {Object} option  the object used to config echarts view
         * @return {module:echarts/data/List} storage initial data
         */
        getInitialData: function getInitialData(option, ecModel) {
          var links = option.edges || option.links;
          var nodes = option.data || option.nodes;
          var levels = option.levels;
          var levelModels = this.levelModels = {};

          for (var i = 0; i < levels.length; i++) {
            if (levels[i].depth != null && levels[i].depth >= 0) {
              levelModels[levels[i].depth] = new Model(levels[i], this, ecModel);
            } else {}
          }

          if (nodes && links) {
            var graph = createGraphFromNodeEdge(nodes, links, this, true, beforeLink);
            return graph.data;
          }

          function beforeLink(nodeData, edgeData) {
            nodeData.wrapMethod('getItemModel', function (model, idx) {
              model.customizeGetParent(function (path) {
                var parentModel = this.parentModel;
                var nodeDepth = parentModel.getData().getItemLayout(idx).depth;
                var levelModel = parentModel.levelModels[nodeDepth];
                return levelModel || this.parentModel;
              });
              return model;
            });
            edgeData.wrapMethod('getItemModel', function (model, idx) {
              model.customizeGetParent(function (path) {
                var parentModel = this.parentModel;
                var edge = parentModel.getGraph().getEdgeByIndex(idx);
                var depth = edge.node1.getLayout().depth;
                var levelModel = parentModel.levelModels[depth];
                return levelModel || this.parentModel;
              });
              return model;
            });
          }
        },
        setNodePosition: function setNodePosition(dataIndex, localPosition) {
          var dataItem = this.option.data[dataIndex];
          dataItem.localX = localPosition[0];
          dataItem.localY = localPosition[1];
        },

        /**
         * Return the graphic data structure
         *
         * @return {module:echarts/data/Graph} graphic data structure
         */
        getGraph: function getGraph() {
          return this.getData().graph;
        },

        /**
         * Get edge data of graphic data structure
         *
         * @return {module:echarts/data/List} data structure of list
         */
        getEdgeData: function getEdgeData() {
          return this.getGraph().edgeData;
        },

        /**
         * @override
         */
        formatTooltip: function formatTooltip(dataIndex, multipleSeries, dataType) {
          // dataType === 'node' or empty do not show tooltip by default
          if (dataType === 'edge') {
            var params = this.getDataParams(dataIndex, dataType);
            var rawDataOpt = params.data;
            var html = rawDataOpt.source + ' -- ' + rawDataOpt.target;

            if (params.value) {
              html += ' : ' + params.value;
            }

            return encodeHTML(html);
          } else if (dataType === 'node') {
            var node = this.getGraph().getNodeByIndex(dataIndex);
            var value = node.getLayout().value;
            var name = this.getDataParams(dataIndex, dataType).data.name;

            if (value) {
              var html = name + ' : ' + value;
            }

            return encodeHTML(html);
          }

          return SankeySeries.superCall(this, 'formatTooltip', dataIndex, multipleSeries);
        },
        optionUpdated: function optionUpdated() {
          var option = this.option;

          if (option.focusNodeAdjacency === true) {
            option.focusNodeAdjacency = 'allEdges';
          }
        },
        // Override Series.getDataParams()
        getDataParams: function getDataParams(dataIndex, dataType) {
          var params = SankeySeries.superCall(this, 'getDataParams', dataIndex, dataType);

          if (params.value == null && dataType === 'node') {
            var node = this.getGraph().getNodeByIndex(dataIndex);
            var nodeValue = node.getLayout().value;
            params.value = nodeValue;
          }

          return params;
        },
        defaultOption: {
          zlevel: 0,
          z: 2,
          coordinateSystem: 'view',
          layout: null,
          // The position of the whole view
          left: '5%',
          top: '5%',
          right: '20%',
          bottom: '5%',
          // Value can be 'vertical'
          orient: 'horizontal',
          // The dx of the node
          nodeWidth: 20,
          // The vertical distance between two nodes
          nodeGap: 8,
          // Control if the node can move or not
          draggable: true,
          // Value can be 'inEdges', 'outEdges', 'allEdges', true (the same as 'allEdges').
          focusNodeAdjacency: false,
          // The number of iterations to change the position of the node
          layoutIterations: 32,
          label: {
            show: true,
            position: 'right',
            color: '#000',
            fontSize: 12
          },
          levels: [],
          // Value can be 'left' or 'right'
          nodeAlign: 'justify',
          itemStyle: {
            borderWidth: 1,
            borderColor: '#333'
          },
          lineStyle: {
            color: '#314656',
            opacity: 0.2,
            curveness: 0.5
          },
          emphasis: {
            label: {
              show: true
            },
            lineStyle: {
              opacity: 0.5
            }
          },
          animationEasing: 'linear',
          animationDuration: 1000
        }
      });
      var _default = SankeySeries;
      module.exports = _default;
      /***/
    },

    /***/
    "0HBW":
    /*!***************************************************!*\
      !*** ./node_modules/echarts/lib/component/geo.js ***!
      \***************************************************/

    /*! no static exports found */

    /***/
    function HBW(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      __webpack_require__(
      /*! ../coord/geo/GeoModel */
      "Hxpc");

      __webpack_require__(
      /*! ../coord/geo/geoCreator */
      "7uqq");

      __webpack_require__(
      /*! ./geo/GeoView */
      "dmGj");

      __webpack_require__(
      /*! ../action/geoRoam */
      "SehX");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function makeAction(method, actionInfo) {
        actionInfo.update = 'updateView';
        echarts.registerAction(actionInfo, function (payload, ecModel) {
          var selected = {};
          ecModel.eachComponent({
            mainType: 'geo',
            query: payload
          }, function (geoModel) {
            geoModel[method](payload.name);
            var geo = geoModel.coordinateSystem;
            zrUtil.each(geo.regions, function (region) {
              selected[region.name] = geoModel.isSelected(region.name) || false;
            });
          });
          return {
            selected: selected,
            name: payload.name
          };
        });
      }

      makeAction('toggleSelected', {
        type: 'geoToggleSelect',
        event: 'geoselectchanged'
      });
      makeAction('select', {
        type: 'geoSelect',
        event: 'geoselected'
      });
      makeAction('unSelect', {
        type: 'geoUnSelect',
        event: 'geounselected'
      });
      /***/
    },

    /***/
    "0JAE":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/calendar/Calendar.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function JAE(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var layout = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var numberUtil = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var CoordinateSystem = __webpack_require__(
      /*! ../../CoordinateSystem */
      "IDmD");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // (24*60*60*1000)


      var PROXIMATE_ONE_DAY = 86400000;
      /**
       * Calendar
       *
       * @constructor
       *
       * @param {Object} calendarModel calendarModel
       * @param {Object} ecModel       ecModel
       * @param {Object} api           api
       */

      function Calendar(calendarModel, ecModel, api) {
        this._model = calendarModel;
      }

      Calendar.prototype = {
        constructor: Calendar,
        type: 'calendar',
        dimensions: ['time', 'value'],
        // Required in createListFromData
        getDimensionsInfo: function getDimensionsInfo() {
          return [{
            name: 'time',
            type: 'time'
          }, 'value'];
        },
        getRangeInfo: function getRangeInfo() {
          return this._rangeInfo;
        },
        getModel: function getModel() {
          return this._model;
        },
        getRect: function getRect() {
          return this._rect;
        },
        getCellWidth: function getCellWidth() {
          return this._sw;
        },
        getCellHeight: function getCellHeight() {
          return this._sh;
        },
        getOrient: function getOrient() {
          return this._orient;
        },

        /**
         * getFirstDayOfWeek
         *
         * @example
         *     0 : start at Sunday
         *     1 : start at Monday
         *
         * @return {number}
         */
        getFirstDayOfWeek: function getFirstDayOfWeek() {
          return this._firstDayOfWeek;
        },

        /**
         * get date info
         *
         * @param  {string|number} date date
         * @return {Object}
         * {
         *      y: string, local full year, eg., '1940',
         *      m: string, local month, from '01' ot '12',
         *      d: string, local date, from '01' to '31' (if exists),
         *      day: It is not date.getDay(). It is the location of the cell in a week, from 0 to 6,
         *      time: timestamp,
         *      formatedDate: string, yyyy-MM-dd,
         *      date: original date object.
         * }
         */
        getDateInfo: function getDateInfo(date) {
          date = numberUtil.parseDate(date);
          var y = date.getFullYear();
          var m = date.getMonth() + 1;
          m = m < 10 ? '0' + m : m;
          var d = date.getDate();
          d = d < 10 ? '0' + d : d;
          var day = date.getDay();
          day = Math.abs((day + 7 - this.getFirstDayOfWeek()) % 7);
          return {
            y: y,
            m: m,
            d: d,
            day: day,
            time: date.getTime(),
            formatedDate: y + '-' + m + '-' + d,
            date: date
          };
        },
        getNextNDay: function getNextNDay(date, n) {
          n = n || 0;

          if (n === 0) {
            return this.getDateInfo(date);
          }

          date = new Date(this.getDateInfo(date).time);
          date.setDate(date.getDate() + n);
          return this.getDateInfo(date);
        },
        update: function update(ecModel, api) {
          this._firstDayOfWeek = +this._model.getModel('dayLabel').get('firstDay');
          this._orient = this._model.get('orient');
          this._lineWidth = this._model.getModel('itemStyle').getItemStyle().lineWidth || 0;
          this._rangeInfo = this._getRangeInfo(this._initRangeOption());
          var weeks = this._rangeInfo.weeks || 1;
          var whNames = ['width', 'height'];

          var cellSize = this._model.get('cellSize').slice();

          var layoutParams = this._model.getBoxLayoutParams();

          var cellNumbers = this._orient === 'horizontal' ? [weeks, 7] : [7, weeks];
          zrUtil.each([0, 1], function (idx) {
            if (cellSizeSpecified(cellSize, idx)) {
              layoutParams[whNames[idx]] = cellSize[idx] * cellNumbers[idx];
            }
          });
          var whGlobal = {
            width: api.getWidth(),
            height: api.getHeight()
          };
          var calendarRect = this._rect = layout.getLayoutRect(layoutParams, whGlobal);
          zrUtil.each([0, 1], function (idx) {
            if (!cellSizeSpecified(cellSize, idx)) {
              cellSize[idx] = calendarRect[whNames[idx]] / cellNumbers[idx];
            }
          });

          function cellSizeSpecified(cellSize, idx) {
            return cellSize[idx] != null && cellSize[idx] !== 'auto';
          }

          this._sw = cellSize[0];
          this._sh = cellSize[1];
        },

        /**
         * Convert a time data(time, value) item to (x, y) point.
         *
         * @override
         * @param  {Array|number} data data
         * @param  {boolean} [clamp=true] out of range
         * @return {Array} point
         */
        dataToPoint: function dataToPoint(data, clamp) {
          zrUtil.isArray(data) && (data = data[0]);
          clamp == null && (clamp = true);
          var dayInfo = this.getDateInfo(data);
          var range = this._rangeInfo;
          var date = dayInfo.formatedDate; // if not in range return [NaN, NaN]

          if (clamp && !(dayInfo.time >= range.start.time && dayInfo.time < range.end.time + PROXIMATE_ONE_DAY)) {
            return [NaN, NaN];
          }

          var week = dayInfo.day;

          var nthWeek = this._getRangeInfo([range.start.time, date]).nthWeek;

          if (this._orient === 'vertical') {
            return [this._rect.x + week * this._sw + this._sw / 2, this._rect.y + nthWeek * this._sh + this._sh / 2];
          }

          return [this._rect.x + nthWeek * this._sw + this._sw / 2, this._rect.y + week * this._sh + this._sh / 2];
        },

        /**
         * Convert a (x, y) point to time data
         *
         * @override
         * @param  {string} point point
         * @return {string}       data
         */
        pointToData: function pointToData(point) {
          var date = this.pointToDate(point);
          return date && date.time;
        },

        /**
         * Convert a time date item to (x, y) four point.
         *
         * @param  {Array} data  date[0] is date
         * @param  {boolean} [clamp=true]  out of range
         * @return {Object}       point
         */
        dataToRect: function dataToRect(data, clamp) {
          var point = this.dataToPoint(data, clamp);
          return {
            contentShape: {
              x: point[0] - (this._sw - this._lineWidth) / 2,
              y: point[1] - (this._sh - this._lineWidth) / 2,
              width: this._sw - this._lineWidth,
              height: this._sh - this._lineWidth
            },
            center: point,
            tl: [point[0] - this._sw / 2, point[1] - this._sh / 2],
            tr: [point[0] + this._sw / 2, point[1] - this._sh / 2],
            br: [point[0] + this._sw / 2, point[1] + this._sh / 2],
            bl: [point[0] - this._sw / 2, point[1] + this._sh / 2]
          };
        },

        /**
         * Convert a (x, y) point to time date
         *
         * @param  {Array} point point
         * @return {Object}       date
         */
        pointToDate: function pointToDate(point) {
          var nthX = Math.floor((point[0] - this._rect.x) / this._sw) + 1;
          var nthY = Math.floor((point[1] - this._rect.y) / this._sh) + 1;
          var range = this._rangeInfo.range;

          if (this._orient === 'vertical') {
            return this._getDateByWeeksAndDay(nthY, nthX - 1, range);
          }

          return this._getDateByWeeksAndDay(nthX, nthY - 1, range);
        },

        /**
         * @inheritDoc
         */
        convertToPixel: zrUtil.curry(doConvert, 'dataToPoint'),

        /**
         * @inheritDoc
         */
        convertFromPixel: zrUtil.curry(doConvert, 'pointToData'),

        /**
         * initRange
         *
         * @private
         * @return {Array} [start, end]
         */
        _initRangeOption: function _initRangeOption() {
          var range = this._model.get('range');

          var rg = range;

          if (zrUtil.isArray(rg) && rg.length === 1) {
            rg = rg[0];
          }

          if (/^\d{4}$/.test(rg)) {
            range = [rg + '-01-01', rg + '-12-31'];
          }

          if (/^\d{4}[\/|-]\d{1,2}$/.test(rg)) {
            var start = this.getDateInfo(rg);
            var firstDay = start.date;
            firstDay.setMonth(firstDay.getMonth() + 1);
            var end = this.getNextNDay(firstDay, -1);
            range = [start.formatedDate, end.formatedDate];
          }

          if (/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(rg)) {
            range = [rg, rg];
          }

          var tmp = this._getRangeInfo(range);

          if (tmp.start.time > tmp.end.time) {
            range.reverse();
          }

          return range;
        },

        /**
         * range info
         *
         * @private
         * @param  {Array} range range ['2017-01-01', '2017-07-08']
         *  If range[0] > range[1], they will not be reversed.
         * @return {Object}       obj
         */
        _getRangeInfo: function _getRangeInfo(range) {
          range = [this.getDateInfo(range[0]), this.getDateInfo(range[1])];
          var reversed;

          if (range[0].time > range[1].time) {
            reversed = true;
            range.reverse();
          }

          var allDay = Math.floor(range[1].time / PROXIMATE_ONE_DAY) - Math.floor(range[0].time / PROXIMATE_ONE_DAY) + 1; // Consider case1 (#11677 #10430):
          // Set the system timezone as "UK", set the range to `['2016-07-01', '2016-12-31']`
          // Consider case2:
          // Firstly set system timezone as "Time Zone: America/Toronto",
          // ```
          // var first = new Date(1478412000000 - 3600 * 1000 * 2.5);
          // var second = new Date(1478412000000);
          // var allDays = Math.floor(second / ONE_DAY) - Math.floor(first / ONE_DAY) + 1;
          // ```
          // will get wrong result because of DST. So we should fix it.

          var date = new Date(range[0].time);
          var startDateNum = date.getDate();
          var endDateNum = range[1].date.getDate();
          date.setDate(startDateNum + allDay - 1); // The bias can not over a month, so just compare date.

          var dateNum = date.getDate();

          if (dateNum !== endDateNum) {
            var sign = date.getTime() - range[1].time > 0 ? 1 : -1;

            while ((dateNum = date.getDate()) !== endDateNum && (date.getTime() - range[1].time) * sign > 0) {
              allDay -= sign;
              date.setDate(dateNum - sign);
            }
          }

          var weeks = Math.floor((allDay + range[0].day + 6) / 7);
          var nthWeek = reversed ? -weeks + 1 : weeks - 1;
          reversed && range.reverse();
          return {
            range: [range[0].formatedDate, range[1].formatedDate],
            start: range[0],
            end: range[1],
            allDay: allDay,
            weeks: weeks,
            // From 0.
            nthWeek: nthWeek,
            fweek: range[0].day,
            lweek: range[1].day
          };
        },

        /**
         * get date by nthWeeks and week day in range
         *
         * @private
         * @param  {number} nthWeek the week
         * @param  {number} day   the week day
         * @param  {Array} range [d1, d2]
         * @return {Object}
         */
        _getDateByWeeksAndDay: function _getDateByWeeksAndDay(nthWeek, day, range) {
          var rangeInfo = this._getRangeInfo(range);

          if (nthWeek > rangeInfo.weeks || nthWeek === 0 && day < rangeInfo.fweek || nthWeek === rangeInfo.weeks && day > rangeInfo.lweek) {
            return false;
          }

          var nthDay = (nthWeek - 1) * 7 - rangeInfo.fweek + day;
          var date = new Date(rangeInfo.start.time);
          date.setDate(rangeInfo.start.d + nthDay);
          return this.getDateInfo(date);
        }
      };
      Calendar.dimensions = Calendar.prototype.dimensions;
      Calendar.getDimensionsInfo = Calendar.prototype.getDimensionsInfo;

      Calendar.create = function (ecModel, api) {
        var calendarList = [];
        ecModel.eachComponent('calendar', function (calendarModel) {
          var calendar = new Calendar(calendarModel, ecModel, api);
          calendarList.push(calendar);
          calendarModel.coordinateSystem = calendar;
        });
        ecModel.eachSeries(function (calendarSeries) {
          if (calendarSeries.get('coordinateSystem') === 'calendar') {
            // Inject coordinate system
            calendarSeries.coordinateSystem = calendarList[calendarSeries.get('calendarIndex') || 0];
          }
        });
        return calendarList;
      };

      function doConvert(methodName, ecModel, finder, value) {
        var calendarModel = finder.calendarModel;
        var seriesModel = finder.seriesModel;
        var coordSys = calendarModel ? calendarModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null;
        return coordSys === this ? coordSys[methodName](value) : null;
      }

      CoordinateSystem.register('calendar', Calendar);
      var _default = Calendar;
      module.exports = _default;
      /***/
    },

    /***/
    "0o9m":
    /*!******************************************************!*\
      !*** ./node_modules/echarts/lib/component/legend.js ***!
      \******************************************************/

    /*! no static exports found */

    /***/
    function o9m(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ./legend/LegendModel */
      "hNWo");

      __webpack_require__(
      /*! ./legend/legendAction */
      "RlCK");

      __webpack_require__(
      /*! ./legend/LegendView */
      "XpcN");

      var legendFilter = __webpack_require__(
      /*! ./legend/legendFilter */
      "kDyi");

      var Component = __webpack_require__(
      /*! ../model/Component */
      "bLfw");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // Do not contain scrollable legend, for sake of file size.
      // Series Filter


      echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter);
      Component.registerSubTypeDefaulter('legend', function () {
        // Default 'plain' when no type specified.
        return 'plain';
      });
      /***/
    },

    /***/
    "0qV/":
    /*!***************************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/helper/focusNodeAdjacencyAction.js ***!
      \***************************************************************************/

    /*! no static exports found */

    /***/
    function qV(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @payload
       * @property {number} [seriesIndex]
       * @property {string} [seriesId]
       * @property {string} [seriesName]
       * @property {number} [dataIndex]
       */


      echarts.registerAction({
        type: 'focusNodeAdjacency',
        event: 'focusNodeAdjacency',
        update: 'series:focusNodeAdjacency'
      }, function () {});
      /**
       * @payload
       * @property {number} [seriesIndex]
       * @property {string} [seriesId]
       * @property {string} [seriesName]
       */

      echarts.registerAction({
        type: 'unfocusNodeAdjacency',
        event: 'unfocusNodeAdjacency',
        update: 'series:unfocusNodeAdjacency'
      }, function () {});
      /***/
    },

    /***/
    "10cm":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/graph/graphAction.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function cm(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var _roamHelper = __webpack_require__(
      /*! ../../action/roamHelper */
      "2B6p");

      var updateCenterAndZoom = _roamHelper.updateCenterAndZoom;

      __webpack_require__(
      /*! ../helper/focusNodeAdjacencyAction */
      "0qV/");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var actionInfo = {
        type: 'graphRoam',
        event: 'graphRoam',
        update: 'none'
      };
      /**
       * @payload
       * @property {string} name Series name
       * @property {number} [dx]
       * @property {number} [dy]
       * @property {number} [zoom]
       * @property {number} [originX]
       * @property {number} [originY]
       */

      echarts.registerAction(actionInfo, function (payload, ecModel) {
        ecModel.eachComponent({
          mainType: 'series',
          query: payload
        }, function (seriesModel) {
          var coordSys = seriesModel.coordinateSystem;
          var res = updateCenterAndZoom(coordSys, payload);
          seriesModel.setCenter && seriesModel.setCenter(res.center);
          seriesModel.setZoom && seriesModel.setZoom(res.zoom);
        });
      });
      /***/
    },

    /***/
    "1LEl":
    /*!***************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/axisPointer/AxisPointerView.js ***!
      \***************************************************************************/

    /*! no static exports found */

    /***/
    function LEl(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var globalListener = __webpack_require__(
      /*! ./globalListener */
      "F9bG");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var AxisPointerView = echarts.extendComponentView({
        type: 'axisPointer',
        render: function render(globalAxisPointerModel, ecModel, api) {
          var globalTooltipModel = ecModel.getComponent('tooltip');
          var triggerOn = globalAxisPointerModel.get('triggerOn') || globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click'; // Register global listener in AxisPointerView to enable
          // AxisPointerView to be independent to Tooltip.

          globalListener.register('axisPointer', api, function (currTrigger, e, dispatchAction) {
            // If 'none', it is not controlled by mouse totally.
            if (triggerOn !== 'none' && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)) {
              dispatchAction({
                type: 'updateAxisPointer',
                currTrigger: currTrigger,
                x: e && e.offsetX,
                y: e && e.offsetY
              });
            }
          });
        },

        /**
         * @override
         */
        remove: function remove(ecModel, api) {
          globalListener.unregister(api.getZr(), 'axisPointer');
          AxisPointerView.superApply(this._model, 'remove', arguments);
        },

        /**
         * @override
         */
        dispose: function dispose(ecModel, api) {
          globalListener.unregister('axisPointer', api);
          AxisPointerView.superApply(this._model, 'dispose', arguments);
        }
      });
      var _default = AxisPointerView;
      module.exports = _default;
      /***/
    },

    /***/
    "1NG9":
    /*!*****************************************************!*\
      !*** ./node_modules/echarts/lib/chart/line/poly.js ***!
      \*****************************************************/

    /*! no static exports found */

    /***/
    function NG9(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var Path = __webpack_require__(
      /*! zrender/lib/graphic/Path */
      "y+Vt");

      var vec2 = __webpack_require__(
      /*! zrender/lib/core/vector */
      "QBsz");

      var fixClipWithShadow = __webpack_require__(
      /*! zrender/lib/graphic/helper/fixClipWithShadow */
      "iXp4");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // Poly path support NaN point


      var vec2Min = vec2.min;
      var vec2Max = vec2.max;
      var scaleAndAdd = vec2.scaleAndAdd;
      var v2Copy = vec2.copy; // Temporary variable

      var v = [];
      var cp0 = [];
      var cp1 = [];

      function isPointNull(p) {
        return isNaN(p[0]) || isNaN(p[1]);
      }

      function drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
        // if (smoothMonotone == null) {
        //     if (isMono(points, 'x')) {
        //         return drawMono(ctx, points, start, segLen, allLen,
        //             dir, smoothMin, smoothMax, smooth, 'x', connectNulls);
        //     }
        //     else if (isMono(points, 'y')) {
        //         return drawMono(ctx, points, start, segLen, allLen,
        //             dir, smoothMin, smoothMax, smooth, 'y', connectNulls);
        //     }
        //     else {
        //         return drawNonMono.apply(this, arguments);
        //     }
        // }
        // else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {
        //     return drawMono.apply(this, arguments);
        // }
        // else {
        //     return drawNonMono.apply(this, arguments);
        // }
        if (smoothMonotone === 'none' || !smoothMonotone) {
          return drawNonMono.apply(this, arguments);
        } else {
          return drawMono.apply(this, arguments);
        }
      }
      /**
       * Check if points is in monotone.
       *
       * @param {number[][]} points         Array of points which is in [x, y] form
       * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which
       *                                    dimension that is checking.
       *                                    If is 'none', `drawNonMono` should be
       *                                    called.
       *                                    If is undefined, either being monotone
       *                                    in 'x' or 'y' will call `drawMono`.
       */
      // function isMono(points, smoothMonotone) {
      //     if (points.length <= 1) {
      //         return true;
      //     }
      //     var dim = smoothMonotone === 'x' ? 0 : 1;
      //     var last = points[0][dim];
      //     var lastDiff = 0;
      //     for (var i = 1; i < points.length; ++i) {
      //         var diff = points[i][dim] - last;
      //         if (!isNaN(diff) && !isNaN(lastDiff)
      //             && diff !== 0 && lastDiff !== 0
      //             && ((diff >= 0) !== (lastDiff >= 0))
      //         ) {
      //             return false;
      //         }
      //         if (!isNaN(diff) && diff !== 0) {
      //             lastDiff = diff;
      //             last = points[i][dim];
      //         }
      //     }
      //     return true;
      // }

      /**
       * Draw smoothed line in monotone, in which only vertical or horizontal bezier
       * control points will be used. This should be used when points are monotone
       * either in x or y dimension.
       */


      function drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
        var prevIdx = 0;
        var idx = start;

        for (var k = 0; k < segLen; k++) {
          var p = points[idx];

          if (idx >= allLen || idx < 0) {
            break;
          }

          if (isPointNull(p)) {
            if (connectNulls) {
              idx += dir;
              continue;
            }

            break;
          }

          if (idx === start) {
            ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);
          } else {
            if (smooth > 0) {
              var prevP = points[prevIdx];
              var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both

              var ctrlLen = (p[dim] - prevP[dim]) * smooth;
              v2Copy(cp0, prevP);
              cp0[dim] = prevP[dim] + ctrlLen;
              v2Copy(cp1, p);
              cp1[dim] = p[dim] - ctrlLen;
              ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);
            } else {
              ctx.lineTo(p[0], p[1]);
            }
          }

          prevIdx = idx;
          idx += dir;
        }

        return k;
      }
      /**
       * Draw smoothed line in non-monotone, in may cause undesired curve in extreme
       * situations. This should be used when points are non-monotone neither in x or
       * y dimension.
       */


      function drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
        var prevIdx = 0;
        var idx = start;

        for (var k = 0; k < segLen; k++) {
          var p = points[idx];

          if (idx >= allLen || idx < 0) {
            break;
          }

          if (isPointNull(p)) {
            if (connectNulls) {
              idx += dir;
              continue;
            }

            break;
          }

          if (idx === start) {
            ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);
            v2Copy(cp0, p);
          } else {
            if (smooth > 0) {
              var nextIdx = idx + dir;
              var nextP = points[nextIdx];

              if (connectNulls) {
                // Find next point not null
                while (nextP && isPointNull(points[nextIdx])) {
                  nextIdx += dir;
                  nextP = points[nextIdx];
                }
              }

              var ratioNextSeg = 0.5;
              var prevP = points[prevIdx];
              var nextP = points[nextIdx]; // Last point

              if (!nextP || isPointNull(nextP)) {
                v2Copy(cp1, p);
              } else {
                // If next data is null in not connect case
                if (isPointNull(nextP) && !connectNulls) {
                  nextP = p;
                }

                vec2.sub(v, nextP, prevP);
                var lenPrevSeg;
                var lenNextSeg;

                if (smoothMonotone === 'x' || smoothMonotone === 'y') {
                  var dim = smoothMonotone === 'x' ? 0 : 1;
                  lenPrevSeg = Math.abs(p[dim] - prevP[dim]);
                  lenNextSeg = Math.abs(p[dim] - nextP[dim]);
                } else {
                  lenPrevSeg = vec2.dist(p, prevP);
                  lenNextSeg = vec2.dist(p, nextP);
                } // Use ratio of seg length


                ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
                scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));
              } // Smooth constraint


              vec2Min(cp0, cp0, smoothMax);
              vec2Max(cp0, cp0, smoothMin);
              vec2Min(cp1, cp1, smoothMax);
              vec2Max(cp1, cp1, smoothMin);
              ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment

              scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);
            } else {
              ctx.lineTo(p[0], p[1]);
            }
          }

          prevIdx = idx;
          idx += dir;
        }

        return k;
      }

      function getBoundingBox(points, smoothConstraint) {
        var ptMin = [Infinity, Infinity];
        var ptMax = [-Infinity, -Infinity];

        if (smoothConstraint) {
          for (var i = 0; i < points.length; i++) {
            var pt = points[i];

            if (pt[0] < ptMin[0]) {
              ptMin[0] = pt[0];
            }

            if (pt[1] < ptMin[1]) {
              ptMin[1] = pt[1];
            }

            if (pt[0] > ptMax[0]) {
              ptMax[0] = pt[0];
            }

            if (pt[1] > ptMax[1]) {
              ptMax[1] = pt[1];
            }
          }
        }

        return {
          min: smoothConstraint ? ptMin : ptMax,
          max: smoothConstraint ? ptMax : ptMin
        };
      }

      var Polyline = Path.extend({
        type: 'ec-polyline',
        shape: {
          points: [],
          smooth: 0,
          smoothConstraint: true,
          smoothMonotone: null,
          connectNulls: false
        },
        style: {
          fill: null,
          stroke: '#000'
        },
        brush: fixClipWithShadow(Path.prototype.brush),
        buildPath: function buildPath(ctx, shape) {
          var points = shape.points;
          var i = 0;
          var len = points.length;
          var result = getBoundingBox(points, shape.smoothConstraint);

          if (shape.connectNulls) {
            // Must remove first and last null values avoid draw error in polygon
            for (; len > 0; len--) {
              if (!isPointNull(points[len - 1])) {
                break;
              }
            }

            for (; i < len; i++) {
              if (!isPointNull(points[i])) {
                break;
              }
            }
          }

          while (i < len) {
            i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
          }
        }
      });
      var Polygon = Path.extend({
        type: 'ec-polygon',
        shape: {
          points: [],
          // Offset between stacked base points and points
          stackedOnPoints: [],
          smooth: 0,
          stackedOnSmooth: 0,
          smoothConstraint: true,
          smoothMonotone: null,
          connectNulls: false
        },
        brush: fixClipWithShadow(Path.prototype.brush),
        buildPath: function buildPath(ctx, shape) {
          var points = shape.points;
          var stackedOnPoints = shape.stackedOnPoints;
          var i = 0;
          var len = points.length;
          var smoothMonotone = shape.smoothMonotone;
          var bbox = getBoundingBox(points, shape.smoothConstraint);
          var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);

          if (shape.connectNulls) {
            // Must remove first and last null values avoid draw error in polygon
            for (; len > 0; len--) {
              if (!isPointNull(points[len - 1])) {
                break;
              }
            }

            for (; i < len; i++) {
              if (!isPointNull(points[i])) {
                break;
              }
            }
          }

          while (i < len) {
            var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);
            drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
            i += k + 1;
            ctx.closePath();
          }
        }
      });
      exports.Polyline = Polyline;
      exports.Polygon = Polygon;
      /***/
    },

    /***/
    "1tlw":
    /*!******************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/bar/PictorialBarSeries.js ***!
      \******************************************************************/

    /*! no static exports found */

    /***/
    function tlw(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var BaseBarSeries = __webpack_require__(
      /*! ./BaseBarSeries */
      "MBQ8");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var PictorialBarSeries = BaseBarSeries.extend({
        type: 'series.pictorialBar',
        dependencies: ['grid'],
        defaultOption: {
          symbol: 'circle',
          // Customized bar shape
          symbolSize: null,
          // Can be ['100%', '100%'], null means auto.
          symbolRotate: null,
          symbolPosition: null,
          // 'start' or 'end' or 'center', null means auto.
          symbolOffset: null,
          symbolMargin: null,
          // start margin and end margin. Can be a number or a percent string.
          // Auto margin by default.
          symbolRepeat: false,
          // false/null/undefined, means no repeat.
          // Can be true, means auto calculate repeat times and cut by data.
          // Can be a number, specifies repeat times, and do not cut by data.
          // Can be 'fixed', means auto calculate repeat times but do not cut by data.
          symbolRepeatDirection: 'end',
          // 'end' means from 'start' to 'end'.
          symbolClip: false,
          symbolBoundingData: null,
          // Can be 60 or -40 or [-40, 60]
          symbolPatternSize: 400,
          // 400 * 400 px
          barGap: '-100%',
          // In most case, overlap is needed.
          // z can be set in data item, which is z2 actually.
          // Disable progressive
          progressive: 0,
          hoverAnimation: false // Open only when needed.

        },
        getInitialData: function getInitialData(option) {
          // Disable stack.
          option.stack = null;
          return PictorialBarSeries.superApply(this, 'getInitialData', arguments);
        }
      });
      var _default = PictorialBarSeries;
      module.exports = _default;
      /***/
    },

    /***/
    "1u/T":
    /*!*************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/visualMap/visualMapAction.js ***!
      \*************************************************************************/

    /*! no static exports found */

    /***/
    function uT(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var actionInfo = {
        type: 'selectDataRange',
        event: 'dataRangeSelected',
        // FIXME use updateView appears wrong
        update: 'update'
      };
      echarts.registerAction(actionInfo, function (payload, ecModel) {
        ecModel.eachComponent({
          mainType: 'visualMap',
          query: payload
        }, function (model) {
          model.setSelected(payload.selected);
        });
      });
      /***/
    },

    /***/
    "1xaR":
    /*!****************************************************!*\
      !*** ./node_modules/echarts/lib/chart/sunburst.js ***!
      \****************************************************/

    /*! no static exports found */

    /***/
    function xaR(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      __webpack_require__(
      /*! ./sunburst/SunburstSeries */
      "qgGe");

      __webpack_require__(
      /*! ./sunburst/SunburstView */
      "NA0q");

      __webpack_require__(
      /*! ./sunburst/sunburstAction */
      "RPvy");

      var dataColor = __webpack_require__(
      /*! ../visual/dataColor */
      "mOdp");

      var sunburstLayout = __webpack_require__(
      /*! ./sunburst/sunburstLayout */
      "y3NT");

      var dataFilter = __webpack_require__(
      /*! ../processor/dataFilter */
      "0/Rx");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      echarts.registerVisual(zrUtil.curry(dataColor, 'sunburst'));
      echarts.registerLayout(zrUtil.curry(sunburstLayout, 'sunburst'));
      echarts.registerProcessor(zrUtil.curry(dataFilter, 'sunburst'));
      /***/
    },

    /***/
    "2548":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/component/toolbox/ToolboxView.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function _(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var textContain = __webpack_require__(
      /*! zrender/lib/contain/text */
      "6GrX");

      var featureManager = __webpack_require__(
      /*! ./featureManager */
      "IUWy");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var Model = __webpack_require__(
      /*! ../../model/Model */
      "Qxkt");

      var DataDiffer = __webpack_require__(
      /*! ../../data/DataDiffer */
      "gPAo");

      var listComponentHelper = __webpack_require__(
      /*! ../helper/listComponent */
      "eRkO");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = echarts.extendComponentView({
        type: 'toolbox',
        render: function render(toolboxModel, ecModel, api, payload) {
          var group = this.group;
          group.removeAll();

          if (!toolboxModel.get('show')) {
            return;
          }

          var itemSize = +toolboxModel.get('itemSize');
          var featureOpts = toolboxModel.get('feature') || {};
          var features = this._features || (this._features = {});
          var featureNames = [];
          zrUtil.each(featureOpts, function (opt, name) {
            featureNames.push(name);
          });
          new DataDiffer(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(zrUtil.curry(processFeature, null)).execute(); // Keep for diff.

          this._featureNames = featureNames;

          function processFeature(newIndex, oldIndex) {
            var featureName = featureNames[newIndex];
            var oldName = featureNames[oldIndex];
            var featureOpt = featureOpts[featureName];
            var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);
            var feature; // FIX#11236, merge feature title from MagicType newOption. TODO: consider seriesIndex ?

            if (payload && payload.newTitle != null && payload.featureName === featureName) {
              featureOpt.title = payload.newTitle;
            }

            if (featureName && !oldName) {
              // Create
              if (isUserFeatureName(featureName)) {
                feature = {
                  model: featureModel,
                  onclick: featureModel.option.onclick,
                  featureName: featureName
                };
              } else {
                var Feature = featureManager.get(featureName);

                if (!Feature) {
                  return;
                }

                feature = new Feature(featureModel, ecModel, api);
              }

              features[featureName] = feature;
            } else {
              feature = features[oldName]; // If feature does not exsit.

              if (!feature) {
                return;
              }

              feature.model = featureModel;
              feature.ecModel = ecModel;
              feature.api = api;
            }

            if (!featureName && oldName) {
              feature.dispose && feature.dispose(ecModel, api);
              return;
            }

            if (!featureModel.get('show') || feature.unusable) {
              feature.remove && feature.remove(ecModel, api);
              return;
            }

            createIconPaths(featureModel, feature, featureName);

            featureModel.setIconStatus = function (iconName, status) {
              var option = this.option;
              var iconPaths = this.iconPaths;
              option.iconStatus = option.iconStatus || {};
              option.iconStatus[iconName] = status; // FIXME

              iconPaths[iconName] && iconPaths[iconName].trigger(status);
            };

            if (feature.render) {
              feature.render(featureModel, ecModel, api, payload);
            }
          }

          function createIconPaths(featureModel, feature, featureName) {
            var iconStyleModel = featureModel.getModel('iconStyle');
            var iconStyleEmphasisModel = featureModel.getModel('emphasis.iconStyle'); // If one feature has mutiple icon. they are orginaized as
            // {
            //     icon: {
            //         foo: '',
            //         bar: ''
            //     },
            //     title: {
            //         foo: '',
            //         bar: ''
            //     }
            // }

            var icons = feature.getIcons ? feature.getIcons() : featureModel.get('icon');
            var titles = featureModel.get('title') || {};

            if (typeof icons === 'string') {
              var icon = icons;
              var title = titles;
              icons = {};
              titles = {};
              icons[featureName] = icon;
              titles[featureName] = title;
            }

            var iconPaths = featureModel.iconPaths = {};
            zrUtil.each(icons, function (iconStr, iconName) {
              var path = graphic.createIcon(iconStr, {}, {
                x: -itemSize / 2,
                y: -itemSize / 2,
                width: itemSize,
                height: itemSize
              });
              path.setStyle(iconStyleModel.getItemStyle());
              path.hoverStyle = iconStyleEmphasisModel.getItemStyle(); // Text position calculation

              path.setStyle({
                text: titles[iconName],
                textAlign: iconStyleEmphasisModel.get('textAlign'),
                textBorderRadius: iconStyleEmphasisModel.get('textBorderRadius'),
                textPadding: iconStyleEmphasisModel.get('textPadding'),
                textFill: null
              });
              var tooltipModel = toolboxModel.getModel('tooltip');

              if (tooltipModel && tooltipModel.get('show')) {
                path.attr('tooltip', zrUtil.extend({
                  content: titles[iconName],
                  formatter: tooltipModel.get('formatter', true) || function () {
                    return titles[iconName];
                  },
                  formatterParams: {
                    componentType: 'toolbox',
                    name: iconName,
                    title: titles[iconName],
                    $vars: ['name', 'title']
                  },
                  position: tooltipModel.get('position', true) || 'bottom'
                }, tooltipModel.option));
              }

              graphic.setHoverStyle(path);

              if (toolboxModel.get('showTitle')) {
                path.__title = titles[iconName];
                path.on('mouseover', function () {
                  // Should not reuse above hoverStyle, which might be modified.
                  var hoverStyle = iconStyleEmphasisModel.getItemStyle();
                  var defaultTextPosition = toolboxModel.get('orient') === 'vertical' ? toolboxModel.get('right') == null ? 'right' : 'left' : toolboxModel.get('bottom') == null ? 'bottom' : 'top';
                  path.setStyle({
                    textFill: iconStyleEmphasisModel.get('textFill') || hoverStyle.fill || hoverStyle.stroke || '#000',
                    textBackgroundColor: iconStyleEmphasisModel.get('textBackgroundColor'),
                    textPosition: iconStyleEmphasisModel.get('textPosition') || defaultTextPosition
                  });
                }).on('mouseout', function () {
                  path.setStyle({
                    textFill: null,
                    textBackgroundColor: null
                  });
                });
              }

              path.trigger(featureModel.get('iconStatus.' + iconName) || 'normal');
              group.add(path);
              path.on('click', zrUtil.bind(feature.onclick, feature, ecModel, api, iconName));
              iconPaths[iconName] = path;
            });
          }

          listComponentHelper.layout(group, toolboxModel, api); // Render background after group is layout
          // FIXME

          group.add(listComponentHelper.makeBackground(group.getBoundingRect(), toolboxModel)); // Adjust icon title positions to avoid them out of screen

          group.eachChild(function (icon) {
            var titleText = icon.__title;
            var hoverStyle = icon.hoverStyle; // May be background element

            if (hoverStyle && titleText) {
              var rect = textContain.getBoundingRect(titleText, textContain.makeFont(hoverStyle));
              var offsetX = icon.position[0] + group.position[0];
              var offsetY = icon.position[1] + group.position[1] + itemSize;
              var needPutOnTop = false;

              if (offsetY + rect.height > api.getHeight()) {
                hoverStyle.textPosition = 'top';
                needPutOnTop = true;
              }

              var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 8;

              if (offsetX + rect.width / 2 > api.getWidth()) {
                hoverStyle.textPosition = ['100%', topOffset];
                hoverStyle.textAlign = 'right';
              } else if (offsetX - rect.width / 2 < 0) {
                hoverStyle.textPosition = [0, topOffset];
                hoverStyle.textAlign = 'left';
              }
            }
          });
        },
        updateView: function updateView(toolboxModel, ecModel, api, payload) {
          zrUtil.each(this._features, function (feature) {
            feature.updateView && feature.updateView(feature.model, ecModel, api, payload);
          });
        },
        // updateLayout: function (toolboxModel, ecModel, api, payload) {
        //     zrUtil.each(this._features, function (feature) {
        //         feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);
        //     });
        // },
        remove: function remove(ecModel, api) {
          zrUtil.each(this._features, function (feature) {
            feature.remove && feature.remove(ecModel, api);
          });
          this.group.removeAll();
        },
        dispose: function dispose(ecModel, api) {
          zrUtil.each(this._features, function (feature) {
            feature.dispose && feature.dispose(ecModel, api);
          });
        }
      });

      function isUserFeatureName(featureName) {
        return featureName.indexOf('my') === 0;
      }

      module.exports = _default;
      /***/
    },

    /***/
    "2B6p":
    /*!*******************************************************!*\
      !*** ./node_modules/echarts/lib/action/roamHelper.js ***!
      \*******************************************************/

    /*! no static exports found */

    /***/
    function B6p(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @param {module:echarts/coord/View} view
       * @param {Object} payload
       * @param {Object} [zoomLimit]
       */
      function updateCenterAndZoom(view, payload, zoomLimit) {
        var previousZoom = view.getZoom();
        var center = view.getCenter();
        var zoom = payload.zoom;
        var point = view.dataToPoint(center);

        if (payload.dx != null && payload.dy != null) {
          point[0] -= payload.dx;
          point[1] -= payload.dy;
          var center = view.pointToData(point);
          view.setCenter(center);
        }

        if (zoom != null) {
          if (zoomLimit) {
            var zoomMin = zoomLimit.min || 0;
            var zoomMax = zoomLimit.max || Infinity;
            zoom = Math.max(Math.min(previousZoom * zoom, zoomMax), zoomMin) / previousZoom;
          } // Zoom on given point(originX, originY)


          view.scale[0] *= zoom;
          view.scale[1] *= zoom;
          var position = view.position;
          var fixX = (payload.originX - position[0]) * (zoom - 1);
          var fixY = (payload.originY - position[1]) * (zoom - 1);
          position[0] -= fixX;
          position[1] -= fixY;
          view.updateTransform(); // Get the new center

          var center = view.pointToData(point);
          view.setCenter(center);
          view.setZoom(zoom * previousZoom);
        }

        return {
          center: view.getCenter(),
          zoom: view.getZoom()
        };
      }

      exports.updateCenterAndZoom = updateCenterAndZoom;
      /***/
    },

    /***/
    "2dDv":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/parallel/Parallel.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function dDv(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var matrix = __webpack_require__(
      /*! zrender/lib/core/matrix */
      "Fofx");

      var layoutUtil = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var axisHelper = __webpack_require__(
      /*! ../../coord/axisHelper */
      "aX7z");

      var ParallelAxis = __webpack_require__(
      /*! ./ParallelAxis */
      "D1WM");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var numberUtil = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var sliderMove = __webpack_require__(
      /*! ../../component/helper/sliderMove */
      "72pK");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Parallel Coordinates
       * <https://en.wikipedia.org/wiki/Parallel_coordinates>
       */


      var each = zrUtil.each;
      var mathMin = Math.min;
      var mathMax = Math.max;
      var mathFloor = Math.floor;
      var mathCeil = Math.ceil;
      var round = numberUtil.round;
      var PI = Math.PI;

      function Parallel(parallelModel, ecModel, api) {
        /**
         * key: dimension
         * @type {Object.<string, module:echarts/coord/parallel/Axis>}
         * @private
         */
        this._axesMap = zrUtil.createHashMap();
        /**
         * key: dimension
         * value: {position: [], rotation, }
         * @type {Object.<string, Object>}
         * @private
         */

        this._axesLayout = {};
        /**
         * Always follow axis order.
         * @type {Array.<string>}
         * @readOnly
         */

        this.dimensions = parallelModel.dimensions;
        /**
         * @type {module:zrender/core/BoundingRect}
         */

        this._rect;
        /**
         * @type {module:echarts/coord/parallel/ParallelModel}
         */

        this._model = parallelModel;

        this._init(parallelModel, ecModel, api);
      }

      Parallel.prototype = {
        type: 'parallel',
        constructor: Parallel,

        /**
         * Initialize cartesian coordinate systems
         * @private
         */
        _init: function _init(parallelModel, ecModel, api) {
          var dimensions = parallelModel.dimensions;
          var parallelAxisIndex = parallelModel.parallelAxisIndex;
          each(dimensions, function (dim, idx) {
            var axisIndex = parallelAxisIndex[idx];
            var axisModel = ecModel.getComponent('parallelAxis', axisIndex);

            var axis = this._axesMap.set(dim, new ParallelAxis(dim, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisIndex));

            var isCategory = axis.type === 'category';
            axis.onBand = isCategory && axisModel.get('boundaryGap');
            axis.inverse = axisModel.get('inverse'); // Injection

            axisModel.axis = axis;
            axis.model = axisModel;
            axis.coordinateSystem = axisModel.coordinateSystem = this;
          }, this);
        },

        /**
         * Update axis scale after data processed
         * @param  {module:echarts/model/Global} ecModel
         * @param  {module:echarts/ExtensionAPI} api
         */
        update: function update(ecModel, api) {
          this._updateAxesFromSeries(this._model, ecModel);
        },

        /**
         * @override
         */
        containPoint: function containPoint(point) {
          var layoutInfo = this._makeLayoutInfo();

          var axisBase = layoutInfo.axisBase;
          var layoutBase = layoutInfo.layoutBase;
          var pixelDimIndex = layoutInfo.pixelDimIndex;
          var pAxis = point[1 - pixelDimIndex];
          var pLayout = point[pixelDimIndex];
          return pAxis >= axisBase && pAxis <= axisBase + layoutInfo.axisLength && pLayout >= layoutBase && pLayout <= layoutBase + layoutInfo.layoutLength;
        },
        getModel: function getModel() {
          return this._model;
        },

        /**
         * Update properties from series
         * @private
         */
        _updateAxesFromSeries: function _updateAxesFromSeries(parallelModel, ecModel) {
          ecModel.eachSeries(function (seriesModel) {
            if (!parallelModel.contains(seriesModel, ecModel)) {
              return;
            }

            var data = seriesModel.getData();
            each(this.dimensions, function (dim) {
              var axis = this._axesMap.get(dim);

              axis.scale.unionExtentFromData(data, data.mapDimension(dim));
              axisHelper.niceScaleExtent(axis.scale, axis.model);
            }, this);
          }, this);
        },

        /**
         * Resize the parallel coordinate system.
         * @param {module:echarts/coord/parallel/ParallelModel} parallelModel
         * @param {module:echarts/ExtensionAPI} api
         */
        resize: function resize(parallelModel, api) {
          this._rect = layoutUtil.getLayoutRect(parallelModel.getBoxLayoutParams(), {
            width: api.getWidth(),
            height: api.getHeight()
          });

          this._layoutAxes();
        },

        /**
         * @return {module:zrender/core/BoundingRect}
         */
        getRect: function getRect() {
          return this._rect;
        },

        /**
         * @private
         */
        _makeLayoutInfo: function _makeLayoutInfo() {
          var parallelModel = this._model;
          var rect = this._rect;
          var xy = ['x', 'y'];
          var wh = ['width', 'height'];
          var layout = parallelModel.get('layout');
          var pixelDimIndex = layout === 'horizontal' ? 0 : 1;
          var layoutLength = rect[wh[pixelDimIndex]];
          var layoutExtent = [0, layoutLength];
          var axisCount = this.dimensions.length;
          var axisExpandWidth = restrict(parallelModel.get('axisExpandWidth'), layoutExtent);
          var axisExpandCount = restrict(parallelModel.get('axisExpandCount') || 0, [0, axisCount]);
          var axisExpandable = parallelModel.get('axisExpandable') && axisCount > 3 && axisCount > axisExpandCount && axisExpandCount > 1 && axisExpandWidth > 0 && layoutLength > 0; // `axisExpandWindow` is According to the coordinates of [0, axisExpandLength],
          // for sake of consider the case that axisCollapseWidth is 0 (when screen is narrow),
          // where collapsed axes should be overlapped.

          var axisExpandWindow = parallelModel.get('axisExpandWindow');
          var winSize;

          if (!axisExpandWindow) {
            winSize = restrict(axisExpandWidth * (axisExpandCount - 1), layoutExtent);
            var axisExpandCenter = parallelModel.get('axisExpandCenter') || mathFloor(axisCount / 2);
            axisExpandWindow = [axisExpandWidth * axisExpandCenter - winSize / 2];
            axisExpandWindow[1] = axisExpandWindow[0] + winSize;
          } else {
            winSize = restrict(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent);
            axisExpandWindow[1] = axisExpandWindow[0] + winSize;
          }

          var axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount); // Avoid axisCollapseWidth is too small.

          axisCollapseWidth < 3 && (axisCollapseWidth = 0); // Find the first and last indices > ewin[0] and < ewin[1].

          var winInnerIndices = [mathFloor(round(axisExpandWindow[0] / axisExpandWidth, 1)) + 1, mathCeil(round(axisExpandWindow[1] / axisExpandWidth, 1)) - 1]; // Pos in ec coordinates.

          var axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0];
          return {
            layout: layout,
            pixelDimIndex: pixelDimIndex,
            layoutBase: rect[xy[pixelDimIndex]],
            layoutLength: layoutLength,
            axisBase: rect[xy[1 - pixelDimIndex]],
            axisLength: rect[wh[1 - pixelDimIndex]],
            axisExpandable: axisExpandable,
            axisExpandWidth: axisExpandWidth,
            axisCollapseWidth: axisCollapseWidth,
            axisExpandWindow: axisExpandWindow,
            axisCount: axisCount,
            winInnerIndices: winInnerIndices,
            axisExpandWindow0Pos: axisExpandWindow0Pos
          };
        },

        /**
         * @private
         */
        _layoutAxes: function _layoutAxes() {
          var rect = this._rect;
          var axes = this._axesMap;
          var dimensions = this.dimensions;

          var layoutInfo = this._makeLayoutInfo();

          var layout = layoutInfo.layout;
          axes.each(function (axis) {
            var axisExtent = [0, layoutInfo.axisLength];
            var idx = axis.inverse ? 1 : 0;
            axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);
          });
          each(dimensions, function (dim, idx) {
            var posInfo = (layoutInfo.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(idx, layoutInfo);
            var positionTable = {
              horizontal: {
                x: posInfo.position,
                y: layoutInfo.axisLength
              },
              vertical: {
                x: 0,
                y: posInfo.position
              }
            };
            var rotationTable = {
              horizontal: PI / 2,
              vertical: 0
            };
            var position = [positionTable[layout].x + rect.x, positionTable[layout].y + rect.y];
            var rotation = rotationTable[layout];
            var transform = matrix.create();
            matrix.rotate(transform, transform, rotation);
            matrix.translate(transform, transform, position); // TODO
            // tick
            // TODO
            // axis order  dimensions

            this._axesLayout[dim] = {
              position: position,
              rotation: rotation,
              transform: transform,
              axisNameAvailableWidth: posInfo.axisNameAvailableWidth,
              axisLabelShow: posInfo.axisLabelShow,
              nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth,
              tickDirection: 1,
              labelDirection: 1
            };
          }, this);
        },

        /**
         * Get axis by dim.
         * @param {string} dim
         * @return {module:echarts/coord/parallel/ParallelAxis} [description]
         */
        getAxis: function getAxis(dim) {
          return this._axesMap.get(dim);
        },

        /**
         * Convert a dim value of a single item of series data to Point.
         * @param {*} value
         * @param {string} dim
         * @return {Array}
         */
        dataToPoint: function dataToPoint(value, dim) {
          return this.axisCoordToPoint(this._axesMap.get(dim).dataToCoord(value), dim);
        },

        /**
         * Travel data for one time, get activeState of each data item.
         * @param {module:echarts/data/List} data
         * @param {Functio} cb param: {string} activeState 'active' or 'inactive' or 'normal'
         *                            {number} dataIndex
         * @param {number} [start=0] the start dataIndex that travel from.
         * @param {number} [end=data.count()] the next dataIndex of the last dataIndex will be travel.
         */
        eachActiveState: function eachActiveState(data, callback, start, end) {
          start == null && (start = 0);
          end == null && (end = data.count());
          var axesMap = this._axesMap;
          var dimensions = this.dimensions;
          var dataDimensions = [];
          var axisModels = [];
          zrUtil.each(dimensions, function (axisDim) {
            dataDimensions.push(data.mapDimension(axisDim));
            axisModels.push(axesMap.get(axisDim).model);
          });
          var hasActiveSet = this.hasAxisBrushed();

          for (var dataIndex = start; dataIndex < end; dataIndex++) {
            var activeState;

            if (!hasActiveSet) {
              activeState = 'normal';
            } else {
              activeState = 'active';
              var values = data.getValues(dataDimensions, dataIndex);

              for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
                var state = axisModels[j].getActiveState(values[j]);

                if (state === 'inactive') {
                  activeState = 'inactive';
                  break;
                }
              }
            }

            callback(activeState, dataIndex);
          }
        },

        /**
         * Whether has any activeSet.
         * @return {boolean}
         */
        hasAxisBrushed: function hasAxisBrushed() {
          var dimensions = this.dimensions;
          var axesMap = this._axesMap;
          var hasActiveSet = false;

          for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
            if (axesMap.get(dimensions[j]).model.getActiveState() !== 'normal') {
              hasActiveSet = true;
            }
          }

          return hasActiveSet;
        },

        /**
         * Convert coords of each axis to Point.
         *  Return point. For example: [10, 20]
         * @param {Array.<number>} coords
         * @param {string} dim
         * @return {Array.<number>}
         */
        axisCoordToPoint: function axisCoordToPoint(coord, dim) {
          var axisLayout = this._axesLayout[dim];
          return graphic.applyTransform([coord, 0], axisLayout.transform);
        },

        /**
         * Get axis layout.
         */
        getAxisLayout: function getAxisLayout(dim) {
          return zrUtil.clone(this._axesLayout[dim]);
        },

        /**
         * @param {Array.<number>} point
         * @return {Object} {axisExpandWindow, delta, behavior: 'jump' | 'slide' | 'none'}.
         */
        getSlidedAxisExpandWindow: function getSlidedAxisExpandWindow(point) {
          var layoutInfo = this._makeLayoutInfo();

          var pixelDimIndex = layoutInfo.pixelDimIndex;
          var axisExpandWindow = layoutInfo.axisExpandWindow.slice();
          var winSize = axisExpandWindow[1] - axisExpandWindow[0];
          var extent = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)]; // Out of the area of coordinate system.

          if (!this.containPoint(point)) {
            return {
              behavior: 'none',
              axisExpandWindow: axisExpandWindow
            };
          } // Conver the point from global to expand coordinates.


          var pointCoord = point[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos; // For dragging operation convenience, the window should not be
          // slided when mouse is the center area of the window.

          var delta;
          var behavior = 'slide';
          var axisCollapseWidth = layoutInfo.axisCollapseWidth;

          var triggerArea = this._model.get('axisExpandSlideTriggerArea'); // But consider touch device, jump is necessary.


          var useJump = triggerArea[0] != null;

          if (axisCollapseWidth) {
            if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) {
              behavior = 'jump';
              delta = pointCoord - winSize * triggerArea[2];
            } else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) {
              behavior = 'jump';
              delta = pointCoord - winSize * (1 - triggerArea[2]);
            } else {
              (delta = pointCoord - winSize * triggerArea[1]) >= 0 && (delta = pointCoord - winSize * (1 - triggerArea[1])) <= 0 && (delta = 0);
            }

            delta *= layoutInfo.axisExpandWidth / axisCollapseWidth;
            delta ? sliderMove(delta, axisExpandWindow, extent, 'all') // Avoid nonsense triger on mousemove.
            : behavior = 'none';
          } // When screen is too narrow, make it visible and slidable, although it is hard to interact.
          else {
            var winSize = axisExpandWindow[1] - axisExpandWindow[0];
            var pos = extent[1] * pointCoord / winSize;
            axisExpandWindow = [mathMax(0, pos - winSize / 2)];
            axisExpandWindow[1] = mathMin(extent[1], axisExpandWindow[0] + winSize);
            axisExpandWindow[0] = axisExpandWindow[1] - winSize;
          }

          return {
            axisExpandWindow: axisExpandWindow,
            behavior: behavior
          };
        }
      };

      function restrict(len, extent) {
        return mathMin(mathMax(len, extent[0]), extent[1]);
      }

      function layoutAxisWithoutExpand(axisIndex, layoutInfo) {
        var step = layoutInfo.layoutLength / (layoutInfo.axisCount - 1);
        return {
          position: step * axisIndex,
          axisNameAvailableWidth: step,
          axisLabelShow: true
        };
      }

      function layoutAxisWithExpand(axisIndex, layoutInfo) {
        var layoutLength = layoutInfo.layoutLength;
        var axisExpandWidth = layoutInfo.axisExpandWidth;
        var axisCount = layoutInfo.axisCount;
        var axisCollapseWidth = layoutInfo.axisCollapseWidth;
        var winInnerIndices = layoutInfo.winInnerIndices;
        var position;
        var axisNameAvailableWidth = axisCollapseWidth;
        var axisLabelShow = false;
        var nameTruncateMaxWidth;

        if (axisIndex < winInnerIndices[0]) {
          position = axisIndex * axisCollapseWidth;
          nameTruncateMaxWidth = axisCollapseWidth;
        } else if (axisIndex <= winInnerIndices[1]) {
          position = layoutInfo.axisExpandWindow0Pos + axisIndex * axisExpandWidth - layoutInfo.axisExpandWindow[0];
          axisNameAvailableWidth = axisExpandWidth;
          axisLabelShow = true;
        } else {
          position = layoutLength - (axisCount - 1 - axisIndex) * axisCollapseWidth;
          nameTruncateMaxWidth = axisCollapseWidth;
        }

        return {
          position: position,
          axisNameAvailableWidth: axisNameAvailableWidth,
          axisLabelShow: axisLabelShow,
          nameTruncateMaxWidth: nameTruncateMaxWidth
        };
      }

      var _default = Parallel;
      module.exports = _default;
      /***/
    },

    /***/
    "2fGM":
    /*!***********************************************************!*\
      !*** ./node_modules/echarts/lib/coord/polar/AxisModel.js ***!
      \***********************************************************/

    /*! no static exports found */

    /***/
    function fGM(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var ComponentModel = __webpack_require__(
      /*! ../../model/Component */
      "bLfw");

      var axisModelCreator = __webpack_require__(
      /*! ../axisModelCreator */
      "nkfE");

      var axisModelCommonMixin = __webpack_require__(
      /*! ../axisModelCommonMixin */
      "ICMv");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var PolarAxisModel = ComponentModel.extend({
        type: 'polarAxis',

        /**
         * @type {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}
         */
        axis: null,

        /**
         * @override
         */
        getCoordSysModel: function getCoordSysModel() {
          return this.ecModel.queryComponents({
            mainType: 'polar',
            index: this.option.polarIndex,
            id: this.option.polarId
          })[0];
        }
      });
      zrUtil.merge(PolarAxisModel.prototype, axisModelCommonMixin);
      var polarAxisDefaultExtendedOption = {
        angle: {
          // polarIndex: 0,
          // polarId: '',
          startAngle: 90,
          clockwise: true,
          splitNumber: 12,
          axisLabel: {
            rotate: false
          }
        },
        radius: {
          // polarIndex: 0,
          // polarId: '',
          splitNumber: 5
        }
      };

      function getAxisType(axisDim, option) {
        // Default axis with data is category axis
        return option.type || (option.data ? 'category' : 'value');
      }

      axisModelCreator('angle', PolarAxisModel, getAxisType, polarAxisDefaultExtendedOption.angle);
      axisModelCreator('radius', PolarAxisModel, getAxisType, polarAxisDefaultExtendedOption.radius);
      /***/
    },

    /***/
    "2uGb":
    /*!***************************************************!*\
      !*** ./node_modules/echarts/lib/chart/treemap.js ***!
      \***************************************************/

    /*! no static exports found */

    /***/
    function uGb(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ./treemap/TreemapSeries */
      "ko1b");

      __webpack_require__(
      /*! ./treemap/TreemapView */
      "s2lz");

      __webpack_require__(
      /*! ./treemap/treemapAction */
      "RBEP");

      var treemapVisual = __webpack_require__(
      /*! ./treemap/treemapVisual */
      "kMLO");

      var treemapLayout = __webpack_require__(
      /*! ./treemap/treemapLayout */
      "nKiI");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      echarts.registerVisual(treemapVisual);
      echarts.registerLayout(treemapLayout);
      /***/
    },

    /***/
    "2w7y":
    /*!*********************************************************!*\
      !*** ./node_modules/echarts/lib/component/markPoint.js ***!
      \*********************************************************/

    /*! no static exports found */

    /***/
    function w7y(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ./marker/MarkPointModel */
      "qMZE");

      __webpack_require__(
      /*! ./marker/MarkPointView */
      "g0SD");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // HINT Markpoint can't be used too much


      echarts.registerPreprocessor(function (opt) {
        // Make sure markPoint component is enabled
        opt.markPoint = opt.markPoint || {};
      });
      /***/
    },

    /***/
    "33Ds":
    /*!***********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/toolbox/feature/Restore.js ***!
      \***********************************************************************/

    /*! no static exports found */

    /***/
    function Ds(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../../echarts */
      "ProS");

      var history = __webpack_require__(
      /*! ../../dataZoom/history */
      "b9oc");

      var lang = __webpack_require__(
      /*! ../../../lang */
      "Kagy");

      var featureManager = __webpack_require__(
      /*! ../featureManager */
      "IUWy");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var restoreLang = lang.toolbox.restore;

      function Restore(model) {
        this.model = model;
      }

      Restore.defaultOption = {
        show: true,

        /* eslint-disable */
        icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',

        /* eslint-enable */
        title: restoreLang.title
      };
      var proto = Restore.prototype;

      proto.onclick = function (ecModel, api, type) {
        history.clear(ecModel);
        api.dispatchAction({
          type: 'restore',
          from: this.uid
        });
      };

      featureManager.register('restore', Restore);
      echarts.registerAction({
        type: 'restore',
        event: 'restore',
        update: 'prepareAndUpdate'
      }, function (payload, ecModel) {
        ecModel.resetOption('recreate');
      });
      var _default = Restore;
      module.exports = _default;
      /***/
    },

    /***/
    "3CBa":
    /*!*************************************************!*\
      !*** ./node_modules/zrender/lib/svg/Painter.js ***!
      \*************************************************/

    /*! no static exports found */

    /***/
    function CBa(module, exports, __webpack_require__) {
      var _core = __webpack_require__(
      /*! ./core */
      "hydK");

      var createElement = _core.createElement;

      var util = __webpack_require__(
      /*! ../core/util */
      "bYtY");

      var logError = __webpack_require__(
      /*! ../core/log */
      "SUKs");

      var Path = __webpack_require__(
      /*! ../graphic/Path */
      "y+Vt");

      var ZImage = __webpack_require__(
      /*! ../graphic/Image */
      "Dagg");

      var ZText = __webpack_require__(
      /*! ../graphic/Text */
      "dqUG");

      var arrayDiff = __webpack_require__(
      /*! ../core/arrayDiff2 */
      "DBLp");

      var GradientManager = __webpack_require__(
      /*! ./helper/GradientManager */
      "sW+o");

      var ClippathManager = __webpack_require__(
      /*! ./helper/ClippathManager */
      "n6Mw");

      var ShadowManager = __webpack_require__(
      /*! ./helper/ShadowManager */
      "vKoX");

      var _graphic = __webpack_require__(
      /*! ./graphic */
      "P47w");

      var svgPath = _graphic.path;
      var svgImage = _graphic.image;
      var svgText = _graphic.text;
      /**
       * SVG Painter
       * @module zrender/svg/Painter
       */

      function parseInt10(val) {
        return parseInt(val, 10);
      }

      function getSvgProxy(el) {
        if (el instanceof Path) {
          return svgPath;
        } else if (el instanceof ZImage) {
          return svgImage;
        } else if (el instanceof ZText) {
          return svgText;
        } else {
          return svgPath;
        }
      }

      function checkParentAvailable(parent, child) {
        return child && parent && child.parentNode !== parent;
      }

      function insertAfter(parent, child, prevSibling) {
        if (checkParentAvailable(parent, child) && prevSibling) {
          var nextSibling = prevSibling.nextSibling;
          nextSibling ? parent.insertBefore(child, nextSibling) : parent.appendChild(child);
        }
      }

      function prepend(parent, child) {
        if (checkParentAvailable(parent, child)) {
          var firstChild = parent.firstChild;
          firstChild ? parent.insertBefore(child, firstChild) : parent.appendChild(child);
        }
      } // function append(parent, child) {
      //     if (checkParentAvailable(parent, child)) {
      //         parent.appendChild(child);
      //     }
      // }


      function remove(parent, child) {
        if (child && parent && child.parentNode === parent) {
          parent.removeChild(child);
        }
      }

      function getTextSvgElement(displayable) {
        return displayable.__textSvgEl;
      }

      function getSvgElement(displayable) {
        return displayable.__svgEl;
      }
      /**
       * @alias module:zrender/svg/Painter
       * @constructor
       * @param {HTMLElement} root 
       * @param {module:zrender/Storage} storage
       * @param {Object} opts
       */


      var SVGPainter = function SVGPainter(root, storage, opts, zrId) {
        this.root = root;
        this.storage = storage;
        this._opts = opts = util.extend({}, opts || {});
        var svgDom = createElement('svg');
        svgDom.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
        svgDom.setAttribute('version', '1.1');
        svgDom.setAttribute('baseProfile', 'full');
        svgDom.style.cssText = 'user-select:none;position:absolute;left:0;top:0;';
        var bgRoot = createElement('g');
        svgDom.appendChild(bgRoot);
        var svgRoot = createElement('g');
        svgDom.appendChild(svgRoot);
        this.gradientManager = new GradientManager(zrId, svgRoot);
        this.clipPathManager = new ClippathManager(zrId, svgRoot);
        this.shadowManager = new ShadowManager(zrId, svgRoot);
        var viewport = document.createElement('div');
        viewport.style.cssText = 'overflow:hidden;position:relative';
        this._svgDom = svgDom;
        this._svgRoot = svgRoot;
        this._backgroundRoot = bgRoot;
        this._viewport = viewport;
        root.appendChild(viewport);
        viewport.appendChild(svgDom);
        this.resize(opts.width, opts.height);
        this._visibleList = [];
      };

      SVGPainter.prototype = {
        constructor: SVGPainter,
        getType: function getType() {
          return 'svg';
        },
        getViewportRoot: function getViewportRoot() {
          return this._viewport;
        },
        getSvgDom: function getSvgDom() {
          return this._svgDom;
        },
        getSvgRoot: function getSvgRoot() {
          return this._svgRoot;
        },
        getViewportRootOffset: function getViewportRootOffset() {
          var viewportRoot = this.getViewportRoot();

          if (viewportRoot) {
            return {
              offsetLeft: viewportRoot.offsetLeft || 0,
              offsetTop: viewportRoot.offsetTop || 0
            };
          }
        },
        refresh: function refresh() {
          var list = this.storage.getDisplayList(true);

          this._paintList(list);
        },
        setBackgroundColor: function setBackgroundColor(backgroundColor) {
          // TODO gradient
          // Insert a bg rect instead of setting background to viewport.
          // Otherwise, the exported SVG don't have background.
          if (this._backgroundRoot && this._backgroundNode) {
            this._backgroundRoot.removeChild(this._backgroundNode);
          }

          var bgNode = createElement('rect');
          bgNode.setAttribute('width', this.getWidth());
          bgNode.setAttribute('height', this.getHeight());
          bgNode.setAttribute('x', 0);
          bgNode.setAttribute('y', 0);
          bgNode.setAttribute('id', 0);
          bgNode.style.fill = backgroundColor;

          this._backgroundRoot.appendChild(bgNode);

          this._backgroundNode = bgNode;
        },
        _paintList: function _paintList(list) {
          this.gradientManager.markAllUnused();
          this.clipPathManager.markAllUnused();
          this.shadowManager.markAllUnused();
          var svgRoot = this._svgRoot;
          var visibleList = this._visibleList;
          var listLen = list.length;
          var newVisibleList = [];
          var i;

          for (i = 0; i < listLen; i++) {
            var displayable = list[i];
            var svgProxy = getSvgProxy(displayable);
            var svgElement = getSvgElement(displayable) || getTextSvgElement(displayable);

            if (!displayable.invisible) {
              if (displayable.__dirty) {
                svgProxy && svgProxy.brush(displayable); // Update clipPath

                this.clipPathManager.update(displayable); // Update gradient and shadow

                if (displayable.style) {
                  this.gradientManager.update(displayable.style.fill);
                  this.gradientManager.update(displayable.style.stroke);
                  this.shadowManager.update(svgElement, displayable);
                }

                displayable.__dirty = false;
              }

              newVisibleList.push(displayable);
            }
          }

          var diff = arrayDiff(visibleList, newVisibleList);
          var prevSvgElement; // First do remove, in case element moved to the head and do remove
          // after add

          for (i = 0; i < diff.length; i++) {
            var item = diff[i];

            if (item.removed) {
              for (var k = 0; k < item.count; k++) {
                var displayable = visibleList[item.indices[k]];
                var svgElement = getSvgElement(displayable);
                var textSvgElement = getTextSvgElement(displayable);
                remove(svgRoot, svgElement);
                remove(svgRoot, textSvgElement);
              }
            }
          }

          for (i = 0; i < diff.length; i++) {
            var item = diff[i];

            if (item.added) {
              for (var k = 0; k < item.count; k++) {
                var displayable = newVisibleList[item.indices[k]];
                var svgElement = getSvgElement(displayable);
                var textSvgElement = getTextSvgElement(displayable);
                prevSvgElement ? insertAfter(svgRoot, svgElement, prevSvgElement) : prepend(svgRoot, svgElement);

                if (svgElement) {
                  insertAfter(svgRoot, textSvgElement, svgElement);
                } else if (prevSvgElement) {
                  insertAfter(svgRoot, textSvgElement, prevSvgElement);
                } else {
                  prepend(svgRoot, textSvgElement);
                } // Insert text


                insertAfter(svgRoot, textSvgElement, svgElement);
                prevSvgElement = textSvgElement || svgElement || prevSvgElement; // zrender.Text only create textSvgElement.

                this.gradientManager.addWithoutUpdate(svgElement || textSvgElement, displayable);
                this.shadowManager.addWithoutUpdate(svgElement || textSvgElement, displayable);
                this.clipPathManager.markUsed(displayable);
              }
            } else if (!item.removed) {
              for (var k = 0; k < item.count; k++) {
                var displayable = newVisibleList[item.indices[k]];
                var svgElement = getSvgElement(displayable);
                var textSvgElement = getTextSvgElement(displayable);
                var svgElement = getSvgElement(displayable);
                var textSvgElement = getTextSvgElement(displayable);
                this.gradientManager.markUsed(displayable);
                this.gradientManager.addWithoutUpdate(svgElement || textSvgElement, displayable);
                this.shadowManager.markUsed(displayable);
                this.shadowManager.addWithoutUpdate(svgElement || textSvgElement, displayable);
                this.clipPathManager.markUsed(displayable);

                if (textSvgElement) {
                  // Insert text.
                  insertAfter(svgRoot, textSvgElement, svgElement);
                }

                prevSvgElement = svgElement || textSvgElement || prevSvgElement;
              }
            }
          }

          this.gradientManager.removeUnused();
          this.clipPathManager.removeUnused();
          this.shadowManager.removeUnused();
          this._visibleList = newVisibleList;
        },
        _getDefs: function _getDefs(isForceCreating) {
          var svgRoot = this._svgDom;
          var defs = svgRoot.getElementsByTagName('defs');

          if (defs.length === 0) {
            // Not exist
            if (isForceCreating) {
              var defs = svgRoot.insertBefore(createElement('defs'), // Create new tag
              svgRoot.firstChild // Insert in the front of svg
              );

              if (!defs.contains) {
                // IE doesn't support contains method
                defs.contains = function (el) {
                  var children = defs.children;

                  if (!children) {
                    return false;
                  }

                  for (var i = children.length - 1; i >= 0; --i) {
                    if (children[i] === el) {
                      return true;
                    }
                  }

                  return false;
                };
              }

              return defs;
            } else {
              return null;
            }
          } else {
            return defs[0];
          }
        },
        resize: function resize(width, height) {
          var viewport = this._viewport; // FIXME Why ?

          viewport.style.display = 'none'; // Save input w/h

          var opts = this._opts;
          width != null && (opts.width = width);
          height != null && (opts.height = height);
          width = this._getSize(0);
          height = this._getSize(1);
          viewport.style.display = '';

          if (this._width !== width || this._height !== height) {
            this._width = width;
            this._height = height;
            var viewportStyle = viewport.style;
            viewportStyle.width = width + 'px';
            viewportStyle.height = height + 'px';
            var svgRoot = this._svgDom; // Set width by 'svgRoot.width = width' is invalid

            svgRoot.setAttribute('width', width);
            svgRoot.setAttribute('height', height);
          }

          if (this._backgroundNode) {
            this._backgroundNode.setAttribute('width', width);

            this._backgroundNode.setAttribute('height', height);
          }
        },

        /**
         * 
         */
        getWidth: function getWidth() {
          return this._width;
        },

        /**
         * 
         */
        getHeight: function getHeight() {
          return this._height;
        },
        _getSize: function _getSize(whIdx) {
          var opts = this._opts;
          var wh = ['width', 'height'][whIdx];
          var cwh = ['clientWidth', 'clientHeight'][whIdx];
          var plt = ['paddingLeft', 'paddingTop'][whIdx];
          var prb = ['paddingRight', 'paddingBottom'][whIdx];

          if (opts[wh] != null && opts[wh] !== 'auto') {
            return parseFloat(opts[wh]);
          }

          var root = this.root; // IE8 does not support getComputedStyle, but it use VML.

          var stl = document.defaultView.getComputedStyle(root);
          return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
        },
        dispose: function dispose() {
          this.root.innerHTML = '';
          this._svgRoot = this._backgroundRoot = this._svgDom = this._backgroundNode = this._viewport = this.storage = null;
        },
        clear: function clear() {
          if (this._viewport) {
            this.root.removeChild(this._viewport);
          }
        },
        toDataURL: function toDataURL() {
          this.refresh();
          var html = encodeURIComponent(this._svgDom.outerHTML.replace(/></g, '>\n\r<'));
          return 'data:image/svg+xml;charset=UTF-8,' + html;
        }
      }; // Not supported methods

      function createMethodNotSupport(method) {
        return function () {
          logError('In SVG mode painter not support method "' + method + '"');
        };
      } // Unsuppoted methods


      util.each(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'pathToImage'], function (name) {
        SVGPainter.prototype[name] = createMethodNotSupport(name);
      });
      var _default = SVGPainter;
      module.exports = _default;
      /***/
    },

    /***/
    "3LNs":
    /*!***************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js ***!
      \***************************************************************************/

    /*! no static exports found */

    /***/
    function LNs(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var clazzUtil = __webpack_require__(
      /*! ../../util/clazz */
      "Yl7c");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var axisPointerModelHelper = __webpack_require__(
      /*! ./modelHelper */
      "zTMp");

      var eventTool = __webpack_require__(
      /*! zrender/lib/core/event */
      "YH21");

      var throttleUtil = __webpack_require__(
      /*! ../../util/throttle */
      "iLNv");

      var _model = __webpack_require__(
      /*! ../../util/model */
      "4NO4");

      var makeInner = _model.makeInner;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var inner = makeInner();
      var clone = zrUtil.clone;
      var bind = zrUtil.bind;
      /**
       * Base axis pointer class in 2D.
       * Implemenents {module:echarts/component/axis/IAxisPointer}.
       */

      function BaseAxisPointer() {}

      BaseAxisPointer.prototype = {
        /**
         * @private
         */
        _group: null,

        /**
         * @private
         */
        _lastGraphicKey: null,

        /**
         * @private
         */
        _handle: null,

        /**
         * @private
         */
        _dragging: false,

        /**
         * @private
         */
        _lastValue: null,

        /**
         * @private
         */
        _lastStatus: null,

        /**
         * @private
         */
        _payloadInfo: null,

        /**
         * In px, arbitrary value. Do not set too small,
         * no animation is ok for most cases.
         * @protected
         */
        animationThreshold: 15,

        /**
         * @implement
         */
        render: function render(axisModel, axisPointerModel, api, forceRender) {
          var value = axisPointerModel.get('value');
          var status = axisPointerModel.get('status'); // Bind them to `this`, not in closure, otherwise they will not
          // be replaced when user calling setOption in not merge mode.

          this._axisModel = axisModel;
          this._axisPointerModel = axisPointerModel;
          this._api = api; // Optimize: `render` will be called repeatly during mouse move.
          // So it is power consuming if performing `render` each time,
          // especially on mobile device.

          if (!forceRender && this._lastValue === value && this._lastStatus === status) {
            return;
          }

          this._lastValue = value;
          this._lastStatus = status;
          var group = this._group;
          var handle = this._handle;

          if (!status || status === 'hide') {
            // Do not clear here, for animation better.
            group && group.hide();
            handle && handle.hide();
            return;
          }

          group && group.show();
          handle && handle.show(); // Otherwise status is 'show'

          var elOption = {};
          this.makeElOption(elOption, value, axisModel, axisPointerModel, api); // Enable change axis pointer type.

          var graphicKey = elOption.graphicKey;

          if (graphicKey !== this._lastGraphicKey) {
            this.clear(api);
          }

          this._lastGraphicKey = graphicKey;
          var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);

          if (!group) {
            group = this._group = new graphic.Group();
            this.createPointerEl(group, elOption, axisModel, axisPointerModel);
            this.createLabelEl(group, elOption, axisModel, axisPointerModel);
            api.getZr().add(group);
          } else {
            var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);
            this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);
            this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
          }

          updateMandatoryProps(group, axisPointerModel, true);

          this._renderHandle(value);
        },

        /**
         * @implement
         */
        remove: function remove(api) {
          this.clear(api);
        },

        /**
         * @implement
         */
        dispose: function dispose(api) {
          this.clear(api);
        },

        /**
         * @protected
         */
        determineAnimation: function determineAnimation(axisModel, axisPointerModel) {
          var animation = axisPointerModel.get('animation');
          var axis = axisModel.axis;
          var isCategoryAxis = axis.type === 'category';
          var useSnap = axisPointerModel.get('snap'); // Value axis without snap always do not snap.

          if (!useSnap && !isCategoryAxis) {
            return false;
          }

          if (animation === 'auto' || animation == null) {
            var animationThreshold = this.animationThreshold;

            if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
              return true;
            } // It is important to auto animation when snap used. Consider if there is
            // a dataZoom, animation will be disabled when too many points exist, while
            // it will be enabled for better visual effect when little points exist.


            if (useSnap) {
              var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;
              var axisExtent = axis.getExtent(); // Approximate band width

              return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
            }

            return false;
          }

          return animation === true;
        },

        /**
         * add {pointer, label, graphicKey} to elOption
         * @protected
         */
        makeElOption: function makeElOption(elOption, value, axisModel, axisPointerModel, api) {// Shoule be implemenented by sub-class.
        },

        /**
         * @protected
         */
        createPointerEl: function createPointerEl(group, elOption, axisModel, axisPointerModel) {
          var pointerOption = elOption.pointer;

          if (pointerOption) {
            var pointerEl = inner(group).pointerEl = new graphic[pointerOption.type](clone(elOption.pointer));
            group.add(pointerEl);
          }
        },

        /**
         * @protected
         */
        createLabelEl: function createLabelEl(group, elOption, axisModel, axisPointerModel) {
          if (elOption.label) {
            var labelEl = inner(group).labelEl = new graphic.Rect(clone(elOption.label));
            group.add(labelEl);
            updateLabelShowHide(labelEl, axisPointerModel);
          }
        },

        /**
         * @protected
         */
        updatePointerEl: function updatePointerEl(group, elOption, updateProps) {
          var pointerEl = inner(group).pointerEl;

          if (pointerEl && elOption.pointer) {
            pointerEl.setStyle(elOption.pointer.style);
            updateProps(pointerEl, {
              shape: elOption.pointer.shape
            });
          }
        },

        /**
         * @protected
         */
        updateLabelEl: function updateLabelEl(group, elOption, updateProps, axisPointerModel) {
          var labelEl = inner(group).labelEl;

          if (labelEl) {
            labelEl.setStyle(elOption.label.style);
            updateProps(labelEl, {
              // Consider text length change in vertical axis, animation should
              // be used on shape, otherwise the effect will be weird.
              shape: elOption.label.shape,
              position: elOption.label.position
            });
            updateLabelShowHide(labelEl, axisPointerModel);
          }
        },

        /**
         * @private
         */
        _renderHandle: function _renderHandle(value) {
          if (this._dragging || !this.updateHandleTransform) {
            return;
          }

          var axisPointerModel = this._axisPointerModel;

          var zr = this._api.getZr();

          var handle = this._handle;
          var handleModel = axisPointerModel.getModel('handle');
          var status = axisPointerModel.get('status');

          if (!handleModel.get('show') || !status || status === 'hide') {
            handle && zr.remove(handle);
            this._handle = null;
            return;
          }

          var isInit;

          if (!this._handle) {
            isInit = true;
            handle = this._handle = graphic.createIcon(handleModel.get('icon'), {
              cursor: 'move',
              draggable: true,
              onmousemove: function onmousemove(e) {
                // Fot mobile devicem, prevent screen slider on the button.
                eventTool.stop(e.event);
              },
              onmousedown: bind(this._onHandleDragMove, this, 0, 0),
              drift: bind(this._onHandleDragMove, this),
              ondragend: bind(this._onHandleDragEnd, this)
            });
            zr.add(handle);
          }

          updateMandatoryProps(handle, axisPointerModel, false); // update style

          var includeStyles = ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];
          handle.setStyle(handleModel.getItemStyle(null, includeStyles)); // update position

          var handleSize = handleModel.get('size');

          if (!zrUtil.isArray(handleSize)) {
            handleSize = [handleSize, handleSize];
          }

          handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);
          throttleUtil.createOrUpdate(this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate');

          this._moveHandleToValue(value, isInit);
        },

        /**
         * @private
         */
        _moveHandleToValue: function _moveHandleToValue(value, isInit) {
          updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
        },

        /**
         * @private
         */
        _onHandleDragMove: function _onHandleDragMove(dx, dy) {
          var handle = this._handle;

          if (!handle) {
            return;
          }

          this._dragging = true; // Persistent for throttle.

          var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
          this._payloadInfo = trans;
          handle.stopAnimation();
          handle.attr(getHandleTransProps(trans));
          inner(handle).lastProp = null;

          this._doDispatchAxisPointer();
        },

        /**
         * Throttled method.
         * @private
         */
        _doDispatchAxisPointer: function _doDispatchAxisPointer() {
          var handle = this._handle;

          if (!handle) {
            return;
          }

          var payloadInfo = this._payloadInfo;
          var axisModel = this._axisModel;

          this._api.dispatchAction({
            type: 'updateAxisPointer',
            x: payloadInfo.cursorPoint[0],
            y: payloadInfo.cursorPoint[1],
            tooltipOption: payloadInfo.tooltipOption,
            axesInfo: [{
              axisDim: axisModel.axis.dim,
              axisIndex: axisModel.componentIndex
            }]
          });
        },

        /**
         * @private
         */
        _onHandleDragEnd: function _onHandleDragEnd(moveAnimation) {
          this._dragging = false;
          var handle = this._handle;

          if (!handle) {
            return;
          }

          var value = this._axisPointerModel.get('value'); // Consider snap or categroy axis, handle may be not consistent with
          // axisPointer. So move handle to align the exact value position when
          // drag ended.


          this._moveHandleToValue(value); // For the effect: tooltip will be shown when finger holding on handle
          // button, and will be hidden after finger left handle button.


          this._api.dispatchAction({
            type: 'hideTip'
          });
        },

        /**
         * Should be implemenented by sub-class if support `handle`.
         * @protected
         * @param {number} value
         * @param {module:echarts/model/Model} axisModel
         * @param {module:echarts/model/Model} axisPointerModel
         * @return {Object} {position: [x, y], rotation: 0}
         */
        getHandleTransform: null,

        /**
         * * Should be implemenented by sub-class if support `handle`.
         * @protected
         * @param {Object} transform {position, rotation}
         * @param {Array.<number>} delta [dx, dy]
         * @param {module:echarts/model/Model} axisModel
         * @param {module:echarts/model/Model} axisPointerModel
         * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}
         */
        updateHandleTransform: null,

        /**
         * @private
         */
        clear: function clear(api) {
          this._lastValue = null;
          this._lastStatus = null;
          var zr = api.getZr();
          var group = this._group;
          var handle = this._handle;

          if (zr && group) {
            this._lastGraphicKey = null;
            group && zr.remove(group);
            handle && zr.remove(handle);
            this._group = null;
            this._handle = null;
            this._payloadInfo = null;
          }
        },

        /**
         * @protected
         */
        doClear: function doClear() {// Implemented by sub-class if necessary.
        },

        /**
         * @protected
         * @param {Array.<number>} xy
         * @param {Array.<number>} wh
         * @param {number} [xDimIndex=0] or 1
         */
        buildLabel: function buildLabel(xy, wh, xDimIndex) {
          xDimIndex = xDimIndex || 0;
          return {
            x: xy[xDimIndex],
            y: xy[1 - xDimIndex],
            width: wh[xDimIndex],
            height: wh[1 - xDimIndex]
          };
        }
      };
      BaseAxisPointer.prototype.constructor = BaseAxisPointer;

      function updateProps(animationModel, moveAnimation, el, props) {
        // Animation optimize.
        if (!propsEqual(inner(el).lastProp, props)) {
          inner(el).lastProp = props;
          moveAnimation ? graphic.updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));
        }
      }

      function propsEqual(lastProps, newProps) {
        if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {
          var equals = true;
          zrUtil.each(newProps, function (item, key) {
            equals = equals && propsEqual(lastProps[key], item);
          });
          return !!equals;
        } else {
          return lastProps === newProps;
        }
      }

      function updateLabelShowHide(labelEl, axisPointerModel) {
        labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();
      }

      function getHandleTransProps(trans) {
        return {
          position: trans.position.slice(),
          rotation: trans.rotation || 0
        };
      }

      function updateMandatoryProps(group, axisPointerModel, silent) {
        var z = axisPointerModel.get('z');
        var zlevel = axisPointerModel.get('zlevel');
        group && group.traverse(function (el) {
          if (el.type !== 'group') {
            z != null && (el.z = z);
            zlevel != null && (el.zlevel = zlevel);
            el.silent = silent;
          }
        });
      }

      clazzUtil.enableClassExtend(BaseAxisPointer);
      var _default = BaseAxisPointer;
      module.exports = _default;
      /***/
    },

    /***/
    "3OrL":
    /*!***************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/boxplot/BoxplotView.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function OrL(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var ChartView = __webpack_require__(
      /*! ../../view/Chart */
      "6Ic6");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var Path = __webpack_require__(
      /*! zrender/lib/graphic/Path */
      "y+Vt");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // Update common properties


      var NORMAL_ITEM_STYLE_PATH = ['itemStyle'];
      var EMPHASIS_ITEM_STYLE_PATH = ['emphasis', 'itemStyle'];
      var BoxplotView = ChartView.extend({
        type: 'boxplot',
        render: function render(seriesModel, ecModel, api) {
          var data = seriesModel.getData();
          var group = this.group;
          var oldData = this._data; // There is no old data only when first rendering or switching from
          // stream mode to normal mode, where previous elements should be removed.

          if (!this._data) {
            group.removeAll();
          }

          var constDim = seriesModel.get('layout') === 'horizontal' ? 1 : 0;
          data.diff(oldData).add(function (newIdx) {
            if (data.hasValue(newIdx)) {
              var itemLayout = data.getItemLayout(newIdx);
              var symbolEl = createNormalBox(itemLayout, data, newIdx, constDim, true);
              data.setItemGraphicEl(newIdx, symbolEl);
              group.add(symbolEl);
            }
          }).update(function (newIdx, oldIdx) {
            var symbolEl = oldData.getItemGraphicEl(oldIdx); // Empty data

            if (!data.hasValue(newIdx)) {
              group.remove(symbolEl);
              return;
            }

            var itemLayout = data.getItemLayout(newIdx);

            if (!symbolEl) {
              symbolEl = createNormalBox(itemLayout, data, newIdx, constDim);
            } else {
              updateNormalBoxData(itemLayout, symbolEl, data, newIdx);
            }

            group.add(symbolEl);
            data.setItemGraphicEl(newIdx, symbolEl);
          }).remove(function (oldIdx) {
            var el = oldData.getItemGraphicEl(oldIdx);
            el && group.remove(el);
          }).execute();
          this._data = data;
        },
        remove: function remove(ecModel) {
          var group = this.group;
          var data = this._data;
          this._data = null;
          data && data.eachItemGraphicEl(function (el) {
            el && group.remove(el);
          });
        },
        dispose: zrUtil.noop
      });
      var BoxPath = Path.extend({
        type: 'boxplotBoxPath',
        shape: {},
        buildPath: function buildPath(ctx, shape) {
          var ends = shape.points;
          var i = 0;
          ctx.moveTo(ends[i][0], ends[i][1]);
          i++;

          for (; i < 4; i++) {
            ctx.lineTo(ends[i][0], ends[i][1]);
          }

          ctx.closePath();

          for (; i < ends.length; i++) {
            ctx.moveTo(ends[i][0], ends[i][1]);
            i++;
            ctx.lineTo(ends[i][0], ends[i][1]);
          }
        }
      });

      function createNormalBox(itemLayout, data, dataIndex, constDim, isInit) {
        var ends = itemLayout.ends;
        var el = new BoxPath({
          shape: {
            points: isInit ? transInit(ends, constDim, itemLayout) : ends
          }
        });
        updateNormalBoxData(itemLayout, el, data, dataIndex, isInit);
        return el;
      }

      function updateNormalBoxData(itemLayout, el, data, dataIndex, isInit) {
        var seriesModel = data.hostModel;
        var updateMethod = graphic[isInit ? 'initProps' : 'updateProps'];
        updateMethod(el, {
          shape: {
            points: itemLayout.ends
          }
        }, seriesModel, dataIndex);
        var itemModel = data.getItemModel(dataIndex);
        var normalItemStyleModel = itemModel.getModel(NORMAL_ITEM_STYLE_PATH);
        var borderColor = data.getItemVisual(dataIndex, 'color'); // Exclude borderColor.

        var itemStyle = normalItemStyleModel.getItemStyle(['borderColor']);
        itemStyle.stroke = borderColor;
        itemStyle.strokeNoScale = true;
        el.useStyle(itemStyle);
        el.z2 = 100;
        var hoverStyle = itemModel.getModel(EMPHASIS_ITEM_STYLE_PATH).getItemStyle();
        graphic.setHoverStyle(el, hoverStyle);
      }

      function transInit(points, dim, itemLayout) {
        return zrUtil.map(points, function (point) {
          point = point.slice();
          point[dim] = itemLayout.initBaseline;
          return point;
        });
      }

      var _default = BoxplotView;
      module.exports = _default;
      /***/
    },

    /***/
    "3TkU":
    /*!**************************************************************!*\
      !*** ./node_modules/echarts/lib/component/dataZoomSelect.js ***!
      \**************************************************************/

    /*! no static exports found */

    /***/
    function TkU(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      __webpack_require__(
      /*! ./dataZoom/typeDefaulter */
      "aTJb");

      __webpack_require__(
      /*! ./dataZoom/DataZoomModel */
      "OlYY");

      __webpack_require__(
      /*! ./dataZoom/DataZoomView */
      "fc+c");

      __webpack_require__(
      /*! ./dataZoom/SelectZoomModel */
      "QUw5");

      __webpack_require__(
      /*! ./dataZoom/SelectZoomView */
      "Swgg");

      __webpack_require__(
      /*! ./dataZoom/dataZoomProcessor */
      "LBfv");

      __webpack_require__(
      /*! ./dataZoom/dataZoomAction */
      "noeP");
      /***/

    },

    /***/
    "3X6L":
    /*!****************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/timeline/SliderTimelineModel.js ***!
      \****************************************************************************/

    /*! no static exports found */

    /***/
    function X6L(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var TimelineModel = __webpack_require__(
      /*! ./TimelineModel */
      "7a+S");

      var dataFormatMixin = __webpack_require__(
      /*! ../../model/mixin/dataFormat */
      "OKJ2");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var SliderTimelineModel = TimelineModel.extend({
        type: 'timeline.slider',

        /**
         * @protected
         */
        defaultOption: {
          backgroundColor: 'rgba(0,0,0,0)',
          // 
          borderColor: '#ccc',
          // 
          borderWidth: 0,
          // px0
          orient: 'horizontal',
          // 'vertical'
          inverse: false,
          tooltip: {
            // boolean or Object
            trigger: 'item' // data item may also have tootip attr.

          },
          symbol: 'emptyCircle',
          symbolSize: 10,
          lineStyle: {
            show: true,
            width: 2,
            color: '#304654'
          },
          label: {
            // 
            position: 'auto',
            // auto left right top bottom
            // When using number, label position is not
            // restricted by viewRect.
            // positive: right/bottom, negative: left/top
            show: true,
            interval: 'auto',
            rotate: 0,
            // formatter: null,
            // TEXTSTYLE
            color: '#304654'
          },
          itemStyle: {
            color: '#304654',
            borderWidth: 1
          },
          checkpointStyle: {
            symbol: 'circle',
            symbolSize: 13,
            color: '#c23531',
            borderWidth: 5,
            borderColor: 'rgba(194,53,49, 0.5)',
            animation: true,
            animationDuration: 300,
            animationEasing: 'quinticInOut'
          },
          controlStyle: {
            show: true,
            showPlayBtn: true,
            showPrevBtn: true,
            showNextBtn: true,
            itemSize: 22,
            itemGap: 12,
            position: 'left',
            // 'left' 'right' 'top' 'bottom'
            playIcon: 'path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z',
            // jshint ignore:line
            stopIcon: 'path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z',
            // jshint ignore:line
            nextIcon: 'path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z',
            // jshint ignore:line
            prevIcon: 'path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z',
            // jshint ignore:line
            color: '#304654',
            borderColor: '#304654',
            borderWidth: 1
          },
          emphasis: {
            label: {
              show: true,
              // TEXTSTYLE
              color: '#c23531'
            },
            itemStyle: {
              color: '#c23531'
            },
            controlStyle: {
              color: '#c23531',
              borderColor: '#c23531',
              borderWidth: 2
            }
          },
          data: []
        }
      });
      zrUtil.mixin(SliderTimelineModel, dataFormatMixin);
      var _default = SliderTimelineModel;
      module.exports = _default;
      /***/
    },

    /***/
    "3m61":
    /*!************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/graph/edgeVisual.js ***!
      \************************************************************/

    /*! no static exports found */

    /***/
    function m61(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      function normalize(a) {
        if (!(a instanceof Array)) {
          a = [a, a];
        }

        return a;
      }

      function _default(ecModel) {
        ecModel.eachSeriesByType('graph', function (seriesModel) {
          var graph = seriesModel.getGraph();
          var edgeData = seriesModel.getEdgeData();
          var symbolType = normalize(seriesModel.get('edgeSymbol'));
          var symbolSize = normalize(seriesModel.get('edgeSymbolSize'));
          var colorQuery = 'lineStyle.color'.split('.');
          var opacityQuery = 'lineStyle.opacity'.split('.');
          edgeData.setVisual('fromSymbol', symbolType && symbolType[0]);
          edgeData.setVisual('toSymbol', symbolType && symbolType[1]);
          edgeData.setVisual('fromSymbolSize', symbolSize && symbolSize[0]);
          edgeData.setVisual('toSymbolSize', symbolSize && symbolSize[1]);
          edgeData.setVisual('color', seriesModel.get(colorQuery));
          edgeData.setVisual('opacity', seriesModel.get(opacityQuery));
          edgeData.each(function (idx) {
            var itemModel = edgeData.getItemModel(idx);
            var edge = graph.getEdgeByIndex(idx);
            var symbolType = normalize(itemModel.getShallow('symbol', true));
            var symbolSize = normalize(itemModel.getShallow('symbolSize', true)); // Edge visual must after node visual

            var color = itemModel.get(colorQuery);
            var opacity = itemModel.get(opacityQuery);

            switch (color) {
              case 'source':
                color = edge.node1.getVisual('color');
                break;

              case 'target':
                color = edge.node2.getVisual('color');
                break;
            }

            symbolType[0] && edge.setVisual('fromSymbol', symbolType[0]);
            symbolType[1] && edge.setVisual('toSymbol', symbolType[1]);
            symbolSize[0] && edge.setVisual('fromSymbolSize', symbolSize[0]);
            symbolSize[1] && edge.setVisual('toSymbolSize', symbolSize[1]);
            edge.setVisual('color', color);
            edge.setVisual('opacity', opacity);
          });
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "3zoK":
    /*!**************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/parallel/AxisModel.js ***!
      \**************************************************************/

    /*! no static exports found */

    /***/
    function zoK(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var ComponentModel = __webpack_require__(
      /*! ../../model/Component */
      "bLfw");

      var makeStyleMapper = __webpack_require__(
      /*! ../../model/mixin/makeStyleMapper */
      "KCsZ");

      var axisModelCreator = __webpack_require__(
      /*! ../axisModelCreator */
      "nkfE");

      var numberUtil = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var axisModelCommonMixin = __webpack_require__(
      /*! ../axisModelCommonMixin */
      "ICMv");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var AxisModel = ComponentModel.extend({
        type: 'baseParallelAxis',

        /**
         * @type {module:echarts/coord/parallel/Axis}
         */
        axis: null,

        /**
         * @type {Array.<Array.<number>}
         * @readOnly
         */
        activeIntervals: [],

        /**
         * @return {Object}
         */
        getAreaSelectStyle: function getAreaSelectStyle() {
          return makeStyleMapper([['fill', 'color'], ['lineWidth', 'borderWidth'], ['stroke', 'borderColor'], ['width', 'width'], ['opacity', 'opacity']])(this.getModel('areaSelectStyle'));
        },

        /**
         * The code of this feature is put on AxisModel but not ParallelAxis,
         * because axisModel can be alive after echarts updating but instance of
         * ParallelAxis having been disposed. this._activeInterval should be kept
         * when action dispatched (i.e. legend click).
         *
         * @param {Array.<Array<number>>} intervals interval.length === 0
         *                                          means set all active.
         * @public
         */
        setActiveIntervals: function setActiveIntervals(intervals) {
          var activeIntervals = this.activeIntervals = zrUtil.clone(intervals); // Normalize

          if (activeIntervals) {
            for (var i = activeIntervals.length - 1; i >= 0; i--) {
              numberUtil.asc(activeIntervals[i]);
            }
          }
        },

        /**
         * @param {number|string} [value] When attempting to detect 'no activeIntervals set',
         *                         value can not be input.
         * @return {string} 'normal': no activeIntervals set,
         *                  'active',
         *                  'inactive'.
         * @public
         */
        getActiveState: function getActiveState(value) {
          var activeIntervals = this.activeIntervals;

          if (!activeIntervals.length) {
            return 'normal';
          }

          if (value == null || isNaN(value)) {
            return 'inactive';
          } // Simple optimization


          if (activeIntervals.length === 1) {
            var interval = activeIntervals[0];

            if (interval[0] <= value && value <= interval[1]) {
              return 'active';
            }
          } else {
            for (var i = 0, len = activeIntervals.length; i < len; i++) {
              if (activeIntervals[i][0] <= value && value <= activeIntervals[i][1]) {
                return 'active';
              }
            }
          }

          return 'inactive';
        }
      });
      var defaultOption = {
        type: 'value',

        /**
         * @type {Array.<number>}
         */
        dim: null,
        // 0, 1, 2, ...
        // parallelIndex: null,
        areaSelectStyle: {
          width: 20,
          borderWidth: 1,
          borderColor: 'rgba(160,197,232)',
          color: 'rgba(160,197,232)',
          opacity: 0.3
        },
        realtime: true,
        // Whether realtime update view when select.
        z: 10
      };
      zrUtil.merge(AxisModel.prototype, axisModelCommonMixin);

      function getAxisType(axisName, option) {
        return option.type || (option.data ? 'category' : 'value');
      }

      axisModelCreator('parallel', AxisModel, getAxisType, defaultOption);
      var _default = AxisModel;
      module.exports = _default;
      /***/
    },

    /***/
    "4Feb":
    /*!**************************************************!*\
      !*** ./node_modules/echarts/lib/chart/custom.js ***!
      \**************************************************/

    /*! no static exports found */

    /***/
    function Feb(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var graphicUtil = __webpack_require__(
      /*! ../util/graphic */
      "IwbS");

      var _labelHelper = __webpack_require__(
      /*! ./helper/labelHelper */
      "x3X8");

      var getDefaultLabel = _labelHelper.getDefaultLabel;

      var createListFromArray = __webpack_require__(
      /*! ./helper/createListFromArray */
      "MwEJ");

      var _barGrid = __webpack_require__(
      /*! ../layout/barGrid */
      "nVfU");

      var getLayoutOnAxis = _barGrid.getLayoutOnAxis;

      var DataDiffer = __webpack_require__(
      /*! ../data/DataDiffer */
      "gPAo");

      var SeriesModel = __webpack_require__(
      /*! ../model/Series */
      "T4UG");

      var Model = __webpack_require__(
      /*! ../model/Model */
      "Qxkt");

      var ChartView = __webpack_require__(
      /*! ../view/Chart */
      "6Ic6");

      var _createClipPathFromCoordSys = __webpack_require__(
      /*! ./helper/createClipPathFromCoordSys */
      "sK/D");

      var createClipPath = _createClipPathFromCoordSys.createClipPath;

      var prepareCartesian2d = __webpack_require__(
      /*! ../coord/cartesian/prepareCustom */
      "qj72");

      var prepareGeo = __webpack_require__(
      /*! ../coord/geo/prepareCustom */
      "ANjR");

      var prepareSingleAxis = __webpack_require__(
      /*! ../coord/single/prepareCustom */
      "MHtr");

      var preparePolar = __webpack_require__(
      /*! ../coord/polar/prepareCustom */
      "6usn");

      var prepareCalendar = __webpack_require__(
      /*! ../coord/calendar/prepareCustom */
      "Rx6q");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var CACHED_LABEL_STYLE_PROPERTIES = graphicUtil.CACHED_LABEL_STYLE_PROPERTIES;
      var ITEM_STYLE_NORMAL_PATH = ['itemStyle'];
      var ITEM_STYLE_EMPHASIS_PATH = ['emphasis', 'itemStyle'];
      var LABEL_NORMAL = ['label'];
      var LABEL_EMPHASIS = ['emphasis', 'label']; // Use prefix to avoid index to be the same as el.name,
      // which will cause weird udpate animation.

      var GROUP_DIFF_PREFIX = 'e\0\0';
      /**
       * To reduce total package size of each coordinate systems, the modules `prepareCustom`
       * of each coordinate systems are not required by each coordinate systems directly, but
       * required by the module `custom`.
       *
       * prepareInfoForCustomSeries {Function}: optional
       *     @return {Object} {coordSys: {...}, api: {
       *         coord: function (data, clamp) {}, // return point in global.
       *         size: function (dataSize, dataItem) {} // return size of each axis in coordSys.
       *     }}
       */

      var prepareCustoms = {
        cartesian2d: prepareCartesian2d,
        geo: prepareGeo,
        singleAxis: prepareSingleAxis,
        polar: preparePolar,
        calendar: prepareCalendar
      }; // ------
      // Model
      // ------

      SeriesModel.extend({
        type: 'series.custom',
        dependencies: ['grid', 'polar', 'geo', 'singleAxis', 'calendar'],
        defaultOption: {
          coordinateSystem: 'cartesian2d',
          // Can be set as 'none'
          zlevel: 0,
          z: 2,
          legendHoverLink: true,
          useTransform: true,
          // Custom series will not clip by default.
          // Some case will use custom series to draw label
          // For example https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight
          // Only works on polar and cartesian2d coordinate system.
          clip: false // Cartesian coordinate system
          // xAxisIndex: 0,
          // yAxisIndex: 0,
          // Polar coordinate system
          // polarIndex: 0,
          // Geo coordinate system
          // geoIndex: 0,
          // label: {}
          // itemStyle: {}

        },

        /**
         * @override
         */
        getInitialData: function getInitialData(option, ecModel) {
          return createListFromArray(this.getSource(), this);
        },

        /**
         * @override
         */
        getDataParams: function getDataParams(dataIndex, dataType, el) {
          var params = SeriesModel.prototype.getDataParams.apply(this, arguments);
          el && (params.info = el.info);
          return params;
        }
      }); // -----
      // View
      // -----

      ChartView.extend({
        type: 'custom',

        /**
         * @private
         * @type {module:echarts/data/List}
         */
        _data: null,

        /**
         * @override
         */
        render: function render(customSeries, ecModel, api, payload) {
          var oldData = this._data;
          var data = customSeries.getData();
          var group = this.group;
          var renderItem = makeRenderItem(customSeries, data, ecModel, api); // By default, merge mode is applied. In most cases, custom series is
          // used in the scenario that data amount is not large but graphic elements
          // is complicated, where merge mode is probably necessary for optimization.
          // For example, reuse graphic elements and only update the transform when
          // roam or data zoom according to `actionType`.

          data.diff(oldData).add(function (newIdx) {
            createOrUpdate(null, newIdx, renderItem(newIdx, payload), customSeries, group, data);
          }).update(function (newIdx, oldIdx) {
            var el = oldData.getItemGraphicEl(oldIdx);
            createOrUpdate(el, newIdx, renderItem(newIdx, payload), customSeries, group, data);
          }).remove(function (oldIdx) {
            var el = oldData.getItemGraphicEl(oldIdx);
            el && group.remove(el);
          }).execute(); // Do clipping

          var clipPath = customSeries.get('clip', true) ? createClipPath(customSeries.coordinateSystem, false, customSeries) : null;

          if (clipPath) {
            group.setClipPath(clipPath);
          } else {
            group.removeClipPath();
          }

          this._data = data;
        },
        incrementalPrepareRender: function incrementalPrepareRender(customSeries, ecModel, api) {
          this.group.removeAll();
          this._data = null;
        },
        incrementalRender: function incrementalRender(params, customSeries, ecModel, api, payload) {
          var data = customSeries.getData();
          var renderItem = makeRenderItem(customSeries, data, ecModel, api);

          function setIncrementalAndHoverLayer(el) {
            if (!el.isGroup) {
              el.incremental = true;
              el.useHoverLayer = true;
            }
          }

          for (var idx = params.start; idx < params.end; idx++) {
            var el = createOrUpdate(null, idx, renderItem(idx, payload), customSeries, this.group, data);
            el.traverse(setIncrementalAndHoverLayer);
          }
        },

        /**
         * @override
         */
        dispose: zrUtil.noop,

        /**
         * @override
         */
        filterForExposedEvent: function filterForExposedEvent(eventType, query, targetEl, packedEvent) {
          var elementName = query.element;

          if (elementName == null || targetEl.name === elementName) {
            return true;
          } // Enable to give a name on a group made by `renderItem`, and listen
          // events that triggerd by its descendents.


          while ((targetEl = targetEl.parent) && targetEl !== this.group) {
            if (targetEl.name === elementName) {
              return true;
            }
          }

          return false;
        }
      });

      function createEl(elOption) {
        var graphicType = elOption.type;
        var el; // Those graphic elements are not shapes. They should not be
        // overwritten by users, so do them first.

        if (graphicType === 'path') {
          var shape = elOption.shape; // Using pathRect brings convenience to users sacle svg path.

          var pathRect = shape.width != null && shape.height != null ? {
            x: shape.x || 0,
            y: shape.y || 0,
            width: shape.width,
            height: shape.height
          } : null;
          var pathData = getPathData(shape); // Path is also used for icon, so layout 'center' by default.

          el = graphicUtil.makePath(pathData, null, pathRect, shape.layout || 'center');
          el.__customPathData = pathData;
        } else if (graphicType === 'image') {
          el = new graphicUtil.Image({});
          el.__customImagePath = elOption.style.image;
        } else if (graphicType === 'text') {
          el = new graphicUtil.Text({});
          el.__customText = elOption.style.text;
        } else if (graphicType === 'group') {
          el = new graphicUtil.Group();
        } else if (graphicType === 'compoundPath') {
          throw new Error('"compoundPath" is not supported yet.');
        } else {
          var Clz = graphicUtil.getShapeClass(graphicType);
          el = new Clz();
        }

        el.__customGraphicType = graphicType;
        el.name = elOption.name;
        return el;
      }

      function updateEl(el, dataIndex, elOption, animatableModel, data, isInit, isRoot) {
        var transitionProps = {};
        var elOptionStyle = elOption.style || {};
        elOption.shape && (transitionProps.shape = zrUtil.clone(elOption.shape));
        elOption.position && (transitionProps.position = elOption.position.slice());
        elOption.scale && (transitionProps.scale = elOption.scale.slice());
        elOption.origin && (transitionProps.origin = elOption.origin.slice());
        elOption.rotation && (transitionProps.rotation = elOption.rotation);

        if (el.type === 'image' && elOption.style) {
          var targetStyle = transitionProps.style = {};
          zrUtil.each(['x', 'y', 'width', 'height'], function (prop) {
            prepareStyleTransition(prop, targetStyle, elOptionStyle, el.style, isInit);
          });
        }

        if (el.type === 'text' && elOption.style) {
          var targetStyle = transitionProps.style = {};
          zrUtil.each(['x', 'y'], function (prop) {
            prepareStyleTransition(prop, targetStyle, elOptionStyle, el.style, isInit);
          }); // Compatible with previous: both support
          // textFill and fill, textStroke and stroke in 'text' element.

          !elOptionStyle.hasOwnProperty('textFill') && elOptionStyle.fill && (elOptionStyle.textFill = elOptionStyle.fill);
          !elOptionStyle.hasOwnProperty('textStroke') && elOptionStyle.stroke && (elOptionStyle.textStroke = elOptionStyle.stroke);
        }

        if (el.type !== 'group') {
          el.useStyle(elOptionStyle); // Init animation.

          if (isInit) {
            el.style.opacity = 0;
            var targetOpacity = elOptionStyle.opacity;
            targetOpacity == null && (targetOpacity = 1);
            graphicUtil.initProps(el, {
              style: {
                opacity: targetOpacity
              }
            }, animatableModel, dataIndex);
          }
        }

        if (isInit) {
          el.attr(transitionProps);
        } else {
          graphicUtil.updateProps(el, transitionProps, animatableModel, dataIndex);
        } // Merge by default.
        // z2 must not be null/undefined, otherwise sort error may occur.


        elOption.hasOwnProperty('z2') && el.attr('z2', elOption.z2 || 0);
        elOption.hasOwnProperty('silent') && el.attr('silent', elOption.silent);
        elOption.hasOwnProperty('invisible') && el.attr('invisible', elOption.invisible);
        elOption.hasOwnProperty('ignore') && el.attr('ignore', elOption.ignore); // `elOption.info` enables user to mount some info on
        // elements and use them in event handlers.
        // Update them only when user specified, otherwise, remain.

        elOption.hasOwnProperty('info') && el.attr('info', elOption.info); // If `elOption.styleEmphasis` is `false`, remove hover style. The
        // logic is ensured by `graphicUtil.setElementHoverStyle`.

        var styleEmphasis = elOption.styleEmphasis; // hoverStyle should always be set here, because if the hover style
        // may already be changed, where the inner cache should be reset.

        graphicUtil.setElementHoverStyle(el, styleEmphasis);

        if (isRoot) {
          graphicUtil.setAsHighDownDispatcher(el, styleEmphasis !== false);
        }
      }

      function prepareStyleTransition(prop, targetStyle, elOptionStyle, oldElStyle, isInit) {
        if (elOptionStyle[prop] != null && !isInit) {
          targetStyle[prop] = elOptionStyle[prop];
          elOptionStyle[prop] = oldElStyle[prop];
        }
      }

      function makeRenderItem(customSeries, data, ecModel, api) {
        var renderItem = customSeries.get('renderItem');
        var coordSys = customSeries.coordinateSystem;
        var prepareResult = {};

        if (coordSys) {
          prepareResult = coordSys.prepareCustoms ? coordSys.prepareCustoms() : prepareCustoms[coordSys.type](coordSys);
        }

        var userAPI = zrUtil.defaults({
          getWidth: api.getWidth,
          getHeight: api.getHeight,
          getZr: api.getZr,
          getDevicePixelRatio: api.getDevicePixelRatio,
          value: value,
          style: style,
          styleEmphasis: styleEmphasis,
          visual: visual,
          barLayout: barLayout,
          currentSeriesIndices: currentSeriesIndices,
          font: font
        }, prepareResult.api || {});
        var userParams = {
          // The life cycle of context: current round of rendering.
          // The global life cycle is probably not necessary, because
          // user can store global status by themselves.
          context: {},
          seriesId: customSeries.id,
          seriesName: customSeries.name,
          seriesIndex: customSeries.seriesIndex,
          coordSys: prepareResult.coordSys,
          dataInsideLength: data.count(),
          encode: wrapEncodeDef(customSeries.getData())
        }; // Do not support call `api` asynchronously without dataIndexInside input.

        var currDataIndexInside;
        var currDirty = true;
        var currItemModel;
        var currLabelNormalModel;
        var currLabelEmphasisModel;
        var currVisualColor;
        return function (dataIndexInside, payload) {
          currDataIndexInside = dataIndexInside;
          currDirty = true;
          return renderItem && renderItem(zrUtil.defaults({
            dataIndexInside: dataIndexInside,
            dataIndex: data.getRawIndex(dataIndexInside),
            // Can be used for optimization when zoom or roam.
            actionType: payload ? payload.type : null
          }, userParams), userAPI);
        }; // Do not update cache until api called.

        function updateCache(dataIndexInside) {
          dataIndexInside == null && (dataIndexInside = currDataIndexInside);

          if (currDirty) {
            currItemModel = data.getItemModel(dataIndexInside);
            currLabelNormalModel = currItemModel.getModel(LABEL_NORMAL);
            currLabelEmphasisModel = currItemModel.getModel(LABEL_EMPHASIS);
            currVisualColor = data.getItemVisual(dataIndexInside, 'color');
            currDirty = false;
          }
        }
        /**
         * @public
         * @param {number|string} dim
         * @param {number} [dataIndexInside=currDataIndexInside]
         * @return {number|string} value
         */


        function value(dim, dataIndexInside) {
          dataIndexInside == null && (dataIndexInside = currDataIndexInside);
          return data.get(data.getDimension(dim || 0), dataIndexInside);
        }
        /**
         * By default, `visual` is applied to style (to support visualMap).
         * `visual.color` is applied at `fill`. If user want apply visual.color on `stroke`,
         * it can be implemented as:
         * `api.style({stroke: api.visual('color'), fill: null})`;
         * @public
         * @param {Object} [extra]
         * @param {number} [dataIndexInside=currDataIndexInside]
         */


        function style(extra, dataIndexInside) {
          dataIndexInside == null && (dataIndexInside = currDataIndexInside);
          updateCache(dataIndexInside);
          var itemStyle = currItemModel.getModel(ITEM_STYLE_NORMAL_PATH).getItemStyle();
          currVisualColor != null && (itemStyle.fill = currVisualColor);
          var opacity = data.getItemVisual(dataIndexInside, 'opacity');
          opacity != null && (itemStyle.opacity = opacity);
          var labelModel = extra ? applyExtraBefore(extra, currLabelNormalModel) : currLabelNormalModel;
          graphicUtil.setTextStyle(itemStyle, labelModel, null, {
            autoColor: currVisualColor,
            isRectText: true
          });
          itemStyle.text = labelModel.getShallow('show') ? zrUtil.retrieve2(customSeries.getFormattedLabel(dataIndexInside, 'normal'), getDefaultLabel(data, dataIndexInside)) : null;
          extra && applyExtraAfter(itemStyle, extra);
          return itemStyle;
        }
        /**
         * @public
         * @param {Object} [extra]
         * @param {number} [dataIndexInside=currDataIndexInside]
         */


        function styleEmphasis(extra, dataIndexInside) {
          dataIndexInside == null && (dataIndexInside = currDataIndexInside);
          updateCache(dataIndexInside);
          var itemStyle = currItemModel.getModel(ITEM_STYLE_EMPHASIS_PATH).getItemStyle();
          var labelModel = extra ? applyExtraBefore(extra, currLabelEmphasisModel) : currLabelEmphasisModel;
          graphicUtil.setTextStyle(itemStyle, labelModel, null, {
            isRectText: true
          }, true);
          itemStyle.text = labelModel.getShallow('show') ? zrUtil.retrieve3(customSeries.getFormattedLabel(dataIndexInside, 'emphasis'), customSeries.getFormattedLabel(dataIndexInside, 'normal'), getDefaultLabel(data, dataIndexInside)) : null;
          extra && applyExtraAfter(itemStyle, extra);
          return itemStyle;
        }
        /**
         * @public
         * @param {string} visualType
         * @param {number} [dataIndexInside=currDataIndexInside]
         */


        function visual(visualType, dataIndexInside) {
          dataIndexInside == null && (dataIndexInside = currDataIndexInside);
          return data.getItemVisual(dataIndexInside, visualType);
        }
        /**
         * @public
         * @param {number} opt.count Positive interger.
         * @param {number} [opt.barWidth]
         * @param {number} [opt.barMaxWidth]
         * @param {number} [opt.barMinWidth]
         * @param {number} [opt.barGap]
         * @param {number} [opt.barCategoryGap]
         * @return {Object} {width, offset, offsetCenter} is not support, return undefined.
         */


        function barLayout(opt) {
          if (coordSys.getBaseAxis) {
            var baseAxis = coordSys.getBaseAxis();
            return getLayoutOnAxis(zrUtil.defaults({
              axis: baseAxis
            }, opt), api);
          }
        }
        /**
         * @public
         * @return {Array.<number>}
         */


        function currentSeriesIndices() {
          return ecModel.getCurrentSeriesIndices();
        }
        /**
         * @public
         * @param {Object} opt
         * @param {string} [opt.fontStyle]
         * @param {number} [opt.fontWeight]
         * @param {number} [opt.fontSize]
         * @param {string} [opt.fontFamily]
         * @return {string} font string
         */


        function font(opt) {
          return graphicUtil.getFont(opt, ecModel);
        }
      }

      function wrapEncodeDef(data) {
        var encodeDef = {};
        zrUtil.each(data.dimensions, function (dimName, dataDimIndex) {
          var dimInfo = data.getDimensionInfo(dimName);

          if (!dimInfo.isExtraCoord) {
            var coordDim = dimInfo.coordDim;
            var dataDims = encodeDef[coordDim] = encodeDef[coordDim] || [];
            dataDims[dimInfo.coordDimIndex] = dataDimIndex;
          }
        });
        return encodeDef;
      }

      function createOrUpdate(el, dataIndex, elOption, animatableModel, group, data) {
        el = doCreateOrUpdate(el, dataIndex, elOption, animatableModel, group, data, true);
        el && data.setItemGraphicEl(dataIndex, el);
        return el;
      }

      function doCreateOrUpdate(el, dataIndex, elOption, animatableModel, group, data, isRoot) {
        // [Rule]
        // By default, follow merge mode.
        //     (It probably brings benifit for performance in some cases of large data, where
        //     user program can be optimized to that only updated props needed to be re-calculated,
        //     or according to `actionType` some calculation can be skipped.)
        // If `renderItem` returns `null`/`undefined`/`false`, remove the previous el if existing.
        //     (It seems that violate the "merge" principle, but most of users probably intuitively
        //     regard "return;" as "show nothing element whatever", so make a exception to meet the
        //     most cases.)
        var simplyRemove = !elOption; // `null`/`undefined`/`false`

        elOption = elOption || {};
        var elOptionType = elOption.type;
        var elOptionShape = elOption.shape;
        var elOptionStyle = elOption.style;

        if (el && (simplyRemove // || elOption.$merge === false
        // If `elOptionType` is `null`, follow the merge principle.
        || elOptionType != null && elOptionType !== el.__customGraphicType || elOptionType === 'path' && hasOwnPathData(elOptionShape) && getPathData(elOptionShape) !== el.__customPathData || elOptionType === 'image' && hasOwn(elOptionStyle, 'image') && elOptionStyle.image !== el.__customImagePath // FIXME test and remove this restriction?
        || elOptionType === 'text' && hasOwn(elOptionShape, 'text') && elOptionStyle.text !== el.__customText)) {
          group.remove(el);
          el = null;
        } // `elOption.type` is undefined when `renderItem` returns nothing.


        if (simplyRemove) {
          return;
        }

        var isInit = !el;
        !el && (el = createEl(elOption));
        updateEl(el, dataIndex, elOption, animatableModel, data, isInit, isRoot);

        if (elOptionType === 'group') {
          mergeChildren(el, dataIndex, elOption, animatableModel, data);
        } // Always add whatever already added to ensure sequence.


        group.add(el);
        return el;
      } // Usage:
      // (1) By default, `elOption.$mergeChildren` is `'byIndex'`, which indicates that
      //     the existing children will not be removed, and enables the feature that
      //     update some of the props of some of the children simply by construct
      //     the returned children of `renderItem` like:
      //     `var children = group.children = []; children[3] = {opacity: 0.5};`
      // (2) If `elOption.$mergeChildren` is `'byName'`, add/update/remove children
      //     by child.name. But that might be lower performance.
      // (3) If `elOption.$mergeChildren` is `false`, the existing children will be
      //     replaced totally.
      // (4) If `!elOption.children`, following the "merge" principle, nothing will happen.
      //
      // For implementation simpleness, do not provide a direct way to remove sinlge
      // child (otherwise the total indicies of the children array have to be modified).
      // User can remove a single child by set its `ignore` as `true` or replace
      // it by another element, where its `$merge` can be set as `true` if necessary.


      function mergeChildren(el, dataIndex, elOption, animatableModel, data) {
        var newChildren = elOption.children;
        var newLen = newChildren ? newChildren.length : 0;
        var mergeChildren = elOption.$mergeChildren; // `diffChildrenByName` has been deprecated.

        var byName = mergeChildren === 'byName' || elOption.diffChildrenByName;
        var notMerge = mergeChildren === false; // For better performance on roam update, only enter if necessary.

        if (!newLen && !byName && !notMerge) {
          return;
        }

        if (byName) {
          diffGroupChildren({
            oldChildren: el.children() || [],
            newChildren: newChildren || [],
            dataIndex: dataIndex,
            animatableModel: animatableModel,
            group: el,
            data: data
          });
          return;
        }

        notMerge && el.removeAll(); // Mapping children of a group simply by index, which
        // might be better performance.

        var index = 0;

        for (; index < newLen; index++) {
          newChildren[index] && doCreateOrUpdate(el.childAt(index), dataIndex, newChildren[index], animatableModel, el, data);
        }
      }

      function diffGroupChildren(context) {
        new DataDiffer(context.oldChildren, context.newChildren, getKey, getKey, context).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();
      }

      function getKey(item, idx) {
        var name = item && item.name;
        return name != null ? name : GROUP_DIFF_PREFIX + idx;
      }

      function processAddUpdate(newIndex, oldIndex) {
        var context = this.context;
        var childOption = newIndex != null ? context.newChildren[newIndex] : null;
        var child = oldIndex != null ? context.oldChildren[oldIndex] : null;
        doCreateOrUpdate(child, context.dataIndex, childOption, context.animatableModel, context.group, context.data);
      } // `graphic#applyDefaultTextStyle` will cache
      // textFill, textStroke, textStrokeWidth.
      // We have to do this trick.


      function applyExtraBefore(extra, model) {
        var dummyModel = new Model({}, model);
        zrUtil.each(CACHED_LABEL_STYLE_PROPERTIES, function (stylePropName, modelPropName) {
          if (extra.hasOwnProperty(stylePropName)) {
            dummyModel.option[modelPropName] = extra[stylePropName];
          }
        });
        return dummyModel;
      }

      function applyExtraAfter(itemStyle, extra) {
        for (var key in extra) {
          if (extra.hasOwnProperty(key) || !CACHED_LABEL_STYLE_PROPERTIES.hasOwnProperty(key)) {
            itemStyle[key] = extra[key];
          }
        }
      }

      function processRemove(oldIndex) {
        var context = this.context;
        var child = context.oldChildren[oldIndex];
        child && context.group.remove(child);
      }

      function getPathData(shape) {
        // "d" follows the SVG convention.
        return shape && (shape.pathData || shape.d);
      }

      function hasOwnPathData(shape) {
        return shape && (shape.hasOwnProperty('pathData') || shape.hasOwnProperty('d'));
      }

      function hasOwn(host, prop) {
        return host && host.hasOwnProperty(prop);
      }
      /***/

    },

    /***/
    "56rv":
    /*!******************************************************!*\
      !*** ./node_modules/echarts/lib/chart/bar/helper.js ***!
      \******************************************************/

    /*! no static exports found */

    /***/
    function rv(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var _labelHelper = __webpack_require__(
      /*! ../helper/labelHelper */
      "x3X8");

      var getDefaultLabel = _labelHelper.getDefaultLabel;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      function setLabel(normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside) {
        var labelModel = itemModel.getModel('label');
        var hoverLabelModel = itemModel.getModel('emphasis.label');
        graphic.setLabelStyle(normalStyle, hoverStyle, labelModel, hoverLabelModel, {
          labelFetcher: seriesModel,
          labelDataIndex: dataIndex,
          defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),
          isRectText: true,
          autoColor: color
        });
        fixPosition(normalStyle);
        fixPosition(hoverStyle);
      }

      function fixPosition(style, labelPositionOutside) {
        if (style.textPosition === 'outside') {
          style.textPosition = labelPositionOutside;
        }
      }

      exports.setLabel = setLabel;
      /***/
    },

    /***/
    "5GhG":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/helper/whiskerBoxCommon.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function GhG(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var createListSimply = __webpack_require__(
      /*! ../helper/createListSimply */
      "5GtS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _dimensionHelper = __webpack_require__(
      /*! ../../data/helper/dimensionHelper */
      "L0Ub");

      var getDimensionTypeByAxis = _dimensionHelper.getDimensionTypeByAxis;

      var _sourceHelper = __webpack_require__(
      /*! ../../data/helper/sourceHelper */
      "D5nY");

      var makeSeriesEncodeForAxisCoordSys = _sourceHelper.makeSeriesEncodeForAxisCoordSys;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var seriesModelMixin = {
        /**
         * @private
         * @type {string}
         */
        _baseAxisDim: null,

        /**
         * @override
         */
        getInitialData: function getInitialData(option, ecModel) {
          // When both types of xAxis and yAxis are 'value', layout is
          // needed to be specified by user. Otherwise, layout can be
          // judged by which axis is category.
          var ordinalMeta;
          var xAxisModel = ecModel.getComponent('xAxis', this.get('xAxisIndex'));
          var yAxisModel = ecModel.getComponent('yAxis', this.get('yAxisIndex'));
          var xAxisType = xAxisModel.get('type');
          var yAxisType = yAxisModel.get('type');
          var addOrdinal; // FIXME
          // Consider time axis.

          if (xAxisType === 'category') {
            option.layout = 'horizontal';
            ordinalMeta = xAxisModel.getOrdinalMeta();
            addOrdinal = true;
          } else if (yAxisType === 'category') {
            option.layout = 'vertical';
            ordinalMeta = yAxisModel.getOrdinalMeta();
            addOrdinal = true;
          } else {
            option.layout = option.layout || 'horizontal';
          }

          var coordDims = ['x', 'y'];
          var baseAxisDimIndex = option.layout === 'horizontal' ? 0 : 1;
          var baseAxisDim = this._baseAxisDim = coordDims[baseAxisDimIndex];
          var otherAxisDim = coordDims[1 - baseAxisDimIndex];
          var axisModels = [xAxisModel, yAxisModel];
          var baseAxisType = axisModels[baseAxisDimIndex].get('type');
          var otherAxisType = axisModels[1 - baseAxisDimIndex].get('type');
          var data = option.data; // ??? FIXME make a stage to perform data transfrom.
          // MUST create a new data, consider setOption({}) again.

          if (data && addOrdinal) {
            var newOptionData = [];
            zrUtil.each(data, function (item, index) {
              var newItem;

              if (item.value && zrUtil.isArray(item.value)) {
                newItem = item.value.slice();
                item.value.unshift(index);
              } else if (zrUtil.isArray(item)) {
                newItem = item.slice();
                item.unshift(index);
              } else {
                newItem = item;
              }

              newOptionData.push(newItem);
            });
            option.data = newOptionData;
          }

          var defaultValueDimensions = this.defaultValueDimensions;
          var coordDimensions = [{
            name: baseAxisDim,
            type: getDimensionTypeByAxis(baseAxisType),
            ordinalMeta: ordinalMeta,
            otherDims: {
              tooltip: false,
              itemName: 0
            },
            dimsDef: ['base']
          }, {
            name: otherAxisDim,
            type: getDimensionTypeByAxis(otherAxisType),
            dimsDef: defaultValueDimensions.slice()
          }];
          return createListSimply(this, {
            coordDimensions: coordDimensions,
            dimensionsCount: defaultValueDimensions.length + 1,
            encodeDefaulter: zrUtil.curry(makeSeriesEncodeForAxisCoordSys, coordDimensions, this)
          });
        },

        /**
         * If horizontal, base axis is x, otherwise y.
         * @override
         */
        getBaseAxis: function getBaseAxis() {
          var dim = this._baseAxisDim;
          return this.ecModel.getComponent(dim + 'Axis', this.get(dim + 'AxisIndex')).axis;
        }
      };
      exports.seriesModelMixin = seriesModelMixin;
      /***/
    },

    /***/
    "5GtS":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/helper/createListSimply.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function GtS(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var createDimensions = __webpack_require__(
      /*! ../../data/helper/createDimensions */
      "sdST");

      var List = __webpack_require__(
      /*! ../../data/List */
      "YXkt");

      var _util = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var extend = _util.extend;
      var isArray = _util.isArray;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * [Usage]:
       * (1)
       * createListSimply(seriesModel, ['value']);
       * (2)
       * createListSimply(seriesModel, {
       *     coordDimensions: ['value'],
       *     dimensionsCount: 5
       * });
       *
       * @param {module:echarts/model/Series} seriesModel
       * @param {Object|Array.<string|Object>} opt opt or coordDimensions
       *        The options in opt, see `echarts/data/helper/createDimensions`
       * @param {Array.<string>} [nameList]
       * @return {module:echarts/data/List}
       */

      function _default(seriesModel, opt, nameList) {
        opt = isArray(opt) && {
          coordDimensions: opt
        } || extend({}, opt);
        var source = seriesModel.getSource();
        var dimensionsInfo = createDimensions(source, opt);
        var list = new List(dimensionsInfo, seriesModel);
        list.initData(source, nameList);
        return list;
      }

      module.exports = _default;
      /***/
    },

    /***/
    "5NHt":
    /*!**************************************************************!*\
      !*** ./node_modules/echarts/lib/component/dataZoomSlider.js ***!
      \**************************************************************/

    /*! no static exports found */

    /***/
    function NHt(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      __webpack_require__(
      /*! ./dataZoom/typeDefaulter */
      "aTJb");

      __webpack_require__(
      /*! ./dataZoom/DataZoomModel */
      "OlYY");

      __webpack_require__(
      /*! ./dataZoom/DataZoomView */
      "fc+c");

      __webpack_require__(
      /*! ./dataZoom/SliderZoomModel */
      "N5BQ");

      __webpack_require__(
      /*! ./dataZoom/SliderZoomView */
      "IyUQ");

      __webpack_require__(
      /*! ./dataZoom/dataZoomProcessor */
      "LBfv");

      __webpack_require__(
      /*! ./dataZoom/dataZoomAction */
      "noeP");
      /***/

    },

    /***/
    "5s0K":
    /*!****************************************************!*\
      !*** ./node_modules/echarts/lib/util/animation.js ***!
      \****************************************************/

    /*! no static exports found */

    /***/
    function s0K(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @param {number} [time=500] Time in ms
       * @param {string} [easing='linear']
       * @param {number} [delay=0]
       * @param {Function} [callback]
       *
       * @example
       *  // Animate position
       *  animation
       *      .createWrap()
       *      .add(el1, {position: [10, 10]})
       *      .add(el2, {shape: {width: 500}, style: {fill: 'red'}}, 400)
       *      .done(function () { // done })
       *      .start('cubicOut');
       */


      function createWrap() {
        var storage = [];
        var elExistsMap = {};
        var doneCallback;
        return {
          /**
           * Caution: a el can only be added once, otherwise 'done'
           * might not be called. This method checks this (by el.id),
           * suppresses adding and returns false when existing el found.
           *
           * @param {modele:zrender/Element} el
           * @param {Object} target
           * @param {number} [time=500]
           * @param {number} [delay=0]
           * @param {string} [easing='linear']
           * @return {boolean} Whether adding succeeded.
           *
           * @example
           *     add(el, target, time, delay, easing);
           *     add(el, target, time, easing);
           *     add(el, target, time);
           *     add(el, target);
           */
          add: function add(el, target, time, delay, easing) {
            if (zrUtil.isString(delay)) {
              easing = delay;
              delay = 0;
            }

            if (elExistsMap[el.id]) {
              return false;
            }

            elExistsMap[el.id] = 1;
            storage.push({
              el: el,
              target: target,
              time: time,
              delay: delay,
              easing: easing
            });
            return true;
          },

          /**
           * Only execute when animation finished. Will not execute when any
           * of 'stop' or 'stopAnimation' called.
           *
           * @param {Function} callback
           */
          done: function done(callback) {
            doneCallback = callback;
            return this;
          },

          /**
           * Will stop exist animation firstly.
           */
          start: function start() {
            var count = storage.length;

            for (var i = 0, len = storage.length; i < len; i++) {
              var item = storage[i];
              item.el.animateTo(item.target, item.time, item.delay, item.easing, done);
            }

            return this;

            function done() {
              count--;

              if (!count) {
                storage.length = 0;
                elExistsMap = {};
                doneCallback && doneCallback();
              }
            }
          }
        };
      }

      exports.createWrap = createWrap;
      /***/
    },

    /***/
    "6/nd":
    /*!*****************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/legend/scrollableLegendAction.js ***!
      \*****************************************************************************/

    /*! no static exports found */

    /***/
    function nd(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @event legendScroll
       * @type {Object}
       * @property {string} type 'legendScroll'
       * @property {string} scrollDataIndex
       */


      echarts.registerAction('legendScroll', 'legendscroll', function (payload, ecModel) {
        var scrollDataIndex = payload.scrollDataIndex;
        scrollDataIndex != null && ecModel.eachComponent({
          mainType: 'legend',
          subType: 'scroll',
          query: payload
        }, function (legendModel) {
          legendModel.setScrollDataIndex(scrollDataIndex);
        });
      });
      /***/
    },

    /***/
    "62sa":
    /*!***********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/axisPointer/axisTrigger.js ***!
      \***********************************************************************/

    /*! no static exports found */

    /***/
    function sa(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _model = __webpack_require__(
      /*! ../../util/model */
      "4NO4");

      var makeInner = _model.makeInner;

      var modelHelper = __webpack_require__(
      /*! ./modelHelper */
      "zTMp");

      var findPointFromSeries = __webpack_require__(
      /*! ./findPointFromSeries */
      "Ez2D");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var each = zrUtil.each;
      var curry = zrUtil.curry;
      var inner = makeInner();
      /**
       * Basic logic: check all axis, if they do not demand show/highlight,
       * then hide/downplay them.
       *
       * @param {Object} coordSysAxesInfo
       * @param {Object} payload
       * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'
       * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to
       *              trigger axisPointer and tooltip.
       * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to
       *              trigger axisPointer and tooltip.
       * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.
       * @param {Object} [payload.dataIndex] finder, restrict target axes.
       * @param {Object} [payload.axesInfo] finder, restrict target axes.
       *        [{
       *          axisDim: 'x'|'y'|'angle'|...,
       *          axisIndex: ...,
       *          value: ...
       *        }, ...]
       * @param {Function} [payload.dispatchAction]
       * @param {Object} [payload.tooltipOption]
       * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,
       *        which can be specified in dispatchAction
       * @param {module:echarts/model/Global} ecModel
       * @param {module:echarts/ExtensionAPI} api
       * @return {Object} content of event obj for echarts.connect.
       */

      function _default(payload, ecModel, api) {
        var currTrigger = payload.currTrigger;
        var point = [payload.x, payload.y];
        var finder = payload;
        var dispatchAction = payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);
        var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo; // Pending
        // See #6121. But we are not able to reproduce it yet.

        if (!coordSysAxesInfo) {
          return;
        }

        if (illegalPoint(point)) {
          // Used in the default behavior of `connection`: use the sample seriesIndex
          // and dataIndex. And also used in the tooltipView trigger.
          point = findPointFromSeries({
            seriesIndex: finder.seriesIndex,
            // Do not use dataIndexInside from other ec instance.
            // FIXME: auto detect it?
            dataIndex: finder.dataIndex
          }, ecModel).point;
        }

        var isIllegalPoint = illegalPoint(point); // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).
        // Notice: In this case, it is difficult to get the `point` (which is necessary to show
        // tooltip, so if point is not given, we just use the point found by sample seriesIndex
        // and dataIndex.

        var inputAxesInfo = finder.axesInfo;
        var axesInfo = coordSysAxesInfo.axesInfo;
        var shouldHide = currTrigger === 'leave' || illegalPoint(point);
        var outputFinder = {};
        var showValueMap = {};
        var dataByCoordSys = {
          list: [],
          map: {}
        };
        var updaters = {
          showPointer: curry(showPointer, showValueMap),
          showTooltip: curry(showTooltip, dataByCoordSys)
        }; // Process for triggered axes.

        each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {
          // If a point given, it must be contained by the coordinate system.
          var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
          each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {
            var axis = axisInfo.axis;
            var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo); // If no inputAxesInfo, no axis is restricted.

            if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
              var val = inputAxisInfo && inputAxisInfo.value;

              if (val == null && !isIllegalPoint) {
                val = axis.pointToData(point);
              }

              val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);
            }
          });
        }); // Process for linked axes.

        var linkTriggers = {};
        each(axesInfo, function (tarAxisInfo, tarKey) {
          var linkGroup = tarAxisInfo.linkGroup; // If axis has been triggered in the previous stage, it should not be triggered by link.

          if (linkGroup && !showValueMap[tarKey]) {
            each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {
              var srcValItem = showValueMap[srcKey]; // If srcValItem exist, source axis is triggered, so link to target axis.

              if (srcAxisInfo !== tarAxisInfo && srcValItem) {
                var val = srcValItem.value;
                linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
                linkTriggers[tarAxisInfo.key] = val;
              }
            });
          }
        });
        each(linkTriggers, function (val, tarKey) {
          processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);
        });
        updateModelActually(showValueMap, axesInfo, outputFinder);
        dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);
        dispatchHighDownActually(axesInfo, dispatchAction, api);
        return outputFinder;
      }

      function processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {
        var axis = axisInfo.axis;

        if (axis.scale.isBlank() || !axis.containData(newValue)) {
          return;
        }

        if (!axisInfo.involveSeries) {
          updaters.showPointer(axisInfo, newValue);
          return;
        } // Heavy calculation. So put it after axis.containData checking.


        var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
        var payloadBatch = payloadInfo.payloadBatch;
        var snapToValue = payloadInfo.snapToValue; // Fill content of event obj for echarts.connect.
        // By default use the first involved series data as a sample to connect.

        if (payloadBatch[0] && outputFinder.seriesIndex == null) {
          zrUtil.extend(outputFinder, payloadBatch[0]);
        } // If no linkSource input, this process is for collecting link
        // target, where snap should not be accepted.


        if (!dontSnap && axisInfo.snap) {
          if (axis.containData(snapToValue) && snapToValue != null) {
            newValue = snapToValue;
          }
        }

        updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder); // Tooltip should always be snapToValue, otherwise there will be
        // incorrect "axis value ~ series value" mapping displayed in tooltip.

        updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
      }

      function buildPayloadsBySeries(value, axisInfo) {
        var axis = axisInfo.axis;
        var dim = axis.dim;
        var snapToValue = value;
        var payloadBatch = [];
        var minDist = Number.MAX_VALUE;
        var minDiff = -1;
        each(axisInfo.seriesModels, function (series, idx) {
          var dataDim = series.getData().mapDimension(dim, true);
          var seriesNestestValue;
          var dataIndices;

          if (series.getAxisTooltipData) {
            var result = series.getAxisTooltipData(dataDim, value, axis);
            dataIndices = result.dataIndices;
            seriesNestestValue = result.nestestValue;
          } else {
            dataIndices = series.getData().indicesOfNearest(dataDim[0], value, // Add a threshold to avoid find the wrong dataIndex
            // when data length is not same.
            // false,
            axis.type === 'category' ? 0.5 : null);

            if (!dataIndices.length) {
              return;
            }

            seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
          }

          if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
            return;
          }

          var diff = value - seriesNestestValue;
          var dist = Math.abs(diff); // Consider category case

          if (dist <= minDist) {
            if (dist < minDist || diff >= 0 && minDiff < 0) {
              minDist = dist;
              minDiff = diff;
              snapToValue = seriesNestestValue;
              payloadBatch.length = 0;
            }

            each(dataIndices, function (dataIndex) {
              payloadBatch.push({
                seriesIndex: series.seriesIndex,
                dataIndexInside: dataIndex,
                dataIndex: series.getData().getRawIndex(dataIndex)
              });
            });
          }
        });
        return {
          payloadBatch: payloadBatch,
          snapToValue: snapToValue
        };
      }

      function showPointer(showValueMap, axisInfo, value, payloadBatch) {
        showValueMap[axisInfo.key] = {
          value: value,
          payloadBatch: payloadBatch
        };
      }

      function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
        var payloadBatch = payloadInfo.payloadBatch;
        var axis = axisInfo.axis;
        var axisModel = axis.model;
        var axisPointerModel = axisInfo.axisPointerModel; // If no data, do not create anything in dataByCoordSys,
        // whose length will be used to judge whether dispatch action.

        if (!axisInfo.triggerTooltip || !payloadBatch.length) {
          return;
        }

        var coordSysModel = axisInfo.coordSys.model;
        var coordSysKey = modelHelper.makeKey(coordSysModel);
        var coordSysItem = dataByCoordSys.map[coordSysKey];

        if (!coordSysItem) {
          coordSysItem = dataByCoordSys.map[coordSysKey] = {
            coordSysId: coordSysModel.id,
            coordSysIndex: coordSysModel.componentIndex,
            coordSysType: coordSysModel.type,
            coordSysMainType: coordSysModel.mainType,
            dataByAxis: []
          };
          dataByCoordSys.list.push(coordSysItem);
        }

        coordSysItem.dataByAxis.push({
          axisDim: axis.dim,
          axisIndex: axisModel.componentIndex,
          axisType: axisModel.type,
          axisId: axisModel.id,
          value: value,
          // Caustion: viewHelper.getValueLabel is actually on "view stage", which
          // depends that all models have been updated. So it should not be performed
          // here. Considering axisPointerModel used here is volatile, which is hard
          // to be retrieve in TooltipView, we prepare parameters here.
          valueLabelOpt: {
            precision: axisPointerModel.get('label.precision'),
            formatter: axisPointerModel.get('label.formatter')
          },
          seriesDataIndices: payloadBatch.slice()
        });
      }

      function updateModelActually(showValueMap, axesInfo, outputFinder) {
        var outputAxesInfo = outputFinder.axesInfo = []; // Basic logic: If no 'show' required, 'hide' this axisPointer.

        each(axesInfo, function (axisInfo, key) {
          var option = axisInfo.axisPointerModel.option;
          var valItem = showValueMap[key];

          if (valItem) {
            !axisInfo.useHandle && (option.status = 'show');
            option.value = valItem.value; // For label formatter param and highlight.

            option.seriesDataIndices = (valItem.payloadBatch || []).slice();
          } // When always show (e.g., handle used), remain
          // original value and status.
          else {
            // If hide, value still need to be set, consider
            // click legend to toggle axis blank.
            !axisInfo.useHandle && (option.status = 'hide');
          } // If status is 'hide', should be no info in payload.


          option.status === 'show' && outputAxesInfo.push({
            axisDim: axisInfo.axis.dim,
            axisIndex: axisInfo.axis.model.componentIndex,
            value: option.value
          });
        });
      }

      function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {
        // Basic logic: If no showTip required, hideTip will be dispatched.
        if (illegalPoint(point) || !dataByCoordSys.list.length) {
          dispatchAction({
            type: 'hideTip'
          });
          return;
        } // In most case only one axis (or event one series is used). It is
        // convinient to fetch payload.seriesIndex and payload.dataIndex
        // dirtectly. So put the first seriesIndex and dataIndex of the first
        // axis on the payload.


        var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
        dispatchAction({
          type: 'showTip',
          escapeConnect: true,
          x: point[0],
          y: point[1],
          tooltipOption: payload.tooltipOption,
          position: payload.position,
          dataIndexInside: sampleItem.dataIndexInside,
          dataIndex: sampleItem.dataIndex,
          seriesIndex: sampleItem.seriesIndex,
          dataByCoordSys: dataByCoordSys.list
        });
      }

      function dispatchHighDownActually(axesInfo, dispatchAction, api) {
        // FIXME
        // highlight status modification shoule be a stage of main process?
        // (Consider confilct (e.g., legend and axisPointer) and setOption)
        var zr = api.getZr();
        var highDownKey = 'axisPointerLastHighlights';
        var lastHighlights = inner(zr)[highDownKey] || {};
        var newHighlights = inner(zr)[highDownKey] = {}; // Update highlight/downplay status according to axisPointer model.
        // Build hash map and remove duplicate incidentally.

        each(axesInfo, function (axisInfo, key) {
          var option = axisInfo.axisPointerModel.option;
          option.status === 'show' && each(option.seriesDataIndices, function (batchItem) {
            var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;
            newHighlights[key] = batchItem;
          });
        }); // Diff.

        var toHighlight = [];
        var toDownplay = [];
        zrUtil.each(lastHighlights, function (batchItem, key) {
          !newHighlights[key] && toDownplay.push(batchItem);
        });
        zrUtil.each(newHighlights, function (batchItem, key) {
          !lastHighlights[key] && toHighlight.push(batchItem);
        });
        toDownplay.length && api.dispatchAction({
          type: 'downplay',
          escapeConnect: true,
          batch: toDownplay
        });
        toHighlight.length && api.dispatchAction({
          type: 'highlight',
          escapeConnect: true,
          batch: toHighlight
        });
      }

      function findInputAxisInfo(inputAxesInfo, axisInfo) {
        for (var i = 0; i < (inputAxesInfo || []).length; i++) {
          var inputAxisInfo = inputAxesInfo[i];

          if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
            return inputAxisInfo;
          }
        }
      }

      function makeMapperParam(axisInfo) {
        var axisModel = axisInfo.axis.model;
        var item = {};
        var dim = item.axisDim = axisInfo.axis.dim;
        item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;
        item.axisName = item[dim + 'AxisName'] = axisModel.name;
        item.axisId = item[dim + 'AxisId'] = axisModel.id;
        return item;
      }

      function illegalPoint(point) {
        return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
      }

      module.exports = _default;
      /***/
    },

    /***/
    "6fms":
    /*!*************************************************!*\
      !*** ./node_modules/zrender/lib/vml/Painter.js ***!
      \*************************************************/

    /*! no static exports found */

    /***/
    function fms(module, exports, __webpack_require__) {
      var logError = __webpack_require__(
      /*! ../core/log */
      "SUKs");

      var vmlCore = __webpack_require__(
      /*! ./core */
      "06Qe");

      var _util = __webpack_require__(
      /*! ../core/util */
      "bYtY");

      var each = _util.each;
      /**
       * VML Painter.
       *
       * @module zrender/vml/Painter
       */

      function parseInt10(val) {
        return parseInt(val, 10);
      }
      /**
       * @alias module:zrender/vml/Painter
       */


      function VMLPainter(root, storage) {
        vmlCore.initVML();
        this.root = root;
        this.storage = storage;
        var vmlViewport = document.createElement('div');
        var vmlRoot = document.createElement('div');
        vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';
        vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';
        root.appendChild(vmlViewport);
        this._vmlRoot = vmlRoot;
        this._vmlViewport = vmlViewport;
        this.resize(); // Modify storage

        var oldDelFromStorage = storage.delFromStorage;
        var oldAddToStorage = storage.addToStorage;

        storage.delFromStorage = function (el) {
          oldDelFromStorage.call(storage, el);

          if (el) {
            el.onRemove && el.onRemove(vmlRoot);
          }
        };

        storage.addToStorage = function (el) {
          // Displayable already has a vml node
          el.onAdd && el.onAdd(vmlRoot);
          oldAddToStorage.call(storage, el);
        };

        this._firstPaint = true;
      }

      VMLPainter.prototype = {
        constructor: VMLPainter,
        getType: function getType() {
          return 'vml';
        },

        /**
         * @return {HTMLDivElement}
         */
        getViewportRoot: function getViewportRoot() {
          return this._vmlViewport;
        },
        getViewportRootOffset: function getViewportRootOffset() {
          var viewportRoot = this.getViewportRoot();

          if (viewportRoot) {
            return {
              offsetLeft: viewportRoot.offsetLeft || 0,
              offsetTop: viewportRoot.offsetTop || 0
            };
          }
        },

        /**
         * 
         */
        refresh: function refresh() {
          var list = this.storage.getDisplayList(true, true);

          this._paintList(list);
        },
        _paintList: function _paintList(list) {
          var vmlRoot = this._vmlRoot;

          for (var i = 0; i < list.length; i++) {
            var el = list[i];

            if (el.invisible || el.ignore) {
              if (!el.__alreadyNotVisible) {
                el.onRemove(vmlRoot);
              } // Set as already invisible


              el.__alreadyNotVisible = true;
            } else {
              if (el.__alreadyNotVisible) {
                el.onAdd(vmlRoot);
              }

              el.__alreadyNotVisible = false;

              if (el.__dirty) {
                el.beforeBrush && el.beforeBrush();
                (el.brushVML || el.brush).call(el, vmlRoot);
                el.afterBrush && el.afterBrush();
              }
            }

            el.__dirty = false;
          }

          if (this._firstPaint) {
            // Detached from document at first time
            // to avoid page refreshing too many times
            // FIXME  removeChild 
            this._vmlViewport.appendChild(vmlRoot);

            this._firstPaint = false;
          }
        },
        resize: function resize(width, height) {
          var width = width == null ? this._getWidth() : width;
          var height = height == null ? this._getHeight() : height;

          if (this._width !== width || this._height !== height) {
            this._width = width;
            this._height = height;
            var vmlViewportStyle = this._vmlViewport.style;
            vmlViewportStyle.width = width + 'px';
            vmlViewportStyle.height = height + 'px';
          }
        },
        dispose: function dispose() {
          this.root.innerHTML = '';
          this._vmlRoot = this._vmlViewport = this.storage = null;
        },
        getWidth: function getWidth() {
          return this._width;
        },
        getHeight: function getHeight() {
          return this._height;
        },
        clear: function clear() {
          if (this._vmlViewport) {
            this.root.removeChild(this._vmlViewport);
          }
        },
        _getWidth: function _getWidth() {
          var root = this.root;
          var stl = root.currentStyle;
          return (root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight) | 0;
        },
        _getHeight: function _getHeight() {
          var root = this.root;
          var stl = root.currentStyle;
          return (root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom) | 0;
        }
      }; // Not supported methods

      function createMethodNotSupport(method) {
        return function () {
          logError('In IE8.0 VML mode painter not support method "' + method + '"');
        };
      } // Unsupported methods


      each(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'], function (name) {
        VMLPainter.prototype[name] = createMethodNotSupport(name);
      });
      var _default = VMLPainter;
      module.exports = _default;
      /***/
    },

    /***/
    "6r85":
    /*!********************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/candlestick/preprocessor.js ***!
      \********************************************************************/

    /*! no static exports found */

    /***/
    function r85(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function _default(option) {
        if (!option || !zrUtil.isArray(option.series)) {
          return;
        } // Translate 'k' to 'candlestick'.


        zrUtil.each(option.series, function (seriesItem) {
          if (zrUtil.isObject(seriesItem) && seriesItem.type === 'k') {
            seriesItem.type = 'candlestick';
          }
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "6uqw":
    /*!************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/visualMap/VisualMapModel.js ***!
      \************************************************************************/

    /*! no static exports found */

    /***/
    function uqw(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var env = __webpack_require__(
      /*! zrender/lib/core/env */
      "ItGF");

      var visualDefault = __webpack_require__(
      /*! ../../visual/visualDefault */
      "YOMW");

      var VisualMapping = __webpack_require__(
      /*! ../../visual/VisualMapping */
      "XxSj");

      var visualSolution = __webpack_require__(
      /*! ../../visual/visualSolution */
      "K4ya");

      var modelUtil = __webpack_require__(
      /*! ../../util/model */
      "4NO4");

      var numberUtil = __webpack_require__(
      /*! ../../util/number */
      "OELB");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var mapVisual = VisualMapping.mapVisual;
      var eachVisual = VisualMapping.eachVisual;
      var isArray = zrUtil.isArray;
      var each = zrUtil.each;
      var asc = numberUtil.asc;
      var linearMap = numberUtil.linearMap;
      var noop = zrUtil.noop;
      var VisualMapModel = echarts.extendComponentModel({
        type: 'visualMap',
        dependencies: ['series'],

        /**
         * @readOnly
         * @type {Array.<string>}
         */
        stateList: ['inRange', 'outOfRange'],

        /**
         * @readOnly
         * @type {Array.<string>}
         */
        replacableOptionKeys: ['inRange', 'outOfRange', 'target', 'controller', 'color'],

        /**
         * [lowerBound, upperBound]
         *
         * @readOnly
         * @type {Array.<number>}
         */
        dataBound: [-Infinity, Infinity],

        /**
         * @readOnly
         * @type {string|Object}
         */
        layoutMode: {
          type: 'box',
          ignoreSize: true
        },

        /**
         * @protected
         */
        defaultOption: {
          show: true,
          zlevel: 0,
          z: 4,
          seriesIndex: 'all',
          // 'all' or null/undefined: all series.
          // A number or an array of number: the specified series.
          // set min: 0, max: 200, only for campatible with ec2.
          // In fact min max should not have default value.
          min: 0,
          // min value, must specified if pieces is not specified.
          max: 200,
          // max value, must specified if pieces is not specified.
          dimension: null,
          inRange: null,
          // 'color', 'colorHue', 'colorSaturation', 'colorLightness', 'colorAlpha',
          // 'symbol', 'symbolSize'
          outOfRange: null,
          // 'color', 'colorHue', 'colorSaturation',
          // 'colorLightness', 'colorAlpha',
          // 'symbol', 'symbolSize'
          left: 0,
          // 'center'  'left'  'right'  {number} (px)
          right: null,
          // The same as left.
          top: null,
          // 'top'  'bottom'  'center'  {number} (px)
          bottom: 0,
          // The same as top.
          itemWidth: null,
          itemHeight: null,
          inverse: false,
          orient: 'vertical',
          // 'horizontal'  'vertical'
          backgroundColor: 'rgba(0,0,0,0)',
          borderColor: '#ccc',
          // 
          contentColor: '#5793f3',
          inactiveColor: '#aaa',
          borderWidth: 0,
          // px0
          padding: 5,
          // px5
          // css
          textGap: 10,
          //
          precision: 0,
          // 0
          color: null,
          //deprecatedec2piecesinRange/outOfRange
          formatter: null,
          text: null,
          // ['', '']ec2text[0]text[1]
          textStyle: {
            color: '#333' // 

          }
        },

        /**
         * @protected
         */
        init: function init(option, parentModel, ecModel) {
          /**
           * @private
           * @type {Array.<number>}
           */
          this._dataExtent;
          /**
           * @readOnly
           */

          this.targetVisuals = {};
          /**
           * @readOnly
           */

          this.controllerVisuals = {};
          /**
           * @readOnly
           */

          this.textStyleModel;
          /**
           * [width, height]
           * @readOnly
           * @type {Array.<number>}
           */

          this.itemSize;
          this.mergeDefaultAndTheme(option, ecModel);
        },

        /**
         * @protected
         */
        optionUpdated: function optionUpdated(newOption, isInit) {
          var thisOption = this.option; // FIXME
          // necessary?
          // Disable realtime view update if canvas is not supported.

          if (!env.canvasSupported) {
            thisOption.realtime = false;
          }

          !isInit && visualSolution.replaceVisualOption(thisOption, newOption, this.replacableOptionKeys);
          this.textStyleModel = this.getModel('textStyle');
          this.resetItemSize();
          this.completeVisualOption();
        },

        /**
         * @protected
         */
        resetVisual: function resetVisual(supplementVisualOption) {
          var stateList = this.stateList;
          supplementVisualOption = zrUtil.bind(supplementVisualOption, this);
          this.controllerVisuals = visualSolution.createVisualMappings(this.option.controller, stateList, supplementVisualOption);
          this.targetVisuals = visualSolution.createVisualMappings(this.option.target, stateList, supplementVisualOption);
        },

        /**
         * @protected
         * @return {Array.<number>} An array of series indices.
         */
        getTargetSeriesIndices: function getTargetSeriesIndices() {
          var optionSeriesIndex = this.option.seriesIndex;
          var seriesIndices = [];

          if (optionSeriesIndex == null || optionSeriesIndex === 'all') {
            this.ecModel.eachSeries(function (seriesModel, index) {
              seriesIndices.push(index);
            });
          } else {
            seriesIndices = modelUtil.normalizeToArray(optionSeriesIndex);
          }

          return seriesIndices;
        },

        /**
         * @public
         */
        eachTargetSeries: function eachTargetSeries(callback, context) {
          zrUtil.each(this.getTargetSeriesIndices(), function (seriesIndex) {
            callback.call(context, this.ecModel.getSeriesByIndex(seriesIndex));
          }, this);
        },

        /**
         * @pubilc
         */
        isTargetSeries: function isTargetSeries(seriesModel) {
          var is = false;
          this.eachTargetSeries(function (model) {
            model === seriesModel && (is = true);
          });
          return is;
        },

        /**
         * @example
         * this.formatValueText(someVal); // format single numeric value to text.
         * this.formatValueText(someVal, true); // format single category value to text.
         * this.formatValueText([min, max]); // format numeric min-max to text.
         * this.formatValueText([this.dataBound[0], max]); // using data lower bound.
         * this.formatValueText([min, this.dataBound[1]]); // using data upper bound.
         *
         * @param {number|Array.<number>} value Real value, or this.dataBound[0 or 1].
         * @param {boolean} [isCategory=false] Only available when value is number.
         * @param {Array.<string>} edgeSymbols Open-close symbol when value is interval.
         * @return {string}
         * @protected
         */
        formatValueText: function formatValueText(value, isCategory, edgeSymbols) {
          var option = this.option;
          var precision = option.precision;
          var dataBound = this.dataBound;
          var formatter = option.formatter;
          var isMinMax;
          var textValue;
          edgeSymbols = edgeSymbols || ['<', '>'];

          if (zrUtil.isArray(value)) {
            value = value.slice();
            isMinMax = true;
          }

          textValue = isCategory ? value : isMinMax ? [toFixed(value[0]), toFixed(value[1])] : toFixed(value);

          if (zrUtil.isString(formatter)) {
            return formatter.replace('{value}', isMinMax ? textValue[0] : textValue).replace('{value2}', isMinMax ? textValue[1] : textValue);
          } else if (zrUtil.isFunction(formatter)) {
            return isMinMax ? formatter(value[0], value[1]) : formatter(value);
          }

          if (isMinMax) {
            if (value[0] === dataBound[0]) {
              return edgeSymbols[0] + ' ' + textValue[1];
            } else if (value[1] === dataBound[1]) {
              return edgeSymbols[1] + ' ' + textValue[0];
            } else {
              return textValue[0] + ' - ' + textValue[1];
            }
          } else {
            // Format single value (includes category case).
            return textValue;
          }

          function toFixed(val) {
            return val === dataBound[0] ? 'min' : val === dataBound[1] ? 'max' : (+val).toFixed(Math.min(precision, 20));
          }
        },

        /**
         * @protected
         */
        resetExtent: function resetExtent() {
          var thisOption = this.option; // Can not calculate data extent by data here.
          // Because series and data may be modified in processing stage.
          // So we do not support the feature "auto min/max".

          var extent = asc([thisOption.min, thisOption.max]);
          this._dataExtent = extent;
        },

        /**
         * @public
         * @param {module:echarts/data/List} list
         * @return {string} Concrete dimention. If return null/undefined,
         *                  no dimension used.
         */
        getDataDimension: function getDataDimension(list) {
          var optDim = this.option.dimension;
          var listDimensions = list.dimensions;

          if (optDim == null && !listDimensions.length) {
            return;
          }

          if (optDim != null) {
            return list.getDimension(optDim);
          }

          var dimNames = list.dimensions;

          for (var i = dimNames.length - 1; i >= 0; i--) {
            var dimName = dimNames[i];
            var dimInfo = list.getDimensionInfo(dimName);

            if (!dimInfo.isCalculationCoord) {
              return dimName;
            }
          }
        },

        /**
         * @public
         * @override
         */
        getExtent: function getExtent() {
          return this._dataExtent.slice();
        },

        /**
         * @protected
         */
        completeVisualOption: function completeVisualOption() {
          var ecModel = this.ecModel;
          var thisOption = this.option;
          var base = {
            inRange: thisOption.inRange,
            outOfRange: thisOption.outOfRange
          };
          var target = thisOption.target || (thisOption.target = {});
          var controller = thisOption.controller || (thisOption.controller = {});
          zrUtil.merge(target, base); // Do not override

          zrUtil.merge(controller, base); // Do not override

          var isCategory = this.isCategory();
          completeSingle.call(this, target);
          completeSingle.call(this, controller);
          completeInactive.call(this, target, 'inRange', 'outOfRange'); // completeInactive.call(this, target, 'outOfRange', 'inRange');

          completeController.call(this, controller);

          function completeSingle(base) {
            // Compatible with ec2 dataRange.color.
            // The mapping order of dataRange.color is: [high value, ..., low value]
            // whereas inRange.color and outOfRange.color is [low value, ..., high value]
            // Notice: ec2 has no inverse.
            if (isArray(thisOption.color) // If there has been inRange: {symbol: ...}, adding color is a mistake.
            // So adding color only when no inRange defined.
            && !base.inRange) {
              base.inRange = {
                color: thisOption.color.slice().reverse()
              };
            } // Compatible with previous logic, always give a defautl color, otherwise
            // simple config with no inRange and outOfRange will not work.
            // Originally we use visualMap.color as the default color, but setOption at
            // the second time the default color will be erased. So we change to use
            // constant DEFAULT_COLOR.
            // If user do not want the default color, set inRange: {color: null}.


            base.inRange = base.inRange || {
              color: ecModel.get('gradientColor')
            }; // If using shortcut like: {inRange: 'symbol'}, complete default value.

            each(this.stateList, function (state) {
              var visualType = base[state];

              if (zrUtil.isString(visualType)) {
                var defa = visualDefault.get(visualType, 'active', isCategory);

                if (defa) {
                  base[state] = {};
                  base[state][visualType] = defa;
                } else {
                  // Mark as not specified.
                  delete base[state];
                }
              }
            }, this);
          }

          function completeInactive(base, stateExist, stateAbsent) {
            var optExist = base[stateExist];
            var optAbsent = base[stateAbsent];

            if (optExist && !optAbsent) {
              optAbsent = base[stateAbsent] = {};
              each(optExist, function (visualData, visualType) {
                if (!VisualMapping.isValidType(visualType)) {
                  return;
                }

                var defa = visualDefault.get(visualType, 'inactive', isCategory);

                if (defa != null) {
                  optAbsent[visualType] = defa; // Compatibable with ec2:
                  // Only inactive color to rgba(0,0,0,0) can not
                  // make label transparent, so use opacity also.

                  if (visualType === 'color' && !optAbsent.hasOwnProperty('opacity') && !optAbsent.hasOwnProperty('colorAlpha')) {
                    optAbsent.opacity = [0, 0];
                  }
                }
              });
            }
          }

          function completeController(controller) {
            var symbolExists = (controller.inRange || {}).symbol || (controller.outOfRange || {}).symbol;
            var symbolSizeExists = (controller.inRange || {}).symbolSize || (controller.outOfRange || {}).symbolSize;
            var inactiveColor = this.get('inactiveColor');
            each(this.stateList, function (state) {
              var itemSize = this.itemSize;
              var visuals = controller[state]; // Set inactive color for controller if no other color
              // attr (like colorAlpha) specified.

              if (!visuals) {
                visuals = controller[state] = {
                  color: isCategory ? inactiveColor : [inactiveColor]
                };
              } // Consistent symbol and symbolSize if not specified.


              if (visuals.symbol == null) {
                visuals.symbol = symbolExists && zrUtil.clone(symbolExists) || (isCategory ? 'roundRect' : ['roundRect']);
              }

              if (visuals.symbolSize == null) {
                visuals.symbolSize = symbolSizeExists && zrUtil.clone(symbolSizeExists) || (isCategory ? itemSize[0] : [itemSize[0], itemSize[0]]);
              } // Filter square and none.


              visuals.symbol = mapVisual(visuals.symbol, function (symbol) {
                return symbol === 'none' || symbol === 'square' ? 'roundRect' : symbol;
              }); // Normalize symbolSize

              var symbolSize = visuals.symbolSize;

              if (symbolSize != null) {
                var max = -Infinity; // symbolSize can be object when categories defined.

                eachVisual(symbolSize, function (value) {
                  value > max && (max = value);
                });
                visuals.symbolSize = mapVisual(symbolSize, function (value) {
                  return linearMap(value, [0, max], [0, itemSize[0]], true);
                });
              }
            }, this);
          }
        },

        /**
         * @protected
         */
        resetItemSize: function resetItemSize() {
          this.itemSize = [parseFloat(this.get('itemWidth')), parseFloat(this.get('itemHeight'))];
        },

        /**
         * @public
         */
        isCategory: function isCategory() {
          return !!this.option.categories;
        },

        /**
         * @public
         * @abstract
         */
        setSelected: noop,

        /**
         * @public
         * @abstract
         * @param {*|module:echarts/data/List} valueOrData
         * @param {number} dataIndex
         * @return {string} state See this.stateList
         */
        getValueState: noop,

        /**
         * FIXME
         * Do not publish to thirt-part-dev temporarily
         * util the interface is stable. (Should it return
         * a function but not visual meta?)
         *
         * @pubilc
         * @abstract
         * @param {Function} getColorVisual
         *        params: value, valueState
         *        return: color
         * @return {Object} visualMeta
         *        should includes {stops, outerColors}
         *        outerColor means [colorBeyondMinValue, colorBeyondMaxValue]
         */
        getVisualMeta: noop
      });
      var _default = VisualMapModel;
      module.exports = _default;
      /***/
    },

    /***/
    "6usn":
    /*!***************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/polar/prepareCustom.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function usn(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function dataToCoordSize(dataSize, dataItem) {
        // dataItem is necessary in log axis.
        return zrUtil.map(['Radius', 'Angle'], function (dim, dimIdx) {
          var axis = this['get' + dim + 'Axis']();
          var val = dataItem[dimIdx];
          var halfSize = dataSize[dimIdx] / 2;
          var method = 'dataTo' + dim;
          var result = axis.type === 'category' ? axis.getBandWidth() : Math.abs(axis[method](val - halfSize) - axis[method](val + halfSize));

          if (dim === 'Angle') {
            result = result * Math.PI / 180;
          }

          return result;
        }, this);
      }

      function _default(coordSys) {
        var radiusAxis = coordSys.getRadiusAxis();
        var angleAxis = coordSys.getAngleAxis();
        var radius = radiusAxis.getExtent();
        radius[0] > radius[1] && radius.reverse();
        return {
          coordSys: {
            type: 'polar',
            cx: coordSys.cx,
            cy: coordSys.cy,
            r: radius[1],
            r0: radius[0]
          },
          api: {
            coord: zrUtil.bind(function (data) {
              var radius = radiusAxis.dataToRadius(data[0]);
              var angle = angleAxis.dataToAngle(data[1]);
              var coord = coordSys.coordToPoint([radius, angle]);
              coord.push(radius, angle * Math.PI / 180);
              return coord;
            }),
            size: zrUtil.bind(dataToCoordSize, coordSys)
          }
        };
      }

      module.exports = _default;
      /***/
    },

    /***/
    "72pK":
    /*!*****************************************************************!*\
      !*** ./node_modules/echarts/lib/component/helper/sliderMove.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function pK(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Calculate slider move result.
       * Usage:
       * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as
       * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.
       * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.
       *
       * @param {number} delta Move length.
       * @param {Array.<number>} handleEnds handleEnds[0] can be bigger then handleEnds[1].
       *              handleEnds will be modified in this method.
       * @param {Array.<number>} extent handleEnds is restricted by extent.
       *              extent[0] should less or equals than extent[1].
       * @param {number|string} handleIndex Can be 'all', means that both move the two handleEnds.
       * @param {number} [minSpan] The range of dataZoom can not be smaller than that.
       *              If not set, handle0 and cross handle1. If set as a non-negative
       *              number (including `0`), handles will push each other when reaching
       *              the minSpan.
       * @param {number} [maxSpan] The range of dataZoom can not be larger than that.
       * @return {Array.<number>} The input handleEnds.
       */
      function _default(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {
        delta = delta || 0;
        var extentSpan = extent[1] - extent[0]; // Notice maxSpan and minSpan can be null/undefined.

        if (minSpan != null) {
          minSpan = restrict(minSpan, [0, extentSpan]);
        }

        if (maxSpan != null) {
          maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);
        }

        if (handleIndex === 'all') {
          var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);
          handleSpan = restrict(handleSpan, [0, extentSpan]);
          minSpan = maxSpan = restrict(handleSpan, [minSpan, maxSpan]);
          handleIndex = 0;
        }

        handleEnds[0] = restrict(handleEnds[0], extent);
        handleEnds[1] = restrict(handleEnds[1], extent);
        var originalDistSign = getSpanSign(handleEnds, handleIndex);
        handleEnds[handleIndex] += delta; // Restrict in extent.

        var extentMinSpan = minSpan || 0;
        var realExtent = extent.slice();
        originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;
        handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent); // Expand span.

        var currDistSign = getSpanSign(handleEnds, handleIndex);

        if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {
          // If minSpan exists, 'cross' is forbidden.
          handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;
        } // Shrink span.


        var currDistSign = getSpanSign(handleEnds, handleIndex);

        if (maxSpan != null && currDistSign.span > maxSpan) {
          handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;
        }

        return handleEnds;
      }

      function getSpanSign(handleEnds, handleIndex) {
        var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex]; // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]
        // is at left of handleEnds[1] for non-cross case.

        return {
          span: Math.abs(dist),
          sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1
        };
      }

      function restrict(value, extend) {
        return Math.min(extend[1] != null ? extend[1] : Infinity, Math.max(extend[0] != null ? extend[0] : -Infinity, value));
      }

      module.exports = _default;
      /***/
    },

    /***/
    "75ce":
    /*!************************************************!*\
      !*** ./node_modules/echarts/lib/chart/line.js ***!
      \************************************************/

    /*! no static exports found */

    /***/
    function ce(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ./line/LineSeries */
      "IXuL");

      __webpack_require__(
      /*! ./line/LineView */
      "8X+K");

      var visualSymbol = __webpack_require__(
      /*! ../visual/symbol */
      "f5Yq");

      var layoutPoints = __webpack_require__(
      /*! ../layout/points */
      "h8O9");

      var dataSample = __webpack_require__(
      /*! ../processor/dataSample */
      "/d5a");

      __webpack_require__(
      /*! ../component/gridSimple */
      "Ae16");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // In case developer forget to include grid component


      echarts.registerVisual(visualSymbol('line', 'circle', 'line'));
      echarts.registerLayout(layoutPoints('line')); // Down sample after filter

      echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));
      /***/
    },

    /***/
    "75ev":
    /*!************************************************!*\
      !*** ./node_modules/echarts/lib/chart/tree.js ***!
      \************************************************/

    /*! no static exports found */

    /***/
    function ev(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ./tree/TreeSeries */
      "IWNH");

      __webpack_require__(
      /*! ./tree/TreeView */
      "bNin");

      __webpack_require__(
      /*! ./tree/treeAction */
      "v5uJ");

      var visualSymbol = __webpack_require__(
      /*! ../visual/symbol */
      "f5Yq");

      var treeLayout = __webpack_require__(
      /*! ./tree/treeLayout */
      "yik8");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      echarts.registerVisual(visualSymbol('tree', 'circle'));
      echarts.registerLayout(treeLayout);
      /***/
    },

    /***/
    "7AJT":
    /*!************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/cartesian/Axis2D.js ***!
      \************************************************************/

    /*! no static exports found */

    /***/
    function AJT(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var Axis = __webpack_require__(
      /*! ../Axis */
      "hM6l");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Extend axis 2d
       * @constructor module:echarts/coord/cartesian/Axis2D
       * @extends {module:echarts/coord/cartesian/Axis}
       * @param {string} dim
       * @param {*} scale
       * @param {Array.<number>} coordExtent
       * @param {string} axisType
       * @param {string} position
       */


      var Axis2D = function Axis2D(dim, scale, coordExtent, axisType, position) {
        Axis.call(this, dim, scale, coordExtent);
        /**
         * Axis type
         *  - 'category'
         *  - 'value'
         *  - 'time'
         *  - 'log'
         * @type {string}
         */

        this.type = axisType || 'value';
        /**
         * Axis position
         *  - 'top'
         *  - 'bottom'
         *  - 'left'
         *  - 'right'
         */

        this.position = position || 'bottom';
      };

      Axis2D.prototype = {
        constructor: Axis2D,

        /**
         * Index of axis, can be used as key
         */
        index: 0,

        /**
         * Implemented in <module:echarts/coord/cartesian/Grid>.
         * @return {Array.<module:echarts/coord/cartesian/Axis2D>}
         *         If not on zero of other axis, return null/undefined.
         *         If no axes, return an empty array.
         */
        getAxesOnZeroOf: null,

        /**
         * Axis model
         * @param {module:echarts/coord/cartesian/AxisModel}
         */
        model: null,
        isHorizontal: function isHorizontal() {
          var position = this.position;
          return position === 'top' || position === 'bottom';
        },

        /**
         * Each item cooresponds to this.getExtent(), which
         * means globalExtent[0] may greater than globalExtent[1],
         * unless `asc` is input.
         *
         * @param {boolean} [asc]
         * @return {Array.<number>}
         */
        getGlobalExtent: function getGlobalExtent(asc) {
          var ret = this.getExtent();
          ret[0] = this.toGlobalCoord(ret[0]);
          ret[1] = this.toGlobalCoord(ret[1]);
          asc && ret[0] > ret[1] && ret.reverse();
          return ret;
        },
        getOtherAxis: function getOtherAxis() {
          this.grid.getOtherAxis();
        },

        /**
         * @override
         */
        pointToData: function pointToData(point, clamp) {
          return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);
        },

        /**
         * Transform global coord to local coord,
         * i.e. var localCoord = axis.toLocalCoord(80);
         * designate by module:echarts/coord/cartesian/Grid.
         * @type {Function}
         */
        toLocalCoord: null,

        /**
         * Transform global coord to local coord,
         * i.e. var globalCoord = axis.toLocalCoord(40);
         * designate by module:echarts/coord/cartesian/Grid.
         * @type {Function}
         */
        toGlobalCoord: null
      };
      zrUtil.inherits(Axis2D, Axis);
      var _default = Axis2D;
      module.exports = _default;
      /***/
    },

    /***/
    "7Phj":
    /*!*****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/boxplot/boxplotLayout.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function Phj(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _number = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var parsePercent = _number.parsePercent;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var each = zrUtil.each;

      function _default(ecModel) {
        var groupResult = groupSeriesByAxis(ecModel);
        each(groupResult, function (groupItem) {
          var seriesModels = groupItem.seriesModels;

          if (!seriesModels.length) {
            return;
          }

          calculateBase(groupItem);
          each(seriesModels, function (seriesModel, idx) {
            layoutSingleSeries(seriesModel, groupItem.boxOffsetList[idx], groupItem.boxWidthList[idx]);
          });
        });
      }
      /**
       * Group series by axis.
       */


      function groupSeriesByAxis(ecModel) {
        var result = [];
        var axisList = [];
        ecModel.eachSeriesByType('boxplot', function (seriesModel) {
          var baseAxis = seriesModel.getBaseAxis();
          var idx = zrUtil.indexOf(axisList, baseAxis);

          if (idx < 0) {
            idx = axisList.length;
            axisList[idx] = baseAxis;
            result[idx] = {
              axis: baseAxis,
              seriesModels: []
            };
          }

          result[idx].seriesModels.push(seriesModel);
        });
        return result;
      }
      /**
       * Calculate offset and box width for each series.
       */


      function calculateBase(groupItem) {
        var extent;
        var baseAxis = groupItem.axis;
        var seriesModels = groupItem.seriesModels;
        var seriesCount = seriesModels.length;
        var boxWidthList = groupItem.boxWidthList = [];
        var boxOffsetList = groupItem.boxOffsetList = [];
        var boundList = [];
        var bandWidth;

        if (baseAxis.type === 'category') {
          bandWidth = baseAxis.getBandWidth();
        } else {
          var maxDataCount = 0;
          each(seriesModels, function (seriesModel) {
            maxDataCount = Math.max(maxDataCount, seriesModel.getData().count());
          });
          extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / maxDataCount;
        }

        each(seriesModels, function (seriesModel) {
          var boxWidthBound = seriesModel.get('boxWidth');

          if (!zrUtil.isArray(boxWidthBound)) {
            boxWidthBound = [boxWidthBound, boxWidthBound];
          }

          boundList.push([parsePercent(boxWidthBound[0], bandWidth) || 0, parsePercent(boxWidthBound[1], bandWidth) || 0]);
        });
        var availableWidth = bandWidth * 0.8 - 2;
        var boxGap = availableWidth / seriesCount * 0.3;
        var boxWidth = (availableWidth - boxGap * (seriesCount - 1)) / seriesCount;
        var base = boxWidth / 2 - availableWidth / 2;
        each(seriesModels, function (seriesModel, idx) {
          boxOffsetList.push(base);
          base += boxGap + boxWidth;
          boxWidthList.push(Math.min(Math.max(boxWidth, boundList[idx][0]), boundList[idx][1]));
        });
      }
      /**
       * Calculate points location for each series.
       */


      function layoutSingleSeries(seriesModel, offset, boxWidth) {
        var coordSys = seriesModel.coordinateSystem;
        var data = seriesModel.getData();
        var halfWidth = boxWidth / 2;
        var cDimIdx = seriesModel.get('layout') === 'horizontal' ? 0 : 1;
        var vDimIdx = 1 - cDimIdx;
        var coordDims = ['x', 'y'];
        var cDim = data.mapDimension(coordDims[cDimIdx]);
        var vDims = data.mapDimension(coordDims[vDimIdx], true);

        if (cDim == null || vDims.length < 5) {
          return;
        }

        for (var dataIndex = 0; dataIndex < data.count(); dataIndex++) {
          var axisDimVal = data.get(cDim, dataIndex);
          var median = getPoint(axisDimVal, vDims[2], dataIndex);
          var end1 = getPoint(axisDimVal, vDims[0], dataIndex);
          var end2 = getPoint(axisDimVal, vDims[1], dataIndex);
          var end4 = getPoint(axisDimVal, vDims[3], dataIndex);
          var end5 = getPoint(axisDimVal, vDims[4], dataIndex);
          var ends = [];
          addBodyEnd(ends, end2, 0);
          addBodyEnd(ends, end4, 1);
          ends.push(end1, end2, end5, end4);
          layEndLine(ends, end1);
          layEndLine(ends, end5);
          layEndLine(ends, median);
          data.setItemLayout(dataIndex, {
            initBaseline: median[vDimIdx],
            ends: ends
          });
        }

        function getPoint(axisDimVal, dimIdx, dataIndex) {
          var val = data.get(dimIdx, dataIndex);
          var p = [];
          p[cDimIdx] = axisDimVal;
          p[vDimIdx] = val;
          var point;

          if (isNaN(axisDimVal) || isNaN(val)) {
            point = [NaN, NaN];
          } else {
            point = coordSys.dataToPoint(p);
            point[cDimIdx] += offset;
          }

          return point;
        }

        function addBodyEnd(ends, point, start) {
          var point1 = point.slice();
          var point2 = point.slice();
          point1[cDimIdx] += halfWidth;
          point2[cDimIdx] -= halfWidth;
          start ? ends.push(point1, point2) : ends.push(point2, point1);
        }

        function layEndLine(ends, endCenter) {
          var from = endCenter.slice();
          var to = endCenter.slice();
          from[cDimIdx] -= halfWidth;
          to[cDimIdx] += halfWidth;
          ends.push(from, to);
        }
      }

      module.exports = _default;
      /***/
    },

    /***/
    "7a+S":
    /*!**********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/timeline/TimelineModel.js ***!
      \**********************************************************************/

    /*! no static exports found */

    /***/
    function aS(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var ComponentModel = __webpack_require__(
      /*! ../../model/Component */
      "bLfw");

      var List = __webpack_require__(
      /*! ../../data/List */
      "YXkt");

      var modelUtil = __webpack_require__(
      /*! ../../util/model */
      "4NO4");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var TimelineModel = ComponentModel.extend({
        type: 'timeline',
        layoutMode: 'box',

        /**
         * @protected
         */
        defaultOption: {
          zlevel: 0,
          // 
          z: 4,
          // 
          show: true,
          axisType: 'time',
          //  value, category
          realtime: true,
          left: '20%',
          top: null,
          right: '20%',
          bottom: 0,
          width: null,
          height: 40,
          padding: 5,
          controlPosition: 'left',
          // 'left' 'right' 'top' 'bottom' 'none'
          autoPlay: false,
          rewind: false,
          // 
          loop: true,
          playInterval: 2000,
          // ms
          currentIndex: 0,
          itemStyle: {},
          label: {
            color: '#000'
          },
          data: []
        },

        /**
         * @override
         */
        init: function init(option, parentModel, ecModel) {
          /**
           * @private
           * @type {module:echarts/data/List}
           */
          this._data;
          /**
           * @private
           * @type {Array.<string>}
           */

          this._names;
          this.mergeDefaultAndTheme(option, ecModel);

          this._initData();
        },

        /**
         * @override
         */
        mergeOption: function mergeOption(option) {
          TimelineModel.superApply(this, 'mergeOption', arguments);

          this._initData();
        },

        /**
         * @param {number} [currentIndex]
         */
        setCurrentIndex: function setCurrentIndex(currentIndex) {
          if (currentIndex == null) {
            currentIndex = this.option.currentIndex;
          }

          var count = this._data.count();

          if (this.option.loop) {
            currentIndex = (currentIndex % count + count) % count;
          } else {
            currentIndex >= count && (currentIndex = count - 1);
            currentIndex < 0 && (currentIndex = 0);
          }

          this.option.currentIndex = currentIndex;
        },

        /**
         * @return {number} currentIndex
         */
        getCurrentIndex: function getCurrentIndex() {
          return this.option.currentIndex;
        },

        /**
         * @return {boolean}
         */
        isIndexMax: function isIndexMax() {
          return this.getCurrentIndex() >= this._data.count() - 1;
        },

        /**
         * @param {boolean} state true: play, false: stop
         */
        setPlayState: function setPlayState(state) {
          this.option.autoPlay = !!state;
        },

        /**
         * @return {boolean} true: play, false: stop
         */
        getPlayState: function getPlayState() {
          return !!this.option.autoPlay;
        },

        /**
         * @private
         */
        _initData: function _initData() {
          var thisOption = this.option;
          var dataArr = thisOption.data || [];
          var axisType = thisOption.axisType;
          var names = this._names = [];

          if (axisType === 'category') {
            var idxArr = [];
            zrUtil.each(dataArr, function (item, index) {
              var value = modelUtil.getDataItemValue(item);
              var newItem;

              if (zrUtil.isObject(item)) {
                newItem = zrUtil.clone(item);
                newItem.value = index;
              } else {
                newItem = index;
              }

              idxArr.push(newItem);

              if (!zrUtil.isString(value) && (value == null || isNaN(value))) {
                value = '';
              }

              names.push(value + '');
            });
            dataArr = idxArr;
          }

          var dimType = {
            category: 'ordinal',
            time: 'time'
          }[axisType] || 'number';
          var data = this._data = new List([{
            name: 'value',
            type: dimType
          }], this);
          data.initData(dataArr, names);
        },
        getData: function getData() {
          return this._data;
        },

        /**
         * @public
         * @return {Array.<string>} categoreis
         */
        getCategories: function getCategories() {
          if (this.get('axisType') === 'category') {
            return this._names.slice();
          }
        }
      });
      var _default = TimelineModel;
      module.exports = _default;
      /***/
    },

    /***/
    "7bkD":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/single/singleAxisHelper.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function bkD(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @param {Object} opt {labelInside}
       * @return {Object} {
       *  position, rotation, labelDirection, labelOffset,
       *  tickDirection, labelRotate, z2
       * }
       */


      function layout(axisModel, opt) {
        opt = opt || {};
        var single = axisModel.coordinateSystem;
        var axis = axisModel.axis;
        var layout = {};
        var axisPosition = axis.position;
        var orient = axis.orient;
        var rect = single.getRect();
        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
        var positionMap = {
          horizontal: {
            top: rectBound[2],
            bottom: rectBound[3]
          },
          vertical: {
            left: rectBound[0],
            right: rectBound[1]
          }
        };
        layout.position = [orient === 'vertical' ? positionMap.vertical[axisPosition] : rectBound[0], orient === 'horizontal' ? positionMap.horizontal[axisPosition] : rectBound[3]];
        var r = {
          horizontal: 0,
          vertical: 1
        };
        layout.rotation = Math.PI / 2 * r[orient];
        var directionMap = {
          top: -1,
          bottom: 1,
          right: 1,
          left: -1
        };
        layout.labelDirection = layout.tickDirection = layout.nameDirection = directionMap[axisPosition];

        if (axisModel.get('axisTick.inside')) {
          layout.tickDirection = -layout.tickDirection;
        }

        if (zrUtil.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {
          layout.labelDirection = -layout.labelDirection;
        }

        var labelRotation = opt.rotate;
        labelRotation == null && (labelRotation = axisModel.get('axisLabel.rotate'));
        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;
        layout.z2 = 1;
        return layout;
      }

      exports.layout = layout;
      /***/
    },

    /***/
    "7mYs":
    /*!*********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/calendar/CalendarView.js ***!
      \*********************************************************************/

    /*! no static exports found */

    /***/
    function mYs(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var formatUtil = __webpack_require__(
      /*! ../../util/format */
      "7aKB");

      var numberUtil = __webpack_require__(
      /*! ../../util/number */
      "OELB");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var MONTH_TEXT = {
        EN: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
        CN: ['', '', '', '', '', '', '', '', '', '', '', '']
      };
      var WEEK_TEXT = {
        EN: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
        CN: ['', '', '', '', '', '', '']
      };

      var _default = echarts.extendComponentView({
        type: 'calendar',

        /**
         * top/left line points
         *  @private
         */
        _tlpoints: null,

        /**
         * bottom/right line points
         *  @private
         */
        _blpoints: null,

        /**
         * first day of month
         *  @private
         */
        _firstDayOfMonth: null,

        /**
         * first day point of month
         *  @private
         */
        _firstDayPoints: null,
        render: function render(calendarModel, ecModel, api) {
          var group = this.group;
          group.removeAll();
          var coordSys = calendarModel.coordinateSystem; // range info

          var rangeData = coordSys.getRangeInfo();
          var orient = coordSys.getOrient();

          this._renderDayRect(calendarModel, rangeData, group); // _renderLines must be called prior to following function


          this._renderLines(calendarModel, rangeData, orient, group);

          this._renderYearText(calendarModel, rangeData, orient, group);

          this._renderMonthText(calendarModel, orient, group);

          this._renderWeekText(calendarModel, rangeData, orient, group);
        },
        // render day rect
        _renderDayRect: function _renderDayRect(calendarModel, rangeData, group) {
          var coordSys = calendarModel.coordinateSystem;
          var itemRectStyleModel = calendarModel.getModel('itemStyle').getItemStyle();
          var sw = coordSys.getCellWidth();
          var sh = coordSys.getCellHeight();

          for (var i = rangeData.start.time; i <= rangeData.end.time; i = coordSys.getNextNDay(i, 1).time) {
            var point = coordSys.dataToRect([i], false).tl; // every rect

            var rect = new graphic.Rect({
              shape: {
                x: point[0],
                y: point[1],
                width: sw,
                height: sh
              },
              cursor: 'default',
              style: itemRectStyleModel
            });
            group.add(rect);
          }
        },
        // render separate line
        _renderLines: function _renderLines(calendarModel, rangeData, orient, group) {
          var self = this;
          var coordSys = calendarModel.coordinateSystem;
          var lineStyleModel = calendarModel.getModel('splitLine.lineStyle').getLineStyle();
          var show = calendarModel.get('splitLine.show');
          var lineWidth = lineStyleModel.lineWidth;
          this._tlpoints = [];
          this._blpoints = [];
          this._firstDayOfMonth = [];
          this._firstDayPoints = [];
          var firstDay = rangeData.start;

          for (var i = 0; firstDay.time <= rangeData.end.time; i++) {
            addPoints(firstDay.formatedDate);

            if (i === 0) {
              firstDay = coordSys.getDateInfo(rangeData.start.y + '-' + rangeData.start.m);
            }

            var date = firstDay.date;
            date.setMonth(date.getMonth() + 1);
            firstDay = coordSys.getDateInfo(date);
          }

          addPoints(coordSys.getNextNDay(rangeData.end.time, 1).formatedDate);

          function addPoints(date) {
            self._firstDayOfMonth.push(coordSys.getDateInfo(date));

            self._firstDayPoints.push(coordSys.dataToRect([date], false).tl);

            var points = self._getLinePointsOfOneWeek(calendarModel, date, orient);

            self._tlpoints.push(points[0]);

            self._blpoints.push(points[points.length - 1]);

            show && self._drawSplitline(points, lineStyleModel, group);
          } // render top/left line


          show && this._drawSplitline(self._getEdgesPoints(self._tlpoints, lineWidth, orient), lineStyleModel, group); // render bottom/right line

          show && this._drawSplitline(self._getEdgesPoints(self._blpoints, lineWidth, orient), lineStyleModel, group);
        },
        // get points at both ends
        _getEdgesPoints: function _getEdgesPoints(points, lineWidth, orient) {
          var rs = [points[0].slice(), points[points.length - 1].slice()];
          var idx = orient === 'horizontal' ? 0 : 1; // both ends of the line are extend half lineWidth

          rs[0][idx] = rs[0][idx] - lineWidth / 2;
          rs[1][idx] = rs[1][idx] + lineWidth / 2;
          return rs;
        },
        // render split line
        _drawSplitline: function _drawSplitline(points, lineStyleModel, group) {
          var poyline = new graphic.Polyline({
            z2: 20,
            shape: {
              points: points
            },
            style: lineStyleModel
          });
          group.add(poyline);
        },
        // render month line of one week points
        _getLinePointsOfOneWeek: function _getLinePointsOfOneWeek(calendarModel, date, orient) {
          var coordSys = calendarModel.coordinateSystem;
          date = coordSys.getDateInfo(date);
          var points = [];

          for (var i = 0; i < 7; i++) {
            var tmpD = coordSys.getNextNDay(date.time, i);
            var point = coordSys.dataToRect([tmpD.time], false);
            points[2 * tmpD.day] = point.tl;
            points[2 * tmpD.day + 1] = point[orient === 'horizontal' ? 'bl' : 'tr'];
          }

          return points;
        },
        _formatterLabel: function _formatterLabel(formatter, params) {
          if (typeof formatter === 'string' && formatter) {
            return formatUtil.formatTplSimple(formatter, params);
          }

          if (typeof formatter === 'function') {
            return formatter(params);
          }

          return params.nameMap;
        },
        _yearTextPositionControl: function _yearTextPositionControl(textEl, point, orient, position, margin) {
          point = point.slice();
          var aligns = ['center', 'bottom'];

          if (position === 'bottom') {
            point[1] += margin;
            aligns = ['center', 'top'];
          } else if (position === 'left') {
            point[0] -= margin;
          } else if (position === 'right') {
            point[0] += margin;
            aligns = ['center', 'top'];
          } else {
            // top
            point[1] -= margin;
          }

          var rotate = 0;

          if (position === 'left' || position === 'right') {
            rotate = Math.PI / 2;
          }

          return {
            rotation: rotate,
            position: point,
            style: {
              textAlign: aligns[0],
              textVerticalAlign: aligns[1]
            }
          };
        },
        // render year
        _renderYearText: function _renderYearText(calendarModel, rangeData, orient, group) {
          var yearLabel = calendarModel.getModel('yearLabel');

          if (!yearLabel.get('show')) {
            return;
          }

          var margin = yearLabel.get('margin');
          var pos = yearLabel.get('position');

          if (!pos) {
            pos = orient !== 'horizontal' ? 'top' : 'left';
          }

          var points = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]];
          var xc = (points[0][0] + points[1][0]) / 2;
          var yc = (points[0][1] + points[1][1]) / 2;
          var idx = orient === 'horizontal' ? 0 : 1;
          var posPoints = {
            top: [xc, points[idx][1]],
            bottom: [xc, points[1 - idx][1]],
            left: [points[1 - idx][0], yc],
            right: [points[idx][0], yc]
          };
          var name = rangeData.start.y;

          if (+rangeData.end.y > +rangeData.start.y) {
            name = name + '-' + rangeData.end.y;
          }

          var formatter = yearLabel.get('formatter');
          var params = {
            start: rangeData.start.y,
            end: rangeData.end.y,
            nameMap: name
          };

          var content = this._formatterLabel(formatter, params);

          var yearText = new graphic.Text({
            z2: 30
          });
          graphic.setTextStyle(yearText.style, yearLabel, {
            text: content
          }), yearText.attr(this._yearTextPositionControl(yearText, posPoints[pos], orient, pos, margin));
          group.add(yearText);
        },
        _monthTextPositionControl: function _monthTextPositionControl(point, isCenter, orient, position, margin) {
          var align = 'left';
          var vAlign = 'top';
          var x = point[0];
          var y = point[1];

          if (orient === 'horizontal') {
            y = y + margin;

            if (isCenter) {
              align = 'center';
            }

            if (position === 'start') {
              vAlign = 'bottom';
            }
          } else {
            x = x + margin;

            if (isCenter) {
              vAlign = 'middle';
            }

            if (position === 'start') {
              align = 'right';
            }
          }

          return {
            x: x,
            y: y,
            textAlign: align,
            textVerticalAlign: vAlign
          };
        },
        // render month and year text
        _renderMonthText: function _renderMonthText(calendarModel, orient, group) {
          var monthLabel = calendarModel.getModel('monthLabel');

          if (!monthLabel.get('show')) {
            return;
          }

          var nameMap = monthLabel.get('nameMap');
          var margin = monthLabel.get('margin');
          var pos = monthLabel.get('position');
          var align = monthLabel.get('align');
          var termPoints = [this._tlpoints, this._blpoints];

          if (zrUtil.isString(nameMap)) {
            nameMap = MONTH_TEXT[nameMap.toUpperCase()] || [];
          }

          var idx = pos === 'start' ? 0 : 1;
          var axis = orient === 'horizontal' ? 0 : 1;
          margin = pos === 'start' ? -margin : margin;
          var isCenter = align === 'center';

          for (var i = 0; i < termPoints[idx].length - 1; i++) {
            var tmp = termPoints[idx][i].slice();
            var firstDay = this._firstDayOfMonth[i];

            if (isCenter) {
              var firstDayPoints = this._firstDayPoints[i];
              tmp[axis] = (firstDayPoints[axis] + termPoints[0][i + 1][axis]) / 2;
            }

            var formatter = monthLabel.get('formatter');
            var name = nameMap[+firstDay.m - 1];
            var params = {
              yyyy: firstDay.y,
              yy: (firstDay.y + '').slice(2),
              MM: firstDay.m,
              M: +firstDay.m,
              nameMap: name
            };

            var content = this._formatterLabel(formatter, params);

            var monthText = new graphic.Text({
              z2: 30
            });
            zrUtil.extend(graphic.setTextStyle(monthText.style, monthLabel, {
              text: content
            }), this._monthTextPositionControl(tmp, isCenter, orient, pos, margin));
            group.add(monthText);
          }
        },
        _weekTextPositionControl: function _weekTextPositionControl(point, orient, position, margin, cellSize) {
          var align = 'center';
          var vAlign = 'middle';
          var x = point[0];
          var y = point[1];
          var isStart = position === 'start';

          if (orient === 'horizontal') {
            x = x + margin + (isStart ? 1 : -1) * cellSize[0] / 2;
            align = isStart ? 'right' : 'left';
          } else {
            y = y + margin + (isStart ? 1 : -1) * cellSize[1] / 2;
            vAlign = isStart ? 'bottom' : 'top';
          }

          return {
            x: x,
            y: y,
            textAlign: align,
            textVerticalAlign: vAlign
          };
        },
        // render weeks
        _renderWeekText: function _renderWeekText(calendarModel, rangeData, orient, group) {
          var dayLabel = calendarModel.getModel('dayLabel');

          if (!dayLabel.get('show')) {
            return;
          }

          var coordSys = calendarModel.coordinateSystem;
          var pos = dayLabel.get('position');
          var nameMap = dayLabel.get('nameMap');
          var margin = dayLabel.get('margin');
          var firstDayOfWeek = coordSys.getFirstDayOfWeek();

          if (zrUtil.isString(nameMap)) {
            nameMap = WEEK_TEXT[nameMap.toUpperCase()] || [];
          }

          var start = coordSys.getNextNDay(rangeData.end.time, 7 - rangeData.lweek).time;
          var cellSize = [coordSys.getCellWidth(), coordSys.getCellHeight()];
          margin = numberUtil.parsePercent(margin, cellSize[orient === 'horizontal' ? 0 : 1]);

          if (pos === 'start') {
            start = coordSys.getNextNDay(rangeData.start.time, -(7 + rangeData.fweek)).time;
            margin = -margin;
          }

          for (var i = 0; i < 7; i++) {
            var tmpD = coordSys.getNextNDay(start, i);
            var point = coordSys.dataToRect([tmpD.time], false).center;
            var day = i;
            day = Math.abs((i + firstDayOfWeek) % 7);
            var weekText = new graphic.Text({
              z2: 30
            });
            zrUtil.extend(graphic.setTextStyle(weekText.style, dayLabel, {
              text: nameMap[day]
            }), this._weekTextPositionControl(point, orient, pos, margin, cellSize));
            group.add(weekText);
          }
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "7pVf":
    /*!********************************************************!*\
      !*** ./node_modules/echarts/lib/component/timeline.js ***!
      \********************************************************/

    /*! no static exports found */

    /***/
    function pVf(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      var preprocessor = __webpack_require__(
      /*! ./timeline/preprocessor */
      "ZqQs");

      __webpack_require__(
      /*! ./timeline/typeDefaulter */
      "oE7X");

      __webpack_require__(
      /*! ./timeline/timelineAction */
      "OUJF");

      __webpack_require__(
      /*! ./timeline/SliderTimelineModel */
      "3X6L");

      __webpack_require__(
      /*! ./timeline/SliderTimelineView */
      "NH9N");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * DataZoom component entry
       */


      echarts.registerPreprocessor(preprocessor);
      /***/
    },

    /***/
    "7ph2":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/lines/linesVisual.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function ph2(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      function normalize(a) {
        if (!(a instanceof Array)) {
          a = [a, a];
        }

        return a;
      }

      var opacityQuery = 'lineStyle.opacity'.split('.');
      var _default = {
        seriesType: 'lines',
        reset: function reset(seriesModel, ecModel, api) {
          var symbolType = normalize(seriesModel.get('symbol'));
          var symbolSize = normalize(seriesModel.get('symbolSize'));
          var data = seriesModel.getData();
          data.setVisual('fromSymbol', symbolType && symbolType[0]);
          data.setVisual('toSymbol', symbolType && symbolType[1]);
          data.setVisual('fromSymbolSize', symbolSize && symbolSize[0]);
          data.setVisual('toSymbolSize', symbolSize && symbolSize[1]);
          data.setVisual('opacity', seriesModel.get(opacityQuery));

          function dataEach(data, idx) {
            var itemModel = data.getItemModel(idx);
            var symbolType = normalize(itemModel.getShallow('symbol', true));
            var symbolSize = normalize(itemModel.getShallow('symbolSize', true));
            var opacity = itemModel.get(opacityQuery);
            symbolType[0] && data.setItemVisual(idx, 'fromSymbol', symbolType[0]);
            symbolType[1] && data.setItemVisual(idx, 'toSymbol', symbolType[1]);
            symbolSize[0] && data.setItemVisual(idx, 'fromSymbolSize', symbolSize[0]);
            symbolSize[1] && data.setItemVisual(idx, 'toSymbolSize', symbolSize[1]);
            data.setItemVisual(idx, 'opacity', opacity);
          }

          return {
            dataEach: data.hasItemOption ? dataEach : null
          };
        }
      };
      module.exports = _default;
      /***/
    },

    /***/
    "7uqq":
    /*!**********************************************************!*\
      !*** ./node_modules/echarts/lib/coord/geo/geoCreator.js ***!
      \**********************************************************/

    /*! no static exports found */

    /***/
    function uqq(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var Geo = __webpack_require__(
      /*! ./Geo */
      "AUH6");

      var layout = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var numberUtil = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var geoSourceManager = __webpack_require__(
      /*! ./geoSourceManager */
      "W4dC");

      var mapDataStorage = __webpack_require__(
      /*! ./mapDataStorage */
      "7DRL");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Resize method bound to the geo
       * @param {module:echarts/coord/geo/GeoModel|module:echarts/chart/map/MapModel} geoModel
       * @param {module:echarts/ExtensionAPI} api
       */


      function resizeGeo(geoModel, api) {
        var boundingCoords = geoModel.get('boundingCoords');

        if (boundingCoords != null) {
          var leftTop = boundingCoords[0];
          var rightBottom = boundingCoords[1];

          if (isNaN(leftTop[0]) || isNaN(leftTop[1]) || isNaN(rightBottom[0]) || isNaN(rightBottom[1])) {} else {
            this.setBoundingRect(leftTop[0], leftTop[1], rightBottom[0] - leftTop[0], rightBottom[1] - leftTop[1]);
          }
        }

        var rect = this.getBoundingRect();
        var boxLayoutOption;
        var center = geoModel.get('layoutCenter');
        var size = geoModel.get('layoutSize');
        var viewWidth = api.getWidth();
        var viewHeight = api.getHeight();
        var aspect = rect.width / rect.height * this.aspectScale;
        var useCenterAndSize = false;

        if (center && size) {
          center = [numberUtil.parsePercent(center[0], viewWidth), numberUtil.parsePercent(center[1], viewHeight)];
          size = numberUtil.parsePercent(size, Math.min(viewWidth, viewHeight));

          if (!isNaN(center[0]) && !isNaN(center[1]) && !isNaN(size)) {
            useCenterAndSize = true;
          } else {}
        }

        var viewRect;

        if (useCenterAndSize) {
          var viewRect = {};

          if (aspect > 1) {
            // Width is same with size
            viewRect.width = size;
            viewRect.height = size / aspect;
          } else {
            viewRect.height = size;
            viewRect.width = size * aspect;
          }

          viewRect.y = center[1] - viewRect.height / 2;
          viewRect.x = center[0] - viewRect.width / 2;
        } else {
          // Use left/top/width/height
          boxLayoutOption = geoModel.getBoxLayoutParams(); // 0.75 rate

          boxLayoutOption.aspect = aspect;
          viewRect = layout.getLayoutRect(boxLayoutOption, {
            width: viewWidth,
            height: viewHeight
          });
        }

        this.setViewRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);
        this.setCenter(geoModel.get('center'));
        this.setZoom(geoModel.get('zoom'));
      }
      /**
       * @param {module:echarts/coord/Geo} geo
       * @param {module:echarts/model/Model} model
       * @inner
       */


      function setGeoCoords(geo, model) {
        zrUtil.each(model.get('geoCoord'), function (geoCoord, name) {
          geo.addGeoCoord(name, geoCoord);
        });
      }

      var geoCreator = {
        // For deciding which dimensions to use when creating list data
        dimensions: Geo.prototype.dimensions,
        create: function create(ecModel, api) {
          var geoList = []; // FIXME Create each time may be slow

          ecModel.eachComponent('geo', function (geoModel, idx) {
            var name = geoModel.get('map');
            var aspectScale = geoModel.get('aspectScale');
            var invertLongitute = true;
            var mapRecords = mapDataStorage.retrieveMap(name);

            if (mapRecords && mapRecords[0] && mapRecords[0].type === 'svg') {
              aspectScale == null && (aspectScale = 1);
              invertLongitute = false;
            } else {
              aspectScale == null && (aspectScale = 0.75);
            }

            var geo = new Geo(name + idx, name, geoModel.get('nameMap'), invertLongitute);
            geo.aspectScale = aspectScale;
            geo.zoomLimit = geoModel.get('scaleLimit');
            geoList.push(geo);
            setGeoCoords(geo, geoModel);
            geoModel.coordinateSystem = geo;
            geo.model = geoModel; // Inject resize method

            geo.resize = resizeGeo;
            geo.resize(geoModel, api);
          });
          ecModel.eachSeries(function (seriesModel) {
            var coordSys = seriesModel.get('coordinateSystem');

            if (coordSys === 'geo') {
              var geoIndex = seriesModel.get('geoIndex') || 0;
              seriesModel.coordinateSystem = geoList[geoIndex];
            }
          }); // If has map series

          var mapModelGroupBySeries = {};
          ecModel.eachSeriesByType('map', function (seriesModel) {
            if (!seriesModel.getHostGeoModel()) {
              var mapType = seriesModel.getMapType();
              mapModelGroupBySeries[mapType] = mapModelGroupBySeries[mapType] || [];
              mapModelGroupBySeries[mapType].push(seriesModel);
            }
          });
          zrUtil.each(mapModelGroupBySeries, function (mapSeries, mapType) {
            var nameMapList = zrUtil.map(mapSeries, function (singleMapSeries) {
              return singleMapSeries.get('nameMap');
            });
            var geo = new Geo(mapType, mapType, zrUtil.mergeAll(nameMapList));
            geo.zoomLimit = zrUtil.retrieve.apply(null, zrUtil.map(mapSeries, function (singleMapSeries) {
              return singleMapSeries.get('scaleLimit');
            }));
            geoList.push(geo); // Inject resize method

            geo.resize = resizeGeo;
            geo.aspectScale = mapSeries[0].get('aspectScale');
            geo.resize(mapSeries[0], api);
            zrUtil.each(mapSeries, function (singleMapSeries) {
              singleMapSeries.coordinateSystem = geo;
              setGeoCoords(geo, singleMapSeries);
            });
          });
          return geoList;
        },

        /**
         * Fill given regions array
         * @param  {Array.<Object>} originRegionArr
         * @param  {string} mapName
         * @param  {Object} [nameMap]
         * @return {Array}
         */
        getFilledRegions: function getFilledRegions(originRegionArr, mapName, nameMap) {
          // Not use the original
          var regionsArr = (originRegionArr || []).slice();
          var dataNameMap = zrUtil.createHashMap();

          for (var i = 0; i < regionsArr.length; i++) {
            dataNameMap.set(regionsArr[i].name, regionsArr[i]);
          }

          var source = geoSourceManager.load(mapName, nameMap);
          zrUtil.each(source.regions, function (region) {
            var name = region.name;
            !dataNameMap.get(name) && regionsArr.push({
              name: name
            });
          });
          return regionsArr;
        }
      };
      echarts.registerCoordinateSystem('geo', geoCreator);
      var _default = geoCreator;
      module.exports = _default;
      /***/
    },

    /***/
    "7yuC":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/graph/forceHelper.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function yuC(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var vec2 = __webpack_require__(
      /*! zrender/lib/core/vector */
      "QBsz");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * A third-party license is embeded for some of the code in this file:
      * Some formulas were originally copied from "d3.js" with some
      * modifications made for this project.
      * (See more details in the comment of the method "step" below.)
      * The use of the source code of this file is also subject to the terms
      * and consitions of the license of "d3.js" (BSD-3Clause, see
      * </licenses/LICENSE-d3>).
      */


      var scaleAndAdd = vec2.scaleAndAdd; // function adjacentNode(n, e) {
      //     return e.n1 === n ? e.n2 : e.n1;
      // }

      function forceLayout(nodes, edges, opts) {
        var rect = opts.rect;
        var width = rect.width;
        var height = rect.height;
        var center = [rect.x + width / 2, rect.y + height / 2]; // var scale = opts.scale || 1;

        var gravity = opts.gravity == null ? 0.1 : opts.gravity; // for (var i = 0; i < edges.length; i++) {
        //     var e = edges[i];
        //     var n1 = e.n1;
        //     var n2 = e.n2;
        //     n1.edges = n1.edges || [];
        //     n2.edges = n2.edges || [];
        //     n1.edges.push(e);
        //     n2.edges.push(e);
        // }
        // Init position

        for (var i = 0; i < nodes.length; i++) {
          var n = nodes[i];

          if (!n.p) {
            n.p = vec2.create(width * (Math.random() - 0.5) + center[0], height * (Math.random() - 0.5) + center[1]);
          }

          n.pp = vec2.clone(n.p);
          n.edges = null;
        } // Formula in 'Graph Drawing by Force-directed Placement'
        // var k = scale * Math.sqrt(width * height / nodes.length);
        // var k2 = k * k;


        var initialFriction = opts.friction == null ? 0.6 : opts.friction;
        var friction = initialFriction;
        return {
          warmUp: function warmUp() {
            friction = initialFriction * 0.8;
          },
          setFixed: function setFixed(idx) {
            nodes[idx].fixed = true;
          },
          setUnfixed: function setUnfixed(idx) {
            nodes[idx].fixed = false;
          },

          /**
           * Some formulas were originally copied from "d3.js"
           * https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/layout/force.js
           * with some modifications made for this project.
           * See the license statement at the head of this file.
           */
          step: function step(cb) {
            var v12 = [];
            var nLen = nodes.length;

            for (var i = 0; i < edges.length; i++) {
              var e = edges[i];

              if (e.ignoreForceLayout) {
                continue;
              }

              var n1 = e.n1;
              var n2 = e.n2;
              vec2.sub(v12, n2.p, n1.p);
              var d = vec2.len(v12) - e.d;
              var w = n2.w / (n1.w + n2.w);

              if (isNaN(w)) {
                w = 0;
              }

              vec2.normalize(v12, v12);
              !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);
              !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);
            } // Gravity


            for (var i = 0; i < nLen; i++) {
              var n = nodes[i];

              if (!n.fixed) {
                vec2.sub(v12, center, n.p); // var d = vec2.len(v12);
                // vec2.scale(v12, v12, 1 / d);
                // var gravityFactor = gravity;

                scaleAndAdd(n.p, n.p, v12, gravity * friction);
              }
            } // Repulsive
            // PENDING


            for (var i = 0; i < nLen; i++) {
              var n1 = nodes[i];

              for (var j = i + 1; j < nLen; j++) {
                var n2 = nodes[j];
                vec2.sub(v12, n2.p, n1.p);
                var d = vec2.len(v12);

                if (d === 0) {
                  // Random repulse
                  vec2.set(v12, Math.random() - 0.5, Math.random() - 0.5);
                  d = 1;
                }

                var repFact = (n1.rep + n2.rep) / d / d;
                !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);
                !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);
              }
            }

            var v = [];

            for (var i = 0; i < nLen; i++) {
              var n = nodes[i];

              if (!n.fixed) {
                vec2.sub(v, n.p, n.pp);
                scaleAndAdd(n.p, n.p, v, friction);
                vec2.copy(n.pp, n.p);
              }
            }

            friction = friction * 0.992;
            cb && cb(nodes, edges, friction < 0.01);
          }
        };
      }

      exports.forceLayout = forceLayout;
      /***/
    },

    /***/
    "8SMY":
    /*!******************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/line/lineAnimationDiff.js ***!
      \******************************************************************/

    /*! no static exports found */

    /***/
    function SMY(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _helper = __webpack_require__(
      /*! ./helper */
      "n4Lv");

      var prepareDataCoordInfo = _helper.prepareDataCoordInfo;
      var getStackedOnPoint = _helper.getStackedOnPoint;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // var arrayDiff = require('zrender/src/core/arrayDiff');
      // 'zrender/src/core/arrayDiff' has been used before, but it did
      // not do well in performance when roam with fixed dataZoom window.
      // function convertToIntId(newIdList, oldIdList) {
      //     // Generate int id instead of string id.
      //     // Compare string maybe slow in score function of arrDiff
      //     // Assume id in idList are all unique
      //     var idIndicesMap = {};
      //     var idx = 0;
      //     for (var i = 0; i < newIdList.length; i++) {
      //         idIndicesMap[newIdList[i]] = idx;
      //         newIdList[i] = idx++;
      //     }
      //     for (var i = 0; i < oldIdList.length; i++) {
      //         var oldId = oldIdList[i];
      //         // Same with newIdList
      //         if (idIndicesMap[oldId]) {
      //             oldIdList[i] = idIndicesMap[oldId];
      //         }
      //         else {
      //             oldIdList[i] = idx++;
      //         }
      //     }
      // }

      function diffData(oldData, newData) {
        var diffResult = [];
        newData.diff(oldData).add(function (idx) {
          diffResult.push({
            cmd: '+',
            idx: idx
          });
        }).update(function (newIdx, oldIdx) {
          diffResult.push({
            cmd: '=',
            idx: oldIdx,
            idx1: newIdx
          });
        }).remove(function (idx) {
          diffResult.push({
            cmd: '-',
            idx: idx
          });
        }).execute();
        return diffResult;
      }

      function _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
        var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);
        // var oldIdList = oldData.mapArray(oldData.getId);
        // convertToIntId(newIdList, oldIdList);
        // // FIXME One data ?
        // diff = arrayDiff(oldIdList, newIdList);

        var currPoints = [];
        var nextPoints = []; // Points for stacking base line

        var currStackedPoints = [];
        var nextStackedPoints = [];
        var status = [];
        var sortedIndices = [];
        var rawIndices = [];
        var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);
        var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);

        for (var i = 0; i < diff.length; i++) {
          var diffItem = diff[i];
          var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast
          // Which is in case remvoing or add more than one data in the tail or head

          switch (diffItem.cmd) {
            case '=':
              var currentPt = oldData.getItemLayout(diffItem.idx);
              var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly

              if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {
                currentPt = nextPt.slice();
              }

              currPoints.push(currentPt);
              nextPoints.push(nextPt);
              currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);
              nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);
              rawIndices.push(newData.getRawIndex(diffItem.idx1));
              break;

            case '+':
              var idx = diffItem.idx;
              currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));
              nextPoints.push(newData.getItemLayout(idx).slice());
              currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));
              nextStackedPoints.push(newStackedOnPoints[idx]);
              rawIndices.push(newData.getRawIndex(idx));
              break;

            case '-':
              var idx = diffItem.idx;
              var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue
              // FIXME FIXME FIXME

              if (rawIndex !== idx) {
                currPoints.push(oldData.getItemLayout(idx));
                nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));
                currStackedPoints.push(oldStackedOnPoints[idx]);
                nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));
                rawIndices.push(rawIndex);
              } else {
                pointAdded = false;
              }

          } // Original indices


          if (pointAdded) {
            status.push(diffItem);
            sortedIndices.push(sortedIndices.length);
          }
        } // Diff result may be crossed if all items are changed
        // Sort by data index


        sortedIndices.sort(function (a, b) {
          return rawIndices[a] - rawIndices[b];
        });
        var sortedCurrPoints = [];
        var sortedNextPoints = [];
        var sortedCurrStackedPoints = [];
        var sortedNextStackedPoints = [];
        var sortedStatus = [];

        for (var i = 0; i < sortedIndices.length; i++) {
          var idx = sortedIndices[i];
          sortedCurrPoints[i] = currPoints[idx];
          sortedNextPoints[i] = nextPoints[idx];
          sortedCurrStackedPoints[i] = currStackedPoints[idx];
          sortedNextStackedPoints[i] = nextStackedPoints[idx];
          sortedStatus[i] = status[idx];
        }

        return {
          current: sortedCurrPoints,
          next: sortedNextPoints,
          stackedOnCurrent: sortedCurrStackedPoints,
          stackedOnNext: sortedNextStackedPoints,
          status: sortedStatus
        };
      }

      module.exports = _default;
      /***/
    },

    /***/
    "8Th4":
    /*!*****************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/axisPointer/SingleAxisPointer.js ***!
      \*****************************************************************************/

    /*! no static exports found */

    /***/
    function Th4(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var BaseAxisPointer = __webpack_require__(
      /*! ./BaseAxisPointer */
      "3LNs");

      var viewHelper = __webpack_require__(
      /*! ./viewHelper */
      "/y7N");

      var singleAxisHelper = __webpack_require__(
      /*! ../../coord/single/singleAxisHelper */
      "7bkD");

      var AxisView = __webpack_require__(
      /*! ../axis/AxisView */
      "Znkb");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var XY = ['x', 'y'];
      var WH = ['width', 'height'];
      var SingleAxisPointer = BaseAxisPointer.extend({
        /**
         * @override
         */
        makeElOption: function makeElOption(elOption, value, axisModel, axisPointerModel, api) {
          var axis = axisModel.axis;
          var coordSys = axis.coordinateSystem;
          var otherExtent = getGlobalExtent(coordSys, 1 - getPointDimIndex(axis));
          var pixelValue = coordSys.dataToPoint(value)[0];
          var axisPointerType = axisPointerModel.get('type');

          if (axisPointerType && axisPointerType !== 'none') {
            var elStyle = viewHelper.buildElStyle(axisPointerModel);
            var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
            pointerOption.style = elStyle;
            elOption.graphicKey = pointerOption.type;
            elOption.pointer = pointerOption;
          }

          var layoutInfo = singleAxisHelper.layout(axisModel);
          viewHelper.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
        },

        /**
         * @override
         */
        getHandleTransform: function getHandleTransform(value, axisModel, axisPointerModel) {
          var layoutInfo = singleAxisHelper.layout(axisModel, {
            labelInside: false
          });
          layoutInfo.labelMargin = axisPointerModel.get('handle.margin');
          return {
            position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),
            rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
          };
        },

        /**
         * @override
         */
        updateHandleTransform: function updateHandleTransform(transform, delta, axisModel, axisPointerModel) {
          var axis = axisModel.axis;
          var coordSys = axis.coordinateSystem;
          var dimIndex = getPointDimIndex(axis);
          var axisExtent = getGlobalExtent(coordSys, dimIndex);
          var currPosition = transform.position;
          currPosition[dimIndex] += delta[dimIndex];
          currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
          currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
          var otherExtent = getGlobalExtent(coordSys, 1 - dimIndex);
          var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
          var cursorPoint = [cursorOtherValue, cursorOtherValue];
          cursorPoint[dimIndex] = currPosition[dimIndex];
          return {
            position: currPosition,
            rotation: transform.rotation,
            cursorPoint: cursorPoint,
            tooltipOption: {
              verticalAlign: 'middle'
            }
          };
        }
      });
      var pointerShapeBuilder = {
        line: function line(axis, pixelValue, otherExtent) {
          var targetShape = viewHelper.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getPointDimIndex(axis));
          return {
            type: 'Line',
            subPixelOptimize: true,
            shape: targetShape
          };
        },
        shadow: function shadow(axis, pixelValue, otherExtent) {
          var bandWidth = axis.getBandWidth();
          var span = otherExtent[1] - otherExtent[0];
          return {
            type: 'Rect',
            shape: viewHelper.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getPointDimIndex(axis))
          };
        }
      };

      function getPointDimIndex(axis) {
        return axis.isHorizontal() ? 0 : 1;
      }

      function getGlobalExtent(coordSys, dimIndex) {
        var rect = coordSys.getRect();
        return [rect[XY[dimIndex]], rect[XY[dimIndex]] + rect[WH[dimIndex]]];
      }

      AxisView.registerAxisPointerClass('SingleAxisPointer', SingleAxisPointer);
      var _default = SingleAxisPointer;
      module.exports = _default;
      /***/
    },

    /***/
    "8Uz6":
    /*!****************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/legend/ScrollableLegendModel.js ***!
      \****************************************************************************/

    /*! no static exports found */

    /***/
    function Uz6(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var LegendModel = __webpack_require__(
      /*! ./LegendModel */
      "hNWo");

      var _layout = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var mergeLayoutParam = _layout.mergeLayoutParam;
      var getLayoutParams = _layout.getLayoutParams;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var ScrollableLegendModel = LegendModel.extend({
        type: 'legend.scroll',

        /**
         * @param {number} scrollDataIndex
         */
        setScrollDataIndex: function setScrollDataIndex(scrollDataIndex) {
          this.option.scrollDataIndex = scrollDataIndex;
        },
        defaultOption: {
          scrollDataIndex: 0,
          pageButtonItemGap: 5,
          pageButtonGap: null,
          pageButtonPosition: 'end',
          // 'start' or 'end'
          pageFormatter: '{current}/{total}',
          // If null/undefined, do not show page.
          pageIcons: {
            horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'],
            vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z']
          },
          pageIconColor: '#2f4554',
          pageIconInactiveColor: '#aaa',
          pageIconSize: 15,
          // Can be [10, 3], which represents [width, height]
          pageTextStyle: {
            color: '#333'
          },
          animationDurationUpdate: 800
        },

        /**
         * @override
         */
        init: function init(option, parentModel, ecModel, extraOpt) {
          var inputPositionParams = getLayoutParams(option);
          ScrollableLegendModel.superCall(this, 'init', option, parentModel, ecModel, extraOpt);
          mergeAndNormalizeLayoutParams(this, option, inputPositionParams);
        },

        /**
         * @override
         */
        mergeOption: function mergeOption(option, extraOpt) {
          ScrollableLegendModel.superCall(this, 'mergeOption', option, extraOpt);
          mergeAndNormalizeLayoutParams(this, this.option, option);
        }
      }); // Do not `ignoreSize` to enable setting {left: 10, right: 10}.

      function mergeAndNormalizeLayoutParams(legendModel, target, raw) {
        var orient = legendModel.getOrient();
        var ignoreSize = [1, 1];
        ignoreSize[orient.index] = 0;
        mergeLayoutParam(target, raw, {
          type: 'box',
          ignoreSize: ignoreSize
        });
      }

      var _default = ScrollableLegendModel;
      module.exports = _default;
      /***/
    },

    /***/
    "8X+K":
    /*!*********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/line/LineView.js ***!
      \*********************************************************/

    /*! no static exports found */

    /***/
    function XK(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _bbox = __webpack_require__(
      /*! zrender/lib/core/bbox */
      "4mN7");

      var fromPoints = _bbox.fromPoints;

      var SymbolDraw = __webpack_require__(
      /*! ../helper/SymbolDraw */
      "9wZj");

      var SymbolClz = __webpack_require__(
      /*! ../helper/Symbol */
      "FBjb");

      var lineAnimationDiff = __webpack_require__(
      /*! ./lineAnimationDiff */
      "8SMY");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var modelUtil = __webpack_require__(
      /*! ../../util/model */
      "4NO4");

      var _poly = __webpack_require__(
      /*! ./poly */
      "1NG9");

      var Polyline = _poly.Polyline;
      var Polygon = _poly.Polygon;

      var ChartView = __webpack_require__(
      /*! ../../view/Chart */
      "6Ic6");

      var _helper = __webpack_require__(
      /*! ./helper */
      "n4Lv");

      var prepareDataCoordInfo = _helper.prepareDataCoordInfo;
      var getStackedOnPoint = _helper.getStackedOnPoint;

      var _createClipPathFromCoordSys = __webpack_require__(
      /*! ../helper/createClipPathFromCoordSys */
      "sK/D");

      var createGridClipPath = _createClipPathFromCoordSys.createGridClipPath;
      var createPolarClipPath = _createClipPathFromCoordSys.createPolarClipPath;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // FIXME step not support polar

      function isPointsSame(points1, points2) {
        if (points1.length !== points2.length) {
          return;
        }

        for (var i = 0; i < points1.length; i++) {
          var p1 = points1[i];
          var p2 = points2[i];

          if (p1[0] !== p2[0] || p1[1] !== p2[1]) {
            return;
          }
        }

        return true;
      }

      function getBoundingDiff(points1, points2) {
        var min1 = [];
        var max1 = [];
        var min2 = [];
        var max2 = [];
        fromPoints(points1, min1, max1);
        fromPoints(points2, min2, max2); // Get a max value from each corner of two boundings.

        return Math.max(Math.abs(min1[0] - min2[0]), Math.abs(min1[1] - min2[1]), Math.abs(max1[0] - max2[0]), Math.abs(max1[1] - max2[1]));
      }

      function getSmooth(smooth) {
        return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;
      }
      /**
       * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys
       * @param {module:echarts/data/List} data
       * @param {Object} dataCoordInfo
       * @param {Array.<Array.<number>>} points
       */


      function getStackedOnPoints(coordSys, data, dataCoordInfo) {
        if (!dataCoordInfo.valueDim) {
          return [];
        }

        var points = [];

        for (var idx = 0, len = data.count(); idx < len; idx++) {
          points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));
        }

        return points;
      }

      function turnPointsIntoStep(points, coordSys, stepTurnAt) {
        var baseAxis = coordSys.getBaseAxis();
        var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;
        var stepPoints = [];

        for (var i = 0; i < points.length - 1; i++) {
          var nextPt = points[i + 1];
          var pt = points[i];
          stepPoints.push(pt);
          var stepPt = [];

          switch (stepTurnAt) {
            case 'end':
              stepPt[baseIndex] = nextPt[baseIndex];
              stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start

              stepPoints.push(stepPt);
              break;

            case 'middle':
              // default is start
              var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
              var stepPt2 = [];
              stepPt[baseIndex] = stepPt2[baseIndex] = middle;
              stepPt[1 - baseIndex] = pt[1 - baseIndex];
              stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
              stepPoints.push(stepPt);
              stepPoints.push(stepPt2);
              break;

            default:
              stepPt[baseIndex] = pt[baseIndex];
              stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start

              stepPoints.push(stepPt);
          }
        } // Last points


        points[i] && stepPoints.push(points[i]);
        return stepPoints;
      }

      function getVisualGradient(data, coordSys) {
        var visualMetaList = data.getVisual('visualMeta');

        if (!visualMetaList || !visualMetaList.length || !data.count()) {
          // When data.count() is 0, gradient range can not be calculated.
          return;
        }

        if (coordSys.type !== 'cartesian2d') {
          return;
        }

        var coordDim;
        var visualMeta;

        for (var i = visualMetaList.length - 1; i >= 0; i--) {
          var dimIndex = visualMetaList[i].dimension;
          var dimName = data.dimensions[dimIndex];
          var dimInfo = data.getDimensionInfo(dimName);
          coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y

          if (coordDim === 'x' || coordDim === 'y') {
            visualMeta = visualMetaList[i];
            break;
          }
        }

        if (!visualMeta) {
          return;
        } // If the area to be rendered is bigger than area defined by LinearGradient,
        // the canvas spec prescribes that the color of the first stop and the last
        // stop should be used. But if two stops are added at offset 0, in effect
        // browsers use the color of the second stop to render area outside
        // LinearGradient. So we can only infinitesimally extend area defined in
        // LinearGradient to render `outerColors`.


        var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.

        var colorStops = zrUtil.map(visualMeta.stops, function (stop) {
          return {
            coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),
            color: stop.color
          };
        });
        var stopLen = colorStops.length;
        var outerColors = visualMeta.outerColors.slice();

        if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
          colorStops.reverse();
          outerColors.reverse();
        }

        var tinyExtent = 10; // Arbitrary value: 10px

        var minCoord = colorStops[0].coord - tinyExtent;
        var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;
        var coordSpan = maxCoord - minCoord;

        if (coordSpan < 1e-3) {
          return 'transparent';
        }

        zrUtil.each(colorStops, function (stop) {
          stop.offset = (stop.coord - minCoord) / coordSpan;
        });
        colorStops.push({
          offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,
          color: outerColors[1] || 'transparent'
        });
        colorStops.unshift({
          // notice colorStops.length have been changed.
          offset: stopLen ? colorStops[0].offset : 0.5,
          color: outerColors[0] || 'transparent'
        }); // zrUtil.each(colorStops, function (colorStop) {
        //     // Make sure each offset has rounded px to avoid not sharp edge
        //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);
        // });

        var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);
        gradient[coordDim] = minCoord;
        gradient[coordDim + '2'] = maxCoord;
        return gradient;
      }

      function getIsIgnoreFunc(seriesModel, data, coordSys) {
        var showAllSymbol = seriesModel.get('showAllSymbol');
        var isAuto = showAllSymbol === 'auto';

        if (showAllSymbol && !isAuto) {
          return;
        }

        var categoryAxis = coordSys.getAxesByScale('ordinal')[0];

        if (!categoryAxis) {
          return;
        } // Note that category label interval strategy might bring some weird effect
        // in some scenario: users may wonder why some of the symbols are not
        // displayed. So we show all symbols as possible as we can.


        if (isAuto // Simplify the logic, do not determine label overlap here.
        && canShowAllSymbolForCategory(categoryAxis, data)) {
          return;
        } // Otherwise follow the label interval strategy on category axis.


        var categoryDataDim = data.mapDimension(categoryAxis.dim);
        var labelMap = {};
        zrUtil.each(categoryAxis.getViewLabels(), function (labelItem) {
          labelMap[labelItem.tickValue] = 1;
        });
        return function (dataIndex) {
          return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
        };
      }

      function canShowAllSymbolForCategory(categoryAxis, data) {
        // In mose cases, line is monotonous on category axis, and the label size
        // is close with each other. So we check the symbol size and some of the
        // label size alone with the category axis to estimate whether all symbol
        // can be shown without overlap.
        var axisExtent = categoryAxis.getExtent();
        var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count();
        isNaN(availSize) && (availSize = 0); // 0/0 is NaN.
        // Sampling some points, max 5.

        var dataLen = data.count();
        var step = Math.max(1, Math.round(dataLen / 5));

        for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {
          if (SymbolClz.getSymbolSize(data, dataIndex // Only for cartesian, where `isHorizontal` exists.
          )[categoryAxis.isHorizontal() ? 1 : 0] // Empirical number
          * 1.5 > availSize) {
            return false;
          }
        }

        return true;
      }

      function createLineClipPath(coordSys, hasAnimation, seriesModel) {
        if (coordSys.type === 'cartesian2d') {
          var isHorizontal = coordSys.getBaseAxis().isHorizontal();
          var clipPath = createGridClipPath(coordSys, hasAnimation, seriesModel); // Expand clip shape to avoid clipping when line value exceeds axis

          if (!seriesModel.get('clip', true)) {
            var rectShape = clipPath.shape;
            var expandSize = Math.max(rectShape.width, rectShape.height);

            if (isHorizontal) {
              rectShape.y -= expandSize;
              rectShape.height += expandSize * 2;
            } else {
              rectShape.x -= expandSize;
              rectShape.width += expandSize * 2;
            }
          }

          return clipPath;
        } else {
          return createPolarClipPath(coordSys, hasAnimation, seriesModel);
        }
      }

      var _default = ChartView.extend({
        type: 'line',
        init: function init() {
          var lineGroup = new graphic.Group();
          var symbolDraw = new SymbolDraw();
          this.group.add(symbolDraw.group);
          this._symbolDraw = symbolDraw;
          this._lineGroup = lineGroup;
        },
        render: function render(seriesModel, ecModel, api) {
          var coordSys = seriesModel.coordinateSystem;
          var group = this.group;
          var data = seriesModel.getData();
          var lineStyleModel = seriesModel.getModel('lineStyle');
          var areaStyleModel = seriesModel.getModel('areaStyle');
          var points = data.mapArray(data.getItemLayout);
          var isCoordSysPolar = coordSys.type === 'polar';
          var prevCoordSys = this._coordSys;
          var symbolDraw = this._symbolDraw;
          var polyline = this._polyline;
          var polygon = this._polygon;
          var lineGroup = this._lineGroup;
          var hasAnimation = seriesModel.get('animation');
          var isAreaChart = !areaStyleModel.isEmpty();
          var valueOrigin = areaStyleModel.get('origin');
          var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);
          var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);
          var showSymbol = seriesModel.get('showSymbol');
          var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys); // Remove temporary symbols

          var oldData = this._data;
          oldData && oldData.eachItemGraphicEl(function (el, idx) {
            if (el.__temp) {
              group.remove(el);
              oldData.setItemGraphicEl(idx, null);
            }
          }); // Remove previous created symbols if showSymbol changed to false

          if (!showSymbol) {
            symbolDraw.remove();
          }

          group.add(lineGroup); // FIXME step not support polar

          var step = !isCoordSysPolar && seriesModel.get('step');
          var clipShapeForSymbol;

          if (coordSys && coordSys.getArea && seriesModel.get('clip', true)) {
            clipShapeForSymbol = coordSys.getArea(); // Avoid float number rounding error for symbol on the edge of axis extent.
            // See #7913 and `test/dataZoom-clip.html`.

            if (clipShapeForSymbol.width != null) {
              clipShapeForSymbol.x -= 0.1;
              clipShapeForSymbol.y -= 0.1;
              clipShapeForSymbol.width += 0.2;
              clipShapeForSymbol.height += 0.2;
            } else if (clipShapeForSymbol.r0) {
              clipShapeForSymbol.r0 -= 0.5;
              clipShapeForSymbol.r1 += 0.5;
            }
          }

          this._clipShapeForSymbol = clipShapeForSymbol; // Initialization animation or coordinate system changed

          if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
            showSymbol && symbolDraw.updateData(data, {
              isIgnore: isIgnoreFunc,
              clipShape: clipShapeForSymbol
            });

            if (step) {
              // TODO If stacked series is not step
              points = turnPointsIntoStep(points, coordSys, step);
              stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
            }

            polyline = this._newPolyline(points, coordSys, hasAnimation);

            if (isAreaChart) {
              polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
            }

            lineGroup.setClipPath(createLineClipPath(coordSys, true, seriesModel));
          } else {
            if (isAreaChart && !polygon) {
              // If areaStyle is added
              polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
            } else if (polygon && !isAreaChart) {
              // If areaStyle is removed
              lineGroup.remove(polygon);
              polygon = this._polygon = null;
            } // Update clipPath


            lineGroup.setClipPath(createLineClipPath(coordSys, false, seriesModel)); // Always update, or it is wrong in the case turning on legend
            // because points are not changed

            showSymbol && symbolDraw.updateData(data, {
              isIgnore: isIgnoreFunc,
              clipShape: clipShapeForSymbol
            }); // Stop symbol animation and sync with line points
            // FIXME performance?

            data.eachItemGraphicEl(function (el) {
              el.stopAnimation(true);
            }); // In the case data zoom triggerred refreshing frequently
            // Data may not change if line has a category axis. So it should animate nothing

            if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {
              if (hasAnimation) {
                this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);
              } else {
                // Not do it in update with animation
                if (step) {
                  // TODO If stacked series is not step
                  points = turnPointsIntoStep(points, coordSys, step);
                  stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
                }

                polyline.setShape({
                  points: points
                });
                polygon && polygon.setShape({
                  points: points,
                  stackedOnPoints: stackedOnPoints
                });
              }
            }
          }

          var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');
          polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first
          lineStyleModel.getLineStyle(), {
            fill: 'none',
            stroke: visualColor,
            lineJoin: 'bevel'
          }));
          var smooth = seriesModel.get('smooth');
          smooth = getSmooth(seriesModel.get('smooth'));
          polyline.setShape({
            smooth: smooth,
            smoothMonotone: seriesModel.get('smoothMonotone'),
            connectNulls: seriesModel.get('connectNulls')
          });

          if (polygon) {
            var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');
            var stackedOnSmooth = 0;
            polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {
              fill: visualColor,
              opacity: 0.7,
              lineJoin: 'bevel'
            }));

            if (stackedOnSeries) {
              stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));
            }

            polygon.setShape({
              smooth: smooth,
              stackedOnSmooth: stackedOnSmooth,
              smoothMonotone: seriesModel.get('smoothMonotone'),
              connectNulls: seriesModel.get('connectNulls')
            });
          }

          this._data = data; // Save the coordinate system for transition animation when data changed

          this._coordSys = coordSys;
          this._stackedOnPoints = stackedOnPoints;
          this._points = points;
          this._step = step;
          this._valueOrigin = valueOrigin;
        },
        dispose: function dispose() {},
        highlight: function highlight(seriesModel, ecModel, api, payload) {
          var data = seriesModel.getData();
          var dataIndex = modelUtil.queryDataIndex(data, payload);

          if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
            var symbol = data.getItemGraphicEl(dataIndex);

            if (!symbol) {
              // Create a temporary symbol if it is not exists
              var pt = data.getItemLayout(dataIndex);

              if (!pt) {
                // Null data
                return;
              } // fix #11360: should't draw symbol outside clipShapeForSymbol


              if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(pt[0], pt[1])) {
                return;
              }

              symbol = new SymbolClz(data, dataIndex);
              symbol.position = pt;
              symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));
              symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);
              symbol.__temp = true;
              data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation

              symbol.stopSymbolAnimation(true);
              this.group.add(symbol);
            }

            symbol.highlight();
          } else {
            // Highlight whole series
            ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
          }
        },
        downplay: function downplay(seriesModel, ecModel, api, payload) {
          var data = seriesModel.getData();
          var dataIndex = modelUtil.queryDataIndex(data, payload);

          if (dataIndex != null && dataIndex >= 0) {
            var symbol = data.getItemGraphicEl(dataIndex);

            if (symbol) {
              if (symbol.__temp) {
                data.setItemGraphicEl(dataIndex, null);
                this.group.remove(symbol);
              } else {
                symbol.downplay();
              }
            }
          } else {
            // FIXME
            // can not downplay completely.
            // Downplay whole series
            ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
          }
        },

        /**
         * @param {module:zrender/container/Group} group
         * @param {Array.<Array.<number>>} points
         * @private
         */
        _newPolyline: function _newPolyline(points) {
          var polyline = this._polyline; // Remove previous created polyline

          if (polyline) {
            this._lineGroup.remove(polyline);
          }

          polyline = new Polyline({
            shape: {
              points: points
            },
            silent: true,
            z2: 10
          });

          this._lineGroup.add(polyline);

          this._polyline = polyline;
          return polyline;
        },

        /**
         * @param {module:zrender/container/Group} group
         * @param {Array.<Array.<number>>} stackedOnPoints
         * @param {Array.<Array.<number>>} points
         * @private
         */
        _newPolygon: function _newPolygon(points, stackedOnPoints) {
          var polygon = this._polygon; // Remove previous created polygon

          if (polygon) {
            this._lineGroup.remove(polygon);
          }

          polygon = new Polygon({
            shape: {
              points: points,
              stackedOnPoints: stackedOnPoints
            },
            silent: true
          });

          this._lineGroup.add(polygon);

          this._polygon = polygon;
          return polygon;
        },

        /**
         * @private
         */
        // FIXME Two value axis
        _updateAnimation: function _updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin) {
          var polyline = this._polyline;
          var polygon = this._polygon;
          var seriesModel = data.hostModel;
          var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);
          var current = diff.current;
          var stackedOnCurrent = diff.stackedOnCurrent;
          var next = diff.next;
          var stackedOnNext = diff.stackedOnNext;

          if (step) {
            // TODO If stacked series is not step
            current = turnPointsIntoStep(diff.current, coordSys, step);
            stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);
            next = turnPointsIntoStep(diff.next, coordSys, step);
            stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);
          } // Don't apply animation if diff is large.
          // For better result and avoid memory explosion problems like
          // https://github.com/apache/incubator-echarts/issues/12229


          if (getBoundingDiff(current, next) > 3000 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3000) {
            polyline.setShape({
              points: next
            });

            if (polygon) {
              polygon.setShape({
                points: next,
                stackedOnPoints: stackedOnNext
              });
            }

            return;
          } // `diff.current` is subset of `current` (which should be ensured by
          // turnPointsIntoStep), so points in `__points` can be updated when
          // points in `current` are update during animation.


          polyline.shape.__points = diff.current;
          polyline.shape.points = current;
          graphic.updateProps(polyline, {
            shape: {
              points: next
            }
          }, seriesModel);

          if (polygon) {
            polygon.setShape({
              points: current,
              stackedOnPoints: stackedOnCurrent
            });
            graphic.updateProps(polygon, {
              shape: {
                points: next,
                stackedOnPoints: stackedOnNext
              }
            }, seriesModel);
          }

          var updatedDataInfo = [];
          var diffStatus = diff.status;

          for (var i = 0; i < diffStatus.length; i++) {
            var cmd = diffStatus[i].cmd;

            if (cmd === '=') {
              var el = data.getItemGraphicEl(diffStatus[i].idx1);

              if (el) {
                updatedDataInfo.push({
                  el: el,
                  ptIdx: i // Index of points

                });
              }
            }
          }

          if (polyline.animators && polyline.animators.length) {
            polyline.animators[0].during(function () {
              for (var i = 0; i < updatedDataInfo.length; i++) {
                var el = updatedDataInfo[i].el;
                el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);
              }
            });
          }
        },
        remove: function remove(ecModel) {
          var group = this.group;
          var oldData = this._data;

          this._lineGroup.removeAll();

          this._symbolDraw.remove(true); // Remove temporary created elements when highlighting


          oldData && oldData.eachItemGraphicEl(function (el, idx) {
            if (el.__temp) {
              group.remove(el);
              oldData.setItemGraphicEl(idx, null);
            }
          });
          this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "8XDt":
    /*!*********************************************!*\
      !*** ./node_modules/zrender/lib/vml/vml.js ***!
      \*********************************************/

    /*! no static exports found */

    /***/
    function XDt(module, exports, __webpack_require__) {
      __webpack_require__(
      /*! ./graphic */
      "qH13");

      var _zrender = __webpack_require__(
      /*! ../zrender */
      "aX58");

      var registerPainter = _zrender.registerPainter;

      var Painter = __webpack_require__(
      /*! ./Painter */
      "6fms");

      registerPainter('vml', Painter);
      /***/
    },

    /***/
    "8nMs":
    /*!**********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/axis/CartesianAxisView.js ***!
      \**********************************************************************/

    /*! no static exports found */

    /***/
    function nMs(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var AxisBuilder = __webpack_require__(
      /*! ./AxisBuilder */
      "+rIm");

      var AxisView = __webpack_require__(
      /*! ./AxisView */
      "Znkb");

      var cartesianAxisHelper = __webpack_require__(
      /*! ../../coord/cartesian/cartesianAxisHelper */
      "AVZG");

      var _axisSplitHelper = __webpack_require__(
      /*! ./axisSplitHelper */
      "WN+l");

      var rectCoordAxisBuildSplitArea = _axisSplitHelper.rectCoordAxisBuildSplitArea;
      var rectCoordAxisHandleRemove = _axisSplitHelper.rectCoordAxisHandleRemove;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];
      var selfBuilderAttrs = ['splitArea', 'splitLine', 'minorSplitLine'];
      var CartesianAxisView = AxisView.extend({
        type: 'cartesianAxis',
        axisPointerClass: 'CartesianAxisPointer',

        /**
         * @override
         */
        render: function render(axisModel, ecModel, api, payload) {
          this.group.removeAll();
          var oldAxisGroup = this._axisGroup;
          this._axisGroup = new graphic.Group();
          this.group.add(this._axisGroup);

          if (!axisModel.get('show')) {
            return;
          }

          var gridModel = axisModel.getCoordSysModel();
          var layout = cartesianAxisHelper.layout(gridModel, axisModel);
          var axisBuilder = new AxisBuilder(axisModel, layout);
          zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);

          this._axisGroup.add(axisBuilder.getGroup());

          zrUtil.each(selfBuilderAttrs, function (name) {
            if (axisModel.get(name + '.show')) {
              this['_' + name](axisModel, gridModel);
            }
          }, this);
          graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);
          CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);
        },
        remove: function remove() {
          rectCoordAxisHandleRemove(this);
        },

        /**
         * @param {module:echarts/coord/cartesian/AxisModel} axisModel
         * @param {module:echarts/coord/cartesian/GridModel} gridModel
         * @private
         */
        _splitLine: function _splitLine(axisModel, gridModel) {
          var axis = axisModel.axis;

          if (axis.scale.isBlank()) {
            return;
          }

          var splitLineModel = axisModel.getModel('splitLine');
          var lineStyleModel = splitLineModel.getModel('lineStyle');
          var lineColors = lineStyleModel.get('color');
          lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];
          var gridRect = gridModel.coordinateSystem.getRect();
          var isHorizontal = axis.isHorizontal();
          var lineCount = 0;
          var ticksCoords = axis.getTicksCoords({
            tickModel: splitLineModel
          });
          var p1 = [];
          var p2 = [];
          var lineStyle = lineStyleModel.getLineStyle();

          for (var i = 0; i < ticksCoords.length; i++) {
            var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);

            if (isHorizontal) {
              p1[0] = tickCoord;
              p1[1] = gridRect.y;
              p2[0] = tickCoord;
              p2[1] = gridRect.y + gridRect.height;
            } else {
              p1[0] = gridRect.x;
              p1[1] = tickCoord;
              p2[0] = gridRect.x + gridRect.width;
              p2[1] = tickCoord;
            }

            var colorIndex = lineCount++ % lineColors.length;
            var tickValue = ticksCoords[i].tickValue;

            this._axisGroup.add(new graphic.Line({
              anid: tickValue != null ? 'line_' + ticksCoords[i].tickValue : null,
              subPixelOptimize: true,
              shape: {
                x1: p1[0],
                y1: p1[1],
                x2: p2[0],
                y2: p2[1]
              },
              style: zrUtil.defaults({
                stroke: lineColors[colorIndex]
              }, lineStyle),
              silent: true
            }));
          }
        },

        /**
         * @param {module:echarts/coord/cartesian/AxisModel} axisModel
         * @param {module:echarts/coord/cartesian/GridModel} gridModel
         * @private
         */
        _minorSplitLine: function _minorSplitLine(axisModel, gridModel) {
          var axis = axisModel.axis;
          var minorSplitLineModel = axisModel.getModel('minorSplitLine');
          var lineStyleModel = minorSplitLineModel.getModel('lineStyle');
          var gridRect = gridModel.coordinateSystem.getRect();
          var isHorizontal = axis.isHorizontal();
          var minorTicksCoords = axis.getMinorTicksCoords();

          if (!minorTicksCoords.length) {
            return;
          }

          var p1 = [];
          var p2 = [];
          var lineStyle = lineStyleModel.getLineStyle();

          for (var i = 0; i < minorTicksCoords.length; i++) {
            for (var k = 0; k < minorTicksCoords[i].length; k++) {
              var tickCoord = axis.toGlobalCoord(minorTicksCoords[i][k].coord);

              if (isHorizontal) {
                p1[0] = tickCoord;
                p1[1] = gridRect.y;
                p2[0] = tickCoord;
                p2[1] = gridRect.y + gridRect.height;
              } else {
                p1[0] = gridRect.x;
                p1[1] = tickCoord;
                p2[0] = gridRect.x + gridRect.width;
                p2[1] = tickCoord;
              }

              this._axisGroup.add(new graphic.Line({
                anid: 'minor_line_' + minorTicksCoords[i][k].tickValue,
                subPixelOptimize: true,
                shape: {
                  x1: p1[0],
                  y1: p1[1],
                  x2: p2[0],
                  y2: p2[1]
                },
                style: lineStyle,
                silent: true
              }));
            }
          }
        },

        /**
         * @param {module:echarts/coord/cartesian/AxisModel} axisModel
         * @param {module:echarts/coord/cartesian/GridModel} gridModel
         * @private
         */
        _splitArea: function _splitArea(axisModel, gridModel) {
          rectCoordAxisBuildSplitArea(this, this._axisGroup, axisModel, gridModel);
        }
      });
      CartesianAxisView.extend({
        type: 'xAxis'
      });
      CartesianAxisView.extend({
        type: 'yAxis'
      });
      /***/
    },

    /***/
    "8waO":
    /*!********************************************************!*\
      !*** ./node_modules/echarts/lib/component/parallel.js ***!
      \********************************************************/

    /*! no static exports found */

    /***/
    function waO(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var throttleUtil = __webpack_require__(
      /*! ../util/throttle */
      "iLNv");

      var parallelPreprocessor = __webpack_require__(
      /*! ../coord/parallel/parallelPreprocessor */
      "ZWlE");

      __webpack_require__(
      /*! ../coord/parallel/parallelCreator */
      "hJvP");

      __webpack_require__(
      /*! ../coord/parallel/ParallelModel */
      "IXyC");

      __webpack_require__(
      /*! ./parallelAxis */
      "xRUu");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var CLICK_THRESHOLD = 5; // > 4
      // Parallel view

      echarts.extendComponentView({
        type: 'parallel',
        render: function render(parallelModel, ecModel, api) {
          this._model = parallelModel;
          this._api = api;

          if (!this._handlers) {
            this._handlers = {};
            zrUtil.each(handlers, function (handler, eventName) {
              api.getZr().on(eventName, this._handlers[eventName] = zrUtil.bind(handler, this));
            }, this);
          }

          throttleUtil.createOrUpdate(this, '_throttledDispatchExpand', parallelModel.get('axisExpandRate'), 'fixRate');
        },
        dispose: function dispose(ecModel, api) {
          zrUtil.each(this._handlers, function (handler, eventName) {
            api.getZr().off(eventName, handler);
          });
          this._handlers = null;
        },

        /**
         * @param {Object} [opt] If null, cancle the last action triggering for debounce.
         */
        _throttledDispatchExpand: function _throttledDispatchExpand(opt) {
          this._dispatchExpand(opt);
        },
        _dispatchExpand: function _dispatchExpand(opt) {
          opt && this._api.dispatchAction(zrUtil.extend({
            type: 'parallelAxisExpand'
          }, opt));
        }
      });
      var handlers = {
        mousedown: function mousedown(e) {
          if (checkTrigger(this, 'click')) {
            this._mouseDownPoint = [e.offsetX, e.offsetY];
          }
        },
        mouseup: function mouseup(e) {
          var mouseDownPoint = this._mouseDownPoint;

          if (checkTrigger(this, 'click') && mouseDownPoint) {
            var point = [e.offsetX, e.offsetY];
            var dist = Math.pow(mouseDownPoint[0] - point[0], 2) + Math.pow(mouseDownPoint[1] - point[1], 2);

            if (dist > CLICK_THRESHOLD) {
              return;
            }

            var result = this._model.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX, e.offsetY]);

            result.behavior !== 'none' && this._dispatchExpand({
              axisExpandWindow: result.axisExpandWindow
            });
          }

          this._mouseDownPoint = null;
        },
        mousemove: function mousemove(e) {
          // Should do nothing when brushing.
          if (this._mouseDownPoint || !checkTrigger(this, 'mousemove')) {
            return;
          }

          var model = this._model;
          var result = model.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX, e.offsetY]);
          var behavior = result.behavior;
          behavior === 'jump' && this._throttledDispatchExpand.debounceNextCall(model.get('axisExpandDebounce'));

          this._throttledDispatchExpand(behavior === 'none' ? null // Cancle the last trigger, in case that mouse slide out of the area quickly.
          : {
            axisExpandWindow: result.axisExpandWindow,
            // Jumping uses animation, and sliding suppresses animation.
            animation: behavior === 'jump' ? null : false
          });
        }
      };

      function checkTrigger(view, triggerOn) {
        var model = view._model;
        return model.get('axisExpandable') && model.get('axisExpandTriggerOn') === triggerOn;
      }

      echarts.registerPreprocessor(parallelPreprocessor);
      /***/
    },

    /***/
    "8x+h":
    /*!****************************************************************!*\
      !*** ./node_modules/echarts/lib/component/brush/BrushModel.js ***!
      \****************************************************************/

    /*! no static exports found */

    /***/
    function xH(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var visualSolution = __webpack_require__(
      /*! ../../visual/visualSolution */
      "K4ya");

      var Model = __webpack_require__(
      /*! ../../model/Model */
      "Qxkt");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var DEFAULT_OUT_OF_BRUSH_COLOR = ['#ddd'];
      var BrushModel = echarts.extendComponentModel({
        type: 'brush',
        dependencies: ['geo', 'grid', 'xAxis', 'yAxis', 'parallel', 'series'],

        /**
         * @protected
         */
        defaultOption: {
          // inBrush: null,
          // outOfBrush: null,
          toolbox: null,
          // Default value see preprocessor.
          brushLink: null,
          // Series indices array, broadcast using dataIndex.
          // or 'all', which means all series. 'none' or null means no series.
          seriesIndex: 'all',
          // seriesIndex array, specify series controlled by this brush component.
          geoIndex: null,
          //
          xAxisIndex: null,
          yAxisIndex: null,
          brushType: 'rect',
          // Default brushType, see BrushController.
          brushMode: 'single',
          // Default brushMode, 'single' or 'multiple'
          transformable: true,
          // Default transformable.
          brushStyle: {
            // Default brushStyle
            borderWidth: 1,
            color: 'rgba(120,140,180,0.3)',
            borderColor: 'rgba(120,140,180,0.8)'
          },
          throttleType: 'fixRate',
          // Throttle in brushSelected event. 'fixRate' or 'debounce'.
          // If null, no throttle. Valid only in the first brush component
          throttleDelay: 0,
          // Unit: ms, 0 means every event will be triggered.
          // FIXME
          // 
          removeOnClick: true,
          z: 10000
        },

        /**
         * @readOnly
         * @type {Array.<Object>}
         */
        areas: [],

        /**
         * Current activated brush type.
         * If null, brush is inactived.
         * see module:echarts/component/helper/BrushController
         * @readOnly
         * @type {string}
         */
        brushType: null,

        /**
         * Current brush opt.
         * see module:echarts/component/helper/BrushController
         * @readOnly
         * @type {Object}
         */
        brushOption: {},

        /**
         * @readOnly
         * @type {Array.<Object>}
         */
        coordInfoList: [],
        optionUpdated: function optionUpdated(newOption, isInit) {
          var thisOption = this.option;
          !isInit && visualSolution.replaceVisualOption(thisOption, newOption, ['inBrush', 'outOfBrush']);
          var inBrush = thisOption.inBrush = thisOption.inBrush || {}; // Always give default visual, consider setOption at the second time.

          thisOption.outOfBrush = thisOption.outOfBrush || {
            color: DEFAULT_OUT_OF_BRUSH_COLOR
          };

          if (!inBrush.hasOwnProperty('liftZ')) {
            // Bigger than the highlight z lift, otherwise it will
            // be effected by the highlight z when brush.
            inBrush.liftZ = 5;
          }
        },

        /**
         * If ranges is null/undefined, range state remain.
         *
         * @param {Array.<Object>} [ranges]
         */
        setAreas: function setAreas(areas) {
          // If ranges is null/undefined, range state remain.
          // This helps user to dispatchAction({type: 'brush'}) with no areas
          // set but just want to get the current brush select info from a `brush` event.
          if (!areas) {
            return;
          }

          this.areas = zrUtil.map(areas, function (area) {
            return generateBrushOption(this.option, area);
          }, this);
        },

        /**
         * see module:echarts/component/helper/BrushController
         * @param {Object} brushOption
         */
        setBrushOption: function setBrushOption(brushOption) {
          this.brushOption = generateBrushOption(this.option, brushOption);
          this.brushType = this.brushOption.brushType;
        }
      });

      function generateBrushOption(option, brushOption) {
        return zrUtil.merge({
          brushType: option.brushType,
          brushMode: option.brushMode,
          transformable: option.transformable,
          brushStyle: new Model(option.brushStyle).getItemStyle(),
          removeOnClick: option.removeOnClick,
          z: option.z
        }, brushOption, true);
      }

      var _default = BrushModel;
      module.exports = _default;
      /***/
    },

    /***/
    "98bh":
    /*!*********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/pie/PieSeries.js ***!
      \*********************************************************/

    /*! no static exports found */

    /***/
    function bh(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var createListSimply = __webpack_require__(
      /*! ../helper/createListSimply */
      "5GtS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var modelUtil = __webpack_require__(
      /*! ../../util/model */
      "4NO4");

      var _number = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var getPercentWithPrecision = _number.getPercentWithPrecision;

      var dataSelectableMixin = __webpack_require__(
      /*! ../../component/helper/selectableMixin */
      "cCMj");

      var _dataProvider = __webpack_require__(
      /*! ../../data/helper/dataProvider */
      "KxfA");

      var retrieveRawAttr = _dataProvider.retrieveRawAttr;

      var _sourceHelper = __webpack_require__(
      /*! ../../data/helper/sourceHelper */
      "D5nY");

      var makeSeriesEncodeForNameBased = _sourceHelper.makeSeriesEncodeForNameBased;

      var LegendVisualProvider = __webpack_require__(
      /*! ../../visual/LegendVisualProvider */
      "xKMd");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var PieSeries = echarts.extendSeriesModel({
        type: 'series.pie',
        // Overwrite
        init: function init(option) {
          PieSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item
          // Use a function instead of direct access because data reference may changed

          this.legendVisualProvider = new LegendVisualProvider(zrUtil.bind(this.getData, this), zrUtil.bind(this.getRawData, this));
          this.updateSelectedMap(this._createSelectableList());

          this._defaultLabelLine(option);
        },
        // Overwrite
        mergeOption: function mergeOption(newOption) {
          PieSeries.superCall(this, 'mergeOption', newOption);
          this.updateSelectedMap(this._createSelectableList());
        },
        getInitialData: function getInitialData(option, ecModel) {
          return createListSimply(this, {
            coordDimensions: ['value'],
            encodeDefaulter: zrUtil.curry(makeSeriesEncodeForNameBased, this)
          });
        },
        _createSelectableList: function _createSelectableList() {
          var data = this.getRawData();
          var valueDim = data.mapDimension('value');
          var targetList = [];

          for (var i = 0, len = data.count(); i < len; i++) {
            targetList.push({
              name: data.getName(i),
              value: data.get(valueDim, i),
              selected: retrieveRawAttr(data, i, 'selected')
            });
          }

          return targetList;
        },
        // Overwrite
        getDataParams: function getDataParams(dataIndex) {
          var data = this.getData();
          var params = PieSeries.superCall(this, 'getDataParams', dataIndex); // FIXME toFixed?

          var valueList = [];
          data.each(data.mapDimension('value'), function (value) {
            valueList.push(value);
          });
          params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get('percentPrecision'));
          params.$vars.push('percent');
          return params;
        },
        _defaultLabelLine: function _defaultLabelLine(option) {
          // Extend labelLine emphasis
          modelUtil.defaultEmphasis(option, 'labelLine', ['show']);
          var labelLineNormalOpt = option.labelLine;
          var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`

          labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
          labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
        },
        defaultOption: {
          zlevel: 0,
          z: 2,
          legendHoverLink: true,
          hoverAnimation: true,
          // 
          center: ['50%', '50%'],
          radius: [0, '75%'],
          // 
          clockwise: true,
          startAngle: 90,
          // 0
          minAngle: 0,
          // If the angle of a sector less than `minShowLabelAngle`,
          // the label will not be displayed.
          minShowLabelAngle: 0,
          // 
          selectedOffset: 10,
          // 
          hoverOffset: 10,
          // If use strategy to avoid label overlapping
          avoidLabelOverlap: true,
          // singlemultiple
          // selectedMode: false,
          // 'radius' | 'area'
          // roseType: null,
          percentPrecision: 2,
          // If still show when all data zero.
          stillShowZeroSum: true,
          // cursor: null,
          left: 0,
          top: 0,
          right: 0,
          bottom: 0,
          width: null,
          height: null,
          label: {
            // If rotate around circle
            rotate: false,
            show: true,
            // 'outer', 'inside', 'center'
            position: 'outer',
            // 'none', 'labelLine', 'edge'. Works only when position is 'outer'
            alignTo: 'none',
            // Closest distance between label and chart edge.
            // Works only position is 'outer' and alignTo is 'edge'.
            margin: '25%',
            // Works only position is 'outer' and alignTo is not 'edge'.
            bleedMargin: 10,
            // Distance between text and label line.
            distanceToLabelLine: 5 // formatter: Tooltip.formatter
            // TEXTSTYLE
            // distance: positioninnerlabel()

          },
          // Enabled when label.normal.position is 'outer'
          labelLine: {
            show: true,
            // 
            length: 15,
            // 
            length2: 15,
            smooth: false,
            lineStyle: {
              // color: ,
              width: 1,
              type: 'solid'
            }
          },
          itemStyle: {
            borderWidth: 1
          },
          // Animation type. Valid values: expansion, scale
          animationType: 'expansion',
          // Animation type when update. Valid values: transition, expansion
          animationTypeUpdate: 'transition',
          animationEasing: 'cubicOut'
        }
      });
      zrUtil.mixin(PieSeries, dataSelectableMixin);
      var _default = PieSeries;
      module.exports = _default;
      /***/
    },

    /***/
    "9KIM":
    /*!******************************************************************!*\
      !*** ./node_modules/echarts/lib/component/helper/brushHelper.js ***!
      \******************************************************************/

    /*! no static exports found */

    /***/
    function KIM(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var BoundingRect = __webpack_require__(
      /*! zrender/lib/core/BoundingRect */
      "mFDi");

      var _cursorHelper = __webpack_require__(
      /*! ./cursorHelper */
      "xSat");

      var onIrrelevantElement = _cursorHelper.onIrrelevantElement;

      var graphicUtil = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function makeRectPanelClipPath(rect) {
        rect = normalizeRect(rect);
        return function (localPoints, transform) {
          return graphicUtil.clipPointsByRect(localPoints, rect);
        };
      }

      function makeLinearBrushOtherExtent(rect, specifiedXYIndex) {
        rect = normalizeRect(rect);
        return function (xyIndex) {
          var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;
          var brushWidth = idx ? rect.width : rect.height;
          var base = idx ? rect.x : rect.y;
          return [base, base + (brushWidth || 0)];
        };
      }

      function makeRectIsTargetByCursor(rect, api, targetModel) {
        rect = normalizeRect(rect);
        return function (e, localCursorPoint, transform) {
          return rect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e, api, targetModel);
        };
      } // Consider width/height is negative.


      function normalizeRect(rect) {
        return BoundingRect.create(rect);
      }

      exports.makeRectPanelClipPath = makeRectPanelClipPath;
      exports.makeLinearBrushOtherExtent = makeLinearBrushOtherExtent;
      exports.makeRectIsTargetByCursor = makeRectIsTargetByCursor;
      /***/
    },

    /***/
    "9eas":
    /*!*********************************************************!*\
      !*** ./node_modules/echarts/lib/component/angleAxis.js ***!
      \*********************************************************/

    /*! no static exports found */

    /***/
    function eas(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      __webpack_require__(
      /*! ../coord/polar/polarCreator */
      "HM/N");

      __webpack_require__(
      /*! ./axis/AngleAxisView */
      "tBnm");
      /***/

    },

    /***/
    "9hCq":
    /*!**************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/treemap/Breadcrumb.js ***!
      \**************************************************************/

    /*! no static exports found */

    /***/
    function hCq(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var layout = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _treeHelper = __webpack_require__(
      /*! ../helper/treeHelper */
      "VaxA");

      var wrapTreePathInfo = _treeHelper.wrapTreePathInfo;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var TEXT_PADDING = 8;
      var ITEM_GAP = 8;
      var ARRAY_LENGTH = 5;

      function Breadcrumb(containerGroup) {
        /**
         * @private
         * @type {module:zrender/container/Group}
         */
        this.group = new graphic.Group();
        containerGroup.add(this.group);
      }

      Breadcrumb.prototype = {
        constructor: Breadcrumb,
        render: function render(seriesModel, api, targetNode, onSelect) {
          var model = seriesModel.getModel('breadcrumb');
          var thisGroup = this.group;
          thisGroup.removeAll();

          if (!model.get('show') || !targetNode) {
            return;
          }

          var normalStyleModel = model.getModel('itemStyle'); // var emphasisStyleModel = model.getModel('emphasis.itemStyle');

          var textStyleModel = normalStyleModel.getModel('textStyle');
          var layoutParam = {
            pos: {
              left: model.get('left'),
              right: model.get('right'),
              top: model.get('top'),
              bottom: model.get('bottom')
            },
            box: {
              width: api.getWidth(),
              height: api.getHeight()
            },
            emptyItemWidth: model.get('emptyItemWidth'),
            totalWidth: 0,
            renderList: []
          };

          this._prepare(targetNode, layoutParam, textStyleModel);

          this._renderContent(seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect);

          layout.positionElement(thisGroup, layoutParam.pos, layoutParam.box);
        },

        /**
         * Prepare render list and total width
         * @private
         */
        _prepare: function _prepare(targetNode, layoutParam, textStyleModel) {
          for (var node = targetNode; node; node = node.parentNode) {
            var text = node.getModel().get('name');
            var textRect = textStyleModel.getTextRect(text);
            var itemWidth = Math.max(textRect.width + TEXT_PADDING * 2, layoutParam.emptyItemWidth);
            layoutParam.totalWidth += itemWidth + ITEM_GAP;
            layoutParam.renderList.push({
              node: node,
              text: text,
              width: itemWidth
            });
          }
        },

        /**
         * @private
         */
        _renderContent: function _renderContent(seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect) {
          // Start rendering.
          var lastX = 0;
          var emptyItemWidth = layoutParam.emptyItemWidth;
          var height = seriesModel.get('breadcrumb.height');
          var availableSize = layout.getAvailableSize(layoutParam.pos, layoutParam.box);
          var totalWidth = layoutParam.totalWidth;
          var renderList = layoutParam.renderList;

          for (var i = renderList.length - 1; i >= 0; i--) {
            var item = renderList[i];
            var itemNode = item.node;
            var itemWidth = item.width;
            var text = item.text; // Hdie text and shorten width if necessary.

            if (totalWidth > availableSize.width) {
              totalWidth -= itemWidth - emptyItemWidth;
              itemWidth = emptyItemWidth;
              text = null;
            }

            var el = new graphic.Polygon({
              shape: {
                points: makeItemPoints(lastX, 0, itemWidth, height, i === renderList.length - 1, i === 0)
              },
              style: zrUtil.defaults(normalStyleModel.getItemStyle(), {
                lineJoin: 'bevel',
                text: text,
                textFill: textStyleModel.getTextColor(),
                textFont: textStyleModel.getFont()
              }),
              z: 10,
              onclick: zrUtil.curry(onSelect, itemNode)
            });
            this.group.add(el);
            packEventData(el, seriesModel, itemNode);
            lastX += itemWidth + ITEM_GAP;
          }
        },

        /**
         * @override
         */
        remove: function remove() {
          this.group.removeAll();
        }
      };

      function makeItemPoints(x, y, itemWidth, itemHeight, head, tail) {
        var points = [[head ? x : x - ARRAY_LENGTH, y], [x + itemWidth, y], [x + itemWidth, y + itemHeight], [head ? x : x - ARRAY_LENGTH, y + itemHeight]];
        !tail && points.splice(2, 0, [x + itemWidth + ARRAY_LENGTH, y + itemHeight / 2]);
        !head && points.push([x, y + itemHeight / 2]);
        return points;
      } // Package custom mouse event.


      function packEventData(el, seriesModel, itemNode) {
        el.eventData = {
          componentType: 'series',
          componentSubType: 'treemap',
          componentIndex: seriesModel.componentIndex,
          seriesIndex: seriesModel.componentIndex,
          seriesName: seriesModel.name,
          seriesType: 'treemap',
          selfType: 'breadcrumb',
          // Distinguish with click event on treemap node.
          nodeData: {
            dataIndex: itemNode && itemNode.dataIndex,
            name: itemNode && itemNode.name
          },
          treePathInfo: itemNode && wrapTreePathInfo(itemNode, seriesModel)
        };
      }

      var _default = Breadcrumb;
      module.exports = _default;
      /***/
    },

    /***/
    "9u0u":
    /*!****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/map/mapDataStatistic.js ***!
      \****************************************************************/

    /*! no static exports found */

    /***/
    function u0u(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // FIXME 

      /**
       * @param {Array.<module:echarts/data/List>} datas
       * @param {string} statisticType 'average' 'sum'
       * @inner
       */


      function dataStatistics(datas, statisticType) {
        var dataNameMap = {};
        zrUtil.each(datas, function (data) {
          data.each(data.mapDimension('value'), function (value, idx) {
            // Add prefix to avoid conflict with Object.prototype.
            var mapKey = 'ec-' + data.getName(idx);
            dataNameMap[mapKey] = dataNameMap[mapKey] || [];

            if (!isNaN(value)) {
              dataNameMap[mapKey].push(value);
            }
          });
        });
        return datas[0].map(datas[0].mapDimension('value'), function (value, idx) {
          var mapKey = 'ec-' + datas[0].getName(idx);
          var sum = 0;
          var min = Infinity;
          var max = -Infinity;
          var len = dataNameMap[mapKey].length;

          for (var i = 0; i < len; i++) {
            min = Math.min(min, dataNameMap[mapKey][i]);
            max = Math.max(max, dataNameMap[mapKey][i]);
            sum += dataNameMap[mapKey][i];
          }

          var result;

          if (statisticType === 'min') {
            result = min;
          } else if (statisticType === 'max') {
            result = max;
          } else if (statisticType === 'average') {
            result = sum / len;
          } else {
            result = sum;
          }

          return len === 0 ? NaN : result;
        });
      }

      function _default(ecModel) {
        var seriesGroups = {};
        ecModel.eachSeriesByType('map', function (seriesModel) {
          var hostGeoModel = seriesModel.getHostGeoModel();
          var key = hostGeoModel ? 'o' + hostGeoModel.id : 'i' + seriesModel.getMapType();
          (seriesGroups[key] = seriesGroups[key] || []).push(seriesModel);
        });
        zrUtil.each(seriesGroups, function (seriesList, key) {
          var data = dataStatistics(zrUtil.map(seriesList, function (seriesModel) {
            return seriesModel.getData();
          }), seriesList[0].get('mapValueCalculation'));

          for (var i = 0; i < seriesList.length; i++) {
            seriesList[i].originalData = seriesList[i].getData();
          } // FIXME Put where?


          for (var i = 0; i < seriesList.length; i++) {
            seriesList[i].seriesGroup = seriesList;
            seriesList[i].needsDrawMap = i === 0 && !seriesList[i].getHostGeoModel();
            seriesList[i].setData(data.cloneShallow());
            seriesList[i].mainSeries = seriesList[0];
          }
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "9wZj":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/helper/SymbolDraw.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function wZj(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var SymbolClz = __webpack_require__(
      /*! ./Symbol */
      "FBjb");

      var _util = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var isObject = _util.isObject;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @module echarts/chart/helper/SymbolDraw
       */

      /**
       * @constructor
       * @alias module:echarts/chart/helper/SymbolDraw
       * @param {module:zrender/graphic/Group} [symbolCtor]
       */

      function SymbolDraw(symbolCtor) {
        this.group = new graphic.Group();
        this._symbolCtor = symbolCtor || SymbolClz;
      }

      var symbolDrawProto = SymbolDraw.prototype;

      function symbolNeedsDraw(data, point, idx, opt) {
        return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will cut part of
        // the symbol element shape. We use the same clip shape here as
        // the line clip.
        && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';
      }
      /**
       * Update symbols draw by new data
       * @param {module:echarts/data/List} data
       * @param {Object} [opt] Or isIgnore
       * @param {Function} [opt.isIgnore]
       * @param {Object} [opt.clipShape]
       */


      symbolDrawProto.updateData = function (data, opt) {
        opt = normalizeUpdateOpt(opt);
        var group = this.group;
        var seriesModel = data.hostModel;
        var oldData = this._data;
        var SymbolCtor = this._symbolCtor;
        var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from
        // stream mode to normal mode, where previous elements should be removed.

        if (!oldData) {
          group.removeAll();
        }

        data.diff(oldData).add(function (newIdx) {
          var point = data.getItemLayout(newIdx);

          if (symbolNeedsDraw(data, point, newIdx, opt)) {
            var symbolEl = new SymbolCtor(data, newIdx, seriesScope);
            symbolEl.attr('position', point);
            data.setItemGraphicEl(newIdx, symbolEl);
            group.add(symbolEl);
          }
        }).update(function (newIdx, oldIdx) {
          var symbolEl = oldData.getItemGraphicEl(oldIdx);
          var point = data.getItemLayout(newIdx);

          if (!symbolNeedsDraw(data, point, newIdx, opt)) {
            group.remove(symbolEl);
            return;
          }

          if (!symbolEl) {
            symbolEl = new SymbolCtor(data, newIdx);
            symbolEl.attr('position', point);
          } else {
            symbolEl.updateData(data, newIdx, seriesScope);
            graphic.updateProps(symbolEl, {
              position: point
            }, seriesModel);
          } // Add back


          group.add(symbolEl);
          data.setItemGraphicEl(newIdx, symbolEl);
        }).remove(function (oldIdx) {
          var el = oldData.getItemGraphicEl(oldIdx);
          el && el.fadeOut(function () {
            group.remove(el);
          });
        }).execute();
        this._data = data;
      };

      symbolDrawProto.isPersistent = function () {
        return true;
      };

      symbolDrawProto.updateLayout = function () {
        var data = this._data;

        if (data) {
          // Not use animation
          data.eachItemGraphicEl(function (el, idx) {
            var point = data.getItemLayout(idx);
            el.attr('position', point);
          });
        }
      };

      symbolDrawProto.incrementalPrepareUpdate = function (data) {
        this._seriesScope = makeSeriesScope(data);
        this._data = null;
        this.group.removeAll();
      };
      /**
       * Update symbols draw by new data
       * @param {module:echarts/data/List} data
       * @param {Object} [opt] Or isIgnore
       * @param {Function} [opt.isIgnore]
       * @param {Object} [opt.clipShape]
       */


      symbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {
        opt = normalizeUpdateOpt(opt);

        function updateIncrementalAndHover(el) {
          if (!el.isGroup) {
            el.incremental = el.useHoverLayer = true;
          }
        }

        for (var idx = taskParams.start; idx < taskParams.end; idx++) {
          var point = data.getItemLayout(idx);

          if (symbolNeedsDraw(data, point, idx, opt)) {
            var el = new this._symbolCtor(data, idx, this._seriesScope);
            el.traverse(updateIncrementalAndHover);
            el.attr('position', point);
            this.group.add(el);
            data.setItemGraphicEl(idx, el);
          }
        }
      };

      function normalizeUpdateOpt(opt) {
        if (opt != null && !isObject(opt)) {
          opt = {
            isIgnore: opt
          };
        }

        return opt || {};
      }

      symbolDrawProto.remove = function (enableAnimation) {
        var group = this.group;
        var data = this._data; // Incremental model do not have this._data.

        if (data && enableAnimation) {
          data.eachItemGraphicEl(function (el) {
            el.fadeOut(function () {
              group.remove(el);
            });
          });
        } else {
          group.removeAll();
        }
      };

      function makeSeriesScope(data) {
        var seriesModel = data.hostModel;
        return {
          itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),
          hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),
          symbolRotate: seriesModel.get('symbolRotate'),
          symbolOffset: seriesModel.get('symbolOffset'),
          hoverAnimation: seriesModel.get('hoverAnimation'),
          labelModel: seriesModel.getModel('label'),
          hoverLabelModel: seriesModel.getModel('emphasis.label'),
          cursorStyle: seriesModel.get('cursor')
        };
      }

      var _default = SymbolDraw;
      module.exports = _default;
      /***/
    },

    /***/
    "AE9C":
    /*!***********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/visualMap/PiecewiseView.js ***!
      \***********************************************************************/

    /*! no static exports found */

    /***/
    function AE9C(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var VisualMapView = __webpack_require__(
      /*! ./VisualMapView */
      "crZl");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var _symbol = __webpack_require__(
      /*! ../../util/symbol */
      "oVpE");

      var createSymbol = _symbol.createSymbol;

      var layout = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var helper = __webpack_require__(
      /*! ./helper */
      "y7Aq");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var PiecewiseVisualMapView = VisualMapView.extend({
        type: 'visualMap.piecewise',

        /**
         * @protected
         * @override
         */
        doRender: function doRender() {
          var thisGroup = this.group;
          thisGroup.removeAll();
          var visualMapModel = this.visualMapModel;
          var textGap = visualMapModel.get('textGap');
          var textStyleModel = visualMapModel.textStyleModel;
          var textFont = textStyleModel.getFont();
          var textFill = textStyleModel.getTextColor();

          var itemAlign = this._getItemAlign();

          var itemSize = visualMapModel.itemSize;

          var viewData = this._getViewData();

          var endsText = viewData.endsText;
          var showLabel = zrUtil.retrieve(visualMapModel.get('showLabel', true), !endsText);
          endsText && this._renderEndsText(thisGroup, endsText[0], itemSize, showLabel, itemAlign);
          zrUtil.each(viewData.viewPieceList, renderItem, this);
          endsText && this._renderEndsText(thisGroup, endsText[1], itemSize, showLabel, itemAlign);
          layout.box(visualMapModel.get('orient'), thisGroup, visualMapModel.get('itemGap'));
          this.renderBackground(thisGroup);
          this.positionGroup(thisGroup);

          function renderItem(item) {
            var piece = item.piece;
            var itemGroup = new graphic.Group();
            itemGroup.onclick = zrUtil.bind(this._onItemClick, this, piece);

            this._enableHoverLink(itemGroup, item.indexInModelPieceList);

            var representValue = visualMapModel.getRepresentValue(piece);

            this._createItemSymbol(itemGroup, representValue, [0, 0, itemSize[0], itemSize[1]]);

            if (showLabel) {
              var visualState = this.visualMapModel.getValueState(representValue);
              itemGroup.add(new graphic.Text({
                style: {
                  x: itemAlign === 'right' ? -textGap : itemSize[0] + textGap,
                  y: itemSize[1] / 2,
                  text: piece.text,
                  textVerticalAlign: 'middle',
                  textAlign: itemAlign,
                  textFont: textFont,
                  textFill: textFill,
                  opacity: visualState === 'outOfRange' ? 0.5 : 1
                }
              }));
            }

            thisGroup.add(itemGroup);
          }
        },

        /**
         * @private
         */
        _enableHoverLink: function _enableHoverLink(itemGroup, pieceIndex) {
          itemGroup.on('mouseover', zrUtil.bind(onHoverLink, this, 'highlight')).on('mouseout', zrUtil.bind(onHoverLink, this, 'downplay'));

          function onHoverLink(method) {
            var visualMapModel = this.visualMapModel;
            visualMapModel.option.hoverLink && this.api.dispatchAction({
              type: method,
              batch: helper.makeHighDownBatch(visualMapModel.findTargetDataIndices(pieceIndex), visualMapModel)
            });
          }
        },

        /**
         * @private
         */
        _getItemAlign: function _getItemAlign() {
          var visualMapModel = this.visualMapModel;
          var modelOption = visualMapModel.option;

          if (modelOption.orient === 'vertical') {
            return helper.getItemAlign(visualMapModel, this.api, visualMapModel.itemSize);
          } else {
            // horizontal, most case left unless specifying right.
            var align = modelOption.align;

            if (!align || align === 'auto') {
              align = 'left';
            }

            return align;
          }
        },

        /**
         * @private
         */
        _renderEndsText: function _renderEndsText(group, text, itemSize, showLabel, itemAlign) {
          if (!text) {
            return;
          }

          var itemGroup = new graphic.Group();
          var textStyleModel = this.visualMapModel.textStyleModel;
          itemGroup.add(new graphic.Text({
            style: {
              x: showLabel ? itemAlign === 'right' ? itemSize[0] : 0 : itemSize[0] / 2,
              y: itemSize[1] / 2,
              textVerticalAlign: 'middle',
              textAlign: showLabel ? itemAlign : 'center',
              text: text,
              textFont: textStyleModel.getFont(),
              textFill: textStyleModel.getTextColor()
            }
          }));
          group.add(itemGroup);
        },

        /**
         * @private
         * @return {Object} {peiceList, endsText} The order is the same as screen pixel order.
         */
        _getViewData: function _getViewData() {
          var visualMapModel = this.visualMapModel;
          var viewPieceList = zrUtil.map(visualMapModel.getPieceList(), function (piece, index) {
            return {
              piece: piece,
              indexInModelPieceList: index
            };
          });
          var endsText = visualMapModel.get('text'); // Consider orient and inverse.

          var orient = visualMapModel.get('orient');
          var inverse = visualMapModel.get('inverse'); // Order of model pieceList is always [low, ..., high]

          if (orient === 'horizontal' ? inverse : !inverse) {
            viewPieceList.reverse();
          } // Origin order of endsText is [high, low]
          else if (endsText) {
            endsText = endsText.slice().reverse();
          }

          return {
            viewPieceList: viewPieceList,
            endsText: endsText
          };
        },

        /**
         * @private
         */
        _createItemSymbol: function _createItemSymbol(group, representValue, shapeParam) {
          group.add(createSymbol(this.getControllerVisual(representValue, 'symbol'), shapeParam[0], shapeParam[1], shapeParam[2], shapeParam[3], this.getControllerVisual(representValue, 'color')));
        },

        /**
         * @private
         */
        _onItemClick: function _onItemClick(piece) {
          var visualMapModel = this.visualMapModel;
          var option = visualMapModel.option;
          var selected = zrUtil.clone(option.selected);
          var newKey = visualMapModel.getSelectedMapKey(piece);

          if (option.selectedMode === 'single') {
            selected[newKey] = true;
            zrUtil.each(selected, function (o, key) {
              selected[key] = key === newKey;
            });
          } else {
            selected[newKey] = !selected[newKey];
          }

          this.api.dispatchAction({
            type: 'selectDataRange',
            from: this.uid,
            visualMapId: this.visualMapModel.id,
            selected: selected
          });
        }
      });
      var _default = PiecewiseVisualMapView;
      module.exports = _default;
      /***/
    },

    /***/
    "AEZ6":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/parallel/ParallelSeries.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function AEZ6(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _util = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var each = _util.each;
      var createHashMap = _util.createHashMap;

      var SeriesModel = __webpack_require__(
      /*! ../../model/Series */
      "T4UG");

      var createListFromArray = __webpack_require__(
      /*! ../helper/createListFromArray */
      "MwEJ");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = SeriesModel.extend({
        type: 'series.parallel',
        dependencies: ['parallel'],
        visualColorAccessPath: 'lineStyle.color',
        getInitialData: function getInitialData(option, ecModel) {
          var source = this.getSource();
          setEncodeAndDimensions(source, this);
          return createListFromArray(source, this);
        },

        /**
         * User can get data raw indices on 'axisAreaSelected' event received.
         *
         * @public
         * @param {string} activeState 'active' or 'inactive' or 'normal'
         * @return {Array.<number>} Raw indices
         */
        getRawIndicesByActiveState: function getRawIndicesByActiveState(activeState) {
          var coordSys = this.coordinateSystem;
          var data = this.getData();
          var indices = [];
          coordSys.eachActiveState(data, function (theActiveState, dataIndex) {
            if (activeState === theActiveState) {
              indices.push(data.getRawIndex(dataIndex));
            }
          });
          return indices;
        },
        defaultOption: {
          zlevel: 0,
          // 
          z: 2,
          // 
          coordinateSystem: 'parallel',
          parallelIndex: 0,
          label: {
            show: false
          },
          inactiveOpacity: 0.05,
          activeOpacity: 1,
          lineStyle: {
            width: 1,
            opacity: 0.45,
            type: 'solid'
          },
          emphasis: {
            label: {
              show: false
            }
          },
          progressive: 500,
          smooth: false,
          // true | false | number
          animationEasing: 'linear'
        }
      });

      function setEncodeAndDimensions(source, seriesModel) {
        // The mapping of parallelAxis dimension to data dimension can
        // be specified in parallelAxis.option.dim. For example, if
        // parallelAxis.option.dim is 'dim3', it mapping to the third
        // dimension of data. But `data.encode` has higher priority.
        // Moreover, parallelModel.dimension should not be regarded as data
        // dimensions. Consider dimensions = ['dim4', 'dim2', 'dim6'];
        if (source.encodeDefine) {
          return;
        }

        var parallelModel = seriesModel.ecModel.getComponent('parallel', seriesModel.get('parallelIndex'));

        if (!parallelModel) {
          return;
        }

        var encodeDefine = source.encodeDefine = createHashMap();
        each(parallelModel.dimensions, function (axisDim) {
          var dataDimIndex = convertDimNameToNumber(axisDim);
          encodeDefine.set(axisDim, dataDimIndex);
        });
      }

      function convertDimNameToNumber(dimName) {
        return +dimName.replace('dim', '');
      }

      module.exports = _default;
      /***/
    },

    /***/
    "AH3D":
    /*!*******************************************************!*\
      !*** ./node_modules/echarts/lib/component/tooltip.js ***!
      \*******************************************************/

    /*! no static exports found */

    /***/
    function AH3D(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ./axisPointer */
      "y4/Y");

      __webpack_require__(
      /*! ./tooltip/TooltipModel */
      "qWt2");

      __webpack_require__(
      /*! ./tooltip/TooltipView */
      "Qvb6");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // FIXME Better way to pack data in graphic element

      /**
       * @action
       * @property {string} type
       * @property {number} seriesIndex
       * @property {number} dataIndex
       * @property {number} [x]
       * @property {number} [y]
       */


      echarts.registerAction({
        type: 'showTip',
        event: 'showTip',
        update: 'tooltip:manuallyShowTip'
      }, // noop
      function () {});
      echarts.registerAction({
        type: 'hideTip',
        event: 'hideTip',
        update: 'tooltip:manuallyHideTip'
      }, // noop
      function () {});
      /***/
    },

    /***/
    "ALo7":
    /*!***************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/funnel/FunnelSeries.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function ALo7(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var createListSimply = __webpack_require__(
      /*! ../helper/createListSimply */
      "5GtS");

      var _model = __webpack_require__(
      /*! ../../util/model */
      "4NO4");

      var defaultEmphasis = _model.defaultEmphasis;

      var _sourceHelper = __webpack_require__(
      /*! ../../data/helper/sourceHelper */
      "D5nY");

      var makeSeriesEncodeForNameBased = _sourceHelper.makeSeriesEncodeForNameBased;

      var LegendVisualProvider = __webpack_require__(
      /*! ../../visual/LegendVisualProvider */
      "xKMd");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var FunnelSeries = echarts.extendSeriesModel({
        type: 'series.funnel',
        init: function init(option) {
          FunnelSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item
          // Use a function instead of direct access because data reference may changed

          this.legendVisualProvider = new LegendVisualProvider(zrUtil.bind(this.getData, this), zrUtil.bind(this.getRawData, this)); // Extend labelLine emphasis

          this._defaultLabelLine(option);
        },
        getInitialData: function getInitialData(option, ecModel) {
          return createListSimply(this, {
            coordDimensions: ['value'],
            encodeDefaulter: zrUtil.curry(makeSeriesEncodeForNameBased, this)
          });
        },
        _defaultLabelLine: function _defaultLabelLine(option) {
          // Extend labelLine emphasis
          defaultEmphasis(option, 'labelLine', ['show']);
          var labelLineNormalOpt = option.labelLine;
          var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`

          labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
          labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
        },
        // Overwrite
        getDataParams: function getDataParams(dataIndex) {
          var data = this.getData();
          var params = FunnelSeries.superCall(this, 'getDataParams', dataIndex);
          var valueDim = data.mapDimension('value');
          var sum = data.getSum(valueDim); // Percent is 0 if sum is 0

          params.percent = !sum ? 0 : +(data.get(valueDim, dataIndex) / sum * 100).toFixed(2);
          params.$vars.push('percent');
          return params;
        },
        defaultOption: {
          zlevel: 0,
          // 
          z: 2,
          // 
          legendHoverLink: true,
          left: 80,
          top: 60,
          right: 80,
          bottom: 60,
          // width: {totalWidth} - left - right,
          // height: {totalHeight} - top - bottom,
          // 
          // min: 0,
          // max: 100,
          minSize: '0%',
          maxSize: '100%',
          sort: 'descending',
          // 'ascending', 'descending'
          orient: 'vertical',
          gap: 0,
          funnelAlign: 'center',
          label: {
            show: true,
            position: 'outer' // formatter: Tooltip.formatter

          },
          labelLine: {
            show: true,
            length: 20,
            lineStyle: {
              // color: ,
              width: 1,
              type: 'solid'
            }
          },
          itemStyle: {
            // color: ,
            borderColor: '#fff',
            borderWidth: 1
          },
          emphasis: {
            label: {
              show: true
            }
          }
        }
      });
      var _default = FunnelSeries;
      module.exports = _default;
      /***/
    },

    /***/
    "ANjR":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/geo/prepareCustom.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function ANjR(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function dataToCoordSize(dataSize, dataItem) {
        dataItem = dataItem || [0, 0];
        return zrUtil.map([0, 1], function (dimIdx) {
          var val = dataItem[dimIdx];
          var halfSize = dataSize[dimIdx] / 2;
          var p1 = [];
          var p2 = [];
          p1[dimIdx] = val - halfSize;
          p2[dimIdx] = val + halfSize;
          p1[1 - dimIdx] = p2[1 - dimIdx] = dataItem[1 - dimIdx];
          return Math.abs(this.dataToPoint(p1)[dimIdx] - this.dataToPoint(p2)[dimIdx]);
        }, this);
      }

      function _default(coordSys) {
        var rect = coordSys.getBoundingRect();
        return {
          coordSys: {
            type: 'geo',
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height,
            zoom: coordSys.getZoom()
          },
          api: {
            coord: function coord(data) {
              // do not provide "out" and noRoam param,
              // Compatible with this usage:
              // echarts.util.map(item.points, api.coord)
              return coordSys.dataToPoint(data);
            },
            size: zrUtil.bind(dataToCoordSize, coordSys)
          }
        };
      }

      module.exports = _default;
      /***/
    },

    /***/
    "AUH6":
    /*!***************************************************!*\
      !*** ./node_modules/echarts/lib/coord/geo/Geo.js ***!
      \***************************************************/

    /*! no static exports found */

    /***/
    function AUH6(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var BoundingRect = __webpack_require__(
      /*! zrender/lib/core/BoundingRect */
      "mFDi");

      var View = __webpack_require__(
      /*! ../View */
      "bMXI");

      var geoSourceManager = __webpack_require__(
      /*! ./geoSourceManager */
      "W4dC");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * [Geo description]
       * For backward compatibility, the orginal interface:
       * `name, map, geoJson, specialAreas, nameMap` is kept.
       *
       * @param {string|Object} name
       * @param {string} map Map type
       *        Specify the positioned areas by left, top, width, height
       * @param {Object.<string, string>} [nameMap]
       *        Specify name alias
       * @param {boolean} [invertLongitute=true]
       */


      function Geo(name, map, nameMap, invertLongitute) {
        View.call(this, name);
        /**
         * Map type
         * @type {string}
         */

        this.map = map;
        var source = geoSourceManager.load(map, nameMap);
        this._nameCoordMap = source.nameCoordMap;
        this._regionsMap = source.regionsMap;
        this._invertLongitute = invertLongitute == null ? true : invertLongitute;
        /**
         * @readOnly
         */

        this.regions = source.regions;
        /**
         * @type {module:zrender/src/core/BoundingRect}
         */

        this._rect = source.boundingRect;
      }

      Geo.prototype = {
        constructor: Geo,
        type: 'geo',

        /**
         * @param {Array.<string>}
         * @readOnly
         */
        dimensions: ['lng', 'lat'],

        /**
         * If contain given lng,lat coord
         * @param {Array.<number>}
         * @readOnly
         */
        containCoord: function containCoord(coord) {
          var regions = this.regions;

          for (var i = 0; i < regions.length; i++) {
            if (regions[i].contain(coord)) {
              return true;
            }
          }

          return false;
        },

        /**
         * @override
         */
        transformTo: function transformTo(x, y, width, height) {
          var rect = this.getBoundingRect();
          var invertLongitute = this._invertLongitute;
          rect = rect.clone();

          if (invertLongitute) {
            // Longitute is inverted
            rect.y = -rect.y - rect.height;
          }

          var rawTransformable = this._rawTransformable;
          rawTransformable.transform = rect.calculateTransform(new BoundingRect(x, y, width, height));
          rawTransformable.decomposeTransform();

          if (invertLongitute) {
            var scale = rawTransformable.scale;
            scale[1] = -scale[1];
          }

          rawTransformable.updateTransform();

          this._updateTransform();
        },

        /**
         * @param {string} name
         * @return {module:echarts/coord/geo/Region}
         */
        getRegion: function getRegion(name) {
          return this._regionsMap.get(name);
        },
        getRegionByCoord: function getRegionByCoord(coord) {
          var regions = this.regions;

          for (var i = 0; i < regions.length; i++) {
            if (regions[i].contain(coord)) {
              return regions[i];
            }
          }
        },

        /**
         * Add geoCoord for indexing by name
         * @param {string} name
         * @param {Array.<number>} geoCoord
         */
        addGeoCoord: function addGeoCoord(name, geoCoord) {
          this._nameCoordMap.set(name, geoCoord);
        },

        /**
         * Get geoCoord by name
         * @param {string} name
         * @return {Array.<number>}
         */
        getGeoCoord: function getGeoCoord(name) {
          return this._nameCoordMap.get(name);
        },

        /**
         * @override
         */
        getBoundingRect: function getBoundingRect() {
          return this._rect;
        },

        /**
         * @param {string|Array.<number>} data
         * @param {boolean} noRoam
         * @param {Array.<number>} [out]
         * @return {Array.<number>}
         */
        dataToPoint: function dataToPoint(data, noRoam, out) {
          if (typeof data === 'string') {
            // Map area name to geoCoord
            data = this.getGeoCoord(data);
          }

          if (data) {
            return View.prototype.dataToPoint.call(this, data, noRoam, out);
          }
        },

        /**
         * @override
         */
        convertToPixel: zrUtil.curry(doConvert, 'dataToPoint'),

        /**
         * @override
         */
        convertFromPixel: zrUtil.curry(doConvert, 'pointToData')
      };
      zrUtil.mixin(Geo, View);

      function doConvert(methodName, ecModel, finder, value) {
        var geoModel = finder.geoModel;
        var seriesModel = finder.seriesModel;
        var coordSys = geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem // For map.
        || (seriesModel.getReferringComponents('geo')[0] || {}).coordinateSystem : null;
        return coordSys === this ? coordSys[methodName](value) : null;
      }

      var _default = Geo;
      module.exports = _default;
      /***/
    },

    /***/
    "AVZG":
    /*!*************************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js ***!
      \*************************************************************************/

    /*! no static exports found */

    /***/
    function AVZG(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Can only be called after coordinate system creation stage.
       * (Can be called before coordinate system update stage).
       *
       * @param {Object} opt {labelInside}
       * @return {Object} {
       *  position, rotation, labelDirection, labelOffset,
       *  tickDirection, labelRotate, z2
       * }
       */


      function layout(gridModel, axisModel, opt) {
        opt = opt || {};
        var grid = gridModel.coordinateSystem;
        var axis = axisModel.axis;
        var layout = {};
        var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];
        var rawAxisPosition = axis.position;
        var axisPosition = otherAxisOnZeroOf ? 'onZero' : rawAxisPosition;
        var axisDim = axis.dim;
        var rect = grid.getRect();
        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
        var idx = {
          left: 0,
          right: 1,
          top: 0,
          bottom: 1,
          onZero: 2
        };
        var axisOffset = axisModel.get('offset') || 0;
        var posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];

        if (otherAxisOnZeroOf) {
          var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
          posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
        } // Axis position


        layout.position = [axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]]; // Axis rotation

        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1); // Tick and label direction, x y is axisDim

        var dirMap = {
          top: -1,
          bottom: 1,
          left: -1,
          right: 1
        };
        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];
        layout.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;

        if (axisModel.get('axisTick.inside')) {
          layout.tickDirection = -layout.tickDirection;
        }

        if (zrUtil.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {
          layout.labelDirection = -layout.labelDirection;
        } // Special label rotation


        var labelRotate = axisModel.get('axisLabel.rotate');
        layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate; // Over splitLine and splitArea

        layout.z2 = 1;
        return layout;
      }

      exports.layout = layout;
      /***/
    },

    /***/
    "Ae+d":
    /*!*****************************************************************!*\
      !*** ./node_modules/echarts/lib/component/helper/roamHelper.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function AeD(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * For geo and graph.
       *
       * @param {Object} controllerHost
       * @param {module:zrender/Element} controllerHost.target
       */
      function updateViewOnPan(controllerHost, dx, dy) {
        var target = controllerHost.target;
        var pos = target.position;
        pos[0] += dx;
        pos[1] += dy;
        target.dirty();
      }
      /**
       * For geo and graph.
       *
       * @param {Object} controllerHost
       * @param {module:zrender/Element} controllerHost.target
       * @param {number} controllerHost.zoom
       * @param {number} controllerHost.zoomLimit like: {min: 1, max: 2}
       */


      function updateViewOnZoom(controllerHost, zoomDelta, zoomX, zoomY) {
        var target = controllerHost.target;
        var zoomLimit = controllerHost.zoomLimit;
        var pos = target.position;
        var scale = target.scale;
        var newZoom = controllerHost.zoom = controllerHost.zoom || 1;
        newZoom *= zoomDelta;

        if (zoomLimit) {
          var zoomMin = zoomLimit.min || 0;
          var zoomMax = zoomLimit.max || Infinity;
          newZoom = Math.max(Math.min(zoomMax, newZoom), zoomMin);
        }

        var zoomScale = newZoom / controllerHost.zoom;
        controllerHost.zoom = newZoom; // Keep the mouse center when scaling

        pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);
        pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);
        scale[0] *= zoomScale;
        scale[1] *= zoomScale;
        target.dirty();
      }

      exports.updateViewOnPan = updateViewOnPan;
      exports.updateViewOnZoom = updateViewOnZoom;
      /***/
    },

    /***/
    "Ae16":
    /*!**********************************************************!*\
      !*** ./node_modules/echarts/lib/component/gridSimple.js ***!
      \**********************************************************/

    /*! no static exports found */

    /***/
    function Ae16(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var graphic = __webpack_require__(
      /*! ../util/graphic */
      "IwbS");

      __webpack_require__(
      /*! ../coord/cartesian/Grid */
      "Wqna");

      __webpack_require__(
      /*! ./axis */
      "rySg");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // Grid view


      echarts.extendComponentView({
        type: 'grid',
        render: function render(gridModel, ecModel) {
          this.group.removeAll();

          if (gridModel.get('show')) {
            this.group.add(new graphic.Rect({
              shape: gridModel.coordinateSystem.getRect(),
              style: zrUtil.defaults({
                fill: gridModel.get('backgroundColor')
              }, gridModel.getItemStyle()),
              silent: true,
              z2: -1
            }));
          }
        }
      });
      echarts.registerPreprocessor(function (option) {
        // Only create grid when need
        if (option.xAxis && option.yAxis && !option.grid) {
          option.grid = {};
        }
      });
      /***/
    },

    /***/
    "B+YJ":
    /*!*************************************************!*\
      !*** ./node_modules/echarts/lib/chart/gauge.js ***!
      \*************************************************/

    /*! no static exports found */

    /***/
    function BYJ(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      __webpack_require__(
      /*! ./gauge/GaugeSeries */
      "TYVI");

      __webpack_require__(
      /*! ./gauge/GaugeView */
      "p1MT");
      /***/

    },

    /***/
    "B9fm":
    /*!**********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/tooltip/TooltipContent.js ***!
      \**********************************************************************/

    /*! no static exports found */

    /***/
    function B9fm(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var zrColor = __webpack_require__(
      /*! zrender/lib/tool/color */
      "Qe9p");

      var eventUtil = __webpack_require__(
      /*! zrender/lib/core/event */
      "YH21");

      var domUtil = __webpack_require__(
      /*! zrender/lib/core/dom */
      "Ze12");

      var env = __webpack_require__(
      /*! zrender/lib/core/env */
      "ItGF");

      var formatUtil = __webpack_require__(
      /*! ../../util/format */
      "7aKB");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var each = zrUtil.each;
      var toCamelCase = formatUtil.toCamelCase;
      var vendors = ['', '-webkit-', '-moz-', '-o-'];
      var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';
      /**
       * @param {number} duration
       * @return {string}
       * @inner
       */

      function assembleTransition(duration) {
        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';
        var transitionText = 'left ' + duration + 's ' + transitionCurve + ',' + 'top ' + duration + 's ' + transitionCurve;
        return zrUtil.map(vendors, function (vendorPrefix) {
          return vendorPrefix + 'transition:' + transitionText;
        }).join(';');
      }
      /**
       * @param {Object} textStyle
       * @return {string}
       * @inner
       */


      function assembleFont(textStyleModel) {
        var cssText = [];
        var fontSize = textStyleModel.get('fontSize');
        var color = textStyleModel.getTextColor();
        color && cssText.push('color:' + color);
        cssText.push('font:' + textStyleModel.getFont());
        var lineHeight = textStyleModel.get('lineHeight');

        if (lineHeight == null) {
          lineHeight = Math.round(fontSize * 3 / 2);
        }

        fontSize && cssText.push('line-height:' + lineHeight + 'px');
        var shadowColor = textStyleModel.get('textShadowColor');
        var shadowBlur = textStyleModel.get('textShadowBlur') || 0;
        var shadowOffsetX = textStyleModel.get('textShadowOffsetX') || 0;
        var shadowOffsetY = textStyleModel.get('textShadowOffsetY') || 0;
        shadowBlur && cssText.push('text-shadow:' + shadowOffsetX + 'px ' + shadowOffsetY + 'px ' + shadowBlur + 'px ' + shadowColor);
        each(['decoration', 'align'], function (name) {
          var val = textStyleModel.get(name);
          val && cssText.push('text-' + name + ':' + val);
        });
        return cssText.join(';');
      }
      /**
       * @param {Object} tooltipModel
       * @return {string}
       * @inner
       */


      function assembleCssText(tooltipModel) {
        var cssText = [];
        var transitionDuration = tooltipModel.get('transitionDuration');
        var backgroundColor = tooltipModel.get('backgroundColor');
        var textStyleModel = tooltipModel.getModel('textStyle');
        var padding = tooltipModel.get('padding'); // Animation transition. Do not animate when transitionDuration is 0.

        transitionDuration && cssText.push(assembleTransition(transitionDuration));

        if (backgroundColor) {
          if (env.canvasSupported) {
            cssText.push('background-Color:' + backgroundColor);
          } else {
            // for ie
            cssText.push('background-Color:#' + zrColor.toHex(backgroundColor));
            cssText.push('filter:alpha(opacity=70)');
          }
        } // Border style


        each(['width', 'color', 'radius'], function (name) {
          var borderName = 'border-' + name;
          var camelCase = toCamelCase(borderName);
          var val = tooltipModel.get(camelCase);
          val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));
        }); // Text style

        cssText.push(assembleFont(textStyleModel)); // Padding

        if (padding != null) {
          cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');
        }

        return cssText.join(';') + ';';
      } // If not able to make, do not modify the input `out`.


      function makeStyleCoord(out, zr, appendToBody, zrX, zrY) {
        var zrPainter = zr && zr.painter;

        if (appendToBody) {
          var zrViewportRoot = zrPainter && zrPainter.getViewportRoot();

          if (zrViewportRoot) {
            // Some APPs might use scale on body, so we support CSS transform here.
            domUtil.transformLocalCoord(out, zrViewportRoot, document.body, zrX, zrY);
          }
        } else {
          out[0] = zrX;
          out[1] = zrY; // xy should be based on canvas root. But tooltipContent is
          // the sibling of canvas root. So padding of ec container
          // should be considered here.

          var viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();

          if (viewportRootOffset) {
            out[0] += viewportRootOffset.offsetLeft;
            out[1] += viewportRootOffset.offsetTop;
          }
        }

        out[2] = out[0] / zr.getWidth(); // The ratio of left to width

        out[3] = out[1] / zr.getHeight(); // The ratio of top to height
      }
      /**
       * @alias module:echarts/component/tooltip/TooltipContent
       * @param {HTMLElement} container
       * @param {ExtensionAPI} api
       * @param {Object} [opt]
       * @param {boolean} [opt.appendToBody]
       *        `false`: the DOM element will be inside the container. Default value.
       *        `true`: the DOM element will be appended to HTML body, which avoid
       *                some overflow clip but intrude outside of the container.
       * @constructor
       */


      function TooltipContent(container, api, opt) {
        if (env.wxa) {
          return null;
        }

        var el = document.createElement('div');
        el.domBelongToZr = true;
        this.el = el;
        var zr = this._zr = api.getZr();
        var appendToBody = this._appendToBody = opt && opt.appendToBody;
        this._styleCoord = [0, 0, 0, 0]; // [left, top, left/width, top/height]

        makeStyleCoord(this._styleCoord, zr, appendToBody, api.getWidth() / 2, api.getHeight() / 2);

        if (appendToBody) {
          document.body.appendChild(el);
        } else {
          container.appendChild(el);
        }

        this._container = container;
        this._show = false;
        /**
         * @private
         */

        this._hideTimeout; // FIXME
        // Is it needed to trigger zr event manually if
        // the browser do not support `pointer-events: none`.

        var self = this;

        el.onmouseenter = function () {
          // clear the timeout in hideLater and keep showing tooltip
          if (self._enterable) {
            clearTimeout(self._hideTimeout);
            self._show = true;
          }

          self._inContent = true;
        };

        el.onmousemove = function (e) {
          e = e || window.event;

          if (!self._enterable) {
            // `pointer-events: none` is set to tooltip content div
            // if `enterable` is set as `false`, and `el.onmousemove`
            // can not be triggered. But in browser that do not
            // support `pointer-events`, we need to do this:
            // Try trigger zrender event to avoid mouse
            // in and out shape too frequently
            var handler = zr.handler;
            var zrViewportRoot = zr.painter.getViewportRoot();
            eventUtil.normalizeEvent(zrViewportRoot, e, true);
            handler.dispatch('mousemove', e);
          }
        };

        el.onmouseleave = function () {
          if (self._enterable) {
            if (self._show) {
              self.hideLater(self._hideDelay);
            }
          }

          self._inContent = false;
        };
      }

      TooltipContent.prototype = {
        constructor: TooltipContent,

        /**
         * @private
         * @type {boolean}
         */
        _enterable: true,

        /**
         * Update when tooltip is rendered
         */
        update: function update(tooltipModel) {
          // FIXME
          // Move this logic to ec main?
          var container = this._container;
          var stl = container.currentStyle || document.defaultView.getComputedStyle(container);
          var domStyle = container.style;

          if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {
            domStyle.position = 'relative';
          }

          var alwaysShowContent = tooltipModel.get('alwaysShowContent');
          alwaysShowContent && this._moveTooltipIfResized(); // Hide the tooltip
          // PENDING
          // this.hide();
        },

        /**
         * when `alwaysShowContent` is true,
         * we should move the tooltip after chart resized
         */
        _moveTooltipIfResized: function _moveTooltipIfResized() {
          var ratioX = this._styleCoord[2]; // The ratio of left to width

          var ratioY = this._styleCoord[3]; // The ratio of top to height

          var realX = ratioX * this._zr.getWidth();

          var realY = ratioY * this._zr.getHeight();

          this.moveTo(realX, realY);
        },
        show: function show(tooltipModel) {
          clearTimeout(this._hideTimeout);
          var el = this.el;
          var styleCoord = this._styleCoord;
          el.style.cssText = gCssText + assembleCssText(tooltipModel) // Because of the reason described in:
          // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore
          // we should set initial value to `left` and `top`.
          + ';left:' + styleCoord[0] + 'px;top:' + styleCoord[1] + 'px;' + (tooltipModel.get('extraCssText') || '');
          el.style.display = el.innerHTML ? 'block' : 'none'; // If mouse occasionally move over the tooltip, a mouseout event will be
          // triggered by canvas, and cause some unexpectable result like dragging
          // stop, "unfocusAdjacency". Here `pointer-events: none` is used to solve
          // it. Although it is not supported by IE8~IE10, fortunately it is a rare
          // scenario.

          el.style.pointerEvents = this._enterable ? 'auto' : 'none';
          this._show = true;
        },
        setContent: function setContent(content) {
          this.el.innerHTML = content == null ? '' : content;
        },
        setEnterable: function setEnterable(enterable) {
          this._enterable = enterable;
        },
        getSize: function getSize() {
          var el = this.el;
          return [el.clientWidth, el.clientHeight];
        },
        moveTo: function moveTo(zrX, zrY) {
          var styleCoord = this._styleCoord;
          makeStyleCoord(styleCoord, this._zr, this._appendToBody, zrX, zrY);
          var style = this.el.style;
          style.left = styleCoord[0] + 'px';
          style.top = styleCoord[1] + 'px';
        },
        hide: function hide() {
          this.el.style.display = 'none';
          this._show = false;
        },
        hideLater: function hideLater(time) {
          if (this._show && !(this._inContent && this._enterable)) {
            if (time) {
              this._hideDelay = time; // Set show false to avoid invoke hideLater multiple times

              this._show = false;
              this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);
            } else {
              this.hide();
            }
          }
        },
        isShow: function isShow() {
          return this._show;
        },
        dispose: function dispose() {
          this.el.parentNode.removeChild(this.el);
        },
        getOuterSize: function getOuterSize() {
          var width = this.el.clientWidth;
          var height = this.el.clientHeight; // Consider browser compatibility.
          // IE8 does not support getComputedStyle.

          if (document.defaultView && document.defaultView.getComputedStyle) {
            var stl = document.defaultView.getComputedStyle(this.el);

            if (stl) {
              width += parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);
              height += parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);
            }
          }

          return {
            width: width,
            height: height
          };
        }
      };
      var _default = TooltipContent;
      module.exports = _default;
      /***/
    },

    /***/
    "Bsck":
    /*!***********************************************!*\
      !*** ./node_modules/echarts/lib/data/Tree.js ***!
      \***********************************************/

    /*! no static exports found */

    /***/
    function Bsck(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var linkList = __webpack_require__(
      /*! ./helper/linkList */
      "Mdki");

      var List = __webpack_require__(
      /*! ./List */
      "YXkt");

      var createDimensions = __webpack_require__(
      /*! ./helper/createDimensions */
      "sdST");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Tree data structure
       *
       * @module echarts/data/Tree
       */

      /**
       * @constructor module:echarts/data/Tree~TreeNode
       * @param {string} name
       * @param {module:echarts/data/Tree} hostTree
       */


      var TreeNode = function TreeNode(name, hostTree) {
        /**
         * @type {string}
         */
        this.name = name || '';
        /**
         * Depth of node
         *
         * @type {number}
         * @readOnly
         */

        this.depth = 0;
        /**
         * Height of the subtree rooted at this node.
         * @type {number}
         * @readOnly
         */

        this.height = 0;
        /**
         * @type {module:echarts/data/Tree~TreeNode}
         * @readOnly
         */

        this.parentNode = null;
        /**
         * Reference to list item.
         * Do not persistent dataIndex outside,
         * besause it may be changed by list.
         * If dataIndex -1,
         * this node is logical deleted (filtered) in list.
         *
         * @type {Object}
         * @readOnly
         */

        this.dataIndex = -1;
        /**
         * @type {Array.<module:echarts/data/Tree~TreeNode>}
         * @readOnly
         */

        this.children = [];
        /**
         * @type {Array.<module:echarts/data/Tree~TreeNode>}
         * @pubilc
         */

        this.viewChildren = [];
        /**
         * @type {moduel:echarts/data/Tree}
         * @readOnly
         */

        this.hostTree = hostTree;
      };

      TreeNode.prototype = {
        constructor: TreeNode,

        /**
         * The node is removed.
         * @return {boolean} is removed.
         */
        isRemoved: function isRemoved() {
          return this.dataIndex < 0;
        },

        /**
         * Travel this subtree (include this node).
         * Usage:
         *    node.eachNode(function () { ... }); // preorder
         *    node.eachNode('preorder', function () { ... }); // preorder
         *    node.eachNode('postorder', function () { ... }); // postorder
         *    node.eachNode(
         *        {order: 'postorder', attr: 'viewChildren'},
         *        function () { ... }
         *    ); // postorder
         *
         * @param {(Object|string)} options If string, means order.
         * @param {string=} options.order 'preorder' or 'postorder'
         * @param {string=} options.attr 'children' or 'viewChildren'
         * @param {Function} cb If in preorder and return false,
         *                      its subtree will not be visited.
         * @param {Object} [context]
         */
        eachNode: function eachNode(options, cb, context) {
          if (typeof options === 'function') {
            context = cb;
            cb = options;
            options = null;
          }

          options = options || {};

          if (zrUtil.isString(options)) {
            options = {
              order: options
            };
          }

          var order = options.order || 'preorder';
          var children = this[options.attr || 'children'];
          var suppressVisitSub;
          order === 'preorder' && (suppressVisitSub = cb.call(context, this));

          for (var i = 0; !suppressVisitSub && i < children.length; i++) {
            children[i].eachNode(options, cb, context);
          }

          order === 'postorder' && cb.call(context, this);
        },

        /**
         * Update depth and height of this subtree.
         *
         * @param  {number} depth
         */
        updateDepthAndHeight: function updateDepthAndHeight(depth) {
          var height = 0;
          this.depth = depth;

          for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            child.updateDepthAndHeight(depth + 1);

            if (child.height > height) {
              height = child.height;
            }
          }

          this.height = height + 1;
        },

        /**
         * @param  {string} id
         * @return {module:echarts/data/Tree~TreeNode}
         */
        getNodeById: function getNodeById(id) {
          if (this.getId() === id) {
            return this;
          }

          for (var i = 0, children = this.children, len = children.length; i < len; i++) {
            var res = children[i].getNodeById(id);

            if (res) {
              return res;
            }
          }
        },

        /**
         * @param {module:echarts/data/Tree~TreeNode} node
         * @return {boolean}
         */
        contains: function contains(node) {
          if (node === this) {
            return true;
          }

          for (var i = 0, children = this.children, len = children.length; i < len; i++) {
            var res = children[i].contains(node);

            if (res) {
              return res;
            }
          }
        },

        /**
         * @param {boolean} includeSelf Default false.
         * @return {Array.<module:echarts/data/Tree~TreeNode>} order: [root, child, grandchild, ...]
         */
        getAncestors: function getAncestors(includeSelf) {
          var ancestors = [];
          var node = includeSelf ? this : this.parentNode;

          while (node) {
            ancestors.push(node);
            node = node.parentNode;
          }

          ancestors.reverse();
          return ancestors;
        },

        /**
         * @param {string|Array=} [dimension='value'] Default 'value'. can be 0, 1, 2, 3
         * @return {number} Value.
         */
        getValue: function getValue(dimension) {
          var data = this.hostTree.data;
          return data.get(data.getDimension(dimension || 'value'), this.dataIndex);
        },

        /**
         * @param {Object} layout
         * @param {boolean=} [merge=false]
         */
        setLayout: function setLayout(layout, merge) {
          this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout, merge);
        },

        /**
         * @return {Object} layout
         */
        getLayout: function getLayout() {
          return this.hostTree.data.getItemLayout(this.dataIndex);
        },

        /**
         * @param {string} [path]
         * @return {module:echarts/model/Model}
         */
        getModel: function getModel(path) {
          if (this.dataIndex < 0) {
            return;
          }

          var hostTree = this.hostTree;
          var itemModel = hostTree.data.getItemModel(this.dataIndex);
          return itemModel.getModel(path);
        },

        /**
         * @example
         *  setItemVisual('color', color);
         *  setItemVisual({
         *      'color': color
         *  });
         */
        setVisual: function setVisual(key, value) {
          this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);
        },

        /**
         * Get item visual
         */
        getVisual: function getVisual(key, ignoreParent) {
          return this.hostTree.data.getItemVisual(this.dataIndex, key, ignoreParent);
        },

        /**
         * @public
         * @return {number}
         */
        getRawIndex: function getRawIndex() {
          return this.hostTree.data.getRawIndex(this.dataIndex);
        },

        /**
         * @public
         * @return {string}
         */
        getId: function getId() {
          return this.hostTree.data.getId(this.dataIndex);
        },

        /**
         * if this is an ancestor of another node
         *
         * @public
         * @param {TreeNode} node another node
         * @return {boolean} if is ancestor
         */
        isAncestorOf: function isAncestorOf(node) {
          var parent = node.parentNode;

          while (parent) {
            if (parent === this) {
              return true;
            }

            parent = parent.parentNode;
          }

          return false;
        },

        /**
         * if this is an descendant of another node
         *
         * @public
         * @param {TreeNode} node another node
         * @return {boolean} if is descendant
         */
        isDescendantOf: function isDescendantOf(node) {
          return node !== this && node.isAncestorOf(this);
        }
      };
      /**
       * @constructor
       * @alias module:echarts/data/Tree
       * @param {module:echarts/model/Model} hostModel
       */

      function Tree(hostModel) {
        /**
         * @type {module:echarts/data/Tree~TreeNode}
         * @readOnly
         */
        this.root;
        /**
         * @type {module:echarts/data/List}
         * @readOnly
         */

        this.data;
        /**
         * Index of each item is the same as the raw index of coresponding list item.
         * @private
         * @type {Array.<module:echarts/data/Tree~TreeNode}
         */

        this._nodes = [];
        /**
         * @private
         * @readOnly
         * @type {module:echarts/model/Model}
         */

        this.hostModel = hostModel;
      }

      Tree.prototype = {
        constructor: Tree,
        type: 'tree',

        /**
         * Travel this subtree (include this node).
         * Usage:
         *    node.eachNode(function () { ... }); // preorder
         *    node.eachNode('preorder', function () { ... }); // preorder
         *    node.eachNode('postorder', function () { ... }); // postorder
         *    node.eachNode(
         *        {order: 'postorder', attr: 'viewChildren'},
         *        function () { ... }
         *    ); // postorder
         *
         * @param {(Object|string)} options If string, means order.
         * @param {string=} options.order 'preorder' or 'postorder'
         * @param {string=} options.attr 'children' or 'viewChildren'
         * @param {Function} cb
         * @param {Object}   [context]
         */
        eachNode: function eachNode(options, cb, context) {
          this.root.eachNode(options, cb, context);
        },

        /**
         * @param {number} dataIndex
         * @return {module:echarts/data/Tree~TreeNode}
         */
        getNodeByDataIndex: function getNodeByDataIndex(dataIndex) {
          var rawIndex = this.data.getRawIndex(dataIndex);
          return this._nodes[rawIndex];
        },

        /**
         * @param {string} name
         * @return {module:echarts/data/Tree~TreeNode}
         */
        getNodeByName: function getNodeByName(name) {
          return this.root.getNodeByName(name);
        },

        /**
         * Update item available by list,
         * when list has been performed options like 'filterSelf' or 'map'.
         */
        update: function update() {
          var data = this.data;
          var nodes = this._nodes;

          for (var i = 0, len = nodes.length; i < len; i++) {
            nodes[i].dataIndex = -1;
          }

          for (var i = 0, len = data.count(); i < len; i++) {
            nodes[data.getRawIndex(i)].dataIndex = i;
          }
        },

        /**
         * Clear all layouts
         */
        clearLayouts: function clearLayouts() {
          this.data.clearItemLayouts();
        }
      };
      /**
       * data node format:
       * {
       *     name: ...
       *     value: ...
       *     children: [
       *         {
       *             name: ...
       *             value: ...
       *             children: ...
       *         },
       *         ...
       *     ]
       * }
       *
       * @static
       * @param {Object} dataRoot Root node.
       * @param {module:echarts/model/Model} hostModel
       * @return module:echarts/data/Tree
       */

      Tree.createTree = function (dataRoot, hostModel, beforeLink) {
        var tree = new Tree(hostModel);
        var listData = [];
        var dimMax = 1;
        buildHierarchy(dataRoot);

        function buildHierarchy(dataNode, parentNode) {
          var value = dataNode.value;
          dimMax = Math.max(dimMax, zrUtil.isArray(value) ? value.length : 1);
          listData.push(dataNode);
          var node = new TreeNode(dataNode.name, tree);
          parentNode ? addChild(node, parentNode) : tree.root = node;

          tree._nodes.push(node);

          var children = dataNode.children;

          if (children) {
            for (var i = 0; i < children.length; i++) {
              buildHierarchy(children[i], node);
            }
          }
        }

        tree.root.updateDepthAndHeight(0);
        var dimensionsInfo = createDimensions(listData, {
          coordDimensions: ['value'],
          dimensionsCount: dimMax
        });
        var list = new List(dimensionsInfo, hostModel);
        list.initData(listData);
        beforeLink && beforeLink(list);
        linkList({
          mainData: list,
          struct: tree,
          structAttr: 'tree'
        });
        tree.update();
        return tree;
      };
      /**
       * It is needed to consider the mess of 'list', 'hostModel' when creating a TreeNote,
       * so this function is not ready and not necessary to be public.
       *
       * @param {(module:echarts/data/Tree~TreeNode|Object)} child
       */


      function addChild(child, node) {
        var children = node.children;

        if (child.parentNode === node) {
          return;
        }

        children.push(child);
        child.parentNode = node;
      }

      var _default = Tree;
      module.exports = _default;
      /***/
    },

    /***/
    "BuqR":
    /*!************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/visualMap/PiecewiseModel.js ***!
      \************************************************************************/

    /*! no static exports found */

    /***/
    function BuqR(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var VisualMapModel = __webpack_require__(
      /*! ./VisualMapModel */
      "6uqw");

      var VisualMapping = __webpack_require__(
      /*! ../../visual/VisualMapping */
      "XxSj");

      var visualDefault = __webpack_require__(
      /*! ../../visual/visualDefault */
      "YOMW");

      var _number = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var reformIntervals = _number.reformIntervals;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var PiecewiseModel = VisualMapModel.extend({
        type: 'visualMap.piecewise',

        /**
         * Order Rule:
         *
         * option.categories / option.pieces / option.text / option.selected:
         *     If !option.inverse,
         *     Order when vertical: ['top', ..., 'bottom'].
         *     Order when horizontal: ['left', ..., 'right'].
         *     If option.inverse, the meaning of
         *     the order should be reversed.
         *
         * this._pieceList:
         *     The order is always [low, ..., high].
         *
         * Mapping from location to low-high:
         *     If !option.inverse
         *     When vertical, top is high.
         *     When horizontal, right is high.
         *     If option.inverse, reverse.
         */

        /**
         * @protected
         */
        defaultOption: {
          selected: null,
          // Object. If not specified, means selected.
          // When pieces and splitNumber: {'0': true, '5': true}
          // When categories: {'cate1': false, 'cate3': true}
          // When selected === false, means all unselected.
          minOpen: false,
          // Whether include values that smaller than `min`.
          maxOpen: false,
          // Whether include values that bigger than `max`.
          align: 'auto',
          // 'auto', 'left', 'right'
          itemWidth: 20,
          // When put the controller vertically, it is the length of
          // horizontal side of each item. Otherwise, vertical side.
          itemHeight: 14,
          // When put the controller vertically, it is the length of
          // vertical side of each item. Otherwise, horizontal side.
          itemSymbol: 'roundRect',
          pieceList: null,
          // Each item is Object, with some of those attrs:
          // {min, max, lt, gt, lte, gte, value,
          // color, colorSaturation, colorAlpha, opacity,
          // symbol, symbolSize}, which customize the range or visual
          // coding of the certain piece. Besides, see "Order Rule".
          categories: null,
          // category names, like: ['some1', 'some2', 'some3'].
          // Attr min/max are ignored when categories set. See "Order Rule"
          splitNumber: 5,
          // If set to 5, auto split five pieces equally.
          // If set to 0 and component type not set, component type will be
          // determined as "continuous". (It is less reasonable but for ec2
          // compatibility, see echarts/component/visualMap/typeDefaulter)
          selectedMode: 'multiple',
          // Can be 'multiple' or 'single'.
          itemGap: 10,
          // The gap between two items, in px.
          hoverLink: true,
          // Enable hover highlight.
          showLabel: null // By default, when text is used, label will hide (the logic
          // is remained for compatibility reason)

        },

        /**
         * @override
         */
        optionUpdated: function optionUpdated(newOption, isInit) {
          PiecewiseModel.superApply(this, 'optionUpdated', arguments);
          /**
           * The order is always [low, ..., high].
           * [{text: string, interval: Array.<number>}, ...]
           * @private
           * @type {Array.<Object>}
           */

          this._pieceList = [];
          this.resetExtent();
          /**
           * 'pieces', 'categories', 'splitNumber'
           * @type {string}
           */

          var mode = this._mode = this._determineMode();

          resetMethods[this._mode].call(this);

          this._resetSelected(newOption, isInit);

          var categories = this.option.categories;
          this.resetVisual(function (mappingOption, state) {
            if (mode === 'categories') {
              mappingOption.mappingMethod = 'category';
              mappingOption.categories = zrUtil.clone(categories);
            } else {
              mappingOption.dataExtent = this.getExtent();
              mappingOption.mappingMethod = 'piecewise';
              mappingOption.pieceList = zrUtil.map(this._pieceList, function (piece) {
                var piece = zrUtil.clone(piece);

                if (state !== 'inRange') {
                  // FIXME
                  // outOfRange do not support special visual in pieces.
                  piece.visual = null;
                }

                return piece;
              });
            }
          });
        },

        /**
         * @protected
         * @override
         */
        completeVisualOption: function completeVisualOption() {
          // Consider this case:
          // visualMap: {
          //      pieces: [{symbol: 'circle', lt: 0}, {symbol: 'rect', gte: 0}]
          // }
          // where no inRange/outOfRange set but only pieces. So we should make
          // default inRange/outOfRange for this case, otherwise visuals that only
          // appear in `pieces` will not be taken into account in visual encoding.
          var option = this.option;
          var visualTypesInPieces = {};
          var visualTypes = VisualMapping.listVisualTypes();
          var isCategory = this.isCategory();
          zrUtil.each(option.pieces, function (piece) {
            zrUtil.each(visualTypes, function (visualType) {
              if (piece.hasOwnProperty(visualType)) {
                visualTypesInPieces[visualType] = 1;
              }
            });
          });
          zrUtil.each(visualTypesInPieces, function (v, visualType) {
            var exists = 0;
            zrUtil.each(this.stateList, function (state) {
              exists |= has(option, state, visualType) || has(option.target, state, visualType);
            }, this);
            !exists && zrUtil.each(this.stateList, function (state) {
              (option[state] || (option[state] = {}))[visualType] = visualDefault.get(visualType, state === 'inRange' ? 'active' : 'inactive', isCategory);
            });
          }, this);

          function has(obj, state, visualType) {
            return obj && obj[state] && (zrUtil.isObject(obj[state]) ? obj[state].hasOwnProperty(visualType) : obj[state] === visualType // e.g., inRange: 'symbol'
            );
          }

          VisualMapModel.prototype.completeVisualOption.apply(this, arguments);
        },
        _resetSelected: function _resetSelected(newOption, isInit) {
          var thisOption = this.option;
          var pieceList = this._pieceList; // Selected do not merge but all override.

          var selected = (isInit ? thisOption : newOption).selected || {};
          thisOption.selected = selected; // Consider 'not specified' means true.

          zrUtil.each(pieceList, function (piece, index) {
            var key = this.getSelectedMapKey(piece);

            if (!selected.hasOwnProperty(key)) {
              selected[key] = true;
            }
          }, this);

          if (thisOption.selectedMode === 'single') {
            // Ensure there is only one selected.
            var hasSel = false;
            zrUtil.each(pieceList, function (piece, index) {
              var key = this.getSelectedMapKey(piece);

              if (selected[key]) {
                hasSel ? selected[key] = false : hasSel = true;
              }
            }, this);
          } // thisOption.selectedMode === 'multiple', default: all selected.

        },

        /**
         * @public
         */
        getSelectedMapKey: function getSelectedMapKey(piece) {
          return this._mode === 'categories' ? piece.value + '' : piece.index + '';
        },

        /**
         * @public
         */
        getPieceList: function getPieceList() {
          return this._pieceList;
        },

        /**
         * @private
         * @return {string}
         */
        _determineMode: function _determineMode() {
          var option = this.option;
          return option.pieces && option.pieces.length > 0 ? 'pieces' : this.option.categories ? 'categories' : 'splitNumber';
        },

        /**
         * @public
         * @override
         */
        setSelected: function setSelected(selected) {
          this.option.selected = zrUtil.clone(selected);
        },

        /**
         * @public
         * @override
         */
        getValueState: function getValueState(value) {
          var index = VisualMapping.findPieceIndex(value, this._pieceList);
          return index != null ? this.option.selected[this.getSelectedMapKey(this._pieceList[index])] ? 'inRange' : 'outOfRange' : 'outOfRange';
        },

        /**
         * @public
         * @params {number} pieceIndex piece index in visualMapModel.getPieceList()
         * @return {Array.<Object>} [{seriesId, dataIndex: <Array.<number>>}, ...]
         */
        findTargetDataIndices: function findTargetDataIndices(pieceIndex) {
          var result = [];
          this.eachTargetSeries(function (seriesModel) {
            var dataIndices = [];
            var data = seriesModel.getData();
            data.each(this.getDataDimension(data), function (value, dataIndex) {
              // Should always base on model pieceList, because it is order sensitive.
              var pIdx = VisualMapping.findPieceIndex(value, this._pieceList);
              pIdx === pieceIndex && dataIndices.push(dataIndex);
            }, this);
            result.push({
              seriesId: seriesModel.id,
              dataIndex: dataIndices
            });
          }, this);
          return result;
        },

        /**
         * @private
         * @param {Object} piece piece.value or piece.interval is required.
         * @return {number} Can be Infinity or -Infinity
         */
        getRepresentValue: function getRepresentValue(piece) {
          var representValue;

          if (this.isCategory()) {
            representValue = piece.value;
          } else {
            if (piece.value != null) {
              representValue = piece.value;
            } else {
              var pieceInterval = piece.interval || [];
              representValue = pieceInterval[0] === -Infinity && pieceInterval[1] === Infinity ? 0 : (pieceInterval[0] + pieceInterval[1]) / 2;
            }
          }

          return representValue;
        },
        getVisualMeta: function getVisualMeta(getColorVisual) {
          // Do not support category. (category axis is ordinal, numerical)
          if (this.isCategory()) {
            return;
          }

          var stops = [];
          var outerColors = [];
          var visualMapModel = this;

          function setStop(interval, valueState) {
            var representValue = visualMapModel.getRepresentValue({
              interval: interval
            });

            if (!valueState) {
              valueState = visualMapModel.getValueState(representValue);
            }

            var color = getColorVisual(representValue, valueState);

            if (interval[0] === -Infinity) {
              outerColors[0] = color;
            } else if (interval[1] === Infinity) {
              outerColors[1] = color;
            } else {
              stops.push({
                value: interval[0],
                color: color
              }, {
                value: interval[1],
                color: color
              });
            }
          } // Suplement


          var pieceList = this._pieceList.slice();

          if (!pieceList.length) {
            pieceList.push({
              interval: [-Infinity, Infinity]
            });
          } else {
            var edge = pieceList[0].interval[0];
            edge !== -Infinity && pieceList.unshift({
              interval: [-Infinity, edge]
            });
            edge = pieceList[pieceList.length - 1].interval[1];
            edge !== Infinity && pieceList.push({
              interval: [edge, Infinity]
            });
          }

          var curr = -Infinity;
          zrUtil.each(pieceList, function (piece) {
            var interval = piece.interval;

            if (interval) {
              // Fulfill gap.
              interval[0] > curr && setStop([curr, interval[0]], 'outOfRange');
              setStop(interval.slice());
              curr = interval[1];
            }
          }, this);
          return {
            stops: stops,
            outerColors: outerColors
          };
        }
      });
      /**
       * Key is this._mode
       * @type {Object}
       * @this {module:echarts/component/viusalMap/PiecewiseMode}
       */

      var resetMethods = {
        splitNumber: function splitNumber() {
          var thisOption = this.option;
          var pieceList = this._pieceList;
          var precision = Math.min(thisOption.precision, 20);
          var dataExtent = this.getExtent();
          var splitNumber = thisOption.splitNumber;
          splitNumber = Math.max(parseInt(splitNumber, 10), 1);
          thisOption.splitNumber = splitNumber;
          var splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber; // Precision auto-adaption

          while (+splitStep.toFixed(precision) !== splitStep && precision < 5) {
            precision++;
          }

          thisOption.precision = precision;
          splitStep = +splitStep.toFixed(precision);

          if (thisOption.minOpen) {
            pieceList.push({
              interval: [-Infinity, dataExtent[0]],
              close: [0, 0]
            });
          }

          for (var index = 0, curr = dataExtent[0]; index < splitNumber; curr += splitStep, index++) {
            var max = index === splitNumber - 1 ? dataExtent[1] : curr + splitStep;
            pieceList.push({
              interval: [curr, max],
              close: [1, 1]
            });
          }

          if (thisOption.maxOpen) {
            pieceList.push({
              interval: [dataExtent[1], Infinity],
              close: [0, 0]
            });
          }

          reformIntervals(pieceList);
          zrUtil.each(pieceList, function (piece, index) {
            piece.index = index;
            piece.text = this.formatValueText(piece.interval);
          }, this);
        },
        categories: function categories() {
          var thisOption = this.option;
          zrUtil.each(thisOption.categories, function (cate) {
            // FIXME categorypieceListvisualMappingpieceList
            // 
            this._pieceList.push({
              text: this.formatValueText(cate, true),
              value: cate
            });
          }, this); // See "Order Rule".

          normalizeReverse(thisOption, this._pieceList);
        },
        pieces: function pieces() {
          var thisOption = this.option;
          var pieceList = this._pieceList;
          zrUtil.each(thisOption.pieces, function (pieceListItem, index) {
            if (!zrUtil.isObject(pieceListItem)) {
              pieceListItem = {
                value: pieceListItem
              };
            }

            var item = {
              text: '',
              index: index
            };

            if (pieceListItem.label != null) {
              item.text = pieceListItem.label;
            }

            if (pieceListItem.hasOwnProperty('value')) {
              var value = item.value = pieceListItem.value;
              item.interval = [value, value];
              item.close = [1, 1];
            } else {
              // `min` `max` is legacy option.
              // `lt` `gt` `lte` `gte` is recommanded.
              var interval = item.interval = [];
              var close = item.close = [0, 0];
              var closeList = [1, 0, 1];
              var infinityList = [-Infinity, Infinity];
              var useMinMax = [];

              for (var lg = 0; lg < 2; lg++) {
                var names = [['gte', 'gt', 'min'], ['lte', 'lt', 'max']][lg];

                for (var i = 0; i < 3 && interval[lg] == null; i++) {
                  interval[lg] = pieceListItem[names[i]];
                  close[lg] = closeList[i];
                  useMinMax[lg] = i === 2;
                }

                interval[lg] == null && (interval[lg] = infinityList[lg]);
              }

              useMinMax[0] && interval[1] === Infinity && (close[0] = 0);
              useMinMax[1] && interval[0] === -Infinity && (close[1] = 0);

              if (interval[0] === interval[1] && close[0] && close[1]) {
                // Consider: [{min: 5, max: 5, visual: {...}}, {min: 0, max: 5}],
                // we use value to lift the priority when min === max
                item.value = interval[0];
              }
            }

            item.visual = VisualMapping.retrieveVisuals(pieceListItem);
            pieceList.push(item);
          }, this); // See "Order Rule".

          normalizeReverse(thisOption, pieceList); // Only pieces

          reformIntervals(pieceList);
          zrUtil.each(pieceList, function (piece) {
            var close = piece.close;
            var edgeSymbols = [['<', ''][close[1]], ['>', ''][close[0]]];
            piece.text = piece.text || this.formatValueText(piece.value != null ? piece.value : piece.interval, false, edgeSymbols);
          }, this);
        }
      };

      function normalizeReverse(thisOption, pieceList) {
        var inverse = thisOption.inverse;

        if (thisOption.orient === 'vertical' ? !inverse : inverse) {
          pieceList.reverse();
        }
      }

      var _default = PiecewiseModel;
      module.exports = _default;
      /***/
    },

    /***/
    "C0tN":
    /*!************************************************************!*\
      !*** ./node_modules/echarts/lib/component/legendScroll.js ***!
      \************************************************************/

    /*! no static exports found */

    /***/
    function C0tN(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      __webpack_require__(
      /*! ./legend */
      "0o9m");

      __webpack_require__(
      /*! ./legend/ScrollableLegendModel */
      "8Uz6");

      __webpack_require__(
      /*! ./legend/ScrollableLegendView */
      "Ducp");

      __webpack_require__(
      /*! ./legend/scrollableLegendAction */
      "6/nd");
      /***/

    },

    /***/
    "CBdT":
    /*!****************************************************!*\
      !*** ./node_modules/echarts/lib/chart/parallel.js ***!
      \****************************************************/

    /*! no static exports found */

    /***/
    function CBdT(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ../component/parallel */
      "8waO");

      __webpack_require__(
      /*! ./parallel/ParallelSeries */
      "AEZ6");

      __webpack_require__(
      /*! ./parallel/ParallelView */
      "YNf1");

      var parallelVisual = __webpack_require__(
      /*! ./parallel/parallelVisual */
      "q3GZ");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      echarts.registerVisual(parallelVisual);
      /***/
    },

    /***/
    "CF2D":
    /*!*******************************************************!*\
      !*** ./node_modules/echarts/lib/chart/candlestick.js ***!
      \*******************************************************/

    /*! no static exports found */

    /***/
    function CF2D(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ./candlestick/CandlestickSeries */
      "vZI5");

      __webpack_require__(
      /*! ./candlestick/CandlestickView */
      "GeKi");

      var preprocessor = __webpack_require__(
      /*! ./candlestick/preprocessor */
      "6r85");

      var candlestickVisual = __webpack_require__(
      /*! ./candlestick/candlestickVisual */
      "TJmX");

      var candlestickLayout = __webpack_require__(
      /*! ./candlestick/candlestickLayout */
      "CbHG");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      echarts.registerPreprocessor(preprocessor);
      echarts.registerVisual(candlestickVisual);
      echarts.registerLayout(candlestickLayout);
      /***/
    },

    /***/
    "CMP+":
    /*!*********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/timeline/TimelineAxis.js ***!
      \*********************************************************************/

    /*! no static exports found */

    /***/
    function CMP(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var Axis = __webpack_require__(
      /*! ../../coord/Axis */
      "hM6l");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Extend axis 2d
       * @constructor module:echarts/coord/cartesian/Axis2D
       * @extends {module:echarts/coord/cartesian/Axis}
       * @param {string} dim
       * @param {*} scale
       * @param {Array.<number>} coordExtent
       * @param {string} axisType
       * @param {string} position
       */


      var TimelineAxis = function TimelineAxis(dim, scale, coordExtent, axisType) {
        Axis.call(this, dim, scale, coordExtent);
        /**
         * Axis type
         *  - 'category'
         *  - 'value'
         *  - 'time'
         *  - 'log'
         * @type {string}
         */

        this.type = axisType || 'value';
        /**
         * Axis model
         * @param {module:echarts/component/TimelineModel}
         */

        this.model = null;
      };

      TimelineAxis.prototype = {
        constructor: TimelineAxis,

        /**
         * @override
         */
        getLabelModel: function getLabelModel() {
          return this.model.getModel('label');
        },

        /**
         * @override
         */
        isHorizontal: function isHorizontal() {
          return this.model.get('orient') === 'horizontal';
        }
      };
      zrUtil.inherits(TimelineAxis, Axis);
      var _default = TimelineAxis;
      module.exports = _default;
      /***/
    },

    /***/
    "CbHG":
    /*!*************************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/candlestick/candlestickLayout.js ***!
      \*************************************************************************/

    /*! no static exports found */

    /***/
    function CbHG(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var subPixelOptimize = _graphic.subPixelOptimize;

      var createRenderPlanner = __webpack_require__(
      /*! ../helper/createRenderPlanner */
      "zM3Q");

      var _number = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var parsePercent = _number.parsePercent;

      var _util = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var retrieve2 = _util.retrieve2;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /* global Float32Array */

      var LargeArr = typeof Float32Array !== 'undefined' ? Float32Array : Array;
      var _default = {
        seriesType: 'candlestick',
        plan: createRenderPlanner(),
        reset: function reset(seriesModel) {
          var coordSys = seriesModel.coordinateSystem;
          var data = seriesModel.getData();
          var candleWidth = calculateCandleWidth(seriesModel, data);
          var cDimIdx = 0;
          var vDimIdx = 1;
          var coordDims = ['x', 'y'];
          var cDim = data.mapDimension(coordDims[cDimIdx]);
          var vDims = data.mapDimension(coordDims[vDimIdx], true);
          var openDim = vDims[0];
          var closeDim = vDims[1];
          var lowestDim = vDims[2];
          var highestDim = vDims[3];
          data.setLayout({
            candleWidth: candleWidth,
            // The value is experimented visually.
            isSimpleBox: candleWidth <= 1.3
          });

          if (cDim == null || vDims.length < 4) {
            return;
          }

          return {
            progress: seriesModel.pipelineContext.large ? largeProgress : normalProgress
          };

          function normalProgress(params, data) {
            var dataIndex;

            while ((dataIndex = params.next()) != null) {
              var axisDimVal = data.get(cDim, dataIndex);
              var openVal = data.get(openDim, dataIndex);
              var closeVal = data.get(closeDim, dataIndex);
              var lowestVal = data.get(lowestDim, dataIndex);
              var highestVal = data.get(highestDim, dataIndex);
              var ocLow = Math.min(openVal, closeVal);
              var ocHigh = Math.max(openVal, closeVal);
              var ocLowPoint = getPoint(ocLow, axisDimVal);
              var ocHighPoint = getPoint(ocHigh, axisDimVal);
              var lowestPoint = getPoint(lowestVal, axisDimVal);
              var highestPoint = getPoint(highestVal, axisDimVal);
              var ends = [];
              addBodyEnd(ends, ocHighPoint, 0);
              addBodyEnd(ends, ocLowPoint, 1);
              ends.push(subPixelOptimizePoint(highestPoint), subPixelOptimizePoint(ocHighPoint), subPixelOptimizePoint(lowestPoint), subPixelOptimizePoint(ocLowPoint));
              data.setItemLayout(dataIndex, {
                sign: getSign(data, dataIndex, openVal, closeVal, closeDim),
                initBaseline: openVal > closeVal ? ocHighPoint[vDimIdx] : ocLowPoint[vDimIdx],
                // open point.
                ends: ends,
                brushRect: makeBrushRect(lowestVal, highestVal, axisDimVal)
              });
            }

            function getPoint(val, axisDimVal) {
              var p = [];
              p[cDimIdx] = axisDimVal;
              p[vDimIdx] = val;
              return isNaN(axisDimVal) || isNaN(val) ? [NaN, NaN] : coordSys.dataToPoint(p);
            }

            function addBodyEnd(ends, point, start) {
              var point1 = point.slice();
              var point2 = point.slice();
              point1[cDimIdx] = subPixelOptimize(point1[cDimIdx] + candleWidth / 2, 1, false);
              point2[cDimIdx] = subPixelOptimize(point2[cDimIdx] - candleWidth / 2, 1, true);
              start ? ends.push(point1, point2) : ends.push(point2, point1);
            }

            function makeBrushRect(lowestVal, highestVal, axisDimVal) {
              var pmin = getPoint(lowestVal, axisDimVal);
              var pmax = getPoint(highestVal, axisDimVal);
              pmin[cDimIdx] -= candleWidth / 2;
              pmax[cDimIdx] -= candleWidth / 2;
              return {
                x: pmin[0],
                y: pmin[1],
                width: vDimIdx ? candleWidth : pmax[0] - pmin[0],
                height: vDimIdx ? pmax[1] - pmin[1] : candleWidth
              };
            }

            function subPixelOptimizePoint(point) {
              point[cDimIdx] = subPixelOptimize(point[cDimIdx], 1);
              return point;
            }
          }

          function largeProgress(params, data) {
            // Structure: [sign, x, yhigh, ylow, sign, x, yhigh, ylow, ...]
            var points = new LargeArr(params.count * 4);
            var offset = 0;
            var point;
            var tmpIn = [];
            var tmpOut = [];
            var dataIndex;

            while ((dataIndex = params.next()) != null) {
              var axisDimVal = data.get(cDim, dataIndex);
              var openVal = data.get(openDim, dataIndex);
              var closeVal = data.get(closeDim, dataIndex);
              var lowestVal = data.get(lowestDim, dataIndex);
              var highestVal = data.get(highestDim, dataIndex);

              if (isNaN(axisDimVal) || isNaN(lowestVal) || isNaN(highestVal)) {
                points[offset++] = NaN;
                offset += 3;
                continue;
              }

              points[offset++] = getSign(data, dataIndex, openVal, closeVal, closeDim);
              tmpIn[cDimIdx] = axisDimVal;
              tmpIn[vDimIdx] = lowestVal;
              point = coordSys.dataToPoint(tmpIn, null, tmpOut);
              points[offset++] = point ? point[0] : NaN;
              points[offset++] = point ? point[1] : NaN;
              tmpIn[vDimIdx] = highestVal;
              point = coordSys.dataToPoint(tmpIn, null, tmpOut);
              points[offset++] = point ? point[1] : NaN;
            }

            data.setLayout('largePoints', points);
          }
        }
      };

      function getSign(data, dataIndex, openVal, closeVal, closeDim) {
        var sign;

        if (openVal > closeVal) {
          sign = -1;
        } else if (openVal < closeVal) {
          sign = 1;
        } else {
          sign = dataIndex > 0 // If close === open, compare with close of last record
          ? data.get(closeDim, dataIndex - 1) <= closeVal ? 1 : -1 : // No record of previous, set to be positive
          1;
        }

        return sign;
      }

      function calculateCandleWidth(seriesModel, data) {
        var baseAxis = seriesModel.getBaseAxis();
        var extent;
        var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : (extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / data.count());
        var barMaxWidth = parsePercent(retrieve2(seriesModel.get('barMaxWidth'), bandWidth), bandWidth);
        var barMinWidth = parsePercent(retrieve2(seriesModel.get('barMinWidth'), 1), bandWidth);
        var barWidth = seriesModel.get('barWidth');
        return barWidth != null ? parsePercent(barWidth, bandWidth) // Put max outer to ensure bar visible in spite of overlap.
        : Math.max(Math.min(bandWidth / 2, barMaxWidth), barMinWidth);
      }

      module.exports = _default;
      /***/
    },

    /***/
    "Cm0C":
    /*!********************************************************!*\
      !*** ./node_modules/echarts/lib/component/dataZoom.js ***!
      \********************************************************/

    /*! no static exports found */

    /***/
    function Cm0C(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      __webpack_require__(
      /*! ./dataZoomSlider */
      "5NHt");

      __webpack_require__(
      /*! ./dataZoomInside */
      "f3JH");
      /***/

    },

    /***/
    "D1WM":
    /*!*****************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/parallel/ParallelAxis.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function D1WM(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var Axis = __webpack_require__(
      /*! ../Axis */
      "hM6l");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @constructor module:echarts/coord/parallel/ParallelAxis
       * @extends {module:echarts/coord/Axis}
       * @param {string} dim
       * @param {*} scale
       * @param {Array.<number>} coordExtent
       * @param {string} axisType
       */


      var ParallelAxis = function ParallelAxis(dim, scale, coordExtent, axisType, axisIndex) {
        Axis.call(this, dim, scale, coordExtent);
        /**
         * Axis type
         *  - 'category'
         *  - 'value'
         *  - 'time'
         *  - 'log'
         * @type {string}
         */

        this.type = axisType || 'value';
        /**
         * @type {number}
         * @readOnly
         */

        this.axisIndex = axisIndex;
      };

      ParallelAxis.prototype = {
        constructor: ParallelAxis,

        /**
         * Axis model
         * @param {module:echarts/coord/parallel/AxisModel}
         */
        model: null,

        /**
         * @override
         */
        isHorizontal: function isHorizontal() {
          return this.coordinateSystem.getModel().get('layout') !== 'horizontal';
        }
      };
      zrUtil.inherits(ParallelAxis, Axis);
      var _default = ParallelAxis;
      module.exports = _default;
      /***/
    },

    /***/
    "D9ME":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/helper/EffectLine.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function D9ME(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var Line = __webpack_require__(
      /*! ./Line */
      "fls0");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _symbol = __webpack_require__(
      /*! ../../util/symbol */
      "oVpE");

      var createSymbol = _symbol.createSymbol;

      var vec2 = __webpack_require__(
      /*! zrender/lib/core/vector */
      "QBsz");

      var curveUtil = __webpack_require__(
      /*! zrender/lib/core/curve */
      "Sj9i");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Provide effect for line
       * @module echarts/chart/helper/EffectLine
       */

      /**
       * @constructor
       * @extends {module:zrender/graphic/Group}
       * @alias {module:echarts/chart/helper/Line}
       */


      function EffectLine(lineData, idx, seriesScope) {
        graphic.Group.call(this);
        this.add(this.createLine(lineData, idx, seriesScope));

        this._updateEffectSymbol(lineData, idx);
      }

      var effectLineProto = EffectLine.prototype;

      effectLineProto.createLine = function (lineData, idx, seriesScope) {
        return new Line(lineData, idx, seriesScope);
      };

      effectLineProto._updateEffectSymbol = function (lineData, idx) {
        var itemModel = lineData.getItemModel(idx);
        var effectModel = itemModel.getModel('effect');
        var size = effectModel.get('symbolSize');
        var symbolType = effectModel.get('symbol');

        if (!zrUtil.isArray(size)) {
          size = [size, size];
        }

        var color = effectModel.get('color') || lineData.getItemVisual(idx, 'color');
        var symbol = this.childAt(1);

        if (this._symbolType !== symbolType) {
          // Remove previous
          this.remove(symbol);
          symbol = createSymbol(symbolType, -0.5, -0.5, 1, 1, color);
          symbol.z2 = 100;
          symbol.culling = true;
          this.add(symbol);
        } // Symbol may be removed if loop is false


        if (!symbol) {
          return;
        } // Shadow color is same with color in default


        symbol.setStyle('shadowColor', color);
        symbol.setStyle(effectModel.getItemStyle(['color']));
        symbol.attr('scale', size);
        symbol.setColor(color);
        symbol.attr('scale', size);
        this._symbolType = symbolType;
        this._symbolScale = size;

        this._updateEffectAnimation(lineData, effectModel, idx);
      };

      effectLineProto._updateEffectAnimation = function (lineData, effectModel, idx) {
        var symbol = this.childAt(1);

        if (!symbol) {
          return;
        }

        var self = this;
        var points = lineData.getItemLayout(idx);
        var period = effectModel.get('period') * 1000;
        var loop = effectModel.get('loop');
        var constantSpeed = effectModel.get('constantSpeed');
        var delayExpr = zrUtil.retrieve(effectModel.get('delay'), function (idx) {
          return idx / lineData.count() * period / 3;
        });
        var isDelayFunc = typeof delayExpr === 'function'; // Ignore when updating

        symbol.ignore = true;
        this.updateAnimationPoints(symbol, points);

        if (constantSpeed > 0) {
          period = this.getLineLength(symbol) / constantSpeed * 1000;
        }

        if (period !== this._period || loop !== this._loop) {
          symbol.stopAnimation();
          var delay = delayExpr;

          if (isDelayFunc) {
            delay = delayExpr(idx);
          }

          if (symbol.__t > 0) {
            delay = -period * symbol.__t;
          }

          symbol.__t = 0;
          var animator = symbol.animate('', loop).when(period, {
            __t: 1
          }).delay(delay).during(function () {
            self.updateSymbolPosition(symbol);
          });

          if (!loop) {
            animator.done(function () {
              self.remove(symbol);
            });
          }

          animator.start();
        }

        this._period = period;
        this._loop = loop;
      };

      effectLineProto.getLineLength = function (symbol) {
        // Not so accurate
        return vec2.dist(symbol.__p1, symbol.__cp1) + vec2.dist(symbol.__cp1, symbol.__p2);
      };

      effectLineProto.updateAnimationPoints = function (symbol, points) {
        symbol.__p1 = points[0];
        symbol.__p2 = points[1];
        symbol.__cp1 = points[2] || [(points[0][0] + points[1][0]) / 2, (points[0][1] + points[1][1]) / 2];
      };

      effectLineProto.updateData = function (lineData, idx, seriesScope) {
        this.childAt(0).updateData(lineData, idx, seriesScope);

        this._updateEffectSymbol(lineData, idx);
      };

      effectLineProto.updateSymbolPosition = function (symbol) {
        var p1 = symbol.__p1;
        var p2 = symbol.__p2;
        var cp1 = symbol.__cp1;
        var t = symbol.__t;
        var pos = symbol.position;
        var lastPos = [pos[0], pos[1]];
        var quadraticAt = curveUtil.quadraticAt;
        var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;
        pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);
        pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t); // Tangent

        var tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);
        var ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);
        symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2; // enable continuity trail for 'line', 'rect', 'roundRect' symbolType

        if (this._symbolType === 'line' || this._symbolType === 'rect' || this._symbolType === 'roundRect') {
          if (symbol.__lastT !== undefined && symbol.__lastT < symbol.__t) {
            var scaleY = vec2.dist(lastPos, pos) * 1.05;
            symbol.attr('scale', [symbol.scale[0], scaleY]); // make sure the last segment render within endPoint

            if (t === 1) {
              pos[0] = lastPos[0] + (pos[0] - lastPos[0]) / 2;
              pos[1] = lastPos[1] + (pos[1] - lastPos[1]) / 2;
            }
          } else if (symbol.__lastT === 1) {
            // After first loop, symbol.__t does NOT start with 0, so connect p1 to pos directly.
            var scaleY = 2 * vec2.dist(p1, pos);
            symbol.attr('scale', [symbol.scale[0], scaleY]);
          } else {
            symbol.attr('scale', this._symbolScale);
          }
        }

        symbol.__lastT = symbol.__t;
        symbol.ignore = false;
      };

      effectLineProto.updateLayout = function (lineData, idx) {
        this.childAt(0).updateLayout(lineData, idx);
        var effectModel = lineData.getItemModel(idx).getModel('effect');

        this._updateEffectAnimation(lineData, effectModel, idx);
      };

      zrUtil.inherits(EffectLine, graphic.Group);
      var _default = EffectLine;
      module.exports = _default;
      /***/
    },

    /***/
    "DBLp":
    /*!*****************************************************!*\
      !*** ./node_modules/zrender/lib/core/arrayDiff2.js ***!
      \*****************************************************/

    /*! no static exports found */

    /***/
    function DBLp(module, exports) {
      // Myers' Diff Algorithm
      // Modified from https://github.com/kpdecker/jsdiff/blob/master/src/diff/base.js
      function Diff() {}

      Diff.prototype = {
        diff: function diff(oldArr, newArr, equals) {
          if (!equals) {
            equals = function equals(a, b) {
              return a === b;
            };
          }

          this.equals = equals;
          var self = this;
          oldArr = oldArr.slice();
          newArr = newArr.slice(); // Allow subclasses to massage the input prior to running

          var newLen = newArr.length;
          var oldLen = oldArr.length;
          var editLength = 1;
          var maxEditLength = newLen + oldLen;
          var bestPath = [{
            newPos: -1,
            components: []
          }]; // Seed editLength = 0, i.e. the content starts with the same values

          var oldPos = this.extractCommon(bestPath[0], newArr, oldArr, 0);

          if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
            var indices = [];

            for (var i = 0; i < newArr.length; i++) {
              indices.push(i);
            } // Identity per the equality and tokenizer


            return [{
              indices: indices,
              count: newArr.length
            }];
          } // Main worker method. checks all permutations of a given edit length for acceptance.


          function execEditLength() {
            for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
              var basePath;
              var addPath = bestPath[diagonalPath - 1];
              var removePath = bestPath[diagonalPath + 1];
              var oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;

              if (addPath) {
                // No one else is going to attempt to use this value, clear it
                bestPath[diagonalPath - 1] = undefined;
              }

              var canAdd = addPath && addPath.newPos + 1 < newLen;
              var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;

              if (!canAdd && !canRemove) {
                // If this path is a terminal then prune
                bestPath[diagonalPath] = undefined;
                continue;
              } // Select the diagonal that we want to branch from. We select the prior
              // path whose position in the new string is the farthest from the origin
              // and does not pass the bounds of the diff graph


              if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
                basePath = clonePath(removePath);
                self.pushComponent(basePath.components, undefined, true);
              } else {
                basePath = addPath; // No need to clone, we've pulled it from the list

                basePath.newPos++;
                self.pushComponent(basePath.components, true, undefined);
              }

              oldPos = self.extractCommon(basePath, newArr, oldArr, diagonalPath); // If we have hit the end of both strings, then we are done

              if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
                return buildValues(self, basePath.components, newArr, oldArr);
              } else {
                // Otherwise track this path as a potential candidate and continue.
                bestPath[diagonalPath] = basePath;
              }
            }

            editLength++;
          }

          while (editLength <= maxEditLength) {
            var ret = execEditLength();

            if (ret) {
              return ret;
            }
          }
        },
        pushComponent: function pushComponent(components, added, removed) {
          var last = components[components.length - 1];

          if (last && last.added === added && last.removed === removed) {
            // We need to clone here as the component clone operation is just
            // as shallow array clone
            components[components.length - 1] = {
              count: last.count + 1,
              added: added,
              removed: removed
            };
          } else {
            components.push({
              count: 1,
              added: added,
              removed: removed
            });
          }
        },
        extractCommon: function extractCommon(basePath, newArr, oldArr, diagonalPath) {
          var newLen = newArr.length;
          var oldLen = oldArr.length;
          var newPos = basePath.newPos;
          var oldPos = newPos - diagonalPath;
          var commonCount = 0;

          while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newArr[newPos + 1], oldArr[oldPos + 1])) {
            newPos++;
            oldPos++;
            commonCount++;
          }

          if (commonCount) {
            basePath.components.push({
              count: commonCount
            });
          }

          basePath.newPos = newPos;
          return oldPos;
        },
        tokenize: function tokenize(value) {
          return value.slice();
        },
        join: function join(value) {
          return value.slice();
        }
      };

      function buildValues(diff, components, newArr, oldArr) {
        var componentPos = 0;
        var componentLen = components.length;
        var newPos = 0;
        var oldPos = 0;

        for (; componentPos < componentLen; componentPos++) {
          var component = components[componentPos];

          if (!component.removed) {
            var indices = [];

            for (var i = newPos; i < newPos + component.count; i++) {
              indices.push(i);
            }

            component.indices = indices;
            newPos += component.count; // Common case

            if (!component.added) {
              oldPos += component.count;
            }
          } else {
            var indices = [];

            for (var i = oldPos; i < oldPos + component.count; i++) {
              indices.push(i);
            }

            component.indices = indices;
            oldPos += component.count;
          }
        }

        return components;
      }

      function clonePath(path) {
        return {
          newPos: path.newPos,
          components: path.components.slice(0)
        };
      }

      var arrayDiff = new Diff();

      function _default(oldArr, newArr, callback) {
        return arrayDiff.diff(oldArr, newArr, callback);
      }

      module.exports = _default;
      /***/
    },

    /***/
    "DDd/":
    /*!**************************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/helper/multipleGraphEdgeHelper.js ***!
      \**************************************************************************/

    /*! no static exports found */

    /***/
    function DDd(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var KEY_DELIMITER = '-->';
      /**
       * params handler
       * @param {module:echarts/model/SeriesModel} seriesModel
       * @returns {*}
       */

      var getAutoCurvenessParams = function getAutoCurvenessParams(seriesModel) {
        return seriesModel.get('autoCurveness') || null;
      };
      /**
       * Generate a list of edge curvatures, 20 is the default
       * @param {module:echarts/model/SeriesModel} seriesModel
       * @param {number} appendLength
       * @return  20 => [0, -0.2, 0.2, -0.4, 0.4, -0.6, 0.6, -0.8, 0.8, -1, 1, -1.2, 1.2, -1.4, 1.4, -1.6, 1.6, -1.8, 1.8, -2]
       */


      var createCurveness = function createCurveness(seriesModel, appendLength) {
        var autoCurvenessParmas = getAutoCurvenessParams(seriesModel);
        var length = 20;
        var curvenessList = []; // handler the function set

        if (typeof autoCurvenessParmas === 'number') {
          length = autoCurvenessParmas;
        } else if (zrUtil.isArray(autoCurvenessParmas)) {
          seriesModel.__curvenessList = autoCurvenessParmas;
          return;
        } // append length


        if (appendLength > length) {
          length = appendLength;
        } // make sure the length is even


        var len = length % 2 ? length + 2 : length + 3;
        curvenessList = [];

        for (var i = 0; i < len; i++) {
          curvenessList.push((i % 2 ? i + 1 : i) / 10 * (i % 2 ? -1 : 1));
        }

        seriesModel.__curvenessList = curvenessList;
      };
      /**
       * Create different cache key data in the positive and negative directions, in order to set the curvature later
       * @param {number|string|module:echarts/data/Graph.Node} n1
       * @param {number|string|module:echarts/data/Graph.Node} n2
       * @param {module:echarts/model/SeriesModel} seriesModel
       * @returns {string} key
       */


      var getKeyOfEdges = function getKeyOfEdges(n1, n2, seriesModel) {
        var source = [n1.id, n1.dataIndex].join('.');
        var target = [n2.id, n2.dataIndex].join('.');
        return [seriesModel.uid, source, target].join(KEY_DELIMITER);
      };
      /**
       * get opposite key
       * @param {string} key
       * @returns {string}
       */


      var getOppositeKey = function getOppositeKey(key) {
        var keys = key.split(KEY_DELIMITER);
        return [keys[0], keys[2], keys[1]].join(KEY_DELIMITER);
      };
      /**
       * get edgeMap with key
       * @param edge
       * @param {module:echarts/model/SeriesModel} seriesModel
       */


      var getEdgeFromMap = function getEdgeFromMap(edge, seriesModel) {
        var key = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
        return seriesModel.__edgeMap[key];
      };
      /**
       * calculate all cases total length
       * @param edge
       * @param seriesModel
       * @returns {number}
       */


      var getTotalLengthBetweenNodes = function getTotalLengthBetweenNodes(edge, seriesModel) {
        var len = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node1, edge.node2, seriesModel), seriesModel);
        var lenV = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node2, edge.node1, seriesModel), seriesModel);
        return len + lenV;
      };
      /**
       *
       * @param key
       */


      var getEdgeMapLengthWithKey = function getEdgeMapLengthWithKey(key, seriesModel) {
        var edgeMap = seriesModel.__edgeMap;
        return edgeMap[key] ? edgeMap[key].length : 0;
      };
      /**
       * Count the number of edges between the same two points, used to obtain the curvature table and the parity of the edge
       * @see /graph/GraphSeries.js@getInitialData
       * @param {module:echarts/model/SeriesModel} seriesModel
       */


      function initCurvenessList(seriesModel) {
        if (!getAutoCurvenessParams(seriesModel)) {
          return;
        }

        seriesModel.__curvenessList = [];
        seriesModel.__edgeMap = {}; // calc the array of curveness List

        createCurveness(seriesModel);
      }
      /**
       * set edgeMap with key
       * @param {number|string|module:echarts/data/Graph.Node} n1
       * @param {number|string|module:echarts/data/Graph.Node} n2
       * @param {module:echarts/model/SeriesModel} seriesModel
       * @param {number} index
       */


      function createEdgeMapForCurveness(n1, n2, seriesModel, index) {
        if (!getAutoCurvenessParams(seriesModel)) {
          return;
        }

        var key = getKeyOfEdges(n1, n2, seriesModel);
        var edgeMap = seriesModel.__edgeMap;
        var oppositeEdges = edgeMap[getOppositeKey(key)]; // set direction

        if (edgeMap[key] && !oppositeEdges) {
          edgeMap[key].isForward = true;
        } else if (oppositeEdges && edgeMap[key]) {
          oppositeEdges.isForward = true;
          edgeMap[key].isForward = false;
        }

        edgeMap[key] = edgeMap[key] || [];
        edgeMap[key].push(index);
      }
      /**
       * get curvature for edge
       * @param edge
       * @param {module:echarts/model/SeriesModel} seriesModel
       * @param index
       */


      function getCurvenessForEdge(edge, seriesModel, index, needReverse) {
        var autoCurvenessParams = getAutoCurvenessParams(seriesModel);
        var isArrayParam = zrUtil.isArray(autoCurvenessParams);

        if (!autoCurvenessParams) {
          return null;
        }

        var edgeArray = getEdgeFromMap(edge, seriesModel);

        if (!edgeArray) {
          return null;
        }

        var edgeIndex = -1;

        for (var i = 0; i < edgeArray.length; i++) {
          if (edgeArray[i] === index) {
            edgeIndex = i;
            break;
          }
        } // if totalLen is Longer createCurveness


        var totalLen = getTotalLengthBetweenNodes(edge, seriesModel);
        createCurveness(seriesModel, totalLen);
        edge.lineStyle = edge.lineStyle || {}; // if is opposite edge, must set curvenss to opposite number

        var curKey = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
        var curvenessList = seriesModel.__curvenessList; // if pass array no need parity

        var parityCorrection = isArrayParam ? 0 : totalLen % 2 ? 0 : 1;

        if (!edgeArray.isForward) {
          // the opposite edge show outside
          var oppositeKey = getOppositeKey(curKey);
          var len = getEdgeMapLengthWithKey(oppositeKey, seriesModel);
          var resValue = curvenessList[edgeIndex + len + parityCorrection]; // isNeedReverse, simple, force type need reverse the curveness in the junction of the forword and the opposite

          if (needReverse) {
            // set as array may make the parity handle with the len of opposite
            if (isArrayParam) {
              if (autoCurvenessParams && autoCurvenessParams[0] === 0) {
                return (len + parityCorrection) % 2 ? resValue : -resValue;
              } else {
                return ((len % 2 ? 0 : 1) + parityCorrection) % 2 ? resValue : -resValue;
              }
            } else {
              return (len + parityCorrection) % 2 ? resValue : -resValue;
            }
          } else {
            return curvenessList[edgeIndex + len + parityCorrection];
          }
        } else {
          return curvenessList[parityCorrection + edgeIndex];
        }
      }

      exports.initCurvenessList = initCurvenessList;
      exports.createEdgeMapForCurveness = createEdgeMapForCurveness;
      exports.getCurvenessForEdge = getCurvenessForEdge;
      /***/
    },

    /***/
    "DEFe":
    /*!**************************************************************!*\
      !*** ./node_modules/echarts/lib/component/helper/MapDraw.js ***!
      \**************************************************************/

    /*! no static exports found */

    /***/
    function DEFe(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var RoamController = __webpack_require__(
      /*! ./RoamController */
      "SgGq");

      var roamHelper = __webpack_require__(
      /*! ../../component/helper/roamHelper */
      "Ae+d");

      var _cursorHelper = __webpack_require__(
      /*! ../../component/helper/cursorHelper */
      "xSat");

      var onIrrelevantElement = _cursorHelper.onIrrelevantElement;

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var geoSourceManager = __webpack_require__(
      /*! ../../coord/geo/geoSourceManager */
      "W4dC");

      var _component = __webpack_require__(
      /*! ../../util/component */
      "iRjW");

      var getUID = _component.getUID;

      var Transformable = __webpack_require__(
      /*! zrender/lib/mixin/Transformable */
      "DN4a");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function getFixedItemStyle(model) {
        var itemStyle = model.getItemStyle();
        var areaColor = model.get('areaColor'); // If user want the color not to be changed when hover,
        // they should both set areaColor and color to be null.

        if (areaColor != null) {
          itemStyle.fill = areaColor;
        }

        return itemStyle;
      }

      function updateMapSelectHandler(mapDraw, mapOrGeoModel, regionsGroup, api, fromView) {
        regionsGroup.off('click');
        regionsGroup.off('mousedown');

        if (mapOrGeoModel.get('selectedMode')) {
          regionsGroup.on('mousedown', function () {
            mapDraw._mouseDownFlag = true;
          });
          regionsGroup.on('click', function (e) {
            if (!mapDraw._mouseDownFlag) {
              return;
            }

            mapDraw._mouseDownFlag = false;
            var el = e.target;

            while (!el.__regions) {
              el = el.parent;
            }

            if (!el) {
              return;
            }

            var action = {
              type: (mapOrGeoModel.mainType === 'geo' ? 'geo' : 'map') + 'ToggleSelect',
              batch: zrUtil.map(el.__regions, function (region) {
                return {
                  name: region.name,
                  from: fromView.uid
                };
              })
            };
            action[mapOrGeoModel.mainType + 'Id'] = mapOrGeoModel.id;
            api.dispatchAction(action);
            updateMapSelected(mapOrGeoModel, regionsGroup);
          });
        }
      }

      function updateMapSelected(mapOrGeoModel, regionsGroup) {
        // FIXME
        regionsGroup.eachChild(function (otherRegionEl) {
          zrUtil.each(otherRegionEl.__regions, function (region) {
            otherRegionEl.trigger(mapOrGeoModel.isSelected(region.name) ? 'emphasis' : 'normal');
          });
        });
      }
      /**
       * @alias module:echarts/component/helper/MapDraw
       * @param {module:echarts/ExtensionAPI} api
       * @param {boolean} updateGroup
       */


      function MapDraw(api, updateGroup) {
        var group = new graphic.Group();
        /**
         * @type {string}
         * @private
         */

        this.uid = getUID('ec_map_draw');
        /**
         * @type {module:echarts/component/helper/RoamController}
         * @private
         */

        this._controller = new RoamController(api.getZr());
        /**
         * @type {Object} {target, zoom, zoomLimit}
         * @private
         */

        this._controllerHost = {
          target: updateGroup ? group : null
        };
        /**
         * @type {module:zrender/container/Group}
         * @readOnly
         */

        this.group = group;
        /**
         * @type {boolean}
         * @private
         */

        this._updateGroup = updateGroup;
        /**
         * This flag is used to make sure that only one among
         * `pan`, `zoom`, `click` can occurs, otherwise 'selected'
         * action may be triggered when `pan`, which is unexpected.
         * @type {booelan}
         */

        this._mouseDownFlag;
        /**
         * @type {string}
         */

        this._mapName;
        /**
         * @type {boolean}
         */

        this._initialized;
        /**
         * @type {module:zrender/container/Group}
         */

        group.add(this._regionsGroup = new graphic.Group());
        /**
         * @type {module:zrender/container/Group}
         */

        group.add(this._backgroundGroup = new graphic.Group());
      }

      MapDraw.prototype = {
        constructor: MapDraw,
        draw: function draw(mapOrGeoModel, ecModel, api, fromView, payload) {
          var isGeo = mapOrGeoModel.mainType === 'geo'; // Map series has data. GEO model that controlled by map series
          // will be assigned with map data. Other GEO model has no data.

          var data = mapOrGeoModel.getData && mapOrGeoModel.getData();
          isGeo && ecModel.eachComponent({
            mainType: 'series',
            subType: 'map'
          }, function (mapSeries) {
            if (!data && mapSeries.getHostGeoModel() === mapOrGeoModel) {
              data = mapSeries.getData();
            }
          });
          var geo = mapOrGeoModel.coordinateSystem;

          this._updateBackground(geo);

          var regionsGroup = this._regionsGroup;
          var group = this.group;
          var transformInfo = geo.getTransformInfo(); // No animation when first draw or in action

          var isFirstDraw = !regionsGroup.childAt(0) || payload;
          var targetScale;

          if (isFirstDraw) {
            group.transform = transformInfo.roamTransform;
            group.decomposeTransform();
            group.dirty();
          } else {
            var target = new Transformable();
            target.transform = transformInfo.roamTransform;
            target.decomposeTransform();
            var props = {
              scale: target.scale,
              position: target.position
            };
            targetScale = target.scale;
            graphic.updateProps(group, props, mapOrGeoModel);
          }

          var scale = transformInfo.rawScale;
          var position = transformInfo.rawPosition;
          regionsGroup.removeAll();
          var itemStyleAccessPath = ['itemStyle'];
          var hoverItemStyleAccessPath = ['emphasis', 'itemStyle'];
          var labelAccessPath = ['label'];
          var hoverLabelAccessPath = ['emphasis', 'label'];
          var nameMap = zrUtil.createHashMap();
          zrUtil.each(geo.regions, function (region) {
            // Consider in GeoJson properties.name may be duplicated, for example,
            // there is multiple region named "United Kindom" or "France" (so many
            // colonies). And it is not appropriate to merge them in geo, which
            // will make them share the same label and bring trouble in label
            // location calculation.
            var regionGroup = nameMap.get(region.name) || nameMap.set(region.name, new graphic.Group());
            var compoundPath = new graphic.CompoundPath({
              segmentIgnoreThreshold: 1,
              shape: {
                paths: []
              }
            });
            regionGroup.add(compoundPath);
            var regionModel = mapOrGeoModel.getRegionModel(region.name) || mapOrGeoModel;
            var itemStyleModel = regionModel.getModel(itemStyleAccessPath);
            var hoverItemStyleModel = regionModel.getModel(hoverItemStyleAccessPath);
            var itemStyle = getFixedItemStyle(itemStyleModel);
            var hoverItemStyle = getFixedItemStyle(hoverItemStyleModel);
            var labelModel = regionModel.getModel(labelAccessPath);
            var hoverLabelModel = regionModel.getModel(hoverLabelAccessPath);
            var dataIdx; // Use the itemStyle in data if has data

            if (data) {
              dataIdx = data.indexOfName(region.name); // Only visual color of each item will be used. It can be encoded by dataRange
              // But visual color of series is used in symbol drawing
              //
              // Visual color for each series is for the symbol draw

              var visualColor = data.getItemVisual(dataIdx, 'color', true);

              if (visualColor) {
                itemStyle.fill = visualColor;
              }
            }

            var transformPoint = function transformPoint(point) {
              return [point[0] * scale[0] + position[0], point[1] * scale[1] + position[1]];
            };

            zrUtil.each(region.geometries, function (geometry) {
              if (geometry.type !== 'polygon') {
                return;
              }

              var points = [];

              for (var i = 0; i < geometry.exterior.length; ++i) {
                points.push(transformPoint(geometry.exterior[i]));
              }

              compoundPath.shape.paths.push(new graphic.Polygon({
                segmentIgnoreThreshold: 1,
                shape: {
                  points: points
                }
              }));

              for (var i = 0; i < (geometry.interiors ? geometry.interiors.length : 0); ++i) {
                var interior = geometry.interiors[i];
                var points = [];

                for (var j = 0; j < interior.length; ++j) {
                  points.push(transformPoint(interior[j]));
                }

                compoundPath.shape.paths.push(new graphic.Polygon({
                  segmentIgnoreThreshold: 1,
                  shape: {
                    points: points
                  }
                }));
              }
            });
            compoundPath.setStyle(itemStyle);
            compoundPath.style.strokeNoScale = true;
            compoundPath.culling = true; // Label

            var showLabel = labelModel.get('show');
            var hoverShowLabel = hoverLabelModel.get('show');
            var isDataNaN = data && isNaN(data.get(data.mapDimension('value'), dataIdx));
            var itemLayout = data && data.getItemLayout(dataIdx); // In the following cases label will be drawn
            // 1. In map series and data value is NaN
            // 2. In geo component
            // 4. Region has no series legendSymbol, which will be add a showLabel flag in mapSymbolLayout

            if (isGeo || isDataNaN && (showLabel || hoverShowLabel) || itemLayout && itemLayout.showLabel) {
              var query = !isGeo ? dataIdx : region.name;
              var labelFetcher; // Consider dataIdx not found.

              if (!data || dataIdx >= 0) {
                labelFetcher = mapOrGeoModel;
              }

              var textEl = new graphic.Text({
                position: transformPoint(region.center.slice()),
                // FIXME
                // label rotation is not support yet in geo or regions of series-map
                // that has no data. The rotation will be effected by this `scale`.
                // So needed to change to RectText?
                scale: [1 / group.scale[0], 1 / group.scale[1]],
                z2: 10,
                silent: true
              });
              graphic.setLabelStyle(textEl.style, textEl.hoverStyle = {}, labelModel, hoverLabelModel, {
                labelFetcher: labelFetcher,
                labelDataIndex: query,
                defaultText: region.name,
                useInsideStyle: false
              }, {
                textAlign: 'center',
                textVerticalAlign: 'middle'
              });

              if (!isFirstDraw) {
                // Text animation
                var textScale = [1 / targetScale[0], 1 / targetScale[1]];
                graphic.updateProps(textEl, {
                  scale: textScale
                }, mapOrGeoModel);
              }

              regionGroup.add(textEl);
            } // setItemGraphicEl, setHoverStyle after all polygons and labels
            // are added to the rigionGroup


            if (data) {
              data.setItemGraphicEl(dataIdx, regionGroup);
            } else {
              var regionModel = mapOrGeoModel.getRegionModel(region.name); // Package custom mouse event for geo component

              compoundPath.eventData = {
                componentType: 'geo',
                componentIndex: mapOrGeoModel.componentIndex,
                geoIndex: mapOrGeoModel.componentIndex,
                name: region.name,
                region: regionModel && regionModel.option || {}
              };
            }

            var groupRegions = regionGroup.__regions || (regionGroup.__regions = []);
            groupRegions.push(region);
            regionGroup.highDownSilentOnTouch = !!mapOrGeoModel.get('selectedMode');
            graphic.setHoverStyle(regionGroup, hoverItemStyle);
            regionsGroup.add(regionGroup);
          });

          this._updateController(mapOrGeoModel, ecModel, api);

          updateMapSelectHandler(this, mapOrGeoModel, regionsGroup, api, fromView);
          updateMapSelected(mapOrGeoModel, regionsGroup);
        },
        remove: function remove() {
          this._regionsGroup.removeAll();

          this._backgroundGroup.removeAll();

          this._controller.dispose();

          this._mapName && geoSourceManager.removeGraphic(this._mapName, this.uid);
          this._mapName = null;
          this._controllerHost = {};
        },
        _updateBackground: function _updateBackground(geo) {
          var mapName = geo.map;

          if (this._mapName !== mapName) {
            zrUtil.each(geoSourceManager.makeGraphic(mapName, this.uid), function (root) {
              this._backgroundGroup.add(root);
            }, this);
          }

          this._mapName = mapName;
        },
        _updateController: function _updateController(mapOrGeoModel, ecModel, api) {
          var geo = mapOrGeoModel.coordinateSystem;
          var controller = this._controller;
          var controllerHost = this._controllerHost;
          controllerHost.zoomLimit = mapOrGeoModel.get('scaleLimit');
          controllerHost.zoom = geo.getZoom(); // roamType is will be set default true if it is null

          controller.enable(mapOrGeoModel.get('roam') || false);
          var mainType = mapOrGeoModel.mainType;

          function makeActionBase() {
            var action = {
              type: 'geoRoam',
              componentType: mainType
            };
            action[mainType + 'Id'] = mapOrGeoModel.id;
            return action;
          }

          controller.off('pan').on('pan', function (e) {
            this._mouseDownFlag = false;
            roamHelper.updateViewOnPan(controllerHost, e.dx, e.dy);
            api.dispatchAction(zrUtil.extend(makeActionBase(), {
              dx: e.dx,
              dy: e.dy
            }));
          }, this);
          controller.off('zoom').on('zoom', function (e) {
            this._mouseDownFlag = false;
            roamHelper.updateViewOnZoom(controllerHost, e.scale, e.originX, e.originY);
            api.dispatchAction(zrUtil.extend(makeActionBase(), {
              zoom: e.scale,
              originX: e.originX,
              originY: e.originY
            }));

            if (this._updateGroup) {
              var scale = this.group.scale;

              this._regionsGroup.traverse(function (el) {
                if (el.type === 'text') {
                  el.attr('scale', [1 / scale[0], 1 / scale[1]]);
                }
              });
            }
          }, this);
          controller.setPointerChecker(function (e, x, y) {
            return geo.getViewRectAfterRoam().contain(x, y) && !onIrrelevantElement(e, api, mapOrGeoModel);
          });
        }
      };
      var _default = MapDraw;
      module.exports = _default;
      /***/
    },

    /***/
    "Dg8C":
    /*!***************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/sankey/sankeyVisual.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function Dg8C(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var VisualMapping = __webpack_require__(
      /*! ../../visual/VisualMapping */
      "XxSj");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function _default(ecModel, payload) {
        ecModel.eachSeriesByType('sankey', function (seriesModel) {
          var graph = seriesModel.getGraph();
          var nodes = graph.nodes;

          if (nodes.length) {
            var minValue = Infinity;
            var maxValue = -Infinity;
            zrUtil.each(nodes, function (node) {
              var nodeValue = node.getLayout().value;

              if (nodeValue < minValue) {
                minValue = nodeValue;
              }

              if (nodeValue > maxValue) {
                maxValue = nodeValue;
              }
            });
            zrUtil.each(nodes, function (node) {
              var mapping = new VisualMapping({
                type: 'color',
                mappingMethod: 'linear',
                dataExtent: [minValue, maxValue],
                visual: seriesModel.get('color')
              });
              var mapValueToColor = mapping.mapValueToVisual(node.getLayout().value);
              var customColor = node.getModel().get('itemStyle.color');
              customColor != null ? node.setVisual('color', customColor) : node.setVisual('color', mapValueToColor);
            });
          }
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "Ducp":
    /*!***************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/legend/ScrollableLegendView.js ***!
      \***************************************************************************/

    /*! no static exports found */

    /***/
    function Ducp(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var layoutUtil = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var LegendView = __webpack_require__(
      /*! ./LegendView */
      "XpcN");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Separate legend and scrollable legend to reduce package size.
       */


      var Group = graphic.Group;
      var WH = ['width', 'height'];
      var XY = ['x', 'y'];
      var ScrollableLegendView = LegendView.extend({
        type: 'legend.scroll',
        newlineDisabled: true,
        init: function init() {
          ScrollableLegendView.superCall(this, 'init');
          /**
           * @private
           * @type {number} For `scroll`.
           */

          this._currentIndex = 0;
          /**
           * @private
           * @type {module:zrender/container/Group}
           */

          this.group.add(this._containerGroup = new Group());

          this._containerGroup.add(this.getContentGroup());
          /**
           * @private
           * @type {module:zrender/container/Group}
           */


          this.group.add(this._controllerGroup = new Group());
          /**
           *
           * @private
           */

          this._showController;
        },

        /**
         * @override
         */
        resetInner: function resetInner() {
          ScrollableLegendView.superCall(this, 'resetInner');

          this._controllerGroup.removeAll();

          this._containerGroup.removeClipPath();

          this._containerGroup.__rectSize = null;
        },

        /**
         * @override
         */
        renderInner: function renderInner(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
          var me = this; // Render content items.

          ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);
          var controllerGroup = this._controllerGroup; // FIXME: support be 'auto' adapt to size number text length,
          // e.g., '3/12345' should not overlap with the control arrow button.

          var pageIconSize = legendModel.get('pageIconSize', true);

          if (!zrUtil.isArray(pageIconSize)) {
            pageIconSize = [pageIconSize, pageIconSize];
          }

          createPageButton('pagePrev', 0);
          var pageTextStyleModel = legendModel.getModel('pageTextStyle');
          controllerGroup.add(new graphic.Text({
            name: 'pageText',
            style: {
              textFill: pageTextStyleModel.getTextColor(),
              font: pageTextStyleModel.getFont(),
              textVerticalAlign: 'middle',
              textAlign: 'center'
            },
            silent: true
          }));
          createPageButton('pageNext', 1);

          function createPageButton(name, iconIdx) {
            var pageDataIndexName = name + 'DataIndex';
            var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {
              // Buttons will be created in each render, so we do not need
              // to worry about avoiding using legendModel kept in scope.
              onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)
            }, {
              x: -pageIconSize[0] / 2,
              y: -pageIconSize[1] / 2,
              width: pageIconSize[0],
              height: pageIconSize[1]
            });
            icon.name = name;
            controllerGroup.add(icon);
          }
        },

        /**
         * @override
         */
        layoutInner: function layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
          var selectorGroup = this.getSelectorGroup();
          var orientIdx = legendModel.getOrient().index;
          var wh = WH[orientIdx];
          var xy = XY[orientIdx];
          var hw = WH[1 - orientIdx];
          var yx = XY[1 - orientIdx];
          selector && layoutUtil.box( // Buttons in selectorGroup always layout horizontally
          'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));
          var selectorButtonGap = legendModel.get('selectorButtonGap', true);
          var selectorRect = selectorGroup.getBoundingRect();
          var selectorPos = [-selectorRect.x, -selectorRect.y];
          var processMaxSize = zrUtil.clone(maxSize);
          selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);

          var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx);

          if (selector) {
            if (selectorPosition === 'end') {
              selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;
            } else {
              var offset = selectorRect[wh] + selectorButtonGap;
              selectorPos[orientIdx] -= offset;
              mainRect[xy] -= offset;
            }

            mainRect[wh] += selectorRect[wh] + selectorButtonGap;
            selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;
            mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);
            mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);
            selectorGroup.attr('position', selectorPos);
          }

          return mainRect;
        },
        _layoutContentAndController: function _layoutContentAndController(legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx) {
          var contentGroup = this.getContentGroup();
          var containerGroup = this._containerGroup;
          var controllerGroup = this._controllerGroup; // Place items in contentGroup.

          layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
          layoutUtil.box( // Buttons in controller are layout always horizontally.
          'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));
          var contentRect = contentGroup.getBoundingRect();
          var controllerRect = controllerGroup.getBoundingRect();
          var showController = this._showController = contentRect[wh] > maxSize[wh];
          var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.
          // If first rendering, `contentGroup.position` is [0, 0], which
          // does not make sense and may cause unexepcted animation if adopted.

          if (!isFirstRender) {
            contentPos[orientIdx] = contentGroup.position[orientIdx];
          } // Layout container group based on 0.


          var containerPos = [0, 0];
          var controllerPos = [-controllerRect.x, -controllerRect.y];
          var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.

          if (showController) {
            var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.

            if (pageButtonPosition === 'end') {
              controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];
            } // controller is on the left / top.
            else {
              containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;
            }
          } // Always align controller to content as 'middle'.


          controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
          contentGroup.attr('position', contentPos);
          containerGroup.attr('position', containerPos);
          controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.
          // mainRect should not be calculated by `this.group.getBoundingRect()`
          // for sake of the overflow.

          var mainRect = {
            x: 0,
            y: 0
          }; // Consider content may be overflow (should be clipped).

          mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];
          mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.

          mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
          containerGroup.__rectSize = maxSize[wh];

          if (showController) {
            var clipShape = {
              x: 0,
              y: 0
            };
            clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);
            clipShape[hw] = mainRect[hw];
            containerGroup.setClipPath(new graphic.Rect({
              shape: clipShape
            })); // Consider content may be larger than container, container rect
            // can not be obtained from `containerGroup.getBoundingRect()`.

            containerGroup.__rectSize = clipShape[wh];
          } else {
            // Do not remove or ignore controller. Keep them set as placeholders.
            controllerGroup.eachChild(function (child) {
              child.attr({
                invisible: true,
                silent: true
              });
            });
          } // Content translate animation.


          var pageInfo = this._getPageInfo(legendModel);

          pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {
            position: pageInfo.contentPosition
          }, // When switch from "show controller" to "not show controller", view should be
          // updated immediately without animation, otherwise causes weird effect.
          showController ? legendModel : false);

          this._updatePageInfoView(legendModel, pageInfo);

          return mainRect;
        },
        _pageGo: function _pageGo(to, legendModel, api) {
          var scrollDataIndex = this._getPageInfo(legendModel)[to];

          scrollDataIndex != null && api.dispatchAction({
            type: 'legendScroll',
            scrollDataIndex: scrollDataIndex,
            legendId: legendModel.id
          });
        },
        _updatePageInfoView: function _updatePageInfoView(legendModel, pageInfo) {
          var controllerGroup = this._controllerGroup;
          zrUtil.each(['pagePrev', 'pageNext'], function (name) {
            var canJump = pageInfo[name + 'DataIndex'] != null;
            var icon = controllerGroup.childOfName(name);

            if (icon) {
              icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));
              icon.cursor = canJump ? 'pointer' : 'default';
            }
          });
          var pageText = controllerGroup.childOfName('pageText');
          var pageFormatter = legendModel.get('pageFormatter');
          var pageIndex = pageInfo.pageIndex;
          var current = pageIndex != null ? pageIndex + 1 : 0;
          var total = pageInfo.pageCount;
          pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({
            current: current,
            total: total
          }));
        },

        /**
         * @param {module:echarts/model/Model} legendModel
         * @return {Object} {
         *  contentPosition: Array.<number>, null when data item not found.
         *  pageIndex: number, null when data item not found.
         *  pageCount: number, always be a number, can be 0.
         *  pagePrevDataIndex: number, null when no previous page.
         *  pageNextDataIndex: number, null when no next page.
         * }
         */
        _getPageInfo: function _getPageInfo(legendModel) {
          var scrollDataIndex = legendModel.get('scrollDataIndex', true);
          var contentGroup = this.getContentGroup();
          var containerRectSize = this._containerGroup.__rectSize;
          var orientIdx = legendModel.getOrient().index;
          var wh = WH[orientIdx];
          var xy = XY[orientIdx];

          var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);

          var children = contentGroup.children();
          var targetItem = children[targetItemIndex];
          var itemCount = children.length;
          var pCount = !itemCount ? 0 : 1;
          var result = {
            contentPosition: contentGroup.position.slice(),
            pageCount: pCount,
            pageIndex: pCount - 1,
            pagePrevDataIndex: null,
            pageNextDataIndex: null
          };

          if (!targetItem) {
            return result;
          }

          var targetItemInfo = getItemInfo(targetItem);
          result.contentPosition[orientIdx] = -targetItemInfo.s; // Strategy:
          // (1) Always align based on the left/top most item.
          // (2) It is user-friendly that the last item shown in the
          // current window is shown at the begining of next window.
          // Otherwise if half of the last item is cut by the window,
          // it will have no chance to display entirely.
          // (3) Consider that item size probably be different, we
          // have calculate pageIndex by size rather than item index,
          // and we can not get page index directly by division.
          // (4) The window is to narrow to contain more than
          // one item, we should make sure that the page can be fliped.

          for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {
            currItemInfo = getItemInfo(children[i]);

            if ( // Half of the last item is out of the window.
            !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || // If the current item does not intersect with the window, the new page
            // can be started at the current item or the last item.
            currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {
              if (winEndItemInfo.i > winStartItemInfo.i) {
                winStartItemInfo = winEndItemInfo;
              } else {
                // e.g., when page size is smaller than item size.
                winStartItemInfo = currItemInfo;
              }

              if (winStartItemInfo) {
                if (result.pageNextDataIndex == null) {
                  result.pageNextDataIndex = winStartItemInfo.i;
                }

                ++result.pageCount;
              }
            }

            winEndItemInfo = currItemInfo;
          }

          for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {
            currItemInfo = getItemInfo(children[i]);

            if ( // If the the end item does not intersect with the window started
            // from the current item, a page can be settled.
            (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && // e.g., when page size is smaller than item size.
            winStartItemInfo.i < winEndItemInfo.i) {
              winEndItemInfo = winStartItemInfo;

              if (result.pagePrevDataIndex == null) {
                result.pagePrevDataIndex = winStartItemInfo.i;
              }

              ++result.pageCount;
              ++result.pageIndex;
            }

            winStartItemInfo = currItemInfo;
          }

          return result;

          function getItemInfo(el) {
            if (el) {
              var itemRect = el.getBoundingRect();
              var start = itemRect[xy] + el.position[orientIdx];
              return {
                s: start,
                e: start + itemRect[wh],
                i: el.__legendDataIndex
              };
            }
          }

          function intersect(itemInfo, winStart) {
            return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;
          }
        },
        _findTargetItemIndex: function _findTargetItemIndex(targetDataIndex) {
          if (!this._showController) {
            return 0;
          }

          var index;
          var contentGroup = this.getContentGroup();
          var defaultIndex;
          contentGroup.eachChild(function (child, idx) {
            var legendDataIdx = child.__legendDataIndex; // FIXME
            // If the given targetDataIndex (from model) is illegal,
            // we use defaultIndex. But the index on the legend model and
            // action payload is still illegal. That case will not be
            // changed until some scenario requires.

            if (defaultIndex == null && legendDataIdx != null) {
              defaultIndex = idx;
            }

            if (legendDataIdx === targetDataIndex) {
              index = idx;
            }
          });
          return index != null ? index : defaultIndex;
        }
      });
      var _default = ScrollableLegendView;
      module.exports = _default;
      /***/
    },

    /***/
    "EMyp":
    /*!********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/brush/visualEncoding.js ***!
      \********************************************************************/

    /*! no static exports found */

    /***/
    function EMyp(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var BoundingRect = __webpack_require__(
      /*! zrender/lib/core/BoundingRect */
      "mFDi");

      var visualSolution = __webpack_require__(
      /*! ../../visual/visualSolution */
      "K4ya");

      var selector = __webpack_require__(
      /*! ./selector */
      "qJCg");

      var throttleUtil = __webpack_require__(
      /*! ../../util/throttle */
      "iLNv");

      var BrushTargetManager = __webpack_require__(
      /*! ../helper/BrushTargetManager */
      "vZ6x");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var STATE_LIST = ['inBrush', 'outOfBrush'];
      var DISPATCH_METHOD = '__ecBrushSelect';
      var DISPATCH_FLAG = '__ecInBrushSelectEvent';
      var PRIORITY_BRUSH = echarts.PRIORITY.VISUAL.BRUSH;
      /**
       * Layout for visual, the priority higher than other layout, and before brush visual.
       */

      echarts.registerLayout(PRIORITY_BRUSH, function (ecModel, api, payload) {
        ecModel.eachComponent({
          mainType: 'brush'
        }, function (brushModel) {
          payload && payload.type === 'takeGlobalCursor' && brushModel.setBrushOption(payload.key === 'brush' ? payload.brushOption : {
            brushType: false
          });
        });
        layoutCovers(ecModel);
      });

      function layoutCovers(ecModel) {
        ecModel.eachComponent({
          mainType: 'brush'
        }, function (brushModel) {
          var brushTargetManager = brushModel.brushTargetManager = new BrushTargetManager(brushModel.option, ecModel);
          brushTargetManager.setInputRanges(brushModel.areas, ecModel);
        });
      }
      /**
       * Register the visual encoding if this modules required.
       */


      echarts.registerVisual(PRIORITY_BRUSH, function (ecModel, api, payload) {
        var brushSelected = [];
        var throttleType;
        var throttleDelay;
        ecModel.eachComponent({
          mainType: 'brush'
        }, function (brushModel, brushIndex) {
          var thisBrushSelected = {
            brushId: brushModel.id,
            brushIndex: brushIndex,
            brushName: brushModel.name,
            areas: zrUtil.clone(brushModel.areas),
            selected: []
          }; // Every brush component exists in event params, convenient
          // for user to find by index.

          brushSelected.push(thisBrushSelected);
          var brushOption = brushModel.option;
          var brushLink = brushOption.brushLink;
          var linkedSeriesMap = [];
          var selectedDataIndexForLink = [];
          var rangeInfoBySeries = [];
          var hasBrushExists = 0;

          if (!brushIndex) {
            // Only the first throttle setting works.
            throttleType = brushOption.throttleType;
            throttleDelay = brushOption.throttleDelay;
          } // Add boundingRect and selectors to range.


          var areas = zrUtil.map(brushModel.areas, function (area) {
            return bindSelector(zrUtil.defaults({
              boundingRect: boundingRectBuilders[area.brushType](area)
            }, area));
          });
          var visualMappings = visualSolution.createVisualMappings(brushModel.option, STATE_LIST, function (mappingOption) {
            mappingOption.mappingMethod = 'fixed';
          });
          zrUtil.isArray(brushLink) && zrUtil.each(brushLink, function (seriesIndex) {
            linkedSeriesMap[seriesIndex] = 1;
          });

          function linkOthers(seriesIndex) {
            return brushLink === 'all' || linkedSeriesMap[seriesIndex];
          } // If no supported brush or no brush on the series,
          // all visuals should be in original state.


          function brushed(rangeInfoList) {
            return !!rangeInfoList.length;
          }
          /**
           * Logic for each series: (If the logic has to be modified one day, do it carefully!)
           *
           * ( brushed  && hasBrushExist  && linkOthers  ) => StepA: record,  StepB: visualByRecord.
           *   !brushed    hasBrushExist                             nothing,        visualByRecord.
           *                !hasBrushExist                                              nothing.
           * ( !brushed  && hasBrushExist  && linkOthers  ) => StepA:  nothing,  StepB: visualByRecord.
           *                !hasBrushExist                                              nothing.
           * ( brushed  &&                     !linkOthers ) => StepA:  nothing,  StepB: visualByCheck.
           *   !brushed                                                                  nothing.
           * ( !brushed  &&                     !linkOthers ) => StepA:  nothing,  StepB:  nothing.
           */
          // Step A


          ecModel.eachSeries(function (seriesModel, seriesIndex) {
            var rangeInfoList = rangeInfoBySeries[seriesIndex] = [];
            seriesModel.subType === 'parallel' ? stepAParallel(seriesModel, seriesIndex, rangeInfoList) : stepAOthers(seriesModel, seriesIndex, rangeInfoList);
          });

          function stepAParallel(seriesModel, seriesIndex) {
            var coordSys = seriesModel.coordinateSystem;
            hasBrushExists |= coordSys.hasAxisBrushed();
            linkOthers(seriesIndex) && coordSys.eachActiveState(seriesModel.getData(), function (activeState, dataIndex) {
              activeState === 'active' && (selectedDataIndexForLink[dataIndex] = 1);
            });
          }

          function stepAOthers(seriesModel, seriesIndex, rangeInfoList) {
            var selectorsByBrushType = getSelectorsByBrushType(seriesModel);

            if (!selectorsByBrushType || brushModelNotControll(brushModel, seriesIndex)) {
              return;
            }

            zrUtil.each(areas, function (area) {
              selectorsByBrushType[area.brushType] && brushModel.brushTargetManager.controlSeries(area, seriesModel, ecModel) && rangeInfoList.push(area);
              hasBrushExists |= brushed(rangeInfoList);
            });

            if (linkOthers(seriesIndex) && brushed(rangeInfoList)) {
              var data = seriesModel.getData();
              data.each(function (dataIndex) {
                if (checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex)) {
                  selectedDataIndexForLink[dataIndex] = 1;
                }
              });
            }
          } // Step B


          ecModel.eachSeries(function (seriesModel, seriesIndex) {
            var seriesBrushSelected = {
              seriesId: seriesModel.id,
              seriesIndex: seriesIndex,
              seriesName: seriesModel.name,
              dataIndex: []
            }; // Every series exists in event params, convenient
            // for user to find series by seriesIndex.

            thisBrushSelected.selected.push(seriesBrushSelected);
            var selectorsByBrushType = getSelectorsByBrushType(seriesModel);
            var rangeInfoList = rangeInfoBySeries[seriesIndex];
            var data = seriesModel.getData();
            var getValueState = linkOthers(seriesIndex) ? function (dataIndex) {
              return selectedDataIndexForLink[dataIndex] ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), 'inBrush') : 'outOfBrush';
            } : function (dataIndex) {
              return checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex) ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), 'inBrush') : 'outOfBrush';
            }; // If no supported brush or no brush, all visuals are in original state.

            (linkOthers(seriesIndex) ? hasBrushExists : brushed(rangeInfoList)) && visualSolution.applyVisual(STATE_LIST, visualMappings, data, getValueState);
          });
        });
        dispatchAction(api, throttleType, throttleDelay, brushSelected, payload);
      });

      function dispatchAction(api, throttleType, throttleDelay, brushSelected, payload) {
        // This event will not be triggered when `setOpion`, otherwise dead lock may
        // triggered when do `setOption` in event listener, which we do not find
        // satisfactory way to solve yet. Some considered resolutions:
        // (a) Diff with prevoius selected data ant only trigger event when changed.
        // But store previous data and diff precisely (i.e., not only by dataIndex, but
        // also detect value changes in selected data) might bring complexity or fragility.
        // (b) Use spectial param like `silent` to suppress event triggering.
        // But such kind of volatile param may be weird in `setOption`.
        if (!payload) {
          return;
        }

        var zr = api.getZr();

        if (zr[DISPATCH_FLAG]) {
          return;
        }

        if (!zr[DISPATCH_METHOD]) {
          zr[DISPATCH_METHOD] = doDispatch;
        }

        var fn = throttleUtil.createOrUpdate(zr, DISPATCH_METHOD, throttleDelay, throttleType);
        fn(api, brushSelected);
      }

      function doDispatch(api, brushSelected) {
        if (!api.isDisposed()) {
          var zr = api.getZr();
          zr[DISPATCH_FLAG] = true;
          api.dispatchAction({
            type: 'brushSelect',
            batch: brushSelected
          });
          zr[DISPATCH_FLAG] = false;
        }
      }

      function checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex) {
        for (var i = 0, len = rangeInfoList.length; i < len; i++) {
          var area = rangeInfoList[i];

          if (selectorsByBrushType[area.brushType](dataIndex, data, area.selectors, area)) {
            return true;
          }
        }
      }

      function getSelectorsByBrushType(seriesModel) {
        var brushSelector = seriesModel.brushSelector;

        if (zrUtil.isString(brushSelector)) {
          var sels = [];
          zrUtil.each(selector, function (selectorsByElementType, brushType) {
            sels[brushType] = function (dataIndex, data, selectors, area) {
              var itemLayout = data.getItemLayout(dataIndex);
              return selectorsByElementType[brushSelector](itemLayout, selectors, area);
            };
          });
          return sels;
        } else if (zrUtil.isFunction(brushSelector)) {
          var bSelector = {};
          zrUtil.each(selector, function (sel, brushType) {
            bSelector[brushType] = brushSelector;
          });
          return bSelector;
        }

        return brushSelector;
      }

      function brushModelNotControll(brushModel, seriesIndex) {
        var seriesIndices = brushModel.option.seriesIndex;
        return seriesIndices != null && seriesIndices !== 'all' && (zrUtil.isArray(seriesIndices) ? zrUtil.indexOf(seriesIndices, seriesIndex) < 0 : seriesIndex !== seriesIndices);
      }

      function bindSelector(area) {
        var selectors = area.selectors = {};
        zrUtil.each(selector[area.brushType], function (selFn, elType) {
          // Do not use function binding or curry for performance.
          selectors[elType] = function (itemLayout) {
            return selFn(itemLayout, selectors, area);
          };
        });
        return area;
      }

      var boundingRectBuilders = {
        lineX: zrUtil.noop,
        lineY: zrUtil.noop,
        rect: function rect(area) {
          return getBoundingRectFromMinMax(area.range);
        },
        polygon: function polygon(area) {
          var minMax;
          var range = area.range;

          for (var i = 0, len = range.length; i < len; i++) {
            minMax = minMax || [[Infinity, -Infinity], [Infinity, -Infinity]];
            var rg = range[i];
            rg[0] < minMax[0][0] && (minMax[0][0] = rg[0]);
            rg[0] > minMax[0][1] && (minMax[0][1] = rg[0]);
            rg[1] < minMax[1][0] && (minMax[1][0] = rg[1]);
            rg[1] > minMax[1][1] && (minMax[1][1] = rg[1]);
          }

          return minMax && getBoundingRectFromMinMax(minMax);
        }
      };

      function getBoundingRectFromMinMax(minMax) {
        return new BoundingRect(minMax[0][0], minMax[1][0], minMax[0][1] - minMax[0][0], minMax[1][1] - minMax[1][0]);
      }

      exports.layoutCovers = layoutCovers;
      /***/
    },

    /***/
    "ERHi":
    /*!*********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/effectScatter.js ***!
      \*********************************************************/

    /*! no static exports found */

    /***/
    function ERHi(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ./effectScatter/EffectScatterSeries */
      "Z6js");

      __webpack_require__(
      /*! ./effectScatter/EffectScatterView */
      "R4Th");

      var visualSymbol = __webpack_require__(
      /*! ../visual/symbol */
      "f5Yq");

      var layoutPoints = __webpack_require__(
      /*! ../layout/points */
      "h8O9");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      echarts.registerVisual(visualSymbol('effectScatter', 'circle'));
      echarts.registerLayout(layoutPoints('effectScatter'));
      /***/
    },

    /***/
    "Ez2D":
    /*!*******************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js ***!
      \*******************************************************************************/

    /*! no static exports found */

    /***/
    function Ez2D(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var modelUtil = __webpack_require__(
      /*! ../../util/model */
      "4NO4");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}
       * @param {module:echarts/model/Global} ecModel
       * @return {Object} {point: [x, y], el: ...} point Will not be null.
       */


      function _default(finder, ecModel) {
        var point = [];
        var seriesIndex = finder.seriesIndex;
        var seriesModel;

        if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
          return {
            point: []
          };
        }

        var data = seriesModel.getData();
        var dataIndex = modelUtil.queryDataIndex(data, finder);

        if (dataIndex == null || dataIndex < 0 || zrUtil.isArray(dataIndex)) {
          return {
            point: []
          };
        }

        var el = data.getItemGraphicEl(dataIndex);
        var coordSys = seriesModel.coordinateSystem;

        if (seriesModel.getTooltipPosition) {
          point = seriesModel.getTooltipPosition(dataIndex) || [];
        } else if (coordSys && coordSys.dataToPoint) {
          point = coordSys.dataToPoint(data.getValues(zrUtil.map(coordSys.dimensions, function (dim) {
            return data.mapDimension(dim);
          }), dataIndex, true)) || [];
        } else if (el) {
          // Use graphic bounding rect
          var rect = el.getBoundingRect().clone();
          rect.applyTransform(el.transform);
          point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
        }

        return {
          point: point,
          el: el
        };
      }

      module.exports = _default;
      /***/
    },

    /***/
    "F0hE":
    /*!************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/radar/RadarModel.js ***!
      \************************************************************/

    /*! no static exports found */

    /***/
    function F0hE(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var axisDefault = __webpack_require__(
      /*! ../axisDefault */
      "ca2m");

      var Model = __webpack_require__(
      /*! ../../model/Model */
      "Qxkt");

      var axisModelCommonMixin = __webpack_require__(
      /*! ../axisModelCommonMixin */
      "ICMv");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var valueAxisDefault = axisDefault.valueAxis;

      function defaultsShow(opt, show) {
        return zrUtil.defaults({
          show: show
        }, opt);
      }

      var RadarModel = echarts.extendComponentModel({
        type: 'radar',
        optionUpdated: function optionUpdated() {
          var boundaryGap = this.get('boundaryGap');
          var splitNumber = this.get('splitNumber');
          var scale = this.get('scale');
          var axisLine = this.get('axisLine');
          var axisTick = this.get('axisTick');
          var axisType = this.get('axisType');
          var axisLabel = this.get('axisLabel');
          var nameTextStyle = this.get('name');
          var showName = this.get('name.show');
          var nameFormatter = this.get('name.formatter');
          var nameGap = this.get('nameGap');
          var triggerEvent = this.get('triggerEvent');
          var indicatorModels = zrUtil.map(this.get('indicator') || [], function (indicatorOpt) {
            // PENDING
            if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {
              indicatorOpt.min = 0;
            } else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {
              indicatorOpt.max = 0;
            }

            var iNameTextStyle = nameTextStyle;

            if (indicatorOpt.color != null) {
              iNameTextStyle = zrUtil.defaults({
                color: indicatorOpt.color
              }, nameTextStyle);
            } // Use same configuration


            indicatorOpt = zrUtil.merge(zrUtil.clone(indicatorOpt), {
              boundaryGap: boundaryGap,
              splitNumber: splitNumber,
              scale: scale,
              axisLine: axisLine,
              axisTick: axisTick,
              axisType: axisType,
              axisLabel: axisLabel,
              // Compatible with 2 and use text
              name: indicatorOpt.text,
              nameLocation: 'end',
              nameGap: nameGap,
              // min: 0,
              nameTextStyle: iNameTextStyle,
              triggerEvent: triggerEvent
            }, false);

            if (!showName) {
              indicatorOpt.name = '';
            }

            if (typeof nameFormatter === 'string') {
              var indName = indicatorOpt.name;
              indicatorOpt.name = nameFormatter.replace('{value}', indName != null ? indName : '');
            } else if (typeof nameFormatter === 'function') {
              indicatorOpt.name = nameFormatter(indicatorOpt.name, indicatorOpt);
            }

            var model = zrUtil.extend(new Model(indicatorOpt, null, this.ecModel), axisModelCommonMixin); // For triggerEvent.

            model.mainType = 'radar';
            model.componentIndex = this.componentIndex;
            return model;
          }, this);

          this.getIndicatorModels = function () {
            return indicatorModels;
          };
        },
        defaultOption: {
          zlevel: 0,
          z: 0,
          center: ['50%', '50%'],
          radius: '75%',
          startAngle: 90,
          name: {
            show: true // formatter: null
            // textStyle: {}

          },
          boundaryGap: [0, 0],
          splitNumber: 5,
          nameGap: 15,
          scale: false,
          // Polygon or circle
          shape: 'polygon',
          axisLine: zrUtil.merge({
            lineStyle: {
              color: '#bbb'
            }
          }, valueAxisDefault.axisLine),
          axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),
          axisTick: defaultsShow(valueAxisDefault.axisTick, false),
          axisType: 'interval',
          splitLine: defaultsShow(valueAxisDefault.splitLine, true),
          splitArea: defaultsShow(valueAxisDefault.splitArea, true),
          // {text, min, max}
          indicator: []
        }
      });
      var _default = RadarModel;
      module.exports = _default;
      /***/
    },

    /***/
    "F5Ls":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/geo/fix/textCoord.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function F5Ls(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var coordsOffsetMap = {
        '': [32, 80],
        // 
        '': [0, -10],
        '': [10, 5],
        '': [-10, 10],
        //'': [-10, 0],
        '': [5, 5]
      };

      function _default(mapType, region) {
        if (mapType === 'china') {
          var coordFix = coordsOffsetMap[region.name];

          if (coordFix) {
            var cp = region.center;
            cp[0] += coordFix[0] / 10.5;
            cp[1] += -coordFix[1] / (10.5 / 0.75);
          }
        }
      }

      module.exports = _default;
      /***/
    },

    /***/
    "F7hV":
    /*!*********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/bar/BarSeries.js ***!
      \*********************************************************/

    /*! no static exports found */

    /***/
    function F7hV(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var BaseBarSeries = __webpack_require__(
      /*! ./BaseBarSeries */
      "MBQ8");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = BaseBarSeries.extend({
        type: 'series.bar',
        dependencies: ['grid', 'polar'],
        brushSelector: 'rect',

        /**
         * @override
         */
        getProgressive: function getProgressive() {
          // Do not support progressive in normal mode.
          return this.get('large') ? this.get('progressive') : false;
        },

        /**
         * @override
         */
        getProgressiveThreshold: function getProgressiveThreshold() {
          // Do not support progressive in normal mode.
          var progressiveThreshold = this.get('progressiveThreshold');
          var largeThreshold = this.get('largeThreshold');

          if (largeThreshold > progressiveThreshold) {
            progressiveThreshold = largeThreshold;
          }

          return progressiveThreshold;
        },
        defaultOption: {
          // If clipped
          // Only available on cartesian2d
          clip: true,
          // If use caps on two sides of bars
          // Only available on tangential polar bar
          roundCap: false,
          showBackground: false,
          backgroundStyle: {
            color: 'rgba(180, 180, 180, 0.2)',
            borderColor: null,
            borderWidth: 0,
            borderType: 'solid',
            borderRadius: 0,
            shadowBlur: 0,
            shadowColor: null,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            opacity: 1
          }
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "F9bG":
    /*!**************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/axisPointer/globalListener.js ***!
      \**************************************************************************/

    /*! no static exports found */

    /***/
    function F9bG(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var env = __webpack_require__(
      /*! zrender/lib/core/env */
      "ItGF");

      var _model = __webpack_require__(
      /*! ../../util/model */
      "4NO4");

      var makeInner = _model.makeInner;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var inner = makeInner();
      var each = zrUtil.each;
      /**
       * @param {string} key
       * @param {module:echarts/ExtensionAPI} api
       * @param {Function} handler
       *      param: {string} currTrigger
       *      param: {Array.<number>} point
       */

      function register(key, api, handler) {
        if (env.node) {
          return;
        }

        var zr = api.getZr();
        inner(zr).records || (inner(zr).records = {});
        initGlobalListeners(zr, api);
        var record = inner(zr).records[key] || (inner(zr).records[key] = {});
        record.handler = handler;
      }

      function initGlobalListeners(zr, api) {
        if (inner(zr).initialized) {
          return;
        }

        inner(zr).initialized = true;
        useHandler('click', zrUtil.curry(doEnter, 'click'));
        useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove')); // useHandler('mouseout', onLeave);

        useHandler('globalout', onLeave);

        function useHandler(eventType, cb) {
          zr.on(eventType, function (e) {
            var dis = makeDispatchAction(api);
            each(inner(zr).records, function (record) {
              record && cb(record, e, dis.dispatchAction);
            });
            dispatchTooltipFinally(dis.pendings, api);
          });
        }
      }

      function dispatchTooltipFinally(pendings, api) {
        var showLen = pendings.showTip.length;
        var hideLen = pendings.hideTip.length;
        var actuallyPayload;

        if (showLen) {
          actuallyPayload = pendings.showTip[showLen - 1];
        } else if (hideLen) {
          actuallyPayload = pendings.hideTip[hideLen - 1];
        }

        if (actuallyPayload) {
          actuallyPayload.dispatchAction = null;
          api.dispatchAction(actuallyPayload);
        }
      }

      function onLeave(record, e, dispatchAction) {
        record.handler('leave', null, dispatchAction);
      }

      function doEnter(currTrigger, record, e, dispatchAction) {
        record.handler(currTrigger, e, dispatchAction);
      }

      function makeDispatchAction(api) {
        var pendings = {
          showTip: [],
          hideTip: []
        }; // FIXME
        // better approach?
        // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,
        // which may be conflict, (axisPointer call showTip but tooltip call hideTip);
        // So we have to add "final stage" to merge those dispatched actions.

        var dispatchAction = function dispatchAction(payload) {
          var pendingList = pendings[payload.type];

          if (pendingList) {
            pendingList.push(payload);
          } else {
            payload.dispatchAction = dispatchAction;
            api.dispatchAction(payload);
          }
        };

        return {
          dispatchAction: dispatchAction,
          pendings: pendings
        };
      }
      /**
       * @param {string} key
       * @param {module:echarts/ExtensionAPI} api
       */


      function unregister(key, api) {
        if (env.node) {
          return;
        }

        var zr = api.getZr();
        var record = (inner(zr).records || {})[key];

        if (record) {
          inner(zr).records[key] = null;
        }
      }

      exports.register = register;
      exports.unregister = unregister;
      /***/
    },

    /***/
    "FBjb":
    /*!*********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/helper/Symbol.js ***!
      \*********************************************************/

    /*! no static exports found */

    /***/
    function FBjb(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _symbol = __webpack_require__(
      /*! ../../util/symbol */
      "oVpE");

      var createSymbol = _symbol.createSymbol;

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var _number = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var parsePercent = _number.parsePercent;

      var _labelHelper = __webpack_require__(
      /*! ./labelHelper */
      "x3X8");

      var getDefaultLabel = _labelHelper.getDefaultLabel;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @module echarts/chart/helper/Symbol
       */

      /**
       * @constructor
       * @alias {module:echarts/chart/helper/Symbol}
       * @param {module:echarts/data/List} data
       * @param {number} idx
       * @extends {module:zrender/graphic/Group}
       */

      function SymbolClz(data, idx, seriesScope) {
        graphic.Group.call(this);
        this.updateData(data, idx, seriesScope);
      }

      var symbolProto = SymbolClz.prototype;
      /**
       * @public
       * @static
       * @param {module:echarts/data/List} data
       * @param {number} dataIndex
       * @return {Array.<number>} [width, height]
       */

      var getSymbolSize = SymbolClz.getSymbolSize = function (data, idx) {
        var symbolSize = data.getItemVisual(idx, 'symbolSize');
        return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];
      };

      function getScale(symbolSize) {
        return [symbolSize[0] / 2, symbolSize[1] / 2];
      }

      function driftSymbol(dx, dy) {
        this.parent.drift(dx, dy);
      }

      symbolProto._createSymbol = function (symbolType, data, idx, symbolSize, keepAspect) {
        // Remove paths created before
        this.removeAll();
        var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(
        //     symbolType, -0.5, -0.5, 1, 1, color
        // );
        // If width/height are set too small (e.g., set to 1) on ios10
        // and macOS Sierra, a circle stroke become a rect, no matter what
        // the scale is set. So we set width/height as 2. See #4150.

        var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color, keepAspect);
        symbolPath.attr({
          z2: 100,
          culling: true,
          scale: getScale(symbolSize)
        }); // Rewrite drift method

        symbolPath.drift = driftSymbol;
        this._symbolType = symbolType;
        this.add(symbolPath);
      };
      /**
       * Stop animation
       * @param {boolean} toLastFrame
       */


      symbolProto.stopSymbolAnimation = function (toLastFrame) {
        this.childAt(0).stopAnimation(toLastFrame);
      };
      /**
       * FIXME:
       * Caution: This method breaks the encapsulation of this module,
       * but it indeed brings convenience. So do not use the method
       * unless you detailedly know all the implements of `Symbol`,
       * especially animation.
       *
       * Get symbol path element.
       */


      symbolProto.getSymbolPath = function () {
        return this.childAt(0);
      };
      /**
       * Get scale(aka, current symbol size).
       * Including the change caused by animation
       */


      symbolProto.getScale = function () {
        return this.childAt(0).scale;
      };
      /**
       * Highlight symbol
       */


      symbolProto.highlight = function () {
        this.childAt(0).trigger('emphasis');
      };
      /**
       * Downplay symbol
       */


      symbolProto.downplay = function () {
        this.childAt(0).trigger('normal');
      };
      /**
       * @param {number} zlevel
       * @param {number} z
       */


      symbolProto.setZ = function (zlevel, z) {
        var symbolPath = this.childAt(0);
        symbolPath.zlevel = zlevel;
        symbolPath.z = z;
      };

      symbolProto.setDraggable = function (draggable) {
        var symbolPath = this.childAt(0);
        symbolPath.draggable = draggable;
        symbolPath.cursor = draggable ? 'move' : symbolPath.cursor;
      };
      /**
       * Update symbol properties
       * @param {module:echarts/data/List} data
       * @param {number} idx
       * @param {Object} [seriesScope]
       * @param {Object} [seriesScope.itemStyle]
       * @param {Object} [seriesScope.hoverItemStyle]
       * @param {Object} [seriesScope.symbolRotate]
       * @param {Object} [seriesScope.symbolOffset]
       * @param {module:echarts/model/Model} [seriesScope.labelModel]
       * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]
       * @param {boolean} [seriesScope.hoverAnimation]
       * @param {Object} [seriesScope.cursorStyle]
       * @param {module:echarts/model/Model} [seriesScope.itemModel]
       * @param {string} [seriesScope.symbolInnerColor]
       * @param {Object} [seriesScope.fadeIn=false]
       */


      symbolProto.updateData = function (data, idx, seriesScope) {
        this.silent = false;
        var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';
        var seriesModel = data.hostModel;
        var symbolSize = getSymbolSize(data, idx);
        var isInit = symbolType !== this._symbolType;

        if (isInit) {
          var keepAspect = data.getItemVisual(idx, 'symbolKeepAspect');

          this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);
        } else {
          var symbolPath = this.childAt(0);
          symbolPath.silent = false;
          graphic.updateProps(symbolPath, {
            scale: getScale(symbolSize)
          }, seriesModel, idx);
        }

        this._updateCommon(data, idx, symbolSize, seriesScope);

        if (isInit) {
          var symbolPath = this.childAt(0);
          var fadeIn = seriesScope && seriesScope.fadeIn;
          var target = {
            scale: symbolPath.scale.slice()
          };
          fadeIn && (target.style = {
            opacity: symbolPath.style.opacity
          });
          symbolPath.scale = [0, 0];
          fadeIn && (symbolPath.style.opacity = 0);
          graphic.initProps(symbolPath, target, seriesModel, idx);
        }

        this._seriesModel = seriesModel;
      }; // Update common properties


      var normalStyleAccessPath = ['itemStyle'];
      var emphasisStyleAccessPath = ['emphasis', 'itemStyle'];
      var normalLabelAccessPath = ['label'];
      var emphasisLabelAccessPath = ['emphasis', 'label'];
      /**
       * @param {module:echarts/data/List} data
       * @param {number} idx
       * @param {Array.<number>} symbolSize
       * @param {Object} [seriesScope]
       */

      symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {
        var symbolPath = this.childAt(0);
        var seriesModel = data.hostModel;
        var color = data.getItemVisual(idx, 'color'); // Reset style

        if (symbolPath.type !== 'image') {
          symbolPath.useStyle({
            strokeNoScale: true
          });
        } else {
          symbolPath.setStyle({
            opacity: 1,
            shadowBlur: null,
            shadowOffsetX: null,
            shadowOffsetY: null,
            shadowColor: null
          });
        }

        var itemStyle = seriesScope && seriesScope.itemStyle;
        var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;
        var symbolOffset = seriesScope && seriesScope.symbolOffset;
        var labelModel = seriesScope && seriesScope.labelModel;
        var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;
        var hoverAnimation = seriesScope && seriesScope.hoverAnimation;
        var cursorStyle = seriesScope && seriesScope.cursorStyle;

        if (!seriesScope || data.hasItemOption) {
          var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.
          // Because symbol provide setColor individually to set fill and stroke

          itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);
          hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();
          symbolOffset = itemModel.getShallow('symbolOffset');
          labelModel = itemModel.getModel(normalLabelAccessPath);
          hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);
          hoverAnimation = itemModel.getShallow('hoverAnimation');
          cursorStyle = itemModel.getShallow('cursor');
        } else {
          hoverItemStyle = zrUtil.extend({}, hoverItemStyle);
        }

        var elStyle = symbolPath.style;
        var symbolRotate = data.getItemVisual(idx, 'symbolRotate');
        symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);

        if (symbolOffset) {
          symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);
        }

        cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!

        symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);
        symbolPath.setStyle(itemStyle);
        var opacity = data.getItemVisual(idx, 'opacity');

        if (opacity != null) {
          elStyle.opacity = opacity;
        }

        var liftZ = data.getItemVisual(idx, 'liftZ');
        var z2Origin = symbolPath.__z2Origin;

        if (liftZ != null) {
          if (z2Origin == null) {
            symbolPath.__z2Origin = symbolPath.z2;
            symbolPath.z2 += liftZ;
          }
        } else if (z2Origin != null) {
          symbolPath.z2 = z2Origin;
          symbolPath.__z2Origin = null;
        }

        var useNameLabel = seriesScope && seriesScope.useNameLabel;
        graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {
          labelFetcher: seriesModel,
          labelDataIndex: idx,
          defaultText: getLabelDefaultText,
          isRectText: true,
          autoColor: color
        }); // Do not execute util needed.

        function getLabelDefaultText(idx, opt) {
          return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);
        }

        symbolPath.__symbolOriginalScale = getScale(symbolSize);
        symbolPath.hoverStyle = hoverItemStyle;
        symbolPath.highDownOnUpdate = hoverAnimation && seriesModel.isAnimationEnabled() ? highDownOnUpdate : null;
        graphic.setHoverStyle(symbolPath);
      };

      function highDownOnUpdate(fromState, toState) {
        // Do not support this hover animation util some scenario required.
        // Animation can only be supported in hover layer when using `el.incremetal`.
        if (this.incremental || this.useHoverLayer) {
          return;
        }

        if (toState === 'emphasis') {
          var scale = this.__symbolOriginalScale;
          var ratio = scale[1] / scale[0];
          var emphasisOpt = {
            scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]
          }; // FIXME
          // modify it after support stop specified animation.
          // toState === fromState
          //     ? (this.stopAnimation(), this.attr(emphasisOpt))

          this.animateTo(emphasisOpt, 400, 'elasticOut');
        } else if (toState === 'normal') {
          this.animateTo({
            scale: this.__symbolOriginalScale
          }, 400, 'elasticOut');
        }
      }
      /**
       * @param {Function} cb
       * @param {Object} [opt]
       * @param {Object} [opt.keepLabel=true]
       */


      symbolProto.fadeOut = function (cb, opt) {
        var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out

        this.silent = symbolPath.silent = true; // Not show text when animating

        !(opt && opt.keepLabel) && (symbolPath.style.text = null);
        graphic.updateProps(symbolPath, {
          style: {
            opacity: 0
          },
          scale: [0, 0]
        }, this._seriesModel, this.dataIndex, cb);
      };

      zrUtil.inherits(SymbolClz, graphic.Group);
      var _default = SymbolClz;
      module.exports = _default;
      /***/
    },

    /***/
    "FGaS":
    /*!***********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/radar/RadarView.js ***!
      \***********************************************************/

    /*! no static exports found */

    /***/
    function FGaS(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var symbolUtil = __webpack_require__(
      /*! ../../util/symbol */
      "oVpE");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function normalizeSymbolSize(symbolSize) {
        if (!zrUtil.isArray(symbolSize)) {
          symbolSize = [+symbolSize, +symbolSize];
        }

        return symbolSize;
      }

      var _default = echarts.extendChartView({
        type: 'radar',
        render: function render(seriesModel, ecModel, api) {
          var polar = seriesModel.coordinateSystem;
          var group = this.group;
          var data = seriesModel.getData();
          var oldData = this._data;

          function createSymbol(data, idx) {
            var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';
            var color = data.getItemVisual(idx, 'color');

            if (symbolType === 'none') {
              return;
            }

            var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));
            var symbolPath = symbolUtil.createSymbol(symbolType, -1, -1, 2, 2, color);
            var symbolRotate = data.getItemVisual(idx, 'symbolRotate') || 0;
            symbolPath.attr({
              style: {
                strokeNoScale: true
              },
              z2: 100,
              scale: [symbolSize[0] / 2, symbolSize[1] / 2],
              rotation: symbolRotate * Math.PI / 180 || 0
            });
            return symbolPath;
          }

          function updateSymbols(oldPoints, newPoints, symbolGroup, data, idx, isInit) {
            // Simply rerender all
            symbolGroup.removeAll();

            for (var i = 0; i < newPoints.length - 1; i++) {
              var symbolPath = createSymbol(data, idx);

              if (symbolPath) {
                symbolPath.__dimIdx = i;

                if (oldPoints[i]) {
                  symbolPath.attr('position', oldPoints[i]);
                  graphic[isInit ? 'initProps' : 'updateProps'](symbolPath, {
                    position: newPoints[i]
                  }, seriesModel, idx);
                } else {
                  symbolPath.attr('position', newPoints[i]);
                }

                symbolGroup.add(symbolPath);
              }
            }
          }

          function getInitialPoints(points) {
            return zrUtil.map(points, function (pt) {
              return [polar.cx, polar.cy];
            });
          }

          data.diff(oldData).add(function (idx) {
            var points = data.getItemLayout(idx);

            if (!points) {
              return;
            }

            var polygon = new graphic.Polygon();
            var polyline = new graphic.Polyline();
            var target = {
              shape: {
                points: points
              }
            };
            polygon.shape.points = getInitialPoints(points);
            polyline.shape.points = getInitialPoints(points);
            graphic.initProps(polygon, target, seriesModel, idx);
            graphic.initProps(polyline, target, seriesModel, idx);
            var itemGroup = new graphic.Group();
            var symbolGroup = new graphic.Group();
            itemGroup.add(polyline);
            itemGroup.add(polygon);
            itemGroup.add(symbolGroup);
            updateSymbols(polyline.shape.points, points, symbolGroup, data, idx, true);
            data.setItemGraphicEl(idx, itemGroup);
          }).update(function (newIdx, oldIdx) {
            var itemGroup = oldData.getItemGraphicEl(oldIdx);
            var polyline = itemGroup.childAt(0);
            var polygon = itemGroup.childAt(1);
            var symbolGroup = itemGroup.childAt(2);
            var target = {
              shape: {
                points: data.getItemLayout(newIdx)
              }
            };

            if (!target.shape.points) {
              return;
            }

            updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false);
            graphic.updateProps(polyline, target, seriesModel);
            graphic.updateProps(polygon, target, seriesModel);
            data.setItemGraphicEl(newIdx, itemGroup);
          }).remove(function (idx) {
            group.remove(oldData.getItemGraphicEl(idx));
          }).execute();
          data.eachItemGraphicEl(function (itemGroup, idx) {
            var itemModel = data.getItemModel(idx);
            var polyline = itemGroup.childAt(0);
            var polygon = itemGroup.childAt(1);
            var symbolGroup = itemGroup.childAt(2);
            var color = data.getItemVisual(idx, 'color');
            group.add(itemGroup);
            polyline.useStyle(zrUtil.defaults(itemModel.getModel('lineStyle').getLineStyle(), {
              fill: 'none',
              stroke: color
            }));
            polyline.hoverStyle = itemModel.getModel('emphasis.lineStyle').getLineStyle();
            var areaStyleModel = itemModel.getModel('areaStyle');
            var hoverAreaStyleModel = itemModel.getModel('emphasis.areaStyle');
            var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();
            var hoverPolygonIgnore = hoverAreaStyleModel.isEmpty() && hoverAreaStyleModel.parentModel.isEmpty();
            hoverPolygonIgnore = hoverPolygonIgnore && polygonIgnore;
            polygon.ignore = polygonIgnore;
            polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {
              fill: color,
              opacity: 0.7
            }));
            polygon.hoverStyle = hoverAreaStyleModel.getAreaStyle();
            var itemStyle = itemModel.getModel('itemStyle').getItemStyle(['color']);
            var itemHoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();
            var labelModel = itemModel.getModel('label');
            var labelHoverModel = itemModel.getModel('emphasis.label');
            symbolGroup.eachChild(function (symbolPath) {
              symbolPath.setStyle(itemStyle);
              symbolPath.hoverStyle = zrUtil.clone(itemHoverStyle);
              var defaultText = data.get(data.dimensions[symbolPath.__dimIdx], idx);
              (defaultText == null || isNaN(defaultText)) && (defaultText = '');
              graphic.setLabelStyle(symbolPath.style, symbolPath.hoverStyle, labelModel, labelHoverModel, {
                labelFetcher: data.hostModel,
                labelDataIndex: idx,
                labelDimIndex: symbolPath.__dimIdx,
                defaultText: defaultText,
                autoColor: color,
                isRectText: true
              });
            });

            itemGroup.highDownOnUpdate = function (fromState, toState) {
              polygon.attr('ignore', toState === 'emphasis' ? hoverPolygonIgnore : polygonIgnore);
            };

            graphic.setHoverStyle(itemGroup);
          });
          this._data = data;
        },
        remove: function remove() {
          this.group.removeAll();
          this._data = null;
        },
        dispose: function dispose() {}
      });

      module.exports = _default;
      /***/
    },

    /***/
    "FNN5":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/component/axis/RadiusAxisView.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function FNN5(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var AxisBuilder = __webpack_require__(
      /*! ./AxisBuilder */
      "+rIm");

      var AxisView = __webpack_require__(
      /*! ./AxisView */
      "Znkb");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];
      var selfBuilderAttrs = ['splitLine', 'splitArea', 'minorSplitLine'];

      var _default = AxisView.extend({
        type: 'radiusAxis',
        axisPointerClass: 'PolarAxisPointer',
        render: function render(radiusAxisModel, ecModel) {
          this.group.removeAll();

          if (!radiusAxisModel.get('show')) {
            return;
          }

          var radiusAxis = radiusAxisModel.axis;
          var polar = radiusAxis.polar;
          var angleAxis = polar.getAngleAxis();
          var ticksCoords = radiusAxis.getTicksCoords();
          var minorTicksCoords = radiusAxis.getMinorTicksCoords();
          var axisAngle = angleAxis.getExtent()[0];
          var radiusExtent = radiusAxis.getExtent();
          var layout = layoutAxis(polar, radiusAxisModel, axisAngle);
          var axisBuilder = new AxisBuilder(radiusAxisModel, layout);
          zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
          this.group.add(axisBuilder.getGroup());
          zrUtil.each(selfBuilderAttrs, function (name) {
            if (radiusAxisModel.get(name + '.show') && !radiusAxis.scale.isBlank()) {
              this['_' + name](radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords);
            }
          }, this);
        },

        /**
         * @private
         */
        _splitLine: function _splitLine(radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
          var splitLineModel = radiusAxisModel.getModel('splitLine');
          var lineStyleModel = splitLineModel.getModel('lineStyle');
          var lineColors = lineStyleModel.get('color');
          var lineCount = 0;
          lineColors = lineColors instanceof Array ? lineColors : [lineColors];
          var splitLines = [];

          for (var i = 0; i < ticksCoords.length; i++) {
            var colorIndex = lineCount++ % lineColors.length;
            splitLines[colorIndex] = splitLines[colorIndex] || [];
            splitLines[colorIndex].push(new graphic.Circle({
              shape: {
                cx: polar.cx,
                cy: polar.cy,
                r: ticksCoords[i].coord
              }
            }));
          } // Simple optimization
          // Batching the lines if color are the same


          for (var i = 0; i < splitLines.length; i++) {
            this.group.add(graphic.mergePath(splitLines[i], {
              style: zrUtil.defaults({
                stroke: lineColors[i % lineColors.length],
                fill: null
              }, lineStyleModel.getLineStyle()),
              silent: true
            }));
          }
        },

        /**
         * @private
         */
        _minorSplitLine: function _minorSplitLine(radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords) {
          if (!minorTicksCoords.length) {
            return;
          }

          var minorSplitLineModel = radiusAxisModel.getModel('minorSplitLine');
          var lineStyleModel = minorSplitLineModel.getModel('lineStyle');
          var lines = [];

          for (var i = 0; i < minorTicksCoords.length; i++) {
            for (var k = 0; k < minorTicksCoords[i].length; k++) {
              lines.push(new graphic.Circle({
                shape: {
                  cx: polar.cx,
                  cy: polar.cy,
                  r: minorTicksCoords[i][k].coord
                }
              }));
            }
          }

          this.group.add(graphic.mergePath(lines, {
            style: zrUtil.defaults({
              fill: null
            }, lineStyleModel.getLineStyle()),
            silent: true
          }));
        },

        /**
         * @private
         */
        _splitArea: function _splitArea(radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
          if (!ticksCoords.length) {
            return;
          }

          var splitAreaModel = radiusAxisModel.getModel('splitArea');
          var areaStyleModel = splitAreaModel.getModel('areaStyle');
          var areaColors = areaStyleModel.get('color');
          var lineCount = 0;
          areaColors = areaColors instanceof Array ? areaColors : [areaColors];
          var splitAreas = [];
          var prevRadius = ticksCoords[0].coord;

          for (var i = 1; i < ticksCoords.length; i++) {
            var colorIndex = lineCount++ % areaColors.length;
            splitAreas[colorIndex] = splitAreas[colorIndex] || [];
            splitAreas[colorIndex].push(new graphic.Sector({
              shape: {
                cx: polar.cx,
                cy: polar.cy,
                r0: prevRadius,
                r: ticksCoords[i].coord,
                startAngle: 0,
                endAngle: Math.PI * 2
              },
              silent: true
            }));
            prevRadius = ticksCoords[i].coord;
          } // Simple optimization
          // Batching the lines if color are the same


          for (var i = 0; i < splitAreas.length; i++) {
            this.group.add(graphic.mergePath(splitAreas[i], {
              style: zrUtil.defaults({
                fill: areaColors[i % areaColors.length]
              }, areaStyleModel.getAreaStyle()),
              silent: true
            }));
          }
        }
      });
      /**
       * @inner
       */


      function layoutAxis(polar, radiusAxisModel, axisAngle) {
        return {
          position: [polar.cx, polar.cy],
          rotation: axisAngle / 180 * Math.PI,
          labelDirection: -1,
          tickDirection: -1,
          nameDirection: 1,
          labelRotate: radiusAxisModel.getModel('axisLabel').get('rotate'),
          // Over splitLine and splitArea
          z2: 1
        };
      }

      module.exports = _default;
      /***/
    },

    /***/
    "Fa/5":
    /*!***************************************************!*\
      !*** ./node_modules/echarts/lib/chart/scatter.js ***!
      \***************************************************/

    /*! no static exports found */

    /***/
    function Fa5(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ./scatter/ScatterSeries */
      "y2l5");

      __webpack_require__(
      /*! ./scatter/ScatterView */
      "q/+u");

      var visualSymbol = __webpack_require__(
      /*! ../visual/symbol */
      "f5Yq");

      var layoutPoints = __webpack_require__(
      /*! ../layout/points */
      "h8O9");

      __webpack_require__(
      /*! ../component/gridSimple */
      "Ae16");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // import * as zrUtil from 'zrender/src/core/util';
      // In case developer forget to include grid component


      echarts.registerVisual(visualSymbol('scatter', 'circle'));
      echarts.registerLayout(layoutPoints('scatter')); // echarts.registerProcessor(function (ecModel, api) {
      //     ecModel.eachSeriesByType('scatter', function (seriesModel) {
      //         var data = seriesModel.getData();
      //         var coordSys = seriesModel.coordinateSystem;
      //         if (coordSys.type !== 'geo') {
      //             return;
      //         }
      //         var startPt = coordSys.pointToData([0, 0]);
      //         var endPt = coordSys.pointToData([api.getWidth(), api.getHeight()]);
      //         var dims = zrUtil.map(coordSys.dimensions, function (dim) {
      //             return data.mapDimension(dim);
      //         });
      //         var range = {};
      //         range[dims[0]] = [Math.min(startPt[0], endPt[0]), Math.max(startPt[0], endPt[0])];
      //         range[dims[1]] = [Math.min(startPt[1], endPt[1]), Math.max(startPt[1], endPt[1])];
      //         data.selectRange(range);
      //     });
      // });

      /***/
    },

    /***/
    "GVMX":
    /*!********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/marker/MarkLineModel.js ***!
      \********************************************************************/

    /*! no static exports found */

    /***/
    function GVMX(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var MarkerModel = __webpack_require__(
      /*! ./MarkerModel */
      "JEkh");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = MarkerModel.extend({
        type: 'markLine',
        defaultOption: {
          zlevel: 0,
          z: 5,
          symbol: ['circle', 'arrow'],
          symbolSize: [8, 16],
          //symbolRotate: 0,
          precision: 2,
          tooltip: {
            trigger: 'item'
          },
          label: {
            show: true,
            position: 'end',
            distance: 5
          },
          lineStyle: {
            type: 'dashed'
          },
          emphasis: {
            label: {
              show: true
            },
            lineStyle: {
              width: 3
            }
          },
          animationEasing: 'linear'
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "GeKi":
    /*!***********************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/candlestick/CandlestickView.js ***!
      \***********************************************************************/

    /*! no static exports found */

    /***/
    function GeKi(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var ChartView = __webpack_require__(
      /*! ../../view/Chart */
      "6Ic6");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var Path = __webpack_require__(
      /*! zrender/lib/graphic/Path */
      "y+Vt");

      var _createClipPathFromCoordSys = __webpack_require__(
      /*! ../helper/createClipPathFromCoordSys */
      "sK/D");

      var createClipPath = _createClipPathFromCoordSys.createClipPath;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var NORMAL_ITEM_STYLE_PATH = ['itemStyle'];
      var EMPHASIS_ITEM_STYLE_PATH = ['emphasis', 'itemStyle'];
      var SKIP_PROPS = ['color', 'color0', 'borderColor', 'borderColor0'];
      var CandlestickView = ChartView.extend({
        type: 'candlestick',
        render: function render(seriesModel, ecModel, api) {
          // If there is clipPath created in large mode. Remove it.
          this.group.removeClipPath();

          this._updateDrawMode(seriesModel);

          this._isLargeDraw ? this._renderLarge(seriesModel) : this._renderNormal(seriesModel);
        },
        incrementalPrepareRender: function incrementalPrepareRender(seriesModel, ecModel, api) {
          this._clear();

          this._updateDrawMode(seriesModel);
        },
        incrementalRender: function incrementalRender(params, seriesModel, ecModel, api) {
          this._isLargeDraw ? this._incrementalRenderLarge(params, seriesModel) : this._incrementalRenderNormal(params, seriesModel);
        },
        _updateDrawMode: function _updateDrawMode(seriesModel) {
          var isLargeDraw = seriesModel.pipelineContext.large;

          if (this._isLargeDraw == null || isLargeDraw ^ this._isLargeDraw) {
            this._isLargeDraw = isLargeDraw;

            this._clear();
          }
        },
        _renderNormal: function _renderNormal(seriesModel) {
          var data = seriesModel.getData();
          var oldData = this._data;
          var group = this.group;
          var isSimpleBox = data.getLayout('isSimpleBox');
          var needsClip = seriesModel.get('clip', true);
          var coord = seriesModel.coordinateSystem;
          var clipArea = coord.getArea && coord.getArea(); // There is no old data only when first rendering or switching from
          // stream mode to normal mode, where previous elements should be removed.

          if (!this._data) {
            group.removeAll();
          }

          data.diff(oldData).add(function (newIdx) {
            if (data.hasValue(newIdx)) {
              var el;
              var itemLayout = data.getItemLayout(newIdx);

              if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
                return;
              }

              el = createNormalBox(itemLayout, newIdx, true);
              graphic.initProps(el, {
                shape: {
                  points: itemLayout.ends
                }
              }, seriesModel, newIdx);
              setBoxCommon(el, data, newIdx, isSimpleBox);
              group.add(el);
              data.setItemGraphicEl(newIdx, el);
            }
          }).update(function (newIdx, oldIdx) {
            var el = oldData.getItemGraphicEl(oldIdx); // Empty data

            if (!data.hasValue(newIdx)) {
              group.remove(el);
              return;
            }

            var itemLayout = data.getItemLayout(newIdx);

            if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
              group.remove(el);
              return;
            }

            if (!el) {
              el = createNormalBox(itemLayout, newIdx);
            } else {
              graphic.updateProps(el, {
                shape: {
                  points: itemLayout.ends
                }
              }, seriesModel, newIdx);
            }

            setBoxCommon(el, data, newIdx, isSimpleBox);
            group.add(el);
            data.setItemGraphicEl(newIdx, el);
          }).remove(function (oldIdx) {
            var el = oldData.getItemGraphicEl(oldIdx);
            el && group.remove(el);
          }).execute();
          this._data = data;
        },
        _renderLarge: function _renderLarge(seriesModel) {
          this._clear();

          createLarge(seriesModel, this.group);
          var clipPath = seriesModel.get('clip', true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;

          if (clipPath) {
            this.group.setClipPath(clipPath);
          } else {
            this.group.removeClipPath();
          }
        },
        _incrementalRenderNormal: function _incrementalRenderNormal(params, seriesModel) {
          var data = seriesModel.getData();
          var isSimpleBox = data.getLayout('isSimpleBox');
          var dataIndex;

          while ((dataIndex = params.next()) != null) {
            var el;
            var itemLayout = data.getItemLayout(dataIndex);
            el = createNormalBox(itemLayout, dataIndex);
            setBoxCommon(el, data, dataIndex, isSimpleBox);
            el.incremental = true;
            this.group.add(el);
          }
        },
        _incrementalRenderLarge: function _incrementalRenderLarge(params, seriesModel) {
          createLarge(seriesModel, this.group, true);
        },
        remove: function remove(ecModel) {
          this._clear();
        },
        _clear: function _clear() {
          this.group.removeAll();
          this._data = null;
        },
        dispose: zrUtil.noop
      });
      var NormalBoxPath = Path.extend({
        type: 'normalCandlestickBox',
        shape: {},
        buildPath: function buildPath(ctx, shape) {
          var ends = shape.points;

          if (this.__simpleBox) {
            ctx.moveTo(ends[4][0], ends[4][1]);
            ctx.lineTo(ends[6][0], ends[6][1]);
          } else {
            ctx.moveTo(ends[0][0], ends[0][1]);
            ctx.lineTo(ends[1][0], ends[1][1]);
            ctx.lineTo(ends[2][0], ends[2][1]);
            ctx.lineTo(ends[3][0], ends[3][1]);
            ctx.closePath();
            ctx.moveTo(ends[4][0], ends[4][1]);
            ctx.lineTo(ends[5][0], ends[5][1]);
            ctx.moveTo(ends[6][0], ends[6][1]);
            ctx.lineTo(ends[7][0], ends[7][1]);
          }
        }
      });

      function createNormalBox(itemLayout, dataIndex, isInit) {
        var ends = itemLayout.ends;
        return new NormalBoxPath({
          shape: {
            points: isInit ? transInit(ends, itemLayout) : ends
          },
          z2: 100
        });
      }

      function isNormalBoxClipped(clipArea, itemLayout) {
        var clipped = true;

        for (var i = 0; i < itemLayout.ends.length; i++) {
          // If any point are in the region.
          if (clipArea.contain(itemLayout.ends[i][0], itemLayout.ends[i][1])) {
            clipped = false;
            break;
          }
        }

        return clipped;
      }

      function setBoxCommon(el, data, dataIndex, isSimpleBox) {
        var itemModel = data.getItemModel(dataIndex);
        var normalItemStyleModel = itemModel.getModel(NORMAL_ITEM_STYLE_PATH);
        var color = data.getItemVisual(dataIndex, 'color');
        var borderColor = data.getItemVisual(dataIndex, 'borderColor') || color; // Color must be excluded.
        // Because symbol provide setColor individually to set fill and stroke

        var itemStyle = normalItemStyleModel.getItemStyle(SKIP_PROPS);
        el.useStyle(itemStyle);
        el.style.strokeNoScale = true;
        el.style.fill = color;
        el.style.stroke = borderColor;
        el.__simpleBox = isSimpleBox;
        var hoverStyle = itemModel.getModel(EMPHASIS_ITEM_STYLE_PATH).getItemStyle();
        graphic.setHoverStyle(el, hoverStyle);
      }

      function transInit(points, itemLayout) {
        return zrUtil.map(points, function (point) {
          point = point.slice();
          point[1] = itemLayout.initBaseline;
          return point;
        });
      }

      var LargeBoxPath = Path.extend({
        type: 'largeCandlestickBox',
        shape: {},
        buildPath: function buildPath(ctx, shape) {
          // Drawing lines is more efficient than drawing
          // a whole line or drawing rects.
          var points = shape.points;

          for (var i = 0; i < points.length;) {
            if (this.__sign === points[i++]) {
              var x = points[i++];
              ctx.moveTo(x, points[i++]);
              ctx.lineTo(x, points[i++]);
            } else {
              i += 3;
            }
          }
        }
      });

      function createLarge(seriesModel, group, incremental) {
        var data = seriesModel.getData();
        var largePoints = data.getLayout('largePoints');
        var elP = new LargeBoxPath({
          shape: {
            points: largePoints
          },
          __sign: 1
        });
        group.add(elP);
        var elN = new LargeBoxPath({
          shape: {
            points: largePoints
          },
          __sign: -1
        });
        group.add(elN);
        setLargeStyle(1, elP, seriesModel, data);
        setLargeStyle(-1, elN, seriesModel, data);

        if (incremental) {
          elP.incremental = true;
          elN.incremental = true;
        }
      }

      function setLargeStyle(sign, el, seriesModel, data) {
        var suffix = sign > 0 ? 'P' : 'N';
        var borderColor = data.getVisual('borderColor' + suffix) || data.getVisual('color' + suffix); // Color must be excluded.
        // Because symbol provide setColor individually to set fill and stroke

        var itemStyle = seriesModel.getModel(NORMAL_ITEM_STYLE_PATH).getItemStyle(SKIP_PROPS);
        el.useStyle(itemStyle);
        el.style.fill = null;
        el.style.stroke = borderColor; // No different
        // el.style.lineWidth = .5;
      }

      var _default = CandlestickView;
      module.exports = _default;
      /***/
    },

    /***/
    "GrNh":
    /*!*******************************************************!*\
      !*** ./node_modules/echarts/lib/chart/pie/PieView.js ***!
      \*******************************************************/

    /*! no static exports found */

    /***/
    function GrNh(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var ChartView = __webpack_require__(
      /*! ../../view/Chart */
      "6Ic6");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @param {module:echarts/model/Series} seriesModel
       * @param {boolean} hasAnimation
       * @inner
       */


      function updateDataSelected(uid, seriesModel, hasAnimation, api) {
        var data = seriesModel.getData();
        var dataIndex = this.dataIndex;
        var name = data.getName(dataIndex);
        var selectedOffset = seriesModel.get('selectedOffset');
        api.dispatchAction({
          type: 'pieToggleSelect',
          from: uid,
          name: name,
          seriesId: seriesModel.id
        });
        data.each(function (idx) {
          toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);
        });
      }
      /**
       * @param {module:zrender/graphic/Sector} el
       * @param {Object} layout
       * @param {boolean} isSelected
       * @param {number} selectedOffset
       * @param {boolean} hasAnimation
       * @inner
       */


      function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {
        var midAngle = (layout.startAngle + layout.endAngle) / 2;
        var dx = Math.cos(midAngle);
        var dy = Math.sin(midAngle);
        var offset = isSelected ? selectedOffset : 0;
        var position = [dx * offset, dy * offset];
        hasAnimation // animateTo will stop revious animation like update transition
        ? el.animate().when(200, {
          position: position
        }).start('bounceOut') : el.attr('position', position);
      }
      /**
       * Piece of pie including Sector, Label, LabelLine
       * @constructor
       * @extends {module:zrender/graphic/Group}
       */


      function PiePiece(data, idx) {
        graphic.Group.call(this);
        var sector = new graphic.Sector({
          z2: 2
        });
        var polyline = new graphic.Polyline();
        var text = new graphic.Text();
        this.add(sector);
        this.add(polyline);
        this.add(text);
        this.updateData(data, idx, true);
      }

      var piePieceProto = PiePiece.prototype;

      piePieceProto.updateData = function (data, idx, firstCreate) {
        var sector = this.childAt(0);
        var labelLine = this.childAt(1);
        var labelText = this.childAt(2);
        var seriesModel = data.hostModel;
        var itemModel = data.getItemModel(idx);
        var layout = data.getItemLayout(idx);
        var sectorShape = zrUtil.extend({}, layout);
        sectorShape.label = null;
        var animationTypeUpdate = seriesModel.getShallow('animationTypeUpdate');

        if (firstCreate) {
          sector.setShape(sectorShape);
          var animationType = seriesModel.getShallow('animationType');

          if (animationType === 'scale') {
            sector.shape.r = layout.r0;
            graphic.initProps(sector, {
              shape: {
                r: layout.r
              }
            }, seriesModel, idx);
          } // Expansion
          else {
            sector.shape.endAngle = layout.startAngle;
            graphic.updateProps(sector, {
              shape: {
                endAngle: layout.endAngle
              }
            }, seriesModel, idx);
          }
        } else {
          if (animationTypeUpdate === 'expansion') {
            // Sectors are set to be target shape and an overlaying clipPath is used for animation
            sector.setShape(sectorShape);
          } else {
            // Transition animation from the old shape
            graphic.updateProps(sector, {
              shape: sectorShape
            }, seriesModel, idx);
          }
        } // Update common style


        var visualColor = data.getItemVisual(idx, 'color');
        sector.useStyle(zrUtil.defaults({
          lineJoin: 'bevel',
          fill: visualColor
        }, itemModel.getModel('itemStyle').getItemStyle()));
        sector.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();
        var cursorStyle = itemModel.getShallow('cursor');
        cursorStyle && sector.attr('cursor', cursorStyle); // Toggle selected

        toggleItemSelected(this, data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), seriesModel.get('selectedOffset'), seriesModel.get('animation')); // Label and text animation should be applied only for transition type animation when update

        var withAnimation = !firstCreate && animationTypeUpdate === 'transition';

        this._updateLabel(data, idx, withAnimation);

        this.highDownOnUpdate = !seriesModel.get('silent') ? function (fromState, toState) {
          var hasAnimation = seriesModel.isAnimationEnabled() && itemModel.get('hoverAnimation');

          if (toState === 'emphasis') {
            labelLine.ignore = labelLine.hoverIgnore;
            labelText.ignore = labelText.hoverIgnore; // Sector may has animation of updating data. Force to move to the last frame
            // Or it may stopped on the wrong shape

            if (hasAnimation) {
              sector.stopAnimation(true);
              sector.animateTo({
                shape: {
                  r: layout.r + seriesModel.get('hoverOffset')
                }
              }, 300, 'elasticOut');
            }
          } else {
            labelLine.ignore = labelLine.normalIgnore;
            labelText.ignore = labelText.normalIgnore;

            if (hasAnimation) {
              sector.stopAnimation(true);
              sector.animateTo({
                shape: {
                  r: layout.r
                }
              }, 300, 'elasticOut');
            }
          }
        } : null;
        graphic.setHoverStyle(this);
      };

      piePieceProto._updateLabel = function (data, idx, withAnimation) {
        var labelLine = this.childAt(1);
        var labelText = this.childAt(2);
        var seriesModel = data.hostModel;
        var itemModel = data.getItemModel(idx);
        var layout = data.getItemLayout(idx);
        var labelLayout = layout.label;
        var visualColor = data.getItemVisual(idx, 'color');

        if (!labelLayout || isNaN(labelLayout.x) || isNaN(labelLayout.y)) {
          labelText.ignore = labelText.normalIgnore = labelText.hoverIgnore = labelLine.ignore = labelLine.normalIgnore = labelLine.hoverIgnore = true;
          return;
        }

        var targetLineShape = {
          points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]
        };
        var targetTextStyle = {
          x: labelLayout.x,
          y: labelLayout.y
        };

        if (withAnimation) {
          graphic.updateProps(labelLine, {
            shape: targetLineShape
          }, seriesModel, idx);
          graphic.updateProps(labelText, {
            style: targetTextStyle
          }, seriesModel, idx);
        } else {
          labelLine.attr({
            shape: targetLineShape
          });
          labelText.attr({
            style: targetTextStyle
          });
        }

        labelText.attr({
          rotation: labelLayout.rotation,
          origin: [labelLayout.x, labelLayout.y],
          z2: 10
        });
        var labelModel = itemModel.getModel('label');
        var labelHoverModel = itemModel.getModel('emphasis.label');
        var labelLineModel = itemModel.getModel('labelLine');
        var labelLineHoverModel = itemModel.getModel('emphasis.labelLine');
        var visualColor = data.getItemVisual(idx, 'color');
        graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {
          labelFetcher: data.hostModel,
          labelDataIndex: idx,
          defaultText: labelLayout.text,
          autoColor: visualColor,
          useInsideStyle: !!labelLayout.inside
        }, {
          textAlign: labelLayout.textAlign,
          textVerticalAlign: labelLayout.verticalAlign,
          opacity: data.getItemVisual(idx, 'opacity')
        });
        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');
        labelText.hoverIgnore = !labelHoverModel.get('show');
        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');
        labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color

        labelLine.setStyle({
          stroke: visualColor,
          opacity: data.getItemVisual(idx, 'opacity')
        });
        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());
        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();
        var smooth = labelLineModel.get('smooth');

        if (smooth && smooth === true) {
          smooth = 0.4;
        }

        labelLine.setShape({
          smooth: smooth
        });
      };

      zrUtil.inherits(PiePiece, graphic.Group); // Pie view

      var PieView = ChartView.extend({
        type: 'pie',
        init: function init() {
          var sectorGroup = new graphic.Group();
          this._sectorGroup = sectorGroup;
        },
        render: function render(seriesModel, ecModel, api, payload) {
          if (payload && payload.from === this.uid) {
            return;
          }

          var data = seriesModel.getData();
          var oldData = this._data;
          var group = this.group;
          var hasAnimation = ecModel.get('animation');
          var isFirstRender = !oldData;
          var animationType = seriesModel.get('animationType');
          var animationTypeUpdate = seriesModel.get('animationTypeUpdate');
          var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);
          var selectedMode = seriesModel.get('selectedMode');
          data.diff(oldData).add(function (idx) {
            var piePiece = new PiePiece(data, idx); // Default expansion animation

            if (isFirstRender && animationType !== 'scale') {
              piePiece.eachChild(function (child) {
                child.stopAnimation(true);
              });
            }

            selectedMode && piePiece.on('click', onSectorClick);
            data.setItemGraphicEl(idx, piePiece);
            group.add(piePiece);
          }).update(function (newIdx, oldIdx) {
            var piePiece = oldData.getItemGraphicEl(oldIdx);

            if (!isFirstRender && animationTypeUpdate !== 'transition') {
              piePiece.eachChild(function (child) {
                child.stopAnimation(true);
              });
            }

            piePiece.updateData(data, newIdx);
            piePiece.off('click');
            selectedMode && piePiece.on('click', onSectorClick);
            group.add(piePiece);
            data.setItemGraphicEl(newIdx, piePiece);
          }).remove(function (idx) {
            var piePiece = oldData.getItemGraphicEl(idx);
            group.remove(piePiece);
          }).execute();

          if (hasAnimation && data.count() > 0 && (isFirstRender ? animationType !== 'scale' : animationTypeUpdate !== 'transition')) {
            var shape = data.getItemLayout(0);

            for (var s = 1; isNaN(shape.startAngle) && s < data.count(); ++s) {
              shape = data.getItemLayout(s);
            }

            var r = Math.max(api.getWidth(), api.getHeight()) / 2;
            var removeClipPath = zrUtil.bind(group.removeClipPath, group);
            group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel, isFirstRender));
          } else {
            // clipPath is used in first-time animation, so remove it when otherwise. See: #8994
            group.removeClipPath();
          }

          this._data = data;
        },
        dispose: function dispose() {},
        _createClipPath: function _createClipPath(cx, cy, r, startAngle, clockwise, cb, seriesModel, isFirstRender) {
          var clipPath = new graphic.Sector({
            shape: {
              cx: cx,
              cy: cy,
              r0: 0,
              r: r,
              startAngle: startAngle,
              endAngle: startAngle,
              clockwise: clockwise
            }
          });
          var initOrUpdate = isFirstRender ? graphic.initProps : graphic.updateProps;
          initOrUpdate(clipPath, {
            shape: {
              endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2
            }
          }, seriesModel, cb);
          return clipPath;
        },

        /**
         * @implement
         */
        containPoint: function containPoint(point, seriesModel) {
          var data = seriesModel.getData();
          var itemLayout = data.getItemLayout(0);

          if (itemLayout) {
            var dx = point[0] - itemLayout.cx;
            var dy = point[1] - itemLayout.cy;
            var radius = Math.sqrt(dx * dx + dy * dy);
            return radius <= itemLayout.r && radius >= itemLayout.r0;
          }
        }
      });
      var _default = PieView;
      module.exports = _default;
      /***/
    },

    /***/
    "HF/U":
    /*!********************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/graph/simpleLayoutHelper.js ***!
      \********************************************************************/

    /*! no static exports found */

    /***/
    function HFU(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var vec2 = __webpack_require__(
      /*! zrender/lib/core/vector */
      "QBsz");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _multipleGraphEdgeHelper = __webpack_require__(
      /*! ../helper/multipleGraphEdgeHelper */
      "DDd/");

      var getCurvenessForEdge = _multipleGraphEdgeHelper.getCurvenessForEdge;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      function simpleLayout(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;

        if (coordSys && coordSys.type !== 'view') {
          return;
        }

        var graph = seriesModel.getGraph();
        graph.eachNode(function (node) {
          var model = node.getModel();
          node.setLayout([+model.get('x'), +model.get('y')]);
        });
        simpleLayoutEdge(graph, seriesModel);
      }

      function simpleLayoutEdge(graph, seriesModel) {
        graph.eachEdge(function (edge, index) {
          var curveness = zrUtil.retrieve3(edge.getModel().get('lineStyle.curveness'), -getCurvenessForEdge(edge, seriesModel, index, true), 0);
          var p1 = vec2.clone(edge.node1.getLayout());
          var p2 = vec2.clone(edge.node2.getLayout());
          var points = [p1, p2];

          if (+curveness) {
            points.push([(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * curveness]);
          }

          edge.setLayout(points);
        });
      }

      exports.simpleLayout = simpleLayout;
      exports.simpleLayoutEdge = simpleLayoutEdge;
      /***/
    },

    /***/
    "HM/N":
    /*!**************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/polar/polarCreator.js ***!
      \**************************************************************/

    /*! no static exports found */

    /***/
    function HMN(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var Polar = __webpack_require__(
      /*! ./Polar */
      "/SeX");

      var _number = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var parsePercent = _number.parsePercent;

      var _axisHelper = __webpack_require__(
      /*! ../../coord/axisHelper */
      "aX7z");

      var createScaleByModel = _axisHelper.createScaleByModel;
      var niceScaleExtent = _axisHelper.niceScaleExtent;

      var CoordinateSystem = __webpack_require__(
      /*! ../../CoordinateSystem */
      "IDmD");

      var _dataStackHelper = __webpack_require__(
      /*! ../../data/helper/dataStackHelper */
      "7hqr");

      var getStackedDimension = _dataStackHelper.getStackedDimension;

      __webpack_require__(
      /*! ./PolarModel */
      "ePAk");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // TODO Axis scale

      /**
       * Resize method bound to the polar
       * @param {module:echarts/coord/polar/PolarModel} polarModel
       * @param {module:echarts/ExtensionAPI} api
       */


      function resizePolar(polar, polarModel, api) {
        var center = polarModel.get('center');
        var width = api.getWidth();
        var height = api.getHeight();
        polar.cx = parsePercent(center[0], width);
        polar.cy = parsePercent(center[1], height);
        var radiusAxis = polar.getRadiusAxis();
        var size = Math.min(width, height) / 2;
        var radius = polarModel.get('radius');

        if (radius == null) {
          radius = [0, '100%'];
        } else if (!zrUtil.isArray(radius)) {
          // r0 = 0
          radius = [0, radius];
        }

        radius = [parsePercent(radius[0], size), parsePercent(radius[1], size)];
        radiusAxis.inverse ? radiusAxis.setExtent(radius[1], radius[0]) : radiusAxis.setExtent(radius[0], radius[1]);
      }
      /**
       * Update polar
       */


      function updatePolarScale(ecModel, api) {
        var polar = this;
        var angleAxis = polar.getAngleAxis();
        var radiusAxis = polar.getRadiusAxis(); // Reset scale

        angleAxis.scale.setExtent(Infinity, -Infinity);
        radiusAxis.scale.setExtent(Infinity, -Infinity);
        ecModel.eachSeries(function (seriesModel) {
          if (seriesModel.coordinateSystem === polar) {
            var data = seriesModel.getData();
            zrUtil.each(data.mapDimension('radius', true), function (dim) {
              radiusAxis.scale.unionExtentFromData(data, getStackedDimension(data, dim));
            });
            zrUtil.each(data.mapDimension('angle', true), function (dim) {
              angleAxis.scale.unionExtentFromData(data, getStackedDimension(data, dim));
            });
          }
        });
        niceScaleExtent(angleAxis.scale, angleAxis.model);
        niceScaleExtent(radiusAxis.scale, radiusAxis.model); // Fix extent of category angle axis

        if (angleAxis.type === 'category' && !angleAxis.onBand) {
          var extent = angleAxis.getExtent();
          var diff = 360 / angleAxis.scale.count();
          angleAxis.inverse ? extent[1] += diff : extent[1] -= diff;
          angleAxis.setExtent(extent[0], extent[1]);
        }
      }
      /**
       * Set common axis properties
       * @param {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}
       * @param {module:echarts/coord/polar/AxisModel}
       * @inner
       */


      function setAxis(axis, axisModel) {
        axis.type = axisModel.get('type');
        axis.scale = createScaleByModel(axisModel);
        axis.onBand = axisModel.get('boundaryGap') && axis.type === 'category';
        axis.inverse = axisModel.get('inverse');

        if (axisModel.mainType === 'angleAxis') {
          axis.inverse ^= axisModel.get('clockwise');
          var startAngle = axisModel.get('startAngle');
          axis.setExtent(startAngle, startAngle + (axis.inverse ? -360 : 360));
        } // Inject axis instance


        axisModel.axis = axis;
        axis.model = axisModel;
      }

      var polarCreator = {
        dimensions: Polar.prototype.dimensions,
        create: function create(ecModel, api) {
          var polarList = [];
          ecModel.eachComponent('polar', function (polarModel, idx) {
            var polar = new Polar(idx); // Inject resize and update method

            polar.update = updatePolarScale;
            var radiusAxis = polar.getRadiusAxis();
            var angleAxis = polar.getAngleAxis();
            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');
            var angleAxisModel = polarModel.findAxisModel('angleAxis');
            setAxis(radiusAxis, radiusAxisModel);
            setAxis(angleAxis, angleAxisModel);
            resizePolar(polar, polarModel, api);
            polarList.push(polar);
            polarModel.coordinateSystem = polar;
            polar.model = polarModel;
          }); // Inject coordinateSystem to series

          ecModel.eachSeries(function (seriesModel) {
            if (seriesModel.get('coordinateSystem') === 'polar') {
              var polarModel = ecModel.queryComponents({
                mainType: 'polar',
                index: seriesModel.get('polarIndex'),
                id: seriesModel.get('polarId')
              })[0];
              seriesModel.coordinateSystem = polarModel.coordinateSystem;
            }
          });
          return polarList;
        }
      };
      CoordinateSystem.register('polar', polarCreator);
      /***/
    },

    /***/
    "HjIi":
    /*!*****************************************************!*\
      !*** ./node_modules/echarts/lib/layout/barPolar.js ***!
      \*****************************************************/

    /*! no static exports found */

    /***/
    function HjIi(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _number = __webpack_require__(
      /*! ../util/number */
      "OELB");

      var parsePercent = _number.parsePercent;

      var _dataStackHelper = __webpack_require__(
      /*! ../data/helper/dataStackHelper */
      "7hqr");

      var isDimensionStacked = _dataStackHelper.isDimensionStacked;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      function getSeriesStackId(seriesModel) {
        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;
      }

      function getAxisKey(polar, axis) {
        return axis.dim + polar.model.componentIndex;
      }
      /**
       * @param {string} seriesType
       * @param {module:echarts/model/Global} ecModel
       * @param {module:echarts/ExtensionAPI} api
       */


      function barLayoutPolar(seriesType, ecModel, api) {
        var lastStackCoords = {};
        var barWidthAndOffset = calRadialBar(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {
          return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'polar';
        }));
        ecModel.eachSeriesByType(seriesType, function (seriesModel) {
          // Check series coordinate, do layout for polar only
          if (seriesModel.coordinateSystem.type !== 'polar') {
            return;
          }

          var data = seriesModel.getData();
          var polar = seriesModel.coordinateSystem;
          var baseAxis = polar.getBaseAxis();
          var axisKey = getAxisKey(polar, baseAxis);
          var stackId = getSeriesStackId(seriesModel);
          var columnLayoutInfo = barWidthAndOffset[axisKey][stackId];
          var columnOffset = columnLayoutInfo.offset;
          var columnWidth = columnLayoutInfo.width;
          var valueAxis = polar.getOtherAxis(baseAxis);
          var cx = seriesModel.coordinateSystem.cx;
          var cy = seriesModel.coordinateSystem.cy;
          var barMinHeight = seriesModel.get('barMinHeight') || 0;
          var barMinAngle = seriesModel.get('barMinAngle') || 0;
          lastStackCoords[stackId] = lastStackCoords[stackId] || [];
          var valueDim = data.mapDimension(valueAxis.dim);
          var baseDim = data.mapDimension(baseAxis.dim);
          var stacked = isDimensionStacked(data, valueDim
          /*, baseDim*/
          );
          var clampLayout = baseAxis.dim !== 'radius' || !seriesModel.get('roundCap', true);
          var valueAxisStart = valueAxis.dim === 'radius' ? valueAxis.dataToRadius(0) : valueAxis.dataToAngle(0);

          for (var idx = 0, len = data.count(); idx < len; idx++) {
            var value = data.get(valueDim, idx);
            var baseValue = data.get(baseDim, idx);
            var sign = value >= 0 ? 'p' : 'n';
            var baseCoord = valueAxisStart; // Because of the barMinHeight, we can not use the value in
            // stackResultDimension directly.
            // Only ordinal axis can be stacked.

            if (stacked) {
              if (!lastStackCoords[stackId][baseValue]) {
                lastStackCoords[stackId][baseValue] = {
                  p: valueAxisStart,
                  // Positive stack
                  n: valueAxisStart // Negative stack

                };
              } // Should also consider #4243


              baseCoord = lastStackCoords[stackId][baseValue][sign];
            }

            var r0;
            var r;
            var startAngle;
            var endAngle; // radial sector

            if (valueAxis.dim === 'radius') {
              var radiusSpan = valueAxis.dataToRadius(value) - valueAxisStart;
              var angle = baseAxis.dataToAngle(baseValue);

              if (Math.abs(radiusSpan) < barMinHeight) {
                radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight;
              }

              r0 = baseCoord;
              r = baseCoord + radiusSpan;
              startAngle = angle - columnOffset;
              endAngle = startAngle - columnWidth;
              stacked && (lastStackCoords[stackId][baseValue][sign] = r);
            } // tangential sector
            else {
              var angleSpan = valueAxis.dataToAngle(value, clampLayout) - valueAxisStart;
              var radius = baseAxis.dataToRadius(baseValue);

              if (Math.abs(angleSpan) < barMinAngle) {
                angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle;
              }

              r0 = radius + columnOffset;
              r = r0 + columnWidth;
              startAngle = baseCoord;
              endAngle = baseCoord + angleSpan; // if the previous stack is at the end of the ring,
              // add a round to differentiate it from origin
              // var extent = angleAxis.getExtent();
              // var stackCoord = angle;
              // if (stackCoord === extent[0] && value > 0) {
              //     stackCoord = extent[1];
              // }
              // else if (stackCoord === extent[1] && value < 0) {
              //     stackCoord = extent[0];
              // }

              stacked && (lastStackCoords[stackId][baseValue][sign] = endAngle);
            }

            data.setItemLayout(idx, {
              cx: cx,
              cy: cy,
              r0: r0,
              r: r,
              // Consider that positive angle is anti-clockwise,
              // while positive radian of sector is clockwise
              startAngle: -startAngle * Math.PI / 180,
              endAngle: -endAngle * Math.PI / 180
            });
          }
        }, this);
      }
      /**
       * Calculate bar width and offset for radial bar charts
       */


      function calRadialBar(barSeries, api) {
        // Columns info on each category axis. Key is polar name
        var columnsMap = {};
        zrUtil.each(barSeries, function (seriesModel, idx) {
          var data = seriesModel.getData();
          var polar = seriesModel.coordinateSystem;
          var baseAxis = polar.getBaseAxis();
          var axisKey = getAxisKey(polar, baseAxis);
          var axisExtent = baseAxis.getExtent();
          var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
          var columnsOnAxis = columnsMap[axisKey] || {
            bandWidth: bandWidth,
            remainedWidth: bandWidth,
            autoWidthCount: 0,
            categoryGap: '20%',
            gap: '30%',
            stacks: {}
          };
          var stacks = columnsOnAxis.stacks;
          columnsMap[axisKey] = columnsOnAxis;
          var stackId = getSeriesStackId(seriesModel);

          if (!stacks[stackId]) {
            columnsOnAxis.autoWidthCount++;
          }

          stacks[stackId] = stacks[stackId] || {
            width: 0,
            maxWidth: 0
          };
          var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);
          var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);
          var barGap = seriesModel.get('barGap');
          var barCategoryGap = seriesModel.get('barCategoryGap');

          if (barWidth && !stacks[stackId].width) {
            barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
            stacks[stackId].width = barWidth;
            columnsOnAxis.remainedWidth -= barWidth;
          }

          barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
          barGap != null && (columnsOnAxis.gap = barGap);
          barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
        });
        var result = {};
        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {
          result[coordSysName] = {};
          var stacks = columnsOnAxis.stacks;
          var bandWidth = columnsOnAxis.bandWidth;
          var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);
          var barGapPercent = parsePercent(columnsOnAxis.gap, 1);
          var remainedWidth = columnsOnAxis.remainedWidth;
          var autoWidthCount = columnsOnAxis.autoWidthCount;
          var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
          autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth

          zrUtil.each(stacks, function (column, stack) {
            var maxWidth = column.maxWidth;

            if (maxWidth && maxWidth < autoWidth) {
              maxWidth = Math.min(maxWidth, remainedWidth);

              if (column.width) {
                maxWidth = Math.min(maxWidth, column.width);
              }

              remainedWidth -= maxWidth;
              column.width = maxWidth;
              autoWidthCount--;
            }
          }); // Recalculate width again

          autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
          autoWidth = Math.max(autoWidth, 0);
          var widthSum = 0;
          var lastColumn;
          zrUtil.each(stacks, function (column, idx) {
            if (!column.width) {
              column.width = autoWidth;
            }

            lastColumn = column;
            widthSum += column.width * (1 + barGapPercent);
          });

          if (lastColumn) {
            widthSum -= lastColumn.width * barGapPercent;
          }

          var offset = -widthSum / 2;
          zrUtil.each(stacks, function (column, stackId) {
            result[coordSysName][stackId] = result[coordSysName][stackId] || {
              offset: offset,
              width: column.width
            };
            offset += column.width * (1 + barGapPercent);
          });
        });
        return result;
      }

      var _default = barLayoutPolar;
      module.exports = _default;
      /***/
    },

    /***/
    "Hw7h":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/gauge/PointerPath.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function Hw7h(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var Path = __webpack_require__(
      /*! zrender/lib/graphic/Path */
      "y+Vt");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = Path.extend({
        type: 'echartsGaugePointer',
        shape: {
          angle: 0,
          width: 10,
          r: 10,
          x: 0,
          y: 0
        },
        buildPath: function buildPath(ctx, shape) {
          var mathCos = Math.cos;
          var mathSin = Math.sin;
          var r = shape.r;
          var width = shape.width;
          var angle = shape.angle;
          var x = shape.x - mathCos(angle) * width * (width >= r / 3 ? 1 : 2);
          var y = shape.y - mathSin(angle) * width * (width >= r / 3 ? 1 : 2);
          angle = shape.angle - Math.PI / 2;
          ctx.moveTo(x, y);
          ctx.lineTo(shape.x + mathCos(angle) * width, shape.y + mathSin(angle) * width);
          ctx.lineTo(shape.x + mathCos(shape.angle) * r, shape.y + mathSin(shape.angle) * r);
          ctx.lineTo(shape.x - mathCos(angle) * width, shape.y - mathSin(angle) * width);
          ctx.lineTo(x, y);
          return;
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "Hxpc":
    /*!********************************************************!*\
      !*** ./node_modules/echarts/lib/coord/geo/GeoModel.js ***!
      \********************************************************/

    /*! no static exports found */

    /***/
    function Hxpc(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var modelUtil = __webpack_require__(
      /*! ../../util/model */
      "4NO4");

      var ComponentModel = __webpack_require__(
      /*! ../../model/Component */
      "bLfw");

      var Model = __webpack_require__(
      /*! ../../model/Model */
      "Qxkt");

      var selectableMixin = __webpack_require__(
      /*! ../../component/helper/selectableMixin */
      "cCMj");

      var geoCreator = __webpack_require__(
      /*! ./geoCreator */
      "7uqq");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var GeoModel = ComponentModel.extend({
        type: 'geo',

        /**
         * @type {module:echarts/coord/geo/Geo}
         */
        coordinateSystem: null,
        layoutMode: 'box',
        init: function init(option) {
          ComponentModel.prototype.init.apply(this, arguments); // Default label emphasis `show`

          modelUtil.defaultEmphasis(option, 'label', ['show']);
        },
        optionUpdated: function optionUpdated() {
          var option = this.option;
          var self = this;
          option.regions = geoCreator.getFilledRegions(option.regions, option.map, option.nameMap);
          this._optionModelMap = zrUtil.reduce(option.regions || [], function (optionModelMap, regionOpt) {
            if (regionOpt.name) {
              optionModelMap.set(regionOpt.name, new Model(regionOpt, self));
            }

            return optionModelMap;
          }, zrUtil.createHashMap());
          this.updateSelectedMap(option.regions);
        },
        defaultOption: {
          zlevel: 0,
          z: 0,
          show: true,
          left: 'center',
          top: 'center',
          // width:,
          // height:,
          // right
          // bottom
          // Aspect is width / height. Inited to be geoJson bbox aspect
          // This parameter is used for scale this aspect
          // If svg used, aspectScale is 1 by default.
          // aspectScale: 0.75,
          aspectScale: null,
          ///// Layout with center and size
          // If you wan't to put map in a fixed size box with right aspect ratio
          // This two properties may more conveninet
          // layoutCenter: [50%, 50%]
          // layoutSize: 100
          silent: false,
          // Map type
          map: '',
          // Define left-top, right-bottom coords to control view
          // For example, [ [180, 90], [-180, -90] ]
          boundingCoords: null,
          // Default on center of map
          center: null,
          zoom: 1,
          scaleLimit: null,
          // selectedMode: false
          label: {
            show: false,
            color: '#000'
          },
          itemStyle: {
            // color: ,
            borderWidth: 0.5,
            borderColor: '#444',
            color: '#eee'
          },
          emphasis: {
            label: {
              show: true,
              color: 'rgb(100,0,0)'
            },
            itemStyle: {
              color: 'rgba(255,215,0,0.8)'
            }
          },
          regions: []
        },

        /**
         * Get model of region
         * @param  {string} name
         * @return {module:echarts/model/Model}
         */
        getRegionModel: function getRegionModel(name) {
          return this._optionModelMap.get(name) || new Model(null, this, this.ecModel);
        },

        /**
         * Format label
         * @param {string} name Region name
         * @param {string} [status='normal'] 'normal' or 'emphasis'
         * @return {string}
         */
        getFormattedLabel: function getFormattedLabel(name, status) {
          status = status || 'normal';
          var regionModel = this.getRegionModel(name);
          var formatter = regionModel.get((status === 'normal' ? '' : status + '.') + 'label.formatter');
          var params = {
            name: name
          };

          if (typeof formatter === 'function') {
            params.status = status;
            return formatter(params);
          } else if (typeof formatter === 'string') {
            return formatter.replace('{a}', name != null ? name : '');
          }
        },
        setZoom: function setZoom(zoom) {
          this.option.zoom = zoom;
        },
        setCenter: function setCenter(center) {
          this.option.center = center;
        }
      });
      zrUtil.mixin(GeoModel, selectableMixin);
      var _default = GeoModel;
      module.exports = _default;
      /***/
    },

    /***/
    "I+77":
    /*!*************************************************!*\
      !*** ./node_modules/echarts/lib/chart/graph.js ***!
      \*************************************************/

    /*! no static exports found */

    /***/
    function I77(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ./graph/GraphSeries */
      "h54F");

      __webpack_require__(
      /*! ./graph/GraphView */
      "lwQL");

      __webpack_require__(
      /*! ./graph/graphAction */
      "10cm");

      var categoryFilter = __webpack_require__(
      /*! ./graph/categoryFilter */
      "Z1r0");

      var visualSymbol = __webpack_require__(
      /*! ../visual/symbol */
      "f5Yq");

      var categoryVisual = __webpack_require__(
      /*! ./graph/categoryVisual */
      "KUOm");

      var edgeVisual = __webpack_require__(
      /*! ./graph/edgeVisual */
      "3m61");

      var simpleLayout = __webpack_require__(
      /*! ./graph/simpleLayout */
      "01d+");

      var circularLayout = __webpack_require__(
      /*! ./graph/circularLayout */
      "rdor");

      var forceLayout = __webpack_require__(
      /*! ./graph/forceLayout */
      "WGYa");

      var createView = __webpack_require__(
      /*! ./graph/createView */
      "ewwo");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      echarts.registerProcessor(categoryFilter);
      echarts.registerVisual(visualSymbol('graph', 'circle', null));
      echarts.registerVisual(categoryVisual);
      echarts.registerVisual(edgeVisual);
      echarts.registerLayout(simpleLayout);
      echarts.registerLayout(echarts.PRIORITY.VISUAL.POST_CHART_LAYOUT, circularLayout);
      echarts.registerLayout(forceLayout); // Graph view coordinate system

      echarts.registerCoordinateSystem('graphView', {
        create: createView
      });
      /***/
    },

    /***/
    "I+Bx":
    /*!*******************************************************!*\
      !*** ./node_modules/echarts/lib/coord/radar/Radar.js ***!
      \*******************************************************/

    /*! no static exports found */

    /***/
    function IBx(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var IndicatorAxis = __webpack_require__(
      /*! ./IndicatorAxis */
      "eIcI");

      var IntervalScale = __webpack_require__(
      /*! ../../scale/Interval */
      "ieMj");

      var numberUtil = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var _axisHelper = __webpack_require__(
      /*! ../axisHelper */
      "aX7z");

      var getScaleExtent = _axisHelper.getScaleExtent;
      var niceScaleExtent = _axisHelper.niceScaleExtent;

      var CoordinateSystem = __webpack_require__(
      /*! ../../CoordinateSystem */
      "IDmD");

      var LogScale = __webpack_require__(
      /*! ../../scale/Log */
      "jCoz");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // TODO clockwise


      function Radar(radarModel, ecModel, api) {
        this._model = radarModel;
        /**
         * Radar dimensions
         * @type {Array.<string>}
         */

        this.dimensions = [];
        this._indicatorAxes = zrUtil.map(radarModel.getIndicatorModels(), function (indicatorModel, idx) {
          var dim = 'indicator_' + idx;
          var indicatorAxis = new IndicatorAxis(dim, indicatorModel.get('axisType') === 'log' ? new LogScale() : new IntervalScale());
          indicatorAxis.name = indicatorModel.get('name'); // Inject model and axis

          indicatorAxis.model = indicatorModel;
          indicatorModel.axis = indicatorAxis;
          this.dimensions.push(dim);
          return indicatorAxis;
        }, this);
        this.resize(radarModel, api);
        /**
         * @type {number}
         * @readOnly
         */

        this.cx;
        /**
         * @type {number}
         * @readOnly
         */

        this.cy;
        /**
         * @type {number}
         * @readOnly
         */

        this.r;
        /**
         * @type {number}
         * @readOnly
         */

        this.r0;
        /**
         * @type {number}
         * @readOnly
         */

        this.startAngle;
      }

      Radar.prototype.getIndicatorAxes = function () {
        return this._indicatorAxes;
      };

      Radar.prototype.dataToPoint = function (value, indicatorIndex) {
        var indicatorAxis = this._indicatorAxes[indicatorIndex];
        return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);
      };

      Radar.prototype.coordToPoint = function (coord, indicatorIndex) {
        var indicatorAxis = this._indicatorAxes[indicatorIndex];
        var angle = indicatorAxis.angle;
        var x = this.cx + coord * Math.cos(angle);
        var y = this.cy - coord * Math.sin(angle);
        return [x, y];
      };

      Radar.prototype.pointToData = function (pt) {
        var dx = pt[0] - this.cx;
        var dy = pt[1] - this.cy;
        var radius = Math.sqrt(dx * dx + dy * dy);
        dx /= radius;
        dy /= radius;
        var radian = Math.atan2(-dy, dx); // Find the closest angle
        // FIXME index can calculated directly

        var minRadianDiff = Infinity;
        var closestAxis;
        var closestAxisIdx = -1;

        for (var i = 0; i < this._indicatorAxes.length; i++) {
          var indicatorAxis = this._indicatorAxes[i];
          var diff = Math.abs(radian - indicatorAxis.angle);

          if (diff < minRadianDiff) {
            closestAxis = indicatorAxis;
            closestAxisIdx = i;
            minRadianDiff = diff;
          }
        }

        return [closestAxisIdx, +(closestAxis && closestAxis.coordToData(radius))];
      };

      Radar.prototype.resize = function (radarModel, api) {
        var center = radarModel.get('center');
        var viewWidth = api.getWidth();
        var viewHeight = api.getHeight();
        var viewSize = Math.min(viewWidth, viewHeight) / 2;
        this.cx = numberUtil.parsePercent(center[0], viewWidth);
        this.cy = numberUtil.parsePercent(center[1], viewHeight);
        this.startAngle = radarModel.get('startAngle') * Math.PI / 180; // radius may be single value like `20`, `'80%'`, or array like `[10, '80%']`

        var radius = radarModel.get('radius');

        if (typeof radius === 'string' || typeof radius === 'number') {
          radius = [0, radius];
        }

        this.r0 = numberUtil.parsePercent(radius[0], viewSize);
        this.r = numberUtil.parsePercent(radius[1], viewSize);
        zrUtil.each(this._indicatorAxes, function (indicatorAxis, idx) {
          indicatorAxis.setExtent(this.r0, this.r);
          var angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length; // Normalize to [-PI, PI]

          angle = Math.atan2(Math.sin(angle), Math.cos(angle));
          indicatorAxis.angle = angle;
        }, this);
      };

      Radar.prototype.update = function (ecModel, api) {
        var indicatorAxes = this._indicatorAxes;
        var radarModel = this._model;
        zrUtil.each(indicatorAxes, function (indicatorAxis) {
          indicatorAxis.scale.setExtent(Infinity, -Infinity);
        });
        ecModel.eachSeriesByType('radar', function (radarSeries, idx) {
          if (radarSeries.get('coordinateSystem') !== 'radar' || ecModel.getComponent('radar', radarSeries.get('radarIndex')) !== radarModel) {
            return;
          }

          var data = radarSeries.getData();
          zrUtil.each(indicatorAxes, function (indicatorAxis) {
            indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim));
          });
        }, this);
        var splitNumber = radarModel.get('splitNumber');

        function increaseInterval(interval) {
          var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10)); // Increase interval

          var f = interval / exp10;

          if (f === 2) {
            f = 5;
          } else {
            // f is 2 or 5
            f *= 2;
          }

          return f * exp10;
        } // Force all the axis fixing the maxSplitNumber.


        zrUtil.each(indicatorAxes, function (indicatorAxis, idx) {
          var rawExtent = getScaleExtent(indicatorAxis.scale, indicatorAxis.model).extent;
          niceScaleExtent(indicatorAxis.scale, indicatorAxis.model);
          var axisModel = indicatorAxis.model;
          var scale = indicatorAxis.scale;
          var fixedMin = axisModel.getMin();
          var fixedMax = axisModel.getMax();
          var interval = scale.getInterval();

          if (fixedMin != null && fixedMax != null) {
            // User set min, max, divide to get new interval
            scale.setExtent(+fixedMin, +fixedMax);
            scale.setInterval((fixedMax - fixedMin) / splitNumber);
          } else if (fixedMin != null) {
            var max; // User set min, expand extent on the other side

            do {
              max = fixedMin + interval * splitNumber;
              scale.setExtent(+fixedMin, max); // Interval must been set after extent
              // FIXME

              scale.setInterval(interval);
              interval = increaseInterval(interval);
            } while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1]));
          } else if (fixedMax != null) {
            var min; // User set min, expand extent on the other side

            do {
              min = fixedMax - interval * splitNumber;
              scale.setExtent(min, +fixedMax);
              scale.setInterval(interval);
              interval = increaseInterval(interval);
            } while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0]));
          } else {
            var nicedSplitNumber = scale.getTicks().length - 1;

            if (nicedSplitNumber > splitNumber) {
              interval = increaseInterval(interval);
            } // TODO


            var max = Math.ceil(rawExtent[1] / interval) * interval;
            var min = numberUtil.round(max - interval * splitNumber);
            scale.setExtent(min, max);
            scale.setInterval(interval);
          }
        });
      };
      /**
       * Radar dimensions is based on the data
       * @type {Array}
       */


      Radar.dimensions = [];

      Radar.create = function (ecModel, api) {
        var radarList = [];
        ecModel.eachComponent('radar', function (radarModel) {
          var radar = new Radar(radarModel, ecModel, api);
          radarList.push(radar);
          radarModel.coordinateSystem = radar;
        });
        ecModel.eachSeriesByType('radar', function (radarSeries) {
          if (radarSeries.get('coordinateSystem') === 'radar') {
            // Inject coordinate system
            radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0];
          }
        });
        return radarList;
      };

      CoordinateSystem.register('radar', Radar);
      var _default = Radar;
      module.exports = _default;
      /***/
    },

    /***/
    "I3/A":
    /*!**************************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/helper/createGraphFromNodeEdge.js ***!
      \**************************************************************************/

    /*! no static exports found */

    /***/
    function I3A(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var List = __webpack_require__(
      /*! ../../data/List */
      "YXkt");

      var Graph = __webpack_require__(
      /*! ../../data/Graph */
      "c2i1");

      var linkList = __webpack_require__(
      /*! ../../data/helper/linkList */
      "Mdki");

      var createDimensions = __webpack_require__(
      /*! ../../data/helper/createDimensions */
      "sdST");

      var CoordinateSystem = __webpack_require__(
      /*! ../../CoordinateSystem */
      "IDmD");

      var createListFromArray = __webpack_require__(
      /*! ./createListFromArray */
      "MwEJ");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function _default(nodes, edges, seriesModel, directed, beforeLink) {
        // ??? TODO
        // support dataset?
        var graph = new Graph(directed);

        for (var i = 0; i < nodes.length; i++) {
          graph.addNode(zrUtil.retrieve( // Id, name, dataIndex
          nodes[i].id, nodes[i].name, i), i);
        }

        var linkNameList = [];
        var validEdges = [];
        var linkCount = 0;

        for (var i = 0; i < edges.length; i++) {
          var link = edges[i];
          var source = link.source;
          var target = link.target; // addEdge may fail when source or target not exists

          if (graph.addEdge(source, target, linkCount)) {
            validEdges.push(link);
            linkNameList.push(zrUtil.retrieve(link.id, source + ' > ' + target));
            linkCount++;
          }
        }

        var coordSys = seriesModel.get('coordinateSystem');
        var nodeData;

        if (coordSys === 'cartesian2d' || coordSys === 'polar') {
          nodeData = createListFromArray(nodes, seriesModel);
        } else {
          var coordSysCtor = CoordinateSystem.get(coordSys);
          var coordDimensions = coordSysCtor && coordSysCtor.type !== 'view' ? coordSysCtor.dimensions || [] : []; // FIXME: Some geo do not need `value` dimenson, whereas `calendar` needs
          // `value` dimension, but graph need `value` dimension. It's better to
          // uniform this behavior.

          if (zrUtil.indexOf(coordDimensions, 'value') < 0) {
            coordDimensions.concat(['value']);
          }

          var dimensionNames = createDimensions(nodes, {
            coordDimensions: coordDimensions
          });
          nodeData = new List(dimensionNames, seriesModel);
          nodeData.initData(nodes);
        }

        var edgeData = new List(['value'], seriesModel);
        edgeData.initData(validEdges, linkNameList);
        beforeLink && beforeLink(nodeData, edgeData);
        linkList({
          mainData: nodeData,
          struct: graph,
          structAttr: 'graph',
          datas: {
            node: nodeData,
            edge: edgeData
          },
          datasAttr: {
            node: 'data',
            edge: 'edgeData'
          }
        }); // Update dataIndex of nodes and edges because invalid edge may be removed

        graph.update();
        return graph;
      }

      module.exports = _default;
      /***/
    },

    /***/
    "IUWy":
    /*!**********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/toolbox/featureManager.js ***!
      \**********************************************************************/

    /*! no static exports found */

    /***/
    function IUWy(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var features = {};

      function register(name, ctor) {
        features[name] = ctor;
      }

      function get(name) {
        return features[name];
      }

      exports.register = register;
      exports.get = get;
      /***/
    },

    /***/
    "IWNH":
    /*!***********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/tree/TreeSeries.js ***!
      \***********************************************************/

    /*! no static exports found */

    /***/
    function IWNH(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var SeriesModel = __webpack_require__(
      /*! ../../model/Series */
      "T4UG");

      var Tree = __webpack_require__(
      /*! ../../data/Tree */
      "Bsck");

      var _format = __webpack_require__(
      /*! ../../util/format */
      "7aKB");

      var encodeHTML = _format.encodeHTML;

      var Model = __webpack_require__(
      /*! ../../model/Model */
      "Qxkt");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = SeriesModel.extend({
        type: 'series.tree',
        layoutInfo: null,
        // can support the position parameters 'left', 'top','right','bottom', 'width',
        // 'height' in the setOption() with 'merge' mode normal.
        layoutMode: 'box',

        /**
         * Init a tree data structure from data in option series
         * @param  {Object} option  the object used to config echarts view
         * @return {module:echarts/data/List} storage initial data
         */
        getInitialData: function getInitialData(option) {
          //create an virtual root
          var root = {
            name: option.name,
            children: option.data
          };
          var leaves = option.leaves || {};
          var leavesModel = new Model(leaves, this, this.ecModel);
          var tree = Tree.createTree(root, this, beforeLink);

          function beforeLink(nodeData) {
            nodeData.wrapMethod('getItemModel', function (model, idx) {
              var node = tree.getNodeByDataIndex(idx);

              if (!node.children.length || !node.isExpand) {
                model.parentModel = leavesModel;
              }

              return model;
            });
          }

          var treeDepth = 0;
          tree.eachNode('preorder', function (node) {
            if (node.depth > treeDepth) {
              treeDepth = node.depth;
            }
          });
          var expandAndCollapse = option.expandAndCollapse;
          var expandTreeDepth = expandAndCollapse && option.initialTreeDepth >= 0 ? option.initialTreeDepth : treeDepth;
          tree.root.eachNode('preorder', function (node) {
            var item = node.hostTree.data.getRawDataItem(node.dataIndex); // Add item.collapsed != null, because users can collapse node original in the series.data.

            node.isExpand = item && item.collapsed != null ? !item.collapsed : node.depth <= expandTreeDepth;
          });
          return tree.data;
        },

        /**
         * Make the configuration 'orient' backward compatibly, with 'horizontal = LR', 'vertical = TB'.
         * @returns {string} orient
         */
        getOrient: function getOrient() {
          var orient = this.get('orient');

          if (orient === 'horizontal') {
            orient = 'LR';
          } else if (orient === 'vertical') {
            orient = 'TB';
          }

          return orient;
        },
        setZoom: function setZoom(zoom) {
          this.option.zoom = zoom;
        },
        setCenter: function setCenter(center) {
          this.option.center = center;
        },

        /**
         * @override
         * @param {number} dataIndex
         */
        formatTooltip: function formatTooltip(dataIndex) {
          var tree = this.getData().tree;
          var realRoot = tree.root.children[0];
          var node = tree.getNodeByDataIndex(dataIndex);
          var value = node.getValue();
          var name = node.name;

          while (node && node !== realRoot) {
            name = node.parentNode.name + '.' + name;
            node = node.parentNode;
          }

          return encodeHTML(name + (isNaN(value) || value == null ? '' : ' : ' + value));
        },
        defaultOption: {
          zlevel: 0,
          z: 2,
          coordinateSystem: 'view',
          // the position of the whole view
          left: '12%',
          top: '12%',
          right: '12%',
          bottom: '12%',
          // the layout of the tree, two value can be selected, 'orthogonal' or 'radial'
          layout: 'orthogonal',
          // value can be 'polyline'
          edgeShape: 'curve',
          edgeForkPosition: '50%',
          // true | false | 'move' | 'scale', see module:component/helper/RoamController.
          roam: false,
          // Symbol size scale ratio in roam
          nodeScaleRatio: 0.4,
          // Default on center of graph
          center: null,
          zoom: 1,
          // The orient of orthoginal layout, can be setted to 'LR', 'TB', 'RL', 'BT'.
          // and the backward compatibility configuration 'horizontal = LR', 'vertical = TB'.
          orient: 'LR',
          symbol: 'emptyCircle',
          symbolSize: 7,
          expandAndCollapse: true,
          initialTreeDepth: 2,
          lineStyle: {
            color: '#ccc',
            width: 1.5,
            curveness: 0.5
          },
          itemStyle: {
            color: 'lightsteelblue',
            borderColor: '#c23531',
            borderWidth: 1.5
          },
          label: {
            show: true,
            color: '#555'
          },
          leaves: {
            label: {
              show: true
            }
          },
          animationEasing: 'linear',
          animationDuration: 700,
          animationDurationUpdate: 1000
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "IXuL":
    /*!***********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/line/LineSeries.js ***!
      \***********************************************************/

    /*! no static exports found */

    /***/
    function IXuL(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var createListFromArray = __webpack_require__(
      /*! ../helper/createListFromArray */
      "MwEJ");

      var SeriesModel = __webpack_require__(
      /*! ../../model/Series */
      "T4UG");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = SeriesModel.extend({
        type: 'series.line',
        dependencies: ['grid', 'polar'],
        getInitialData: function getInitialData(option, ecModel) {
          return createListFromArray(this.getSource(), this, {
            useEncodeDefaulter: true
          });
        },
        defaultOption: {
          zlevel: 0,
          z: 2,
          coordinateSystem: 'cartesian2d',
          legendHoverLink: true,
          hoverAnimation: true,
          // stack: null
          // xAxisIndex: 0,
          // yAxisIndex: 0,
          // polarIndex: 0,
          // If clip the overflow value
          clip: true,
          // cursor: null,
          label: {
            position: 'top'
          },
          // itemStyle: {
          // },
          lineStyle: {
            width: 2,
            type: 'solid'
          },
          // areaStyle: {
          // origin of areaStyle. Valid values:
          // `'auto'/null/undefined`: from axisLine to data
          // `'start'`: from min to data
          // `'end'`: from data to max
          // origin: 'auto'
          // },
          // false, 'start', 'end', 'middle'
          step: false,
          // Disabled if step is true
          smooth: false,
          smoothMonotone: null,
          symbol: 'emptyCircle',
          symbolSize: 4,
          symbolRotate: null,
          showSymbol: true,
          // `false`: follow the label interval strategy.
          // `true`: show all symbols.
          // `'auto'`: If possible, show all symbols, otherwise
          //           follow the label interval strategy.
          showAllSymbol: 'auto',
          // Whether to connect break point.
          connectNulls: false,
          // Sampling for large data. Can be: 'average', 'max', 'min', 'sum'.
          sampling: 'none',
          animationEasing: 'linear',
          // Disable progressive
          progressive: 0,
          hoverLayerThreshold: Infinity
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "IXyC":
    /*!******************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/parallel/ParallelModel.js ***!
      \******************************************************************/

    /*! no static exports found */

    /***/
    function IXyC(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var Component = __webpack_require__(
      /*! ../../model/Component */
      "bLfw");

      __webpack_require__(
      /*! ./AxisModel */
      "3zoK");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = Component.extend({
        type: 'parallel',
        dependencies: ['parallelAxis'],

        /**
         * @type {module:echarts/coord/parallel/Parallel}
         */
        coordinateSystem: null,

        /**
         * Each item like: 'dim0', 'dim1', 'dim2', ...
         * @type {Array.<string>}
         * @readOnly
         */
        dimensions: null,

        /**
         * Coresponding to dimensions.
         * @type {Array.<number>}
         * @readOnly
         */
        parallelAxisIndex: null,
        layoutMode: 'box',
        defaultOption: {
          zlevel: 0,
          z: 0,
          left: 80,
          top: 60,
          right: 80,
          bottom: 60,
          // width: {totalWidth} - left - right,
          // height: {totalHeight} - top - bottom,
          layout: 'horizontal',
          // 'horizontal' or 'vertical'
          // FIXME
          // naming?
          axisExpandable: false,
          axisExpandCenter: null,
          axisExpandCount: 0,
          axisExpandWidth: 50,
          // FIXME '10%' ?
          axisExpandRate: 17,
          axisExpandDebounce: 50,
          // [out, in, jumpTarget]. In percentage. If use [null, 0.05], null means full.
          // Do not doc to user until necessary.
          axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
          axisExpandTriggerOn: 'click',
          // 'mousemove' or 'click'
          parallelAxisDefault: null
        },

        /**
         * @override
         */
        init: function init() {
          Component.prototype.init.apply(this, arguments);
          this.mergeOption({});
        },

        /**
         * @override
         */
        mergeOption: function mergeOption(newOption) {
          var thisOption = this.option;
          newOption && zrUtil.merge(thisOption, newOption, true);

          this._initDimensions();
        },

        /**
         * Whether series or axis is in this coordinate system.
         * @param {module:echarts/model/Series|module:echarts/coord/parallel/AxisModel} model
         * @param {module:echarts/model/Global} ecModel
         */
        contains: function contains(model, ecModel) {
          var parallelIndex = model.get('parallelIndex');
          return parallelIndex != null && ecModel.getComponent('parallel', parallelIndex) === this;
        },
        setAxisExpand: function setAxisExpand(opt) {
          zrUtil.each(['axisExpandable', 'axisExpandCenter', 'axisExpandCount', 'axisExpandWidth', 'axisExpandWindow'], function (name) {
            if (opt.hasOwnProperty(name)) {
              this.option[name] = opt[name];
            }
          }, this);
        },

        /**
         * @private
         */
        _initDimensions: function _initDimensions() {
          var dimensions = this.dimensions = [];
          var parallelAxisIndex = this.parallelAxisIndex = [];
          var axisModels = zrUtil.filter(this.dependentModels.parallelAxis, function (axisModel) {
            // Can not use this.contains here, because
            // initialization has not been completed yet.
            return (axisModel.get('parallelIndex') || 0) === this.componentIndex;
          }, this);
          zrUtil.each(axisModels, function (axisModel) {
            dimensions.push('dim' + axisModel.get('dim'));
            parallelAxisIndex.push(axisModel.componentIndex);
          });
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "Itpr":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/tree/layoutHelper.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function Itpr(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var layout = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * A third-party license is embeded for some of the code in this file:
      * The tree layoutHelper implementation was originally copied from
      * "d3.js"(https://github.com/d3/d3-hierarchy) with
      * some modifications made for this project.
      * (see more details in the comment of the specific method below.)
      * The use of the source code of this file is also subject to the terms
      * and consitions of the licence of "d3.js" (BSD-3Clause, see
      * </licenses/LICENSE-d3>).
      */

      /**
       * @file The layout algorithm of node-link tree diagrams. Here we using Reingold-Tilford algorithm to drawing
       *       the tree.
       */

      /**
       * Initialize all computational message for following algorithm.
       *
       * @param  {module:echarts/data/Tree~TreeNode} root   The virtual root of the tree.
       */


      function init(root) {
        root.hierNode = {
          defaultAncestor: null,
          ancestor: root,
          prelim: 0,
          modifier: 0,
          change: 0,
          shift: 0,
          i: 0,
          thread: null
        };
        var nodes = [root];
        var node;
        var children;

        while (node = nodes.pop()) {
          // jshint ignore:line
          children = node.children;

          if (node.isExpand && children.length) {
            var n = children.length;

            for (var i = n - 1; i >= 0; i--) {
              var child = children[i];
              child.hierNode = {
                defaultAncestor: null,
                ancestor: child,
                prelim: 0,
                modifier: 0,
                change: 0,
                shift: 0,
                i: i,
                thread: null
              };
              nodes.push(child);
            }
          }
        }
      }
      /**
       * The implementation of this function was originally copied from "d3.js"
       * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
       * with some modifications made for this program.
       * See the license statement at the head of this file.
       *
       * Computes a preliminary x coordinate for node. Before that, this function is
       * applied recursively to the children of node, as well as the function
       * apportion(). After spacing out the children by calling executeShifts(), the
       * node is placed to the midpoint of its outermost children.
       *
       * @param  {module:echarts/data/Tree~TreeNode} node
       * @param {Function} separation
       */


      function firstWalk(node, separation) {
        var children = node.isExpand ? node.children : [];
        var siblings = node.parentNode.children;
        var subtreeW = node.hierNode.i ? siblings[node.hierNode.i - 1] : null;

        if (children.length) {
          executeShifts(node);
          var midPoint = (children[0].hierNode.prelim + children[children.length - 1].hierNode.prelim) / 2;

          if (subtreeW) {
            node.hierNode.prelim = subtreeW.hierNode.prelim + separation(node, subtreeW);
            node.hierNode.modifier = node.hierNode.prelim - midPoint;
          } else {
            node.hierNode.prelim = midPoint;
          }
        } else if (subtreeW) {
          node.hierNode.prelim = subtreeW.hierNode.prelim + separation(node, subtreeW);
        }

        node.parentNode.hierNode.defaultAncestor = apportion(node, subtreeW, node.parentNode.hierNode.defaultAncestor || siblings[0], separation);
      }
      /**
       * The implementation of this function was originally copied from "d3.js"
       * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
       * with some modifications made for this program.
       * See the license statement at the head of this file.
       *
       * Computes all real x-coordinates by summing up the modifiers recursively.
       *
       * @param  {module:echarts/data/Tree~TreeNode} node
       */


      function secondWalk(node) {
        var nodeX = node.hierNode.prelim + node.parentNode.hierNode.modifier;
        node.setLayout({
          x: nodeX
        }, true);
        node.hierNode.modifier += node.parentNode.hierNode.modifier;
      }

      function separation(cb) {
        return arguments.length ? cb : defaultSeparation;
      }
      /**
       * Transform the common coordinate to radial coordinate.
       *
       * @param  {number} x
       * @param  {number} y
       * @return {Object}
       */


      function radialCoordinate(x, y) {
        var radialCoor = {};
        x -= Math.PI / 2;
        radialCoor.x = y * Math.cos(x);
        radialCoor.y = y * Math.sin(x);
        return radialCoor;
      }
      /**
       * Get the layout position of the whole view.
       *
       * @param {module:echarts/model/Series} seriesModel  the model object of sankey series
       * @param {module:echarts/ExtensionAPI} api  provide the API list that the developer can call
       * @return {module:zrender/core/BoundingRect}  size of rect to draw the sankey view
       */


      function getViewRect(seriesModel, api) {
        return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
          width: api.getWidth(),
          height: api.getHeight()
        });
      }
      /**
       * All other shifts, applied to the smaller subtrees between w- and w+, are
       * performed by this function.
       *
       * The implementation of this function was originally copied from "d3.js"
       * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
       * with some modifications made for this program.
       * See the license statement at the head of this file.
       *
       * @param  {module:echarts/data/Tree~TreeNode} node
       */


      function executeShifts(node) {
        var children = node.children;
        var n = children.length;
        var shift = 0;
        var change = 0;

        while (--n >= 0) {
          var child = children[n];
          child.hierNode.prelim += shift;
          child.hierNode.modifier += shift;
          change += child.hierNode.change;
          shift += child.hierNode.shift + change;
        }
      }
      /**
       * The implementation of this function was originally copied from "d3.js"
       * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
       * with some modifications made for this program.
       * See the license statement at the head of this file.
       *
       * The core of the algorithm. Here, a new subtree is combined with the
       * previous subtrees. Threads are used to traverse the inside and outside
       * contours of the left and right subtree up to the highest common level.
       * Whenever two nodes of the inside contours conflict, we compute the left
       * one of the greatest uncommon ancestors using the function nextAncestor()
       * and call moveSubtree() to shift the subtree and prepare the shifts of
       * smaller subtrees. Finally, we add a new thread (if necessary).
       *
       * @param  {module:echarts/data/Tree~TreeNode} subtreeV
       * @param  {module:echarts/data/Tree~TreeNode} subtreeW
       * @param  {module:echarts/data/Tree~TreeNode} ancestor
       * @param  {Function} separation
       * @return {module:echarts/data/Tree~TreeNode}
       */


      function apportion(subtreeV, subtreeW, ancestor, separation) {
        if (subtreeW) {
          var nodeOutRight = subtreeV;
          var nodeInRight = subtreeV;
          var nodeOutLeft = nodeInRight.parentNode.children[0];
          var nodeInLeft = subtreeW;
          var sumOutRight = nodeOutRight.hierNode.modifier;
          var sumInRight = nodeInRight.hierNode.modifier;
          var sumOutLeft = nodeOutLeft.hierNode.modifier;
          var sumInLeft = nodeInLeft.hierNode.modifier;

          while (nodeInLeft = nextRight(nodeInLeft), nodeInRight = nextLeft(nodeInRight), nodeInLeft && nodeInRight) {
            nodeOutRight = nextRight(nodeOutRight);
            nodeOutLeft = nextLeft(nodeOutLeft);
            nodeOutRight.hierNode.ancestor = subtreeV;
            var shift = nodeInLeft.hierNode.prelim + sumInLeft - nodeInRight.hierNode.prelim - sumInRight + separation(nodeInLeft, nodeInRight);

            if (shift > 0) {
              moveSubtree(nextAncestor(nodeInLeft, subtreeV, ancestor), subtreeV, shift);
              sumInRight += shift;
              sumOutRight += shift;
            }

            sumInLeft += nodeInLeft.hierNode.modifier;
            sumInRight += nodeInRight.hierNode.modifier;
            sumOutRight += nodeOutRight.hierNode.modifier;
            sumOutLeft += nodeOutLeft.hierNode.modifier;
          }

          if (nodeInLeft && !nextRight(nodeOutRight)) {
            nodeOutRight.hierNode.thread = nodeInLeft;
            nodeOutRight.hierNode.modifier += sumInLeft - sumOutRight;
          }

          if (nodeInRight && !nextLeft(nodeOutLeft)) {
            nodeOutLeft.hierNode.thread = nodeInRight;
            nodeOutLeft.hierNode.modifier += sumInRight - sumOutLeft;
            ancestor = subtreeV;
          }
        }

        return ancestor;
      }
      /**
       * This function is used to traverse the right contour of a subtree.
       * It returns the rightmost child of node or the thread of node. The function
       * returns null if and only if node is on the highest depth of its subtree.
       *
       * @param  {module:echarts/data/Tree~TreeNode} node
       * @return {module:echarts/data/Tree~TreeNode}
       */


      function nextRight(node) {
        var children = node.children;
        return children.length && node.isExpand ? children[children.length - 1] : node.hierNode.thread;
      }
      /**
       * This function is used to traverse the left contour of a subtree (or a subforest).
       * It returns the leftmost child of node or the thread of node. The function
       * returns null if and only if node is on the highest depth of its subtree.
       *
       * @param  {module:echarts/data/Tree~TreeNode} node
       * @return {module:echarts/data/Tree~TreeNode}
       */


      function nextLeft(node) {
        var children = node.children;
        return children.length && node.isExpand ? children[0] : node.hierNode.thread;
      }
      /**
       * If nodeInLefts ancestor is a sibling of node, returns nodeInLefts ancestor.
       * Otherwise, returns the specified ancestor.
       *
       * @param  {module:echarts/data/Tree~TreeNode} nodeInLeft
       * @param  {module:echarts/data/Tree~TreeNode} node
       * @param  {module:echarts/data/Tree~TreeNode} ancestor
       * @return {module:echarts/data/Tree~TreeNode}
       */


      function nextAncestor(nodeInLeft, node, ancestor) {
        return nodeInLeft.hierNode.ancestor.parentNode === node.parentNode ? nodeInLeft.hierNode.ancestor : ancestor;
      }
      /**
       * The implementation of this function was originally copied from "d3.js"
       * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
       * with some modifications made for this program.
       * See the license statement at the head of this file.
       *
       * Shifts the current subtree rooted at wr.
       * This is done by increasing prelim(w+) and modifier(w+) by shift.
       *
       * @param  {module:echarts/data/Tree~TreeNode} wl
       * @param  {module:echarts/data/Tree~TreeNode} wr
       * @param  {number} shift [description]
       */


      function moveSubtree(wl, wr, shift) {
        var change = shift / (wr.hierNode.i - wl.hierNode.i);
        wr.hierNode.change -= change;
        wr.hierNode.shift += shift;
        wr.hierNode.modifier += shift;
        wr.hierNode.prelim += shift;
        wl.hierNode.change += change;
      }
      /**
       * The implementation of this function was originally copied from "d3.js"
       * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
       * with some modifications made for this program.
       * See the license statement at the head of this file.
       */


      function defaultSeparation(node1, node2) {
        return node1.parentNode === node2.parentNode ? 1 : 2;
      }

      exports.init = init;
      exports.firstWalk = firstWalk;
      exports.secondWalk = secondWalk;
      exports.separation = separation;
      exports.radialCoordinate = radialCoordinate;
      exports.getViewRect = getViewRect;
      /***/
    },

    /***/
    "IyUQ":
    /*!***********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/dataZoom/SliderZoomView.js ***!
      \***********************************************************************/

    /*! no static exports found */

    /***/
    function IyUQ(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var eventTool = __webpack_require__(
      /*! zrender/lib/core/event */
      "YH21");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var throttle = __webpack_require__(
      /*! ../../util/throttle */
      "iLNv");

      var DataZoomView = __webpack_require__(
      /*! ./DataZoomView */
      "fc+c");

      var numberUtil = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var layout = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var sliderMove = __webpack_require__(
      /*! ../helper/sliderMove */
      "72pK");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var Rect = graphic.Rect;
      var linearMap = numberUtil.linearMap;
      var asc = numberUtil.asc;
      var bind = zrUtil.bind;
      var each = zrUtil.each; // Constants

      var DEFAULT_LOCATION_EDGE_GAP = 7;
      var DEFAULT_FRAME_BORDER_WIDTH = 1;
      var DEFAULT_FILLER_SIZE = 30;
      var HORIZONTAL = 'horizontal';
      var VERTICAL = 'vertical';
      var LABEL_GAP = 5;
      var SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];
      var SliderZoomView = DataZoomView.extend({
        type: 'dataZoom.slider',
        init: function init(ecModel, api) {
          /**
           * @private
           * @type {Object}
           */
          this._displayables = {};
          /**
           * @private
           * @type {string}
           */

          this._orient;
          /**
           * [0, 100]
           * @private
           */

          this._range;
          /**
           * [coord of the first handle, coord of the second handle]
           * @private
           */

          this._handleEnds;
          /**
           * [length, thick]
           * @private
           * @type {Array.<number>}
           */

          this._size;
          /**
           * @private
           * @type {number}
           */

          this._handleWidth;
          /**
           * @private
           * @type {number}
           */

          this._handleHeight;
          /**
           * @private
           */

          this._location;
          /**
           * @private
           */

          this._dragging;
          /**
           * @private
           */

          this._dataShadowInfo;
          this.api = api;
        },

        /**
         * @override
         */
        render: function render(dataZoomModel, ecModel, api, payload) {
          SliderZoomView.superApply(this, 'render', arguments);
          throttle.createOrUpdate(this, '_dispatchZoomAction', this.dataZoomModel.get('throttle'), 'fixRate');
          this._orient = dataZoomModel.get('orient');

          if (this.dataZoomModel.get('show') === false) {
            this.group.removeAll();
            return;
          } // Notice: this._resetInterval() should not be executed when payload.type
          // is 'dataZoom', origin this._range should be maintained, otherwise 'pan'
          // or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,


          if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {
            this._buildView();
          }

          this._updateView();
        },

        /**
         * @override
         */
        remove: function remove() {
          SliderZoomView.superApply(this, 'remove', arguments);
          throttle.clear(this, '_dispatchZoomAction');
        },

        /**
         * @override
         */
        dispose: function dispose() {
          SliderZoomView.superApply(this, 'dispose', arguments);
          throttle.clear(this, '_dispatchZoomAction');
        },
        _buildView: function _buildView() {
          var thisGroup = this.group;
          thisGroup.removeAll();

          this._resetLocation();

          this._resetInterval();

          var barGroup = this._displayables.barGroup = new graphic.Group();

          this._renderBackground();

          this._renderHandle();

          this._renderDataShadow();

          thisGroup.add(barGroup);

          this._positionGroup();
        },

        /**
         * @private
         */
        _resetLocation: function _resetLocation() {
          var dataZoomModel = this.dataZoomModel;
          var api = this.api; // If some of x/y/width/height are not specified,
          // auto-adapt according to target grid.

          var coordRect = this._findCoordRect();

          var ecSize = {
            width: api.getWidth(),
            height: api.getHeight()
          }; // Default align by coordinate system rect.

          var positionInfo = this._orient === HORIZONTAL ? {
            // Why using 'right', because right should be used in vertical,
            // and it is better to be consistent for dealing with position param merge.
            right: ecSize.width - coordRect.x - coordRect.width,
            top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP,
            width: coordRect.width,
            height: DEFAULT_FILLER_SIZE
          } : {
            // vertical
            right: DEFAULT_LOCATION_EDGE_GAP,
            top: coordRect.y,
            width: DEFAULT_FILLER_SIZE,
            height: coordRect.height
          }; // Do not write back to option and replace value 'ph', because
          // the 'ph' value should be recalculated when resize.

          var layoutParams = layout.getLayoutParams(dataZoomModel.option); // Replace the placeholder value.

          zrUtil.each(['right', 'top', 'width', 'height'], function (name) {
            if (layoutParams[name] === 'ph') {
              layoutParams[name] = positionInfo[name];
            }
          });
          var layoutRect = layout.getLayoutRect(layoutParams, ecSize, dataZoomModel.padding);
          this._location = {
            x: layoutRect.x,
            y: layoutRect.y
          };
          this._size = [layoutRect.width, layoutRect.height];
          this._orient === VERTICAL && this._size.reverse();
        },

        /**
         * @private
         */
        _positionGroup: function _positionGroup() {
          var thisGroup = this.group;
          var location = this._location;
          var orient = this._orient; // Just use the first axis to determine mapping.

          var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();
          var inverse = targetAxisModel && targetAxisModel.get('inverse');
          var barGroup = this._displayables.barGroup;
          var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse; // Transform barGroup.

          barGroup.attr(orient === HORIZONTAL && !inverse ? {
            scale: otherAxisInverse ? [1, 1] : [1, -1]
          } : orient === HORIZONTAL && inverse ? {
            scale: otherAxisInverse ? [-1, 1] : [-1, -1]
          } : orient === VERTICAL && !inverse ? {
            scale: otherAxisInverse ? [1, -1] : [1, 1],
            rotation: Math.PI / 2 // Dont use Math.PI, considering shadow direction.

          } : {
            scale: otherAxisInverse ? [-1, -1] : [-1, 1],
            rotation: Math.PI / 2
          }); // Position barGroup

          var rect = thisGroup.getBoundingRect([barGroup]);
          thisGroup.attr('position', [location.x - rect.x, location.y - rect.y]);
        },

        /**
         * @private
         */
        _getViewExtent: function _getViewExtent() {
          return [0, this._size[0]];
        },
        _renderBackground: function _renderBackground() {
          var dataZoomModel = this.dataZoomModel;
          var size = this._size;
          var barGroup = this._displayables.barGroup;
          barGroup.add(new Rect({
            silent: true,
            shape: {
              x: 0,
              y: 0,
              width: size[0],
              height: size[1]
            },
            style: {
              fill: dataZoomModel.get('backgroundColor')
            },
            z2: -40
          })); // Click panel, over shadow, below handles.

          barGroup.add(new Rect({
            shape: {
              x: 0,
              y: 0,
              width: size[0],
              height: size[1]
            },
            style: {
              fill: 'transparent'
            },
            z2: 0,
            onclick: zrUtil.bind(this._onClickPanelClick, this)
          }));
        },
        _renderDataShadow: function _renderDataShadow() {
          var info = this._dataShadowInfo = this._prepareDataShadowInfo();

          if (!info) {
            return;
          }

          var size = this._size;
          var seriesModel = info.series;
          var data = seriesModel.getRawData();
          var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() // @see candlestick
          : info.otherDim;

          if (otherDim == null) {
            return;
          }

          var otherDataExtent = data.getDataExtent(otherDim); // Nice extent.

          var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;
          otherDataExtent = [otherDataExtent[0] - otherOffset, otherDataExtent[1] + otherOffset];
          var otherShadowExtent = [0, size[1]];
          var thisShadowExtent = [0, size[0]];
          var areaPoints = [[size[0], 0], [0, 0]];
          var linePoints = [];
          var step = thisShadowExtent[1] / (data.count() - 1);
          var thisCoord = 0; // Optimize for large data shadow

          var stride = Math.round(data.count() / size[0]);
          var lastIsEmpty;
          data.each([otherDim], function (value, index) {
            if (stride > 0 && index % stride) {
              thisCoord += step;
              return;
            } // FIXME
            // Should consider axis.min/axis.max when drawing dataShadow.
            // FIXME
            // list


            var isEmpty = value == null || isNaN(value) || value === ''; // See #4235.

            var otherCoord = isEmpty ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, true); // Attempt to draw data shadow precisely when there are empty value.

            if (isEmpty && !lastIsEmpty && index) {
              areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);
              linePoints.push([linePoints[linePoints.length - 1][0], 0]);
            } else if (!isEmpty && lastIsEmpty) {
              areaPoints.push([thisCoord, 0]);
              linePoints.push([thisCoord, 0]);
            }

            areaPoints.push([thisCoord, otherCoord]);
            linePoints.push([thisCoord, otherCoord]);
            thisCoord += step;
            lastIsEmpty = isEmpty;
          });
          var dataZoomModel = this.dataZoomModel; // var dataBackgroundModel = dataZoomModel.getModel('dataBackground');

          this._displayables.barGroup.add(new graphic.Polygon({
            shape: {
              points: areaPoints
            },
            style: zrUtil.defaults({
              fill: dataZoomModel.get('dataBackgroundColor')
            }, dataZoomModel.getModel('dataBackground.areaStyle').getAreaStyle()),
            silent: true,
            z2: -20
          }));

          this._displayables.barGroup.add(new graphic.Polyline({
            shape: {
              points: linePoints
            },
            style: dataZoomModel.getModel('dataBackground.lineStyle').getLineStyle(),
            silent: true,
            z2: -19
          }));
        },
        _prepareDataShadowInfo: function _prepareDataShadowInfo() {
          var dataZoomModel = this.dataZoomModel;
          var showDataShadow = dataZoomModel.get('showDataShadow');

          if (showDataShadow === false) {
            return;
          } // Find a representative series.


          var result;
          var ecModel = this.ecModel;
          dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {
            var seriesModels = dataZoomModel.getAxisProxy(dimNames.name, axisIndex).getTargetSeriesModels();
            zrUtil.each(seriesModels, function (seriesModel) {
              if (result) {
                return;
              }

              if (showDataShadow !== true && zrUtil.indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')) < 0) {
                return;
              }

              var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis;
              var otherDim = getOtherDim(dimNames.name);
              var otherAxisInverse;
              var coordSys = seriesModel.coordinateSystem;

              if (otherDim != null && coordSys.getOtherAxis) {
                otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;
              }

              otherDim = seriesModel.getData().mapDimension(otherDim);
              result = {
                thisAxis: thisAxis,
                series: seriesModel,
                thisDim: dimNames.name,
                otherDim: otherDim,
                otherAxisInverse: otherAxisInverse
              };
            }, this);
          }, this);
          return result;
        },
        _renderHandle: function _renderHandle() {
          var displaybles = this._displayables;
          var handles = displaybles.handles = [];
          var handleLabels = displaybles.handleLabels = [];
          var barGroup = this._displayables.barGroup;
          var size = this._size;
          var dataZoomModel = this.dataZoomModel;
          barGroup.add(displaybles.filler = new Rect({
            draggable: true,
            cursor: getCursor(this._orient),
            drift: bind(this._onDragMove, this, 'all'),
            ondragstart: bind(this._showDataInfo, this, true),
            ondragend: bind(this._onDragEnd, this),
            onmouseover: bind(this._showDataInfo, this, true),
            onmouseout: bind(this._showDataInfo, this, false),
            style: {
              fill: dataZoomModel.get('fillerColor'),
              textPosition: 'inside'
            }
          })); // Frame border.

          barGroup.add(new Rect({
            silent: true,
            subPixelOptimize: true,
            shape: {
              x: 0,
              y: 0,
              width: size[0],
              height: size[1]
            },
            style: {
              stroke: dataZoomModel.get('dataBackgroundColor') || dataZoomModel.get('borderColor'),
              lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
              fill: 'rgba(0,0,0,0)'
            }
          }));
          each([0, 1], function (handleIndex) {
            var path = graphic.createIcon(dataZoomModel.get('handleIcon'), {
              cursor: getCursor(this._orient),
              draggable: true,
              drift: bind(this._onDragMove, this, handleIndex),
              ondragend: bind(this._onDragEnd, this),
              onmouseover: bind(this._showDataInfo, this, true),
              onmouseout: bind(this._showDataInfo, this, false)
            }, {
              x: -1,
              y: 0,
              width: 2,
              height: 2
            });
            var bRect = path.getBoundingRect();
            this._handleHeight = numberUtil.parsePercent(dataZoomModel.get('handleSize'), this._size[1]);
            this._handleWidth = bRect.width / bRect.height * this._handleHeight;
            path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());
            var handleColor = dataZoomModel.get('handleColor'); // Compatitable with previous version

            if (handleColor != null) {
              path.style.fill = handleColor;
            }

            barGroup.add(handles[handleIndex] = path);
            var textStyleModel = dataZoomModel.textStyleModel;
            this.group.add(handleLabels[handleIndex] = new graphic.Text({
              silent: true,
              invisible: true,
              style: {
                x: 0,
                y: 0,
                text: '',
                textVerticalAlign: 'middle',
                textAlign: 'center',
                textFill: textStyleModel.getTextColor(),
                textFont: textStyleModel.getFont()
              },
              z2: 10
            }));
          }, this);
        },

        /**
         * @private
         */
        _resetInterval: function _resetInterval() {
          var range = this._range = this.dataZoomModel.getPercentRange();

          var viewExtent = this._getViewExtent();

          this._handleEnds = [linearMap(range[0], [0, 100], viewExtent, true), linearMap(range[1], [0, 100], viewExtent, true)];
        },

        /**
         * @private
         * @param {(number|string)} handleIndex 0 or 1 or 'all'
         * @param {number} delta
         * @return {boolean} changed
         */
        _updateInterval: function _updateInterval(handleIndex, delta) {
          var dataZoomModel = this.dataZoomModel;
          var handleEnds = this._handleEnds;

          var viewExtend = this._getViewExtent();

          var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
          var percentExtent = [0, 100];
          sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get('zoomLock') ? 'all' : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
          var lastRange = this._range;
          var range = this._range = asc([linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true)]);
          return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1];
        },

        /**
         * @private
         */
        _updateView: function _updateView(nonRealtime) {
          var displaybles = this._displayables;
          var handleEnds = this._handleEnds;
          var handleInterval = asc(handleEnds.slice());
          var size = this._size;
          each([0, 1], function (handleIndex) {
            // Handles
            var handle = displaybles.handles[handleIndex];
            var handleHeight = this._handleHeight;
            handle.attr({
              scale: [handleHeight / 2, handleHeight / 2],
              position: [handleEnds[handleIndex], size[1] / 2 - handleHeight / 2]
            });
          }, this); // Filler

          displaybles.filler.setShape({
            x: handleInterval[0],
            y: 0,
            width: handleInterval[1] - handleInterval[0],
            height: size[1]
          });

          this._updateDataInfo(nonRealtime);
        },

        /**
         * @private
         */
        _updateDataInfo: function _updateDataInfo(nonRealtime) {
          var dataZoomModel = this.dataZoomModel;
          var displaybles = this._displayables;
          var handleLabels = displaybles.handleLabels;
          var orient = this._orient;
          var labelTexts = ['', '']; // FIXME
          // dateformatterautoformatterec2 date.getAutoFormatter

          if (dataZoomModel.get('showDetail')) {
            var axisProxy = dataZoomModel.findRepresentativeAxisProxy();

            if (axisProxy) {
              var axis = axisProxy.getAxisModel().axis;
              var range = this._range;
              var dataInterval = nonRealtime // See #4434, data and axis are not processed and reset yet in non-realtime mode.
              ? axisProxy.calculateDataWindow({
                start: range[0],
                end: range[1]
              }).valueWindow : axisProxy.getDataValueWindow();
              labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];
            }
          }

          var orderedHandleEnds = asc(this._handleEnds.slice());
          setLabel.call(this, 0);
          setLabel.call(this, 1);

          function setLabel(handleIndex) {
            // Label
            // Text should not transform by barGroup.
            // Ignore handlers transform
            var barTransform = graphic.getTransform(displaybles.handles[handleIndex].parent, this.group);
            var direction = graphic.transformDirection(handleIndex === 0 ? 'right' : 'left', barTransform);
            var offset = this._handleWidth / 2 + LABEL_GAP;
            var textPoint = graphic.applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);
            handleLabels[handleIndex].setStyle({
              x: textPoint[0],
              y: textPoint[1],
              textVerticalAlign: orient === HORIZONTAL ? 'middle' : direction,
              textAlign: orient === HORIZONTAL ? direction : 'center',
              text: labelTexts[handleIndex]
            });
          }
        },

        /**
         * @private
         */
        _formatLabel: function _formatLabel(value, axis) {
          var dataZoomModel = this.dataZoomModel;
          var labelFormatter = dataZoomModel.get('labelFormatter');
          var labelPrecision = dataZoomModel.get('labelPrecision');

          if (labelPrecision == null || labelPrecision === 'auto') {
            labelPrecision = axis.getPixelPrecision();
          }

          var valueStr = value == null || isNaN(value) ? '' // FIXME Glue code
          : axis.type === 'category' || axis.type === 'time' ? axis.scale.getLabel(Math.round(value)) // param of toFixed should less then 20.
          : value.toFixed(Math.min(labelPrecision, 20));
          return zrUtil.isFunction(labelFormatter) ? labelFormatter(value, valueStr) : zrUtil.isString(labelFormatter) ? labelFormatter.replace('{value}', valueStr) : valueStr;
        },

        /**
         * @private
         * @param {boolean} showOrHide true: show, false: hide
         */
        _showDataInfo: function _showDataInfo(showOrHide) {
          // Always show when drgging.
          showOrHide = this._dragging || showOrHide;
          var handleLabels = this._displayables.handleLabels;
          handleLabels[0].attr('invisible', !showOrHide);
          handleLabels[1].attr('invisible', !showOrHide);
        },
        _onDragMove: function _onDragMove(handleIndex, dx, dy, event) {
          this._dragging = true; // For mobile device, prevent screen slider on the button.

          eventTool.stop(event.event); // Transform dx, dy to bar coordination.

          var barTransform = this._displayables.barGroup.getLocalTransform();

          var vertex = graphic.applyTransform([dx, dy], barTransform, true);

          var changed = this._updateInterval(handleIndex, vertex[0]);

          var realtime = this.dataZoomModel.get('realtime');

          this._updateView(!realtime); // Avoid dispatch dataZoom repeatly but range not changed,
          // which cause bad visual effect when progressive enabled.


          changed && realtime && this._dispatchZoomAction();
        },
        _onDragEnd: function _onDragEnd() {
          this._dragging = false;

          this._showDataInfo(false); // While in realtime mode and stream mode, dispatch action when
          // drag end will cause the whole view rerender, which is unnecessary.


          var realtime = this.dataZoomModel.get('realtime');
          !realtime && this._dispatchZoomAction();
        },
        _onClickPanelClick: function _onClickPanelClick(e) {
          var size = this._size;

          var localPoint = this._displayables.barGroup.transformCoordToLocal(e.offsetX, e.offsetY);

          if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {
            return;
          }

          var handleEnds = this._handleEnds;
          var center = (handleEnds[0] + handleEnds[1]) / 2;

          var changed = this._updateInterval('all', localPoint[0] - center);

          this._updateView();

          changed && this._dispatchZoomAction();
        },

        /**
         * This action will be throttled.
         * @private
         */
        _dispatchZoomAction: function _dispatchZoomAction() {
          var range = this._range;
          this.api.dispatchAction({
            type: 'dataZoom',
            from: this.uid,
            dataZoomId: this.dataZoomModel.id,
            start: range[0],
            end: range[1]
          });
        },

        /**
         * @private
         */
        _findCoordRect: function _findCoordRect() {
          // Find the grid coresponding to the first axis referred by dataZoom.
          var rect;
          each(this.getTargetCoordInfo(), function (coordInfoList) {
            if (!rect && coordInfoList.length) {
              var coordSys = coordInfoList[0].model.coordinateSystem;
              rect = coordSys.getRect && coordSys.getRect();
            }
          });

          if (!rect) {
            var width = this.api.getWidth();
            var height = this.api.getHeight();
            rect = {
              x: width * 0.2,
              y: height * 0.2,
              width: width * 0.6,
              height: height * 0.6
            };
          }

          return rect;
        }
      });

      function getOtherDim(thisDim) {
        // FIXME
        // getOtherAxis
        var map = {
          x: 'y',
          y: 'x',
          radius: 'angle',
          angle: 'radius'
        };
        return map[thisDim];
      }

      function getCursor(orient) {
        return orient === 'vertical' ? 'ns-resize' : 'ew-resize';
      }

      var _default = SliderZoomView;
      module.exports = _default;
      /***/
    },

    /***/
    "JEkh":
    /*!******************************************************************!*\
      !*** ./node_modules/echarts/lib/component/marker/MarkerModel.js ***!
      \******************************************************************/

    /*! no static exports found */

    /***/
    function JEkh(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var env = __webpack_require__(
      /*! zrender/lib/core/env */
      "ItGF");

      var modelUtil = __webpack_require__(
      /*! ../../util/model */
      "4NO4");

      var formatUtil = __webpack_require__(
      /*! ../../util/format */
      "7aKB");

      var dataFormatMixin = __webpack_require__(
      /*! ../../model/mixin/dataFormat */
      "OKJ2");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var addCommas = formatUtil.addCommas;
      var encodeHTML = formatUtil.encodeHTML;

      function fillLabel(opt) {
        modelUtil.defaultEmphasis(opt, 'label', ['show']);
      }

      var MarkerModel = echarts.extendComponentModel({
        type: 'marker',
        dependencies: ['series', 'grid', 'polar', 'geo'],

        /**
         * @overrite
         */
        init: function init(option, parentModel, ecModel) {
          this.mergeDefaultAndTheme(option, ecModel);

          this._mergeOption(option, ecModel, false, true);
        },

        /**
         * @return {boolean}
         */
        isAnimationEnabled: function isAnimationEnabled() {
          if (env.node) {
            return false;
          }

          var hostSeries = this.__hostSeries;
          return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();
        },

        /**
         * @overrite
         */
        mergeOption: function mergeOption(newOpt, ecModel) {
          this._mergeOption(newOpt, ecModel, false, false);
        },
        _mergeOption: function _mergeOption(newOpt, ecModel, createdBySelf, isInit) {
          var MarkerModel = this.constructor;
          var modelPropName = this.mainType + 'Model';

          if (!createdBySelf) {
            ecModel.eachSeries(function (seriesModel) {
              var markerOpt = seriesModel.get(this.mainType, true);
              var markerModel = seriesModel[modelPropName];

              if (!markerOpt || !markerOpt.data) {
                seriesModel[modelPropName] = null;
                return;
              }

              if (!markerModel) {
                if (isInit) {
                  // Default label emphasis `position` and `show`
                  fillLabel(markerOpt);
                }

                zrUtil.each(markerOpt.data, function (item) {
                  // FIXME Overwrite fillLabel method ?
                  if (item instanceof Array) {
                    fillLabel(item[0]);
                    fillLabel(item[1]);
                  } else {
                    fillLabel(item);
                  }
                });
                markerModel = new MarkerModel(markerOpt, this, ecModel);
                zrUtil.extend(markerModel, {
                  mainType: this.mainType,
                  // Use the same series index and name
                  seriesIndex: seriesModel.seriesIndex,
                  name: seriesModel.name,
                  createdBySelf: true
                });
                markerModel.__hostSeries = seriesModel;
              } else {
                markerModel._mergeOption(markerOpt, ecModel, true);
              }

              seriesModel[modelPropName] = markerModel;
            }, this);
          }
        },
        formatTooltip: function formatTooltip(dataIndex, multipleSeries, dataType, renderMode) {
          var data = this.getData();
          var value = this.getRawValue(dataIndex);
          var formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);
          var name = data.getName(dataIndex);
          var html = encodeHTML(this.name);
          var newLine = renderMode === 'html' ? '<br/>' : '\n';

          if (value != null || name) {
            html += newLine;
          }

          if (name) {
            html += encodeHTML(name);

            if (value != null) {
              html += ' : ';
            }
          }

          if (value != null) {
            html += encodeHTML(formattedValue);
          }

          return html;
        },
        getData: function getData() {
          return this._data;
        },
        setData: function setData(data) {
          this._data = data;
        }
      });
      zrUtil.mixin(MarkerModel, dataFormatMixin);
      var _default = MarkerModel;
      module.exports = _default;
      /***/
    },

    /***/
    "JLnu":
    /*!***************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/funnel/funnelLayout.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function JLnu(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var layout = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var _number = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var parsePercent = _number.parsePercent;
      var linearMap = _number.linearMap;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      function getViewRect(seriesModel, api) {
        return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
          width: api.getWidth(),
          height: api.getHeight()
        });
      }

      function getSortedIndices(data, sort) {
        var valueDim = data.mapDimension('value');
        var valueArr = data.mapArray(valueDim, function (val) {
          return val;
        });
        var indices = [];
        var isAscending = sort === 'ascending';

        for (var i = 0, len = data.count(); i < len; i++) {
          indices[i] = i;
        } // Add custom sortable function & none sortable opetion by "options.sort"


        if (typeof sort === 'function') {
          indices.sort(sort);
        } else if (sort !== 'none') {
          indices.sort(function (a, b) {
            return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];
          });
        }

        return indices;
      }

      function labelLayout(data) {
        data.each(function (idx) {
          var itemModel = data.getItemModel(idx);
          var labelModel = itemModel.getModel('label');
          var labelPosition = labelModel.get('position');
          var orient = itemModel.get('orient');
          var labelLineModel = itemModel.getModel('labelLine');
          var layout = data.getItemLayout(idx);
          var points = layout.points;
          var isLabelInside = labelPosition === 'inner' || labelPosition === 'inside' || labelPosition === 'center' || labelPosition === 'insideLeft' || labelPosition === 'insideRight';
          var textAlign;
          var textX;
          var textY;
          var linePoints;

          if (isLabelInside) {
            if (labelPosition === 'insideLeft') {
              textX = (points[0][0] + points[3][0]) / 2 + 5;
              textY = (points[0][1] + points[3][1]) / 2;
              textAlign = 'left';
            } else if (labelPosition === 'insideRight') {
              textX = (points[1][0] + points[2][0]) / 2 - 5;
              textY = (points[1][1] + points[2][1]) / 2;
              textAlign = 'right';
            } else {
              textX = (points[0][0] + points[1][0] + points[2][0] + points[3][0]) / 4;
              textY = (points[0][1] + points[1][1] + points[2][1] + points[3][1]) / 4;
              textAlign = 'center';
            }

            linePoints = [[textX, textY], [textX, textY]];
          } else {
            var x1;
            var y1;
            var x2;
            var y2;
            var labelLineLen = labelLineModel.get('length');

            if (labelPosition === 'left') {
              // Left side
              x1 = (points[3][0] + points[0][0]) / 2;
              y1 = (points[3][1] + points[0][1]) / 2;
              x2 = x1 - labelLineLen;
              textX = x2 - 5;
              textAlign = 'right';
            } else if (labelPosition === 'right') {
              // Right side
              x1 = (points[1][0] + points[2][0]) / 2;
              y1 = (points[1][1] + points[2][1]) / 2;
              x2 = x1 + labelLineLen;
              textX = x2 + 5;
              textAlign = 'left';
            } else if (labelPosition === 'top') {
              // Top side
              x1 = (points[3][0] + points[0][0]) / 2;
              y1 = (points[3][1] + points[0][1]) / 2;
              y2 = y1 - labelLineLen;
              textY = y2 - 5;
              textAlign = 'center';
            } else if (labelPosition === 'bottom') {
              // Bottom side
              x1 = (points[1][0] + points[2][0]) / 2;
              y1 = (points[1][1] + points[2][1]) / 2;
              y2 = y1 + labelLineLen;
              textY = y2 + 5;
              textAlign = 'center';
            } else if (labelPosition === 'rightTop') {
              // RightTop side
              x1 = orient === 'horizontal' ? points[3][0] : points[1][0];
              y1 = orient === 'horizontal' ? points[3][1] : points[1][1];

              if (orient === 'horizontal') {
                y2 = y1 - labelLineLen;
                textY = y2 - 5;
                textAlign = 'center';
              } else {
                x2 = x1 + labelLineLen;
                textX = x2 + 5;
                textAlign = 'top';
              }
            } else if (labelPosition === 'rightBottom') {
              // RightBottom side
              x1 = points[2][0];
              y1 = points[2][1];

              if (orient === 'horizontal') {
                y2 = y1 + labelLineLen;
                textY = y2 + 5;
                textAlign = 'center';
              } else {
                x2 = x1 + labelLineLen;
                textX = x2 + 5;
                textAlign = 'bottom';
              }
            } else if (labelPosition === 'leftTop') {
              // LeftTop side
              x1 = points[0][0];
              y1 = orient === 'horizontal' ? points[0][1] : points[1][1];

              if (orient === 'horizontal') {
                y2 = y1 - labelLineLen;
                textY = y2 - 5;
                textAlign = 'center';
              } else {
                x2 = x1 - labelLineLen;
                textX = x2 - 5;
                textAlign = 'right';
              }
            } else if (labelPosition === 'leftBottom') {
              // LeftBottom side
              x1 = orient === 'horizontal' ? points[1][0] : points[3][0];
              y1 = orient === 'horizontal' ? points[1][1] : points[2][1];

              if (orient === 'horizontal') {
                y2 = y1 + labelLineLen;
                textY = y2 + 5;
                textAlign = 'center';
              } else {
                x2 = x1 - labelLineLen;
                textX = x2 - 5;
                textAlign = 'right';
              }
            } else {
              // Right side or Bottom side
              x1 = (points[1][0] + points[2][0]) / 2;
              y1 = (points[1][1] + points[2][1]) / 2;

              if (orient === 'horizontal') {
                y2 = y1 + labelLineLen;
                textY = y2 + 5;
                textAlign = 'center';
              } else {
                x2 = x1 + labelLineLen;
                textX = x2 + 5;
                textAlign = 'left';
              }
            }

            if (orient === 'horizontal') {
              x2 = x1;
              textX = x2;
            } else {
              y2 = y1;
              textY = y2;
            }

            linePoints = [[x1, y1], [x2, y2]];
          }

          layout.label = {
            linePoints: linePoints,
            x: textX,
            y: textY,
            verticalAlign: 'middle',
            textAlign: textAlign,
            inside: isLabelInside
          };
        });
      }

      function _default(ecModel, api, payload) {
        ecModel.eachSeriesByType('funnel', function (seriesModel) {
          var data = seriesModel.getData();
          var valueDim = data.mapDimension('value');
          var sort = seriesModel.get('sort');
          var viewRect = getViewRect(seriesModel, api);
          var indices = getSortedIndices(data, sort);
          var orient = seriesModel.get('orient');
          var viewWidth = viewRect.width;
          var viewHeight = viewRect.height;
          var x = viewRect.x;
          var y = viewRect.y;
          var sizeExtent = orient === 'horizontal' ? [parsePercent(seriesModel.get('minSize'), viewHeight), parsePercent(seriesModel.get('maxSize'), viewHeight)] : [parsePercent(seriesModel.get('minSize'), viewWidth), parsePercent(seriesModel.get('maxSize'), viewWidth)];
          var dataExtent = data.getDataExtent(valueDim);
          var min = seriesModel.get('min');
          var max = seriesModel.get('max');

          if (min == null) {
            min = Math.min(dataExtent[0], 0);
          }

          if (max == null) {
            max = dataExtent[1];
          }

          var funnelAlign = seriesModel.get('funnelAlign');
          var gap = seriesModel.get('gap');
          var viewSize = orient === 'horizontal' ? viewWidth : viewHeight;
          var itemSize = (viewSize - gap * (data.count() - 1)) / data.count();

          var getLinePoints = function getLinePoints(idx, offset) {
            // End point index is data.count() and we assign it 0
            if (orient === 'horizontal') {
              var val = data.get(valueDim, idx) || 0;
              var itemHeight = linearMap(val, [min, max], sizeExtent, true);
              var y0;

              switch (funnelAlign) {
                case 'top':
                  y0 = y;
                  break;

                case 'center':
                  y0 = y + (viewHeight - itemHeight) / 2;
                  break;

                case 'bottom':
                  y0 = y + (viewHeight - itemHeight);
                  break;
              }

              return [[offset, y0], [offset, y0 + itemHeight]];
            }

            var val = data.get(valueDim, idx) || 0;
            var itemWidth = linearMap(val, [min, max], sizeExtent, true);
            var x0;

            switch (funnelAlign) {
              case 'left':
                x0 = x;
                break;

              case 'center':
                x0 = x + (viewWidth - itemWidth) / 2;
                break;

              case 'right':
                x0 = x + viewWidth - itemWidth;
                break;
            }

            return [[x0, offset], [x0 + itemWidth, offset]];
          };

          if (sort === 'ascending') {
            // From bottom to top
            itemSize = -itemSize;
            gap = -gap;

            if (orient === 'horizontal') {
              x += viewWidth;
            } else {
              y += viewHeight;
            }

            indices = indices.reverse();
          }

          for (var i = 0; i < indices.length; i++) {
            var idx = indices[i];
            var nextIdx = indices[i + 1];
            var itemModel = data.getItemModel(idx);

            if (orient === 'horizontal') {
              var width = itemModel.get('itemStyle.width');

              if (width == null) {
                width = itemSize;
              } else {
                width = parsePercent(width, viewWidth);

                if (sort === 'ascending') {
                  width = -width;
                }
              }

              var start = getLinePoints(idx, x);
              var end = getLinePoints(nextIdx, x + width);
              x += width + gap;
              data.setItemLayout(idx, {
                points: start.concat(end.slice().reverse())
              });
            } else {
              var height = itemModel.get('itemStyle.height');

              if (height == null) {
                height = itemSize;
              } else {
                height = parsePercent(height, viewHeight);

                if (sort === 'ascending') {
                  height = -height;
                }
              }

              var start = orient === 'horizontal' ? getLinePoints(idx, x) : getLinePoints(idx, y);
              var end = orient === 'horizontal' ? getLinePoints(nextIdx, x + width) : getLinePoints(nextIdx, y + height);
              y += height + gap;
              data.setItemLayout(idx, {
                points: start.concat(end.slice().reverse())
              });
            }
          }

          labelLayout(data);
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "JVwQ":
    /*!*********************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/themeRiver/ThemeRiverView.js ***!
      \*********************************************************************/

    /*! no static exports found */

    /***/
    function JVwQ(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var _poly = __webpack_require__(
      /*! ../line/poly */
      "1NG9");

      var Polygon = _poly.Polygon;

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var _util = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var bind = _util.bind;
      var extend = _util.extend;

      var DataDiffer = __webpack_require__(
      /*! ../../data/DataDiffer */
      "gPAo");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = echarts.extendChartView({
        type: 'themeRiver',
        init: function init() {
          this._layers = [];
        },
        render: function render(seriesModel, ecModel, api) {
          var data = seriesModel.getData();
          var group = this.group;
          var layerSeries = seriesModel.getLayerSeries();
          var layoutInfo = data.getLayout('layoutInfo');
          var rect = layoutInfo.rect;
          var boundaryGap = layoutInfo.boundaryGap;
          group.attr('position', [0, rect.y + boundaryGap[0]]);

          function keyGetter(item) {
            return item.name;
          }

          var dataDiffer = new DataDiffer(this._layersSeries || [], layerSeries, keyGetter, keyGetter);
          var newLayersGroups = {};
          dataDiffer.add(bind(process, this, 'add')).update(bind(process, this, 'update')).remove(bind(process, this, 'remove')).execute();

          function process(status, idx, oldIdx) {
            var oldLayersGroups = this._layers;

            if (status === 'remove') {
              group.remove(oldLayersGroups[idx]);
              return;
            }

            var points0 = [];
            var points1 = [];
            var color;
            var indices = layerSeries[idx].indices;

            for (var j = 0; j < indices.length; j++) {
              var layout = data.getItemLayout(indices[j]);
              var x = layout.x;
              var y0 = layout.y0;
              var y = layout.y;
              points0.push([x, y0]);
              points1.push([x, y0 + y]);
              color = data.getItemVisual(indices[j], 'color');
            }

            var polygon;
            var text;
            var textLayout = data.getItemLayout(indices[0]);
            var itemModel = data.getItemModel(indices[j - 1]);
            var labelModel = itemModel.getModel('label');
            var margin = labelModel.get('margin');

            if (status === 'add') {
              var layerGroup = newLayersGroups[idx] = new graphic.Group();
              polygon = new Polygon({
                shape: {
                  points: points0,
                  stackedOnPoints: points1,
                  smooth: 0.4,
                  stackedOnSmooth: 0.4,
                  smoothConstraint: false
                },
                z2: 0
              });
              text = new graphic.Text({
                style: {
                  x: textLayout.x - margin,
                  y: textLayout.y0 + textLayout.y / 2
                }
              });
              layerGroup.add(polygon);
              layerGroup.add(text);
              group.add(layerGroup);
              polygon.setClipPath(createGridClipShape(polygon.getBoundingRect(), seriesModel, function () {
                polygon.removeClipPath();
              }));
            } else {
              var layerGroup = oldLayersGroups[oldIdx];
              polygon = layerGroup.childAt(0);
              text = layerGroup.childAt(1);
              group.add(layerGroup);
              newLayersGroups[idx] = layerGroup;
              graphic.updateProps(polygon, {
                shape: {
                  points: points0,
                  stackedOnPoints: points1
                }
              }, seriesModel);
              graphic.updateProps(text, {
                style: {
                  x: textLayout.x - margin,
                  y: textLayout.y0 + textLayout.y / 2
                }
              }, seriesModel);
            }

            var hoverItemStyleModel = itemModel.getModel('emphasis.itemStyle');
            var itemStyleModel = itemModel.getModel('itemStyle');
            graphic.setTextStyle(text.style, labelModel, {
              text: labelModel.get('show') ? seriesModel.getFormattedLabel(indices[j - 1], 'normal') || data.getName(indices[j - 1]) : null,
              textVerticalAlign: 'middle'
            });
            polygon.setStyle(extend({
              fill: color
            }, itemStyleModel.getItemStyle(['color'])));
            graphic.setHoverStyle(polygon, hoverItemStyleModel.getItemStyle());
          }

          this._layersSeries = layerSeries;
          this._layers = newLayersGroups;
        },
        dispose: function dispose() {}
      }); // add animation to the view


      function createGridClipShape(rect, seriesModel, cb) {
        var rectEl = new graphic.Rect({
          shape: {
            x: rect.x - 10,
            y: rect.y - 10,
            width: 0,
            height: rect.height + 20
          }
        });
        graphic.initProps(rectEl, {
          shape: {
            width: rect.width + 20,
            height: rect.height + 20
          }
        }, seriesModel, cb);
        return rectEl;
      }

      module.exports = _default;
      /***/
    },

    /***/
    "K4ya":
    /*!***********************************************************!*\
      !*** ./node_modules/echarts/lib/visual/visualSolution.js ***!
      \***********************************************************/

    /*! no static exports found */

    /***/
    function K4ya(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var VisualMapping = __webpack_require__(
      /*! ./VisualMapping */
      "XxSj");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @file Visual solution, for consistent option specification.
       */


      var each = zrUtil.each;

      function hasKeys(obj) {
        if (obj) {
          for (var name in obj) {
            if (obj.hasOwnProperty(name)) {
              return true;
            }
          }
        }
      }
      /**
       * @param {Object} option
       * @param {Array.<string>} stateList
       * @param {Function} [supplementVisualOption]
       * @return {Object} visualMappings <state, <visualType, module:echarts/visual/VisualMapping>>
       */


      function createVisualMappings(option, stateList, supplementVisualOption) {
        var visualMappings = {};
        each(stateList, function (state) {
          var mappings = visualMappings[state] = createMappings();
          each(option[state], function (visualData, visualType) {
            if (!VisualMapping.isValidType(visualType)) {
              return;
            }

            var mappingOption = {
              type: visualType,
              visual: visualData
            };
            supplementVisualOption && supplementVisualOption(mappingOption, state);
            mappings[visualType] = new VisualMapping(mappingOption); // Prepare a alpha for opacity, for some case that opacity
            // is not supported, such as rendering using gradient color.

            if (visualType === 'opacity') {
              mappingOption = zrUtil.clone(mappingOption);
              mappingOption.type = 'colorAlpha';
              mappings.__hidden.__alphaForOpacity = new VisualMapping(mappingOption);
            }
          });
        });
        return visualMappings;

        function createMappings() {
          var Creater = function Creater() {}; // Make sure hidden fields will not be visited by
          // object iteration (with hasOwnProperty checking).


          Creater.prototype.__hidden = Creater.prototype;
          var obj = new Creater();
          return obj;
        }
      }
      /**
       * @param {Object} thisOption
       * @param {Object} newOption
       * @param {Array.<string>} keys
       */


      function replaceVisualOption(thisOption, newOption, keys) {
        // Visual attributes merge is not supported, otherwise it
        // brings overcomplicated merge logic. See #2853. So if
        // newOption has anyone of these keys, all of these keys
        // will be reset. Otherwise, all keys remain.
        var has;
        zrUtil.each(keys, function (key) {
          if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
            has = true;
          }
        });
        has && zrUtil.each(keys, function (key) {
          if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
            thisOption[key] = zrUtil.clone(newOption[key]);
          } else {
            delete thisOption[key];
          }
        });
      }
      /**
       * @param {Array.<string>} stateList
       * @param {Object} visualMappings <state, Object.<visualType, module:echarts/visual/VisualMapping>>
       * @param {module:echarts/data/List} list
       * @param {Function} getValueState param: valueOrIndex, return: state.
       * @param {object} [scope] Scope for getValueState
       * @param {string} [dimension] Concrete dimension, if used.
       */
      // ???! handle brush?


      function applyVisual(stateList, visualMappings, data, getValueState, scope, dimension) {
        var visualTypesMap = {};
        zrUtil.each(stateList, function (state) {
          var visualTypes = VisualMapping.prepareVisualTypes(visualMappings[state]);
          visualTypesMap[state] = visualTypes;
        });
        var dataIndex;

        function getVisual(key) {
          return data.getItemVisual(dataIndex, key);
        }

        function setVisual(key, value) {
          data.setItemVisual(dataIndex, key, value);
        }

        if (dimension == null) {
          data.each(eachItem);
        } else {
          data.each([dimension], eachItem);
        }

        function eachItem(valueOrIndex, index) {
          dataIndex = dimension == null ? valueOrIndex : index;
          var rawDataItem = data.getRawDataItem(dataIndex); // Consider performance

          if (rawDataItem && rawDataItem.visualMap === false) {
            return;
          }

          var valueState = getValueState.call(scope, valueOrIndex);
          var mappings = visualMappings[valueState];
          var visualTypes = visualTypesMap[valueState];

          for (var i = 0, len = visualTypes.length; i < len; i++) {
            var type = visualTypes[i];
            mappings[type] && mappings[type].applyVisual(valueOrIndex, getVisual, setVisual);
          }
        }
      }
      /**
       * @param {module:echarts/data/List} data
       * @param {Array.<string>} stateList
       * @param {Object} visualMappings <state, Object.<visualType, module:echarts/visual/VisualMapping>>
       * @param {Function} getValueState param: valueOrIndex, return: state.
       * @param {number} [dim] dimension or dimension index.
       */


      function incrementalApplyVisual(stateList, visualMappings, getValueState, dim) {
        var visualTypesMap = {};
        zrUtil.each(stateList, function (state) {
          var visualTypes = VisualMapping.prepareVisualTypes(visualMappings[state]);
          visualTypesMap[state] = visualTypes;
        });

        function progress(params, data) {
          if (dim != null) {
            dim = data.getDimension(dim);
          }

          function getVisual(key) {
            return data.getItemVisual(dataIndex, key);
          }

          function setVisual(key, value) {
            data.setItemVisual(dataIndex, key, value);
          }

          var dataIndex;

          while ((dataIndex = params.next()) != null) {
            var rawDataItem = data.getRawDataItem(dataIndex); // Consider performance

            if (rawDataItem && rawDataItem.visualMap === false) {
              continue;
            }

            var value = dim != null ? data.get(dim, dataIndex, true) : dataIndex;
            var valueState = getValueState(value);
            var mappings = visualMappings[valueState];
            var visualTypes = visualTypesMap[valueState];

            for (var i = 0, len = visualTypes.length; i < len; i++) {
              var type = visualTypes[i];
              mappings[type] && mappings[type].applyVisual(value, getVisual, setVisual);
            }
          }
        }

        return {
          progress: progress
        };
      }

      exports.createVisualMappings = createVisualMappings;
      exports.replaceVisualOption = replaceVisualOption;
      exports.applyVisual = applyVisual;
      exports.incrementalApplyVisual = incrementalApplyVisual;
      /***/
    },

    /***/
    "KS52":
    /*!*********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/pie/pieLayout.js ***!
      \*********************************************************/

    /*! no static exports found */

    /***/
    function KS52(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _number = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var parsePercent = _number.parsePercent;
      var linearMap = _number.linearMap;

      var layout = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var labelLayout = __webpack_require__(
      /*! ./labelLayout */
      "u3DP");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var PI2 = Math.PI * 2;
      var RADIAN = Math.PI / 180;

      function getViewRect(seriesModel, api) {
        return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
          width: api.getWidth(),
          height: api.getHeight()
        });
      }

      function _default(seriesType, ecModel, api, payload) {
        ecModel.eachSeriesByType(seriesType, function (seriesModel) {
          var data = seriesModel.getData();
          var valueDim = data.mapDimension('value');
          var viewRect = getViewRect(seriesModel, api);
          var center = seriesModel.get('center');
          var radius = seriesModel.get('radius');

          if (!zrUtil.isArray(radius)) {
            radius = [0, radius];
          }

          if (!zrUtil.isArray(center)) {
            center = [center, center];
          }

          var width = parsePercent(viewRect.width, api.getWidth());
          var height = parsePercent(viewRect.height, api.getHeight());
          var size = Math.min(width, height);
          var cx = parsePercent(center[0], width) + viewRect.x;
          var cy = parsePercent(center[1], height) + viewRect.y;
          var r0 = parsePercent(radius[0], size / 2);
          var r = parsePercent(radius[1], size / 2);
          var startAngle = -seriesModel.get('startAngle') * RADIAN;
          var minAngle = seriesModel.get('minAngle') * RADIAN;
          var validDataCount = 0;
          data.each(valueDim, function (value) {
            !isNaN(value) && validDataCount++;
          });
          var sum = data.getSum(valueDim); // Sum may be 0

          var unitRadian = Math.PI / (sum || validDataCount) * 2;
          var clockwise = seriesModel.get('clockwise');
          var roseType = seriesModel.get('roseType');
          var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]

          var extent = data.getDataExtent(valueDim);
          extent[0] = 0; // In the case some sector angle is smaller than minAngle

          var restAngle = PI2;
          var valueSumLargerThanMinAngle = 0;
          var currentAngle = startAngle;
          var dir = clockwise ? 1 : -1;
          data.each(valueDim, function (value, idx) {
            var angle;

            if (isNaN(value)) {
              data.setItemLayout(idx, {
                angle: NaN,
                startAngle: NaN,
                endAngle: NaN,
                clockwise: clockwise,
                cx: cx,
                cy: cy,
                r0: r0,
                r: roseType ? NaN : r,
                viewRect: viewRect
              });
              return;
            } // FIXME  2.0  roseType  area 


            if (roseType !== 'area') {
              angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
            } else {
              angle = PI2 / validDataCount;
            }

            if (angle < minAngle) {
              angle = minAngle;
              restAngle -= minAngle;
            } else {
              valueSumLargerThanMinAngle += value;
            }

            var endAngle = currentAngle + dir * angle;
            data.setItemLayout(idx, {
              angle: angle,
              startAngle: currentAngle,
              endAngle: endAngle,
              clockwise: clockwise,
              cx: cx,
              cy: cy,
              r0: r0,
              r: roseType ? linearMap(value, extent, [r0, r]) : r,
              viewRect: viewRect
            });
            currentAngle = endAngle;
          }); // Some sector is constrained by minAngle
          // Rest sectors needs recalculate angle

          if (restAngle < PI2 && validDataCount) {
            // Average the angle if rest angle is not enough after all angles is
            // Constrained by minAngle
            if (restAngle <= 1e-3) {
              var angle = PI2 / validDataCount;
              data.each(valueDim, function (value, idx) {
                if (!isNaN(value)) {
                  var layout = data.getItemLayout(idx);
                  layout.angle = angle;
                  layout.startAngle = startAngle + dir * idx * angle;
                  layout.endAngle = startAngle + dir * (idx + 1) * angle;
                }
              });
            } else {
              unitRadian = restAngle / valueSumLargerThanMinAngle;
              currentAngle = startAngle;
              data.each(valueDim, function (value, idx) {
                if (!isNaN(value)) {
                  var layout = data.getItemLayout(idx);
                  var angle = layout.angle === minAngle ? minAngle : value * unitRadian;
                  layout.startAngle = currentAngle;
                  layout.endAngle = currentAngle + dir * angle;
                  currentAngle += dir * angle;
                }
              });
            }
          }

          labelLayout(seriesModel, r, viewRect.width, viewRect.height, viewRect.x, viewRect.y);
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "KUOm":
    /*!****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/graph/categoryVisual.js ***!
      \****************************************************************/

    /*! no static exports found */

    /***/
    function KUOm(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      function _default(ecModel) {
        var paletteScope = {};
        ecModel.eachSeriesByType('graph', function (seriesModel) {
          var categoriesData = seriesModel.getCategoriesData();
          var data = seriesModel.getData();
          var categoryNameIdxMap = {};
          categoriesData.each(function (idx) {
            var name = categoriesData.getName(idx); // Add prefix to avoid conflict with Object.prototype.

            categoryNameIdxMap['ec-' + name] = idx;
            var itemModel = categoriesData.getItemModel(idx);
            var color = itemModel.get('itemStyle.color') || seriesModel.getColorFromPalette(name, paletteScope);
            categoriesData.setItemVisual(idx, 'color', color);
            var itemStyleList = ['opacity', 'symbol', 'symbolSize', 'symbolKeepAspect'];

            for (var i = 0; i < itemStyleList.length; i++) {
              var itemStyle = itemModel.getShallow(itemStyleList[i], true);

              if (itemStyle != null) {
                categoriesData.setItemVisual(idx, itemStyleList[i], itemStyle);
              }
            }
          }); // Assign category color to visual

          if (categoriesData.count()) {
            data.each(function (idx) {
              var model = data.getItemModel(idx);
              var category = model.getShallow('category');

              if (category != null) {
                if (typeof category === 'string') {
                  category = categoryNameIdxMap['ec-' + category];
                }

                var itemStyleList = ['color', 'opacity', 'symbol', 'symbolSize', 'symbolKeepAspect'];

                for (var i = 0; i < itemStyleList.length; i++) {
                  if (data.getItemVisual(idx, itemStyleList[i], true) == null) {
                    data.setItemVisual(idx, itemStyleList[i], categoriesData.getItemVisual(category, itemStyleList[i]));
                  }
                }
              }
            });
          }
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "KamJ":
    /*!******************************************************************!*\
      !*** ./node_modules/echarts/lib/component/visualMapPiecewise.js ***!
      \******************************************************************/

    /*! no static exports found */

    /***/
    function KamJ(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      var preprocessor = __webpack_require__(
      /*! ./visualMap/preprocessor */
      "szbU");

      __webpack_require__(
      /*! ./visualMap/typeDefaulter */
      "vF/C");

      __webpack_require__(
      /*! ./visualMap/visualEncoding */
      "qwVE");

      __webpack_require__(
      /*! ./visualMap/PiecewiseModel */
      "BuqR");

      __webpack_require__(
      /*! ./visualMap/PiecewiseView */
      "AE9C");

      __webpack_require__(
      /*! ./visualMap/visualMapAction */
      "1u/T");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * DataZoom component entry
       */


      echarts.registerPreprocessor(preprocessor);
      /***/
    },

    /***/
    "L3Oj":
    /*!*****************************************************!*\
      !*** ./node_modules/echarts/lib/component/polar.js ***!
      \*****************************************************/

    /*! no static exports found */

    /***/
    function L3Oj(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var barPolar = __webpack_require__(
      /*! ../layout/barPolar */
      "HjIi");

      __webpack_require__(
      /*! ../coord/polar/polarCreator */
      "HM/N");

      __webpack_require__(
      /*! ./angleAxis */
      "9eas");

      __webpack_require__(
      /*! ./radiusAxis */
      "eS4l");

      __webpack_require__(
      /*! ./axisPointer */
      "y4/Y");

      __webpack_require__(
      /*! ./axisPointer/PolarAxisPointer */
      "as94");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // For reducing size of echarts.min, barLayoutPolar is required by polar.


      echarts.registerLayout(zrUtil.curry(barPolar, 'bar')); // Polar view

      echarts.extendComponentView({
        type: 'polar'
      });
      /***/
    },

    /***/
    "L5E0":
    /*!*****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/boxplot/boxplotVisual.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function L5E0(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var borderColorQuery = ['itemStyle', 'borderColor'];

      function _default(ecModel, api) {
        var globalColors = ecModel.get('color');
        ecModel.eachRawSeriesByType('boxplot', function (seriesModel) {
          var defaulColor = globalColors[seriesModel.seriesIndex % globalColors.length];
          var data = seriesModel.getData();
          data.setVisual({
            legendSymbol: 'roundRect',
            // Use name 'color' but not 'borderColor' for legend usage and
            // visual coding from other component like dataRange.
            color: seriesModel.get(borderColorQuery) || defaulColor
          }); // Only visible series has each data be visual encoded

          if (!ecModel.isSeriesFiltered(seriesModel)) {
            data.each(function (idx) {
              var itemModel = data.getItemModel(idx);
              data.setItemVisual(idx, {
                color: itemModel.get(borderColorQuery, true)
              });
            });
          }
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "LBfv":
    /*!**************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js ***!
      \**************************************************************************/

    /*! no static exports found */

    /***/
    function LBfv(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var _util = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var createHashMap = _util.createHashMap;
      var each = _util.each;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      echarts.registerProcessor({
        // `dataZoomProcessor` will only be performed in needed series. Consider if
        // there is a line series and a pie series, it is better not to update the
        // line series if only pie series is needed to be updated.
        getTargetSeries: function getTargetSeries(ecModel) {
          var seriesModelMap = createHashMap();
          ecModel.eachComponent('dataZoom', function (dataZoomModel) {
            dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {
              var axisProxy = dataZoomModel.getAxisProxy(dimNames.name, axisIndex);
              each(axisProxy.getTargetSeriesModels(), function (seriesModel) {
                seriesModelMap.set(seriesModel.uid, seriesModel);
              });
            });
          });
          return seriesModelMap;
        },
        modifyOutputEnd: true,
        // Consider appendData, where filter should be performed. Because data process is
        // in block mode currently, it is not need to worry about that the overallProgress
        // execute every frame.
        overallReset: function overallReset(ecModel, api) {
          ecModel.eachComponent('dataZoom', function (dataZoomModel) {
            // We calculate window and reset axis here but not in model
            // init stage and not after action dispatch handler, because
            // reset should be called after seriesData.restoreData.
            dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {
              dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel, api);
            }); // Caution: data zoom filtering is order sensitive when using
            // percent range and no min/max/scale set on axis.
            // For example, we have dataZoom definition:
            // [
            //      {xAxisIndex: 0, start: 30, end: 70},
            //      {yAxisIndex: 0, start: 20, end: 80}
            // ]
            // In this case, [20, 80] of y-dataZoom should be based on data
            // that have filtered by x-dataZoom using range of [30, 70],
            // but should not be based on full raw data. Thus sliding
            // x-dataZoom will change both ranges of xAxis and yAxis,
            // while sliding y-dataZoom will only change the range of yAxis.
            // So we should filter x-axis after reset x-axis immediately,
            // and then reset y-axis and filter y-axis.

            dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {
              dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel, api);
            });
          });
          ecModel.eachComponent('dataZoom', function (dataZoomModel) {
            // Fullfill all of the range props so that user
            // is able to get them from chart.getOption().
            var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
            var percentRange = axisProxy.getDataPercentWindow();
            var valueRange = axisProxy.getDataValueWindow();
            dataZoomModel.setCalculatedRange({
              start: percentRange[0],
              end: percentRange[1],
              startValue: valueRange[0],
              endValue: valueRange[1]
            });
          });
        }
      });
      /***/
    },

    /***/
    "LPzL":
    /*!**********************************************************!*\
      !*** ./node_modules/echarts/lib/component/singleAxis.js ***!
      \**********************************************************/

    /*! no static exports found */

    /***/
    function LPzL(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ../coord/single/singleCreator */
      "QzjZ");

      __webpack_require__(
      /*! ./axis/SingleAxisView */
      "vL6D");

      __webpack_require__(
      /*! ../coord/single/AxisModel */
      "xiyX");

      __webpack_require__(
      /*! ./axisPointer */
      "y4/Y");

      __webpack_require__(
      /*! ./axisPointer/SingleAxisPointer */
      "8Th4");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      echarts.extendComponentView({
        type: 'single'
      });
      /***/
    },

    /***/
    "LzGr":
    /*!*****************************************************!*\
      !*** ./node_modules/echarts/lib/component/brush.js ***!
      \*****************************************************/

    /*! no static exports found */

    /***/
    function LzGr(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      var preprocessor = __webpack_require__(
      /*! ./brush/preprocessor */
      "rnVJ");

      __webpack_require__(
      /*! ./brush/visualEncoding */
      "EMyp");

      __webpack_require__(
      /*! ./brush/BrushModel */
      "8x+h");

      __webpack_require__(
      /*! ./brush/BrushView */
      "wt3j");

      __webpack_require__(
      /*! ./brush/brushAction */
      "uOyE");

      __webpack_require__(
      /*! ./toolbox/feature/Brush */
      "/stD");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Brush component entry
       */


      echarts.registerPreprocessor(preprocessor);
      /***/
    },

    /***/
    "MBQ8":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/bar/BaseBarSeries.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function MBQ8(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var SeriesModel = __webpack_require__(
      /*! ../../model/Series */
      "T4UG");

      var createListFromArray = __webpack_require__(
      /*! ../helper/createListFromArray */
      "MwEJ");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = SeriesModel.extend({
        type: 'series.__base_bar__',
        getInitialData: function getInitialData(option, ecModel) {
          return createListFromArray(this.getSource(), this, {
            useEncodeDefaulter: true
          });
        },
        getMarkerPosition: function getMarkerPosition(value) {
          var coordSys = this.coordinateSystem;

          if (coordSys) {
            // PENDING if clamp ?
            var pt = coordSys.dataToPoint(coordSys.clampData(value));
            var data = this.getData();
            var offset = data.getLayout('offset');
            var size = data.getLayout('size');
            var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
            pt[offsetIndex] += offset + size / 2;
            return pt;
          }

          return [NaN, NaN];
        },
        defaultOption: {
          zlevel: 0,
          // 
          z: 2,
          // 
          coordinateSystem: 'cartesian2d',
          legendHoverLink: true,
          // stack: null
          // Cartesian coordinate system
          // xAxisIndex: 0,
          // yAxisIndex: 0,
          // 0
          barMinHeight: 0,
          // 0
          barMinAngle: 0,
          // cursor: null,
          large: false,
          largeThreshold: 400,
          progressive: 3e3,
          progressiveChunkMode: 'mod',
          // barMaxWidth: null,
          // In cartesian, the default value is 1. Otherwise null.
          // barMinWidth: null,
          // 
          // barWidth: null,
          // 30%
          // barGap: '30%',
          // 20%
          // barCategoryGap: '20%',
          // label: {
          //      show: false
          // },
          itemStyle: {},
          emphasis: {}
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "MH26":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/component/marker/MarkLineView.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function MH26(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var List = __webpack_require__(
      /*! ../../data/List */
      "YXkt");

      var numberUtil = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var markerHelper = __webpack_require__(
      /*! ./markerHelper */
      "kj2x");

      var LineDraw = __webpack_require__(
      /*! ../../chart/helper/LineDraw */
      "c8qY");

      var MarkerView = __webpack_require__(
      /*! ./MarkerView */
      "iPDy");

      var _dataStackHelper = __webpack_require__(
      /*! ../../data/helper/dataStackHelper */
      "7hqr");

      var getStackedDimension = _dataStackHelper.getStackedDimension;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var markLineTransform = function markLineTransform(seriesModel, coordSys, mlModel, item) {
        var data = seriesModel.getData(); // Special type markLine like 'min', 'max', 'average', 'median'

        var mlType = item.type;

        if (!zrUtil.isArray(item) && (mlType === 'min' || mlType === 'max' || mlType === 'average' || mlType === 'median' // In case
        // data: [{
        //   yAxis: 10
        // }]
        || item.xAxis != null || item.yAxis != null)) {
          var valueAxis;
          var value;

          if (item.yAxis != null || item.xAxis != null) {
            valueAxis = coordSys.getAxis(item.yAxis != null ? 'y' : 'x');
            value = zrUtil.retrieve(item.yAxis, item.xAxis);
          } else {
            var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);
            valueAxis = axisInfo.valueAxis;
            var valueDataDim = getStackedDimension(data, axisInfo.valueDataDim);
            value = markerHelper.numCalculate(data, valueDataDim, mlType);
          }

          var valueIndex = valueAxis.dim === 'x' ? 0 : 1;
          var baseIndex = 1 - valueIndex;
          var mlFrom = zrUtil.clone(item);
          var mlTo = {};
          mlFrom.type = null;
          mlFrom.coord = [];
          mlTo.coord = [];
          mlFrom.coord[baseIndex] = -Infinity;
          mlTo.coord[baseIndex] = Infinity;
          var precision = mlModel.get('precision');

          if (precision >= 0 && typeof value === 'number') {
            value = +value.toFixed(Math.min(precision, 20));
          }

          mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;
          item = [mlFrom, mlTo, {
            // Extra option for tooltip and label
            type: mlType,
            valueIndex: item.valueIndex,
            // Force to use the value of calculated value.
            value: value
          }];
        }

        item = [markerHelper.dataTransform(seriesModel, item[0]), markerHelper.dataTransform(seriesModel, item[1]), zrUtil.extend({}, item[2])]; // Avoid line data type is extended by from(to) data type

        item[2].type = item[2].type || ''; // Merge from option and to option into line option

        zrUtil.merge(item[2], item[0]);
        zrUtil.merge(item[2], item[1]);
        return item;
      };

      function isInifinity(val) {
        return !isNaN(val) && !isFinite(val);
      } // If a markLine has one dim


      function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
        var otherDimIndex = 1 - dimIndex;
        var dimName = coordSys.dimensions[dimIndex];
        return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);
      }

      function markLineFilter(coordSys, item) {
        if (coordSys.type === 'cartesian2d') {
          var fromCoord = item[0].coord;
          var toCoord = item[1].coord; // In case
          // {
          //  markLine: {
          //    data: [{ yAxis: 2 }]
          //  }
          // }

          if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
            return true;
          }
        }

        return markerHelper.dataFilter(coordSys, item[0]) && markerHelper.dataFilter(coordSys, item[1]);
      }

      function updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {
        var coordSys = seriesModel.coordinateSystem;
        var itemModel = data.getItemModel(idx);
        var point;
        var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());
        var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());

        if (!isNaN(xPx) && !isNaN(yPx)) {
          point = [xPx, yPx];
        } else {
          // Chart like bar may have there own marker positioning logic
          if (seriesModel.getMarkerPosition) {
            // Use the getMarkerPoisition
            point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));
          } else {
            var dims = coordSys.dimensions;
            var x = data.get(dims[0], idx);
            var y = data.get(dims[1], idx);
            point = coordSys.dataToPoint([x, y]);
          } // Expand line to the edge of grid if value on one axis is Inifnity
          // In case
          //  markLine: {
          //    data: [{
          //      yAxis: 2
          //      // or
          //      type: 'average'
          //    }]
          //  }


          if (coordSys.type === 'cartesian2d') {
            var xAxis = coordSys.getAxis('x');
            var yAxis = coordSys.getAxis('y');
            var dims = coordSys.dimensions;

            if (isInifinity(data.get(dims[0], idx))) {
              point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);
            } else if (isInifinity(data.get(dims[1], idx))) {
              point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);
            }
          } // Use x, y if has any


          if (!isNaN(xPx)) {
            point[0] = xPx;
          }

          if (!isNaN(yPx)) {
            point[1] = yPx;
          }
        }

        data.setItemLayout(idx, point);
      }

      var _default = MarkerView.extend({
        type: 'markLine',
        // updateLayout: function (markLineModel, ecModel, api) {
        //     ecModel.eachSeries(function (seriesModel) {
        //         var mlModel = seriesModel.markLineModel;
        //         if (mlModel) {
        //             var mlData = mlModel.getData();
        //             var fromData = mlModel.__from;
        //             var toData = mlModel.__to;
        //             // Update visual and layout of from symbol and to symbol
        //             fromData.each(function (idx) {
        //                 updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);
        //                 updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);
        //             });
        //             // Update layout of line
        //             mlData.each(function (idx) {
        //                 mlData.setItemLayout(idx, [
        //                     fromData.getItemLayout(idx),
        //                     toData.getItemLayout(idx)
        //                 ]);
        //             });
        //             this.markerGroupMap.get(seriesModel.id).updateLayout();
        //         }
        //     }, this);
        // },
        updateTransform: function updateTransform(markLineModel, ecModel, api) {
          ecModel.eachSeries(function (seriesModel) {
            var mlModel = seriesModel.markLineModel;

            if (mlModel) {
              var mlData = mlModel.getData();
              var fromData = mlModel.__from;
              var toData = mlModel.__to; // Update visual and layout of from symbol and to symbol

              fromData.each(function (idx) {
                updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);
                updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);
              }); // Update layout of line

              mlData.each(function (idx) {
                mlData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
              });
              this.markerGroupMap.get(seriesModel.id).updateLayout();
            }
          }, this);
        },
        renderSeries: function renderSeries(seriesModel, mlModel, ecModel, api) {
          var coordSys = seriesModel.coordinateSystem;
          var seriesId = seriesModel.id;
          var seriesData = seriesModel.getData();
          var lineDrawMap = this.markerGroupMap;
          var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw());
          this.group.add(lineDraw.group);
          var mlData = createList(coordSys, seriesModel, mlModel);
          var fromData = mlData.from;
          var toData = mlData.to;
          var lineData = mlData.line;
          mlModel.__from = fromData;
          mlModel.__to = toData; // Line data for tooltip and formatter

          mlModel.setData(lineData);
          var symbolType = mlModel.get('symbol');
          var symbolSize = mlModel.get('symbolSize');

          if (!zrUtil.isArray(symbolType)) {
            symbolType = [symbolType, symbolType];
          }

          if (typeof symbolSize === 'number') {
            symbolSize = [symbolSize, symbolSize];
          } // Update visual and layout of from symbol and to symbol


          mlData.from.each(function (idx) {
            updateDataVisualAndLayout(fromData, idx, true);
            updateDataVisualAndLayout(toData, idx, false);
          }); // Update visual and layout of line

          lineData.each(function (idx) {
            var lineColor = lineData.getItemModel(idx).get('lineStyle.color');
            lineData.setItemVisual(idx, {
              color: lineColor || fromData.getItemVisual(idx, 'color')
            });
            lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
            lineData.setItemVisual(idx, {
              'fromSymbolRotate': fromData.getItemVisual(idx, 'symbolRotate'),
              'fromSymbolSize': fromData.getItemVisual(idx, 'symbolSize'),
              'fromSymbol': fromData.getItemVisual(idx, 'symbol'),
              'toSymbolRotate': toData.getItemVisual(idx, 'symbolRotate'),
              'toSymbolSize': toData.getItemVisual(idx, 'symbolSize'),
              'toSymbol': toData.getItemVisual(idx, 'symbol')
            });
          });
          lineDraw.updateData(lineData); // Set host model for tooltip
          // FIXME

          mlData.line.eachItemGraphicEl(function (el, idx) {
            el.traverse(function (child) {
              child.dataModel = mlModel;
            });
          });

          function updateDataVisualAndLayout(data, idx, isFrom) {
            var itemModel = data.getItemModel(idx);
            updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);
            data.setItemVisual(idx, {
              symbolRotate: itemModel.get('symbolRotate'),
              symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1],
              symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1],
              color: itemModel.get('itemStyle.color') || seriesData.getVisual('color')
            });
          }

          lineDraw.__keep = true;
          lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');
        }
      });
      /**
       * @inner
       * @param {module:echarts/coord/*} coordSys
       * @param {module:echarts/model/Series} seriesModel
       * @param {module:echarts/model/Model} mpModel
       */


      function createList(coordSys, seriesModel, mlModel) {
        var coordDimsInfos;

        if (coordSys) {
          coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {
            var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys

            return zrUtil.defaults({
              name: coordDim
            }, info);
          });
        } else {
          coordDimsInfos = [{
            name: 'value',
            type: 'float'
          }];
        }

        var fromData = new List(coordDimsInfos, mlModel);
        var toData = new List(coordDimsInfos, mlModel); // No dimensions

        var lineData = new List([], mlModel);
        var optData = zrUtil.map(mlModel.get('data'), zrUtil.curry(markLineTransform, seriesModel, coordSys, mlModel));

        if (coordSys) {
          optData = zrUtil.filter(optData, zrUtil.curry(markLineFilter, coordSys));
        }

        var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function (item) {
          return item.value;
        };
        fromData.initData(zrUtil.map(optData, function (item) {
          return item[0];
        }), null, dimValueGetter);
        toData.initData(zrUtil.map(optData, function (item) {
          return item[1];
        }), null, dimValueGetter);
        lineData.initData(zrUtil.map(optData, function (item) {
          return item[2];
        }));
        lineData.hasItemOption = true;
        return {
          from: fromData,
          to: toData,
          line: lineData
        };
      }

      module.exports = _default;
      /***/
    },

    /***/
    "MHoB":
    /*!*************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/visualMap/ContinuousModel.js ***!
      \*************************************************************************/

    /*! no static exports found */

    /***/
    function MHoB(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var VisualMapModel = __webpack_require__(
      /*! ./VisualMapModel */
      "6uqw");

      var numberUtil = __webpack_require__(
      /*! ../../util/number */
      "OELB");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // Constant


      var DEFAULT_BAR_BOUND = [20, 140];
      var ContinuousModel = VisualMapModel.extend({
        type: 'visualMap.continuous',

        /**
         * @protected
         */
        defaultOption: {
          align: 'auto',
          // 'auto', 'left', 'right', 'top', 'bottom'
          calculable: false,
          // This prop effect default component type determine,
          // See echarts/component/visualMap/typeDefaulter.
          range: null,
          // selected range. In default case `range` is [min, max]
          // and can auto change along with modification of min max,
          // util use specifid a range.
          realtime: true,
          // Whether realtime update.
          itemHeight: null,
          // The length of the range control edge.
          itemWidth: null,
          // The length of the other side.
          hoverLink: true,
          // Enable hover highlight.
          hoverLinkDataSize: null,
          // The size of hovered data.
          hoverLinkOnHandle: null // Whether trigger hoverLink when hover handle.
          // If not specified, follow the value of `realtime`.

        },

        /**
         * @override
         */
        optionUpdated: function optionUpdated(newOption, isInit) {
          ContinuousModel.superApply(this, 'optionUpdated', arguments);
          this.resetExtent();
          this.resetVisual(function (mappingOption) {
            mappingOption.mappingMethod = 'linear';
            mappingOption.dataExtent = this.getExtent();
          });

          this._resetRange();
        },

        /**
         * @protected
         * @override
         */
        resetItemSize: function resetItemSize() {
          ContinuousModel.superApply(this, 'resetItemSize', arguments);
          var itemSize = this.itemSize;
          this._orient === 'horizontal' && itemSize.reverse();
          (itemSize[0] == null || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]);
          (itemSize[1] == null || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1]);
        },

        /**
         * @private
         */
        _resetRange: function _resetRange() {
          var dataExtent = this.getExtent();
          var range = this.option.range;

          if (!range || range.auto) {
            // `range` should always be array (so we dont use other
            // value like 'auto') for user-friend. (consider getOption).
            dataExtent.auto = 1;
            this.option.range = dataExtent;
          } else if (zrUtil.isArray(range)) {
            if (range[0] > range[1]) {
              range.reverse();
            }

            range[0] = Math.max(range[0], dataExtent[0]);
            range[1] = Math.min(range[1], dataExtent[1]);
          }
        },

        /**
         * @protected
         * @override
         */
        completeVisualOption: function completeVisualOption() {
          VisualMapModel.prototype.completeVisualOption.apply(this, arguments);
          zrUtil.each(this.stateList, function (state) {
            var symbolSize = this.option.controller[state].symbolSize;

            if (symbolSize && symbolSize[0] !== symbolSize[1]) {
              symbolSize[0] = 0; // For good looking.
            }
          }, this);
        },

        /**
         * @override
         */
        setSelected: function setSelected(selected) {
          this.option.range = selected.slice();

          this._resetRange();
        },

        /**
         * @public
         */
        getSelected: function getSelected() {
          var dataExtent = this.getExtent();
          var dataInterval = numberUtil.asc((this.get('range') || []).slice()); // Clamp

          dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1]);
          dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1]);
          dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0]);
          dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0]);
          return dataInterval;
        },

        /**
         * @override
         */
        getValueState: function getValueState(value) {
          var range = this.option.range;
          var dataExtent = this.getExtent(); // When range[0] === dataExtent[0], any value larger than dataExtent[0] maps to 'inRange'.
          // range[1] is processed likewise.

          return (range[0] <= dataExtent[0] || range[0] <= value) && (range[1] >= dataExtent[1] || value <= range[1]) ? 'inRange' : 'outOfRange';
        },

        /**
         * @params {Array.<number>} range target value: range[0] <= value && value <= range[1]
         * @return {Array.<Object>} [{seriesId, dataIndices: <Array.<number>>}, ...]
         */
        findTargetDataIndices: function findTargetDataIndices(range) {
          var result = [];
          this.eachTargetSeries(function (seriesModel) {
            var dataIndices = [];
            var data = seriesModel.getData();
            data.each(this.getDataDimension(data), function (value, dataIndex) {
              range[0] <= value && value <= range[1] && dataIndices.push(dataIndex);
            }, this);
            result.push({
              seriesId: seriesModel.id,
              dataIndex: dataIndices
            });
          }, this);
          return result;
        },

        /**
         * @implement
         */
        getVisualMeta: function getVisualMeta(getColorVisual) {
          var oVals = getColorStopValues(this, 'outOfRange', this.getExtent());
          var iVals = getColorStopValues(this, 'inRange', this.option.range.slice());
          var stops = [];

          function setStop(value, valueState) {
            stops.push({
              value: value,
              color: getColorVisual(value, valueState)
            });
          } // Format to: outOfRange -- inRange -- outOfRange.


          var iIdx = 0;
          var oIdx = 0;
          var iLen = iVals.length;
          var oLen = oVals.length;

          for (; oIdx < oLen && (!iVals.length || oVals[oIdx] <= iVals[0]); oIdx++) {
            // If oVal[oIdx] === iVals[iIdx], oVal[oIdx] should be ignored.
            if (oVals[oIdx] < iVals[iIdx]) {
              setStop(oVals[oIdx], 'outOfRange');
            }
          }

          for (var first = 1; iIdx < iLen; iIdx++, first = 0) {
            // If range is full, value beyond min, max will be clamped.
            // make a singularity
            first && stops.length && setStop(iVals[iIdx], 'outOfRange');
            setStop(iVals[iIdx], 'inRange');
          }

          for (var first = 1; oIdx < oLen; oIdx++) {
            if (!iVals.length || iVals[iVals.length - 1] < oVals[oIdx]) {
              // make a singularity
              if (first) {
                stops.length && setStop(stops[stops.length - 1].value, 'outOfRange');
                first = 0;
              }

              setStop(oVals[oIdx], 'outOfRange');
            }
          }

          var stopsLen = stops.length;
          return {
            stops: stops,
            outerColors: [stopsLen ? stops[0].color : 'transparent', stopsLen ? stops[stopsLen - 1].color : 'transparent']
          };
        }
      });

      function getColorStopValues(visualMapModel, valueState, dataExtent) {
        if (dataExtent[0] === dataExtent[1]) {
          return dataExtent.slice();
        } // When using colorHue mapping, it is not linear color any more.
        // Moreover, canvas gradient seems not to be accurate linear.
        // FIXME
        // Should be arbitrary value 100? or based on pixel size?


        var count = 200;
        var step = (dataExtent[1] - dataExtent[0]) / count;
        var value = dataExtent[0];
        var stopValues = [];

        for (var i = 0; i <= count && value < dataExtent[1]; i++) {
          stopValues.push(value);
          value += step;
        }

        stopValues.push(dataExtent[1]);
        return stopValues;
      }

      var _default = ContinuousModel;
      module.exports = _default;
      /***/
    },

    /***/
    "MHtr":
    /*!****************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/single/prepareCustom.js ***!
      \****************************************************************/

    /*! no static exports found */

    /***/
    function MHtr(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function dataToCoordSize(dataSize, dataItem) {
        // dataItem is necessary in log axis.
        var axis = this.getAxis();
        var val = dataItem instanceof Array ? dataItem[0] : dataItem;
        var halfSize = (dataSize instanceof Array ? dataSize[0] : dataSize) / 2;
        return axis.type === 'category' ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
      }

      function _default(coordSys) {
        var rect = coordSys.getRect();
        return {
          coordSys: {
            type: 'singleAxis',
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height
          },
          api: {
            coord: function coord(val) {
              // do not provide "out" param
              return coordSys.dataToPoint(val);
            },
            size: zrUtil.bind(dataToCoordSize, coordSys)
          }
        };
      }

      module.exports = _default;
      /***/
    },

    /***/
    "MRoa":
    /*!**************************************************!*\
      !*** ./node_modules/echarts/lib/chart/sankey.js ***!
      \**************************************************/

    /*! no static exports found */

    /***/
    function MRoa(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ./sankey/SankeySeries */
      "0Bwj");

      __webpack_require__(
      /*! ./sankey/SankeyView */
      "W2nI");

      __webpack_require__(
      /*! ./sankey/sankeyAction */
      "vcCh");

      var sankeyLayout = __webpack_require__(
      /*! ./sankey/sankeyLayout */
      "gawk");

      var sankeyVisual = __webpack_require__(
      /*! ./sankey/sankeyVisual */
      "Dg8C");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      echarts.registerLayout(sankeyLayout);
      echarts.registerVisual(sankeyVisual);
      /***/
    },

    /***/
    "MT78":
    /*!***************************************!*\
      !*** ./node_modules/echarts/index.js ***!
      \***************************************/

    /*! no static exports found */

    /***/
    function MT78(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _echarts = __webpack_require__(
      /*! ./lib/echarts */
      "ProS");

      (function () {
        for (var key in _echarts) {
          if (_echarts == null || !_echarts.hasOwnProperty(key) || key === 'default' || key === '__esModule') return;
          exports[key] = _echarts[key];
        }
      })();

      var _export = __webpack_require__(
      /*! ./lib/export */
      "txkQ");

      (function () {
        for (var key in _export) {
          if (_export == null || !_export.hasOwnProperty(key) || key === 'default' || key === '__esModule') return;
          exports[key] = _export[key];
        }
      })();

      __webpack_require__(
      /*! ./lib/component/dataset */
      "A1Ka");

      __webpack_require__(
      /*! ./lib/chart/line */
      "75ce");

      __webpack_require__(
      /*! ./lib/chart/bar */
      "lLGD");

      __webpack_require__(
      /*! ./lib/chart/pie */
      "wDdD");

      __webpack_require__(
      /*! ./lib/chart/scatter */
      "Fa/5");

      __webpack_require__(
      /*! ./lib/chart/radar */
      "jett");

      __webpack_require__(
      /*! ./lib/chart/map */
      "Z1wy");

      __webpack_require__(
      /*! ./lib/chart/tree */
      "75ev");

      __webpack_require__(
      /*! ./lib/chart/treemap */
      "2uGb");

      __webpack_require__(
      /*! ./lib/chart/graph */
      "I+77");

      __webpack_require__(
      /*! ./lib/chart/gauge */
      "B+YJ");

      __webpack_require__(
      /*! ./lib/chart/funnel */
      "pLH3");

      __webpack_require__(
      /*! ./lib/chart/parallel */
      "CBdT");

      __webpack_require__(
      /*! ./lib/chart/sankey */
      "MRoa");

      __webpack_require__(
      /*! ./lib/chart/boxplot */
      "+lIL");

      __webpack_require__(
      /*! ./lib/chart/candlestick */
      "CF2D");

      __webpack_require__(
      /*! ./lib/chart/effectScatter */
      "ERHi");

      __webpack_require__(
      /*! ./lib/chart/lines */
      "p+If");

      __webpack_require__(
      /*! ./lib/chart/heatmap */
      "XOKv");

      __webpack_require__(
      /*! ./lib/chart/pictorialBar */
      "qt/9");

      __webpack_require__(
      /*! ./lib/chart/themeRiver */
      "bBL8");

      __webpack_require__(
      /*! ./lib/chart/sunburst */
      "1xaR");

      __webpack_require__(
      /*! ./lib/chart/custom */
      "4Feb");

      __webpack_require__(
      /*! ./lib/component/grid */
      "zRKj");

      __webpack_require__(
      /*! ./lib/component/polar */
      "L3Oj");

      __webpack_require__(
      /*! ./lib/component/geo */
      "0HBW");

      __webpack_require__(
      /*! ./lib/component/singleAxis */
      "LPzL");

      __webpack_require__(
      /*! ./lib/component/parallel */
      "8waO");

      __webpack_require__(
      /*! ./lib/component/calendar */
      "k5C7");

      __webpack_require__(
      /*! ./lib/component/graphic */
      "f1nB");

      __webpack_require__(
      /*! ./lib/component/toolbox */
      "sRwP");

      __webpack_require__(
      /*! ./lib/component/tooltip */
      "AH3D");

      __webpack_require__(
      /*! ./lib/component/axisPointer */
      "y4/Y");

      __webpack_require__(
      /*! ./lib/component/brush */
      "LzGr");

      __webpack_require__(
      /*! ./lib/component/title */
      "Ynxi");

      __webpack_require__(
      /*! ./lib/component/timeline */
      "7pVf");

      __webpack_require__(
      /*! ./lib/component/markPoint */
      "2w7y");

      __webpack_require__(
      /*! ./lib/component/markLine */
      "laiN");

      __webpack_require__(
      /*! ./lib/component/markArea */
      "fjKi");

      __webpack_require__(
      /*! ./lib/component/legendScroll */
      "C0tN");

      __webpack_require__(
      /*! ./lib/component/legend */
      "0o9m");

      __webpack_require__(
      /*! ./lib/component/dataZoom */
      "Cm0C");

      __webpack_require__(
      /*! ./lib/component/dataZoomInside */
      "f3JH");

      __webpack_require__(
      /*! ./lib/component/dataZoomSlider */
      "5NHt");

      __webpack_require__(
      /*! ./lib/component/visualMap */
      "VFCP");

      __webpack_require__(
      /*! ./lib/component/visualMapContinuous */
      "dBmv");

      __webpack_require__(
      /*! ./lib/component/visualMapPiecewise */
      "KamJ");

      __webpack_require__(
      /*! zrender/lib/vml/vml */
      "8XDt");

      __webpack_require__(
      /*! zrender/lib/svg/svg */
      "juDX");
      /***/

    },

    /***/
    "Mdki":
    /*!**********************************************************!*\
      !*** ./node_modules/echarts/lib/data/helper/linkList.js ***!
      \**********************************************************/

    /*! no static exports found */

    /***/
    function Mdki(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Link lists and struct (graph or tree)
       */


      var each = zrUtil.each;
      var DATAS = '\0__link_datas';
      var MAIN_DATA = '\0__link_mainData'; // Caution:
      // In most case, either list or its shallow clones (see list.cloneShallow)
      // is active in echarts process. So considering heap memory consumption,
      // we do not clone tree or graph, but share them among list and its shallow clones.
      // But in some rare case, we have to keep old list (like do animation in chart). So
      // please take care that both the old list and the new list share the same tree/graph.

      /**
       * @param {Object} opt
       * @param {module:echarts/data/List} opt.mainData
       * @param {Object} [opt.struct] For example, instance of Graph or Tree.
       * @param {string} [opt.structAttr] designation: list[structAttr] = struct;
       * @param {Object} [opt.datas] {dataType: data},
       *                 like: {node: nodeList, edge: edgeList}.
       *                 Should contain mainData.
       * @param {Object} [opt.datasAttr] {dataType: attr},
       *                 designation: struct[datasAttr[dataType]] = list;
       */

      function linkList(opt) {
        var mainData = opt.mainData;
        var datas = opt.datas;

        if (!datas) {
          datas = {
            main: mainData
          };
          opt.datasAttr = {
            main: 'data'
          };
        }

        opt.datas = opt.mainData = null;
        linkAll(mainData, datas, opt); // Porxy data original methods.

        each(datas, function (data) {
          each(mainData.TRANSFERABLE_METHODS, function (methodName) {
            data.wrapMethod(methodName, zrUtil.curry(transferInjection, opt));
          });
        }); // Beyond transfer, additional features should be added to `cloneShallow`.

        mainData.wrapMethod('cloneShallow', zrUtil.curry(cloneShallowInjection, opt)); // Only mainData trigger change, because struct.update may trigger
        // another changable methods, which may bring about dead lock.

        each(mainData.CHANGABLE_METHODS, function (methodName) {
          mainData.wrapMethod(methodName, zrUtil.curry(changeInjection, opt));
        }); // Make sure datas contains mainData.

        zrUtil.assert(datas[mainData.dataType] === mainData);
      }

      function transferInjection(opt, res) {
        if (isMainData(this)) {
          // Transfer datas to new main data.
          var datas = zrUtil.extend({}, this[DATAS]);
          datas[this.dataType] = res;
          linkAll(res, datas, opt);
        } else {
          // Modify the reference in main data to point newData.
          linkSingle(res, this.dataType, this[MAIN_DATA], opt);
        }

        return res;
      }

      function changeInjection(opt, res) {
        opt.struct && opt.struct.update(this);
        return res;
      }

      function cloneShallowInjection(opt, res) {
        // cloneShallow, which brings about some fragilities, may be inappropriate
        // to be exposed as an API. So for implementation simplicity we can make
        // the restriction that cloneShallow of not-mainData should not be invoked
        // outside, but only be invoked here.
        each(res[DATAS], function (data, dataType) {
          data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);
        });
        return res;
      }
      /**
       * Supplement method to List.
       *
       * @public
       * @param {string} [dataType] If not specified, return mainData.
       * @return {module:echarts/data/List}
       */


      function getLinkedData(dataType) {
        var mainData = this[MAIN_DATA];
        return dataType == null || mainData == null ? mainData : mainData[DATAS][dataType];
      }

      function isMainData(data) {
        return data[MAIN_DATA] === data;
      }

      function linkAll(mainData, datas, opt) {
        mainData[DATAS] = {};
        each(datas, function (data, dataType) {
          linkSingle(data, dataType, mainData, opt);
        });
      }

      function linkSingle(data, dataType, mainData, opt) {
        mainData[DATAS][dataType] = data;
        data[MAIN_DATA] = mainData;
        data.dataType = dataType;

        if (opt.struct) {
          data[opt.structAttr] = opt.struct;
          opt.struct[opt.datasAttr[dataType]] = data;
        } // Supplement method.


        data.getLinkedData = getLinkedData;
      }

      var _default = linkList;
      module.exports = _default;
      /***/
    },

    /***/
    "Mgri":
    /*!**********************************************************!*\
      !*** ./node_modules/echarts/lib/coord/geo/fix/nanhai.js ***!
      \**********************************************************/

    /*! no static exports found */

    /***/
    function Mgri(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var Region = __webpack_require__(
      /*! ../Region */
      "8nly");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // Fix for 


      var geoCoord = [126, 25];
      var points = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];

      for (var i = 0; i < points.length; i++) {
        for (var k = 0; k < points[i].length; k++) {
          points[i][k][0] /= 10.5;
          points[i][k][1] /= -10.5 / 0.75;
          points[i][k][0] += geoCoord[0];
          points[i][k][1] += geoCoord[1];
        }
      }

      function _default(mapType, regions) {
        if (mapType === 'china') {
          regions.push(new Region('', zrUtil.map(points, function (exterior) {
            return {
              type: 'polygon',
              exterior: exterior
            };
          }), geoCoord));
        }
      }

      module.exports = _default;
      /***/
    },

    /***/
    "MqEG":
    /*!***********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/dataZoom/InsideZoomView.js ***!
      \***********************************************************************/

    /*! no static exports found */

    /***/
    function MqEG(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var DataZoomView = __webpack_require__(
      /*! ./DataZoomView */
      "fc+c");

      var sliderMove = __webpack_require__(
      /*! ../helper/sliderMove */
      "72pK");

      var roams = __webpack_require__(
      /*! ./roams */
      "VXYp");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var bind = zrUtil.bind;
      var InsideZoomView = DataZoomView.extend({
        type: 'dataZoom.inside',

        /**
         * @override
         */
        init: function init(ecModel, api) {
          /**
           * 'throttle' is used in this.dispatchAction, so we save range
           * to avoid missing some 'pan' info.
           * @private
           * @type {Array.<number>}
           */
          this._range;
        },

        /**
         * @override
         */
        render: function render(dataZoomModel, ecModel, api, payload) {
          InsideZoomView.superApply(this, 'render', arguments); // Hence the `throttle` util ensures to preserve command order,
          // here simply updating range all the time will not cause missing
          // any of the the roam change.

          this._range = dataZoomModel.getPercentRange(); // Reset controllers.

          zrUtil.each(this.getTargetCoordInfo(), function (coordInfoList, coordSysName) {
            var allCoordIds = zrUtil.map(coordInfoList, function (coordInfo) {
              return roams.generateCoordId(coordInfo.model);
            });
            zrUtil.each(coordInfoList, function (coordInfo) {
              var coordModel = coordInfo.model;
              var getRange = {};
              zrUtil.each(['pan', 'zoom', 'scrollMove'], function (eventName) {
                getRange[eventName] = bind(roamHandlers[eventName], this, coordInfo, coordSysName);
              }, this);
              roams.register(api, {
                coordId: roams.generateCoordId(coordModel),
                allCoordIds: allCoordIds,
                containsPoint: function containsPoint(e, x, y) {
                  return coordModel.coordinateSystem.containPoint([x, y]);
                },
                dataZoomId: dataZoomModel.id,
                dataZoomModel: dataZoomModel,
                getRange: getRange
              });
            }, this);
          }, this);
        },

        /**
         * @override
         */
        dispose: function dispose() {
          roams.unregister(this.api, this.dataZoomModel.id);
          InsideZoomView.superApply(this, 'dispose', arguments);
          this._range = null;
        }
      });
      var roamHandlers = {
        /**
         * @this {module:echarts/component/dataZoom/InsideZoomView}
         */
        zoom: function zoom(coordInfo, coordSysName, controller, e) {
          var lastRange = this._range;
          var range = lastRange.slice(); // Calculate transform by the first axis.

          var axisModel = coordInfo.axisModels[0];

          if (!axisModel) {
            return;
          }

          var directionInfo = getDirectionInfo[coordSysName](null, [e.originX, e.originY], axisModel, controller, coordInfo);
          var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];
          var scale = Math.max(1 / e.scale, 0);
          range[0] = (range[0] - percentPoint) * scale + percentPoint;
          range[1] = (range[1] - percentPoint) * scale + percentPoint; // Restrict range.

          var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
          sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);
          this._range = range;

          if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
            return range;
          }
        },

        /**
         * @this {module:echarts/component/dataZoom/InsideZoomView}
         */
        pan: makeMover(function (range, axisModel, coordInfo, coordSysName, controller, e) {
          var directionInfo = getDirectionInfo[coordSysName]([e.oldX, e.oldY], [e.newX, e.newY], axisModel, controller, coordInfo);
          return directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;
        }),

        /**
         * @this {module:echarts/component/dataZoom/InsideZoomView}
         */
        scrollMove: makeMover(function (range, axisModel, coordInfo, coordSysName, controller, e) {
          var directionInfo = getDirectionInfo[coordSysName]([0, 0], [e.scrollDelta, e.scrollDelta], axisModel, controller, coordInfo);
          return directionInfo.signal * (range[1] - range[0]) * e.scrollDelta;
        })
      };

      function makeMover(getPercentDelta) {
        return function (coordInfo, coordSysName, controller, e) {
          var lastRange = this._range;
          var range = lastRange.slice(); // Calculate transform by the first axis.

          var axisModel = coordInfo.axisModels[0];

          if (!axisModel) {
            return;
          }

          var percentDelta = getPercentDelta(range, axisModel, coordInfo, coordSysName, controller, e);
          sliderMove(percentDelta, range, [0, 100], 'all');
          this._range = range;

          if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
            return range;
          }
        };
      }

      var getDirectionInfo = {
        grid: function grid(oldPoint, newPoint, axisModel, controller, coordInfo) {
          var axis = axisModel.axis;
          var ret = {};
          var rect = coordInfo.model.coordinateSystem.getRect();
          oldPoint = oldPoint || [0, 0];

          if (axis.dim === 'x') {
            ret.pixel = newPoint[0] - oldPoint[0];
            ret.pixelLength = rect.width;
            ret.pixelStart = rect.x;
            ret.signal = axis.inverse ? 1 : -1;
          } else {
            // axis.dim === 'y'
            ret.pixel = newPoint[1] - oldPoint[1];
            ret.pixelLength = rect.height;
            ret.pixelStart = rect.y;
            ret.signal = axis.inverse ? -1 : 1;
          }

          return ret;
        },
        polar: function polar(oldPoint, newPoint, axisModel, controller, coordInfo) {
          var axis = axisModel.axis;
          var ret = {};
          var polar = coordInfo.model.coordinateSystem;
          var radiusExtent = polar.getRadiusAxis().getExtent();
          var angleExtent = polar.getAngleAxis().getExtent();
          oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];
          newPoint = polar.pointToCoord(newPoint);

          if (axisModel.mainType === 'radiusAxis') {
            ret.pixel = newPoint[0] - oldPoint[0]; // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);
            // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);

            ret.pixelLength = radiusExtent[1] - radiusExtent[0];
            ret.pixelStart = radiusExtent[0];
            ret.signal = axis.inverse ? 1 : -1;
          } else {
            // 'angleAxis'
            ret.pixel = newPoint[1] - oldPoint[1]; // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);
            // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);

            ret.pixelLength = angleExtent[1] - angleExtent[0];
            ret.pixelStart = angleExtent[0];
            ret.signal = axis.inverse ? -1 : 1;
          }

          return ret;
        },
        singleAxis: function singleAxis(oldPoint, newPoint, axisModel, controller, coordInfo) {
          var axis = axisModel.axis;
          var rect = coordInfo.model.coordinateSystem.getRect();
          var ret = {};
          oldPoint = oldPoint || [0, 0];

          if (axis.orient === 'horizontal') {
            ret.pixel = newPoint[0] - oldPoint[0];
            ret.pixelLength = rect.width;
            ret.pixelStart = rect.x;
            ret.signal = axis.inverse ? 1 : -1;
          } else {
            // 'vertical'
            ret.pixel = newPoint[1] - oldPoint[1];
            ret.pixelLength = rect.height;
            ret.pixelStart = rect.y;
            ret.signal = axis.inverse ? -1 : 1;
          }

          return ret;
        }
      };
      var _default = InsideZoomView;
      module.exports = _default;
      /***/
    },

    /***/
    "Mylv":
    /*!****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/bar/PictorialBarView.js ***!
      \****************************************************************/

    /*! no static exports found */

    /***/
    function Mylv(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var _symbol = __webpack_require__(
      /*! ../../util/symbol */
      "oVpE");

      var createSymbol = _symbol.createSymbol;

      var _number = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var parsePercent = _number.parsePercent;
      var isNumeric = _number.isNumeric;

      var _helper = __webpack_require__(
      /*! ./helper */
      "56rv");

      var setLabel = _helper.setLabel;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'borderWidth']; // index: +isHorizontal

      var LAYOUT_ATTRS = [{
        xy: 'x',
        wh: 'width',
        index: 0,
        posDesc: ['left', 'right']
      }, {
        xy: 'y',
        wh: 'height',
        index: 1,
        posDesc: ['top', 'bottom']
      }];
      var pathForLineWidth = new graphic.Circle();
      var BarView = echarts.extendChartView({
        type: 'pictorialBar',
        render: function render(seriesModel, ecModel, api) {
          var group = this.group;
          var data = seriesModel.getData();
          var oldData = this._data;
          var cartesian = seriesModel.coordinateSystem;
          var baseAxis = cartesian.getBaseAxis();
          var isHorizontal = !!baseAxis.isHorizontal();
          var coordSysRect = cartesian.grid.getRect();
          var opt = {
            ecSize: {
              width: api.getWidth(),
              height: api.getHeight()
            },
            seriesModel: seriesModel,
            coordSys: cartesian,
            coordSysExtent: [[coordSysRect.x, coordSysRect.x + coordSysRect.width], [coordSysRect.y, coordSysRect.y + coordSysRect.height]],
            isHorizontal: isHorizontal,
            valueDim: LAYOUT_ATTRS[+isHorizontal],
            categoryDim: LAYOUT_ATTRS[1 - isHorizontal]
          };
          data.diff(oldData).add(function (dataIndex) {
            if (!data.hasValue(dataIndex)) {
              return;
            }

            var itemModel = getItemModel(data, dataIndex);
            var symbolMeta = getSymbolMeta(data, dataIndex, itemModel, opt);
            var bar = createBar(data, opt, symbolMeta);
            data.setItemGraphicEl(dataIndex, bar);
            group.add(bar);
            updateCommon(bar, opt, symbolMeta);
          }).update(function (newIndex, oldIndex) {
            var bar = oldData.getItemGraphicEl(oldIndex);

            if (!data.hasValue(newIndex)) {
              group.remove(bar);
              return;
            }

            var itemModel = getItemModel(data, newIndex);
            var symbolMeta = getSymbolMeta(data, newIndex, itemModel, opt);
            var pictorialShapeStr = getShapeStr(data, symbolMeta);

            if (bar && pictorialShapeStr !== bar.__pictorialShapeStr) {
              group.remove(bar);
              data.setItemGraphicEl(newIndex, null);
              bar = null;
            }

            if (bar) {
              updateBar(bar, opt, symbolMeta);
            } else {
              bar = createBar(data, opt, symbolMeta, true);
            }

            data.setItemGraphicEl(newIndex, bar);
            bar.__pictorialSymbolMeta = symbolMeta; // Add back

            group.add(bar);
            updateCommon(bar, opt, symbolMeta);
          }).remove(function (dataIndex) {
            var bar = oldData.getItemGraphicEl(dataIndex);
            bar && removeBar(oldData, dataIndex, bar.__pictorialSymbolMeta.animationModel, bar);
          }).execute();
          this._data = data;
          return this.group;
        },
        dispose: zrUtil.noop,
        remove: function remove(ecModel, api) {
          var group = this.group;
          var data = this._data;

          if (ecModel.get('animation')) {
            if (data) {
              data.eachItemGraphicEl(function (bar) {
                removeBar(data, bar.dataIndex, ecModel, bar);
              });
            }
          } else {
            group.removeAll();
          }
        }
      }); // Set or calculate default value about symbol, and calculate layout info.

      function getSymbolMeta(data, dataIndex, itemModel, opt) {
        var layout = data.getItemLayout(dataIndex);
        var symbolRepeat = itemModel.get('symbolRepeat');
        var symbolClip = itemModel.get('symbolClip');
        var symbolPosition = itemModel.get('symbolPosition') || 'start';
        var symbolRotate = itemModel.get('symbolRotate');
        var rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
        var symbolPatternSize = itemModel.get('symbolPatternSize') || 2;
        var isAnimationEnabled = itemModel.isAnimationEnabled();
        var symbolMeta = {
          dataIndex: dataIndex,
          layout: layout,
          itemModel: itemModel,
          symbolType: data.getItemVisual(dataIndex, 'symbol') || 'circle',
          color: data.getItemVisual(dataIndex, 'color'),
          symbolClip: symbolClip,
          symbolRepeat: symbolRepeat,
          symbolRepeatDirection: itemModel.get('symbolRepeatDirection'),
          symbolPatternSize: symbolPatternSize,
          rotation: rotation,
          animationModel: isAnimationEnabled ? itemModel : null,
          hoverAnimation: isAnimationEnabled && itemModel.get('hoverAnimation'),
          z2: itemModel.getShallow('z', true) || 0
        };
        prepareBarLength(itemModel, symbolRepeat, layout, opt, symbolMeta);
        prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, symbolMeta.boundingLength, symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta);
        prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta);
        var symbolSize = symbolMeta.symbolSize;
        var symbolOffset = itemModel.get('symbolOffset');

        if (zrUtil.isArray(symbolOffset)) {
          symbolOffset = [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])];
        }

        prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength, opt, symbolMeta);
        return symbolMeta;
      } // bar length can be negative.


      function prepareBarLength(itemModel, symbolRepeat, layout, opt, output) {
        var valueDim = opt.valueDim;
        var symbolBoundingData = itemModel.get('symbolBoundingData');
        var valueAxis = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis());
        var zeroPx = valueAxis.toGlobalCoord(valueAxis.dataToCoord(0));
        var pxSignIdx = 1 - +(layout[valueDim.wh] <= 0);
        var boundingLength;

        if (zrUtil.isArray(symbolBoundingData)) {
          var symbolBoundingExtent = [convertToCoordOnAxis(valueAxis, symbolBoundingData[0]) - zeroPx, convertToCoordOnAxis(valueAxis, symbolBoundingData[1]) - zeroPx];
          symbolBoundingExtent[1] < symbolBoundingExtent[0] && symbolBoundingExtent.reverse();
          boundingLength = symbolBoundingExtent[pxSignIdx];
        } else if (symbolBoundingData != null) {
          boundingLength = convertToCoordOnAxis(valueAxis, symbolBoundingData) - zeroPx;
        } else if (symbolRepeat) {
          boundingLength = opt.coordSysExtent[valueDim.index][pxSignIdx] - zeroPx;
        } else {
          boundingLength = layout[valueDim.wh];
        }

        output.boundingLength = boundingLength;

        if (symbolRepeat) {
          output.repeatCutLength = layout[valueDim.wh];
        }

        output.pxSign = boundingLength > 0 ? 1 : boundingLength < 0 ? -1 : 0;
      }

      function convertToCoordOnAxis(axis, value) {
        return axis.toGlobalCoord(axis.dataToCoord(axis.scale.parse(value)));
      } // Support ['100%', '100%']


      function prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, boundingLength, pxSign, symbolPatternSize, opt, output) {
        var valueDim = opt.valueDim;
        var categoryDim = opt.categoryDim;
        var categorySize = Math.abs(layout[categoryDim.wh]);
        var symbolSize = data.getItemVisual(dataIndex, 'symbolSize');

        if (zrUtil.isArray(symbolSize)) {
          symbolSize = symbolSize.slice();
        } else {
          if (symbolSize == null) {
            symbolSize = '100%';
          }

          symbolSize = [symbolSize, symbolSize];
        } // Note: percentage symbolSize (like '100%') do not consider lineWidth, because it is
        // to complicated to calculate real percent value if considering scaled lineWidth.
        // So the actual size will bigger than layout size if lineWidth is bigger than zero,
        // which can be tolerated in pictorial chart.


        symbolSize[categoryDim.index] = parsePercent(symbolSize[categoryDim.index], categorySize);
        symbolSize[valueDim.index] = parsePercent(symbolSize[valueDim.index], symbolRepeat ? categorySize : Math.abs(boundingLength));
        output.symbolSize = symbolSize; // If x or y is less than zero, show reversed shape.

        var symbolScale = output.symbolScale = [symbolSize[0] / symbolPatternSize, symbolSize[1] / symbolPatternSize]; // Follow convention, 'right' and 'top' is the normal scale.

        symbolScale[valueDim.index] *= (opt.isHorizontal ? -1 : 1) * pxSign;
      }

      function prepareLineWidth(itemModel, symbolScale, rotation, opt, output) {
        // In symbols are drawn with scale, so do not need to care about the case that width
        // or height are too small. But symbol use strokeNoScale, where acture lineWidth should
        // be calculated.
        var valueLineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;

        if (valueLineWidth) {
          pathForLineWidth.attr({
            scale: symbolScale.slice(),
            rotation: rotation
          });
          pathForLineWidth.updateTransform();
          valueLineWidth /= pathForLineWidth.getLineScale();
          valueLineWidth *= symbolScale[opt.valueDim.index];
        }

        output.valueLineWidth = valueLineWidth;
      }

      function prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, valueLineWidth, boundingLength, repeatCutLength, opt, output) {
        var categoryDim = opt.categoryDim;
        var valueDim = opt.valueDim;
        var pxSign = output.pxSign;
        var unitLength = Math.max(symbolSize[valueDim.index] + valueLineWidth, 0);
        var pathLen = unitLength; // Note: rotation will not effect the layout of symbols, because user may
        // want symbols to rotate on its center, which should not be translated
        // when rotating.

        if (symbolRepeat) {
          var absBoundingLength = Math.abs(boundingLength);
          var symbolMargin = zrUtil.retrieve(itemModel.get('symbolMargin'), '15%') + '';
          var hasEndGap = false;

          if (symbolMargin.lastIndexOf('!') === symbolMargin.length - 1) {
            hasEndGap = true;
            symbolMargin = symbolMargin.slice(0, symbolMargin.length - 1);
          }

          symbolMargin = parsePercent(symbolMargin, symbolSize[valueDim.index]);
          var uLenWithMargin = Math.max(unitLength + symbolMargin * 2, 0); // When symbol margin is less than 0, margin at both ends will be subtracted
          // to ensure that all of the symbols will not be overflow the given area.

          var endFix = hasEndGap ? 0 : symbolMargin * 2; // Both final repeatTimes and final symbolMargin area calculated based on
          // boundingLength.

          var repeatSpecified = isNumeric(symbolRepeat);
          var repeatTimes = repeatSpecified ? symbolRepeat : toIntTimes((absBoundingLength + endFix) / uLenWithMargin); // Adjust calculate margin, to ensure each symbol is displayed
          // entirely in the given layout area.

          var mDiff = absBoundingLength - repeatTimes * unitLength;
          symbolMargin = mDiff / 2 / (hasEndGap ? repeatTimes : repeatTimes - 1);
          uLenWithMargin = unitLength + symbolMargin * 2;
          endFix = hasEndGap ? 0 : symbolMargin * 2; // Update repeatTimes when not all symbol will be shown.

          if (!repeatSpecified && symbolRepeat !== 'fixed') {
            repeatTimes = repeatCutLength ? toIntTimes((Math.abs(repeatCutLength) + endFix) / uLenWithMargin) : 0;
          }

          pathLen = repeatTimes * uLenWithMargin - endFix;
          output.repeatTimes = repeatTimes;
          output.symbolMargin = symbolMargin;
        }

        var sizeFix = pxSign * (pathLen / 2);
        var pathPosition = output.pathPosition = [];
        pathPosition[categoryDim.index] = layout[categoryDim.wh] / 2;
        pathPosition[valueDim.index] = symbolPosition === 'start' ? sizeFix : symbolPosition === 'end' ? boundingLength - sizeFix : boundingLength / 2; // 'center'

        if (symbolOffset) {
          pathPosition[0] += symbolOffset[0];
          pathPosition[1] += symbolOffset[1];
        }

        var bundlePosition = output.bundlePosition = [];
        bundlePosition[categoryDim.index] = layout[categoryDim.xy];
        bundlePosition[valueDim.index] = layout[valueDim.xy];
        var barRectShape = output.barRectShape = zrUtil.extend({}, layout);
        barRectShape[valueDim.wh] = pxSign * Math.max(Math.abs(layout[valueDim.wh]), Math.abs(pathPosition[valueDim.index] + sizeFix));
        barRectShape[categoryDim.wh] = layout[categoryDim.wh];
        var clipShape = output.clipShape = {}; // Consider that symbol may be overflow layout rect.

        clipShape[categoryDim.xy] = -layout[categoryDim.xy];
        clipShape[categoryDim.wh] = opt.ecSize[categoryDim.wh];
        clipShape[valueDim.xy] = 0;
        clipShape[valueDim.wh] = layout[valueDim.wh];
      }

      function createPath(symbolMeta) {
        var symbolPatternSize = symbolMeta.symbolPatternSize;
        var path = createSymbol( // Consider texture img, make a big size.
        symbolMeta.symbolType, -symbolPatternSize / 2, -symbolPatternSize / 2, symbolPatternSize, symbolPatternSize, symbolMeta.color);
        path.attr({
          culling: true
        });
        path.type !== 'image' && path.setStyle({
          strokeNoScale: true
        });
        return path;
      }

      function createOrUpdateRepeatSymbols(bar, opt, symbolMeta, isUpdate) {
        var bundle = bar.__pictorialBundle;
        var symbolSize = symbolMeta.symbolSize;
        var valueLineWidth = symbolMeta.valueLineWidth;
        var pathPosition = symbolMeta.pathPosition;
        var valueDim = opt.valueDim;
        var repeatTimes = symbolMeta.repeatTimes || 0;
        var index = 0;
        var unit = symbolSize[opt.valueDim.index] + valueLineWidth + symbolMeta.symbolMargin * 2;
        eachPath(bar, function (path) {
          path.__pictorialAnimationIndex = index;
          path.__pictorialRepeatTimes = repeatTimes;

          if (index < repeatTimes) {
            updateAttr(path, null, makeTarget(index), symbolMeta, isUpdate);
          } else {
            updateAttr(path, null, {
              scale: [0, 0]
            }, symbolMeta, isUpdate, function () {
              bundle.remove(path);
            });
          }

          updateHoverAnimation(path, symbolMeta);
          index++;
        });

        for (; index < repeatTimes; index++) {
          var path = createPath(symbolMeta);
          path.__pictorialAnimationIndex = index;
          path.__pictorialRepeatTimes = repeatTimes;
          bundle.add(path);
          var target = makeTarget(index);
          updateAttr(path, {
            position: target.position,
            scale: [0, 0]
          }, {
            scale: target.scale,
            rotation: target.rotation
          }, symbolMeta, isUpdate); // FIXME
          // If all emphasis/normal through action.

          path.on('mouseover', onMouseOver).on('mouseout', onMouseOut);
          updateHoverAnimation(path, symbolMeta);
        }

        function makeTarget(index) {
          var position = pathPosition.slice(); // (start && pxSign > 0) || (end && pxSign < 0): i = repeatTimes - index
          // Otherwise: i = index;

          var pxSign = symbolMeta.pxSign;
          var i = index;

          if (symbolMeta.symbolRepeatDirection === 'start' ? pxSign > 0 : pxSign < 0) {
            i = repeatTimes - 1 - index;
          }

          position[valueDim.index] = unit * (i - repeatTimes / 2 + 0.5) + pathPosition[valueDim.index];
          return {
            position: position,
            scale: symbolMeta.symbolScale.slice(),
            rotation: symbolMeta.rotation
          };
        }

        function onMouseOver() {
          eachPath(bar, function (path) {
            path.trigger('emphasis');
          });
        }

        function onMouseOut() {
          eachPath(bar, function (path) {
            path.trigger('normal');
          });
        }
      }

      function createOrUpdateSingleSymbol(bar, opt, symbolMeta, isUpdate) {
        var bundle = bar.__pictorialBundle;
        var mainPath = bar.__pictorialMainPath;

        if (!mainPath) {
          mainPath = bar.__pictorialMainPath = createPath(symbolMeta);
          bundle.add(mainPath);
          updateAttr(mainPath, {
            position: symbolMeta.pathPosition.slice(),
            scale: [0, 0],
            rotation: symbolMeta.rotation
          }, {
            scale: symbolMeta.symbolScale.slice()
          }, symbolMeta, isUpdate);
          mainPath.on('mouseover', onMouseOver).on('mouseout', onMouseOut);
        } else {
          updateAttr(mainPath, null, {
            position: symbolMeta.pathPosition.slice(),
            scale: symbolMeta.symbolScale.slice(),
            rotation: symbolMeta.rotation
          }, symbolMeta, isUpdate);
        }

        updateHoverAnimation(mainPath, symbolMeta);

        function onMouseOver() {
          this.trigger('emphasis');
        }

        function onMouseOut() {
          this.trigger('normal');
        }
      } // bar rect is used for label.


      function createOrUpdateBarRect(bar, symbolMeta, isUpdate) {
        var rectShape = zrUtil.extend({}, symbolMeta.barRectShape);
        var barRect = bar.__pictorialBarRect;

        if (!barRect) {
          barRect = bar.__pictorialBarRect = new graphic.Rect({
            z2: 2,
            shape: rectShape,
            silent: true,
            style: {
              stroke: 'transparent',
              fill: 'transparent',
              lineWidth: 0
            }
          });
          bar.add(barRect);
        } else {
          updateAttr(barRect, null, {
            shape: rectShape
          }, symbolMeta, isUpdate);
        }
      }

      function createOrUpdateClip(bar, opt, symbolMeta, isUpdate) {
        // If not clip, symbol will be remove and rebuilt.
        if (symbolMeta.symbolClip) {
          var clipPath = bar.__pictorialClipPath;
          var clipShape = zrUtil.extend({}, symbolMeta.clipShape);
          var valueDim = opt.valueDim;
          var animationModel = symbolMeta.animationModel;
          var dataIndex = symbolMeta.dataIndex;

          if (clipPath) {
            graphic.updateProps(clipPath, {
              shape: clipShape
            }, animationModel, dataIndex);
          } else {
            clipShape[valueDim.wh] = 0;
            clipPath = new graphic.Rect({
              shape: clipShape
            });

            bar.__pictorialBundle.setClipPath(clipPath);

            bar.__pictorialClipPath = clipPath;
            var target = {};
            target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh];
            graphic[isUpdate ? 'updateProps' : 'initProps'](clipPath, {
              shape: target
            }, animationModel, dataIndex);
          }
        }
      }

      function getItemModel(data, dataIndex) {
        var itemModel = data.getItemModel(dataIndex);
        itemModel.getAnimationDelayParams = getAnimationDelayParams;
        itemModel.isAnimationEnabled = isAnimationEnabled;
        return itemModel;
      }

      function getAnimationDelayParams(path) {
        // The order is the same as the z-order, see `symbolRepeatDiretion`.
        return {
          index: path.__pictorialAnimationIndex,
          count: path.__pictorialRepeatTimes
        };
      }

      function isAnimationEnabled() {
        // `animation` prop can be set on itemModel in pictorial bar chart.
        return this.parentModel.isAnimationEnabled() && !!this.getShallow('animation');
      }

      function updateHoverAnimation(path, symbolMeta) {
        path.off('emphasis').off('normal');
        var scale = symbolMeta.symbolScale.slice();
        symbolMeta.hoverAnimation && path.on('emphasis', function () {
          this.animateTo({
            scale: [scale[0] * 1.1, scale[1] * 1.1]
          }, 400, 'elasticOut');
        }).on('normal', function () {
          this.animateTo({
            scale: scale.slice()
          }, 400, 'elasticOut');
        });
      }

      function createBar(data, opt, symbolMeta, isUpdate) {
        // bar is the main element for each data.
        var bar = new graphic.Group(); // bundle is used for location and clip.

        var bundle = new graphic.Group();
        bar.add(bundle);
        bar.__pictorialBundle = bundle;
        bundle.attr('position', symbolMeta.bundlePosition.slice());

        if (symbolMeta.symbolRepeat) {
          createOrUpdateRepeatSymbols(bar, opt, symbolMeta);
        } else {
          createOrUpdateSingleSymbol(bar, opt, symbolMeta);
        }

        createOrUpdateBarRect(bar, symbolMeta, isUpdate);
        createOrUpdateClip(bar, opt, symbolMeta, isUpdate);
        bar.__pictorialShapeStr = getShapeStr(data, symbolMeta);
        bar.__pictorialSymbolMeta = symbolMeta;
        return bar;
      }

      function updateBar(bar, opt, symbolMeta) {
        var animationModel = symbolMeta.animationModel;
        var dataIndex = symbolMeta.dataIndex;
        var bundle = bar.__pictorialBundle;
        graphic.updateProps(bundle, {
          position: symbolMeta.bundlePosition.slice()
        }, animationModel, dataIndex);

        if (symbolMeta.symbolRepeat) {
          createOrUpdateRepeatSymbols(bar, opt, symbolMeta, true);
        } else {
          createOrUpdateSingleSymbol(bar, opt, symbolMeta, true);
        }

        createOrUpdateBarRect(bar, symbolMeta, true);
        createOrUpdateClip(bar, opt, symbolMeta, true);
      }

      function removeBar(data, dataIndex, animationModel, bar) {
        // Not show text when animating
        var labelRect = bar.__pictorialBarRect;
        labelRect && (labelRect.style.text = null);
        var pathes = [];
        eachPath(bar, function (path) {
          pathes.push(path);
        });
        bar.__pictorialMainPath && pathes.push(bar.__pictorialMainPath); // I do not find proper remove animation for clip yet.

        bar.__pictorialClipPath && (animationModel = null);
        zrUtil.each(pathes, function (path) {
          graphic.updateProps(path, {
            scale: [0, 0]
          }, animationModel, dataIndex, function () {
            bar.parent && bar.parent.remove(bar);
          });
        });
        data.setItemGraphicEl(dataIndex, null);
      }

      function getShapeStr(data, symbolMeta) {
        return [data.getItemVisual(symbolMeta.dataIndex, 'symbol') || 'none', !!symbolMeta.symbolRepeat, !!symbolMeta.symbolClip].join(':');
      }

      function eachPath(bar, cb, context) {
        // Do not use Group#eachChild, because it do not support remove.
        zrUtil.each(bar.__pictorialBundle.children(), function (el) {
          el !== bar.__pictorialBarRect && cb.call(context, el);
        });
      }

      function updateAttr(el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) {
        immediateAttrs && el.attr(immediateAttrs); // when symbolCip used, only clip path has init animation, otherwise it would be weird effect.

        if (symbolMeta.symbolClip && !isUpdate) {
          animationAttrs && el.attr(animationAttrs);
        } else {
          animationAttrs && graphic[isUpdate ? 'updateProps' : 'initProps'](el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb);
        }
      }

      function updateCommon(bar, opt, symbolMeta) {
        var color = symbolMeta.color;
        var dataIndex = symbolMeta.dataIndex;
        var itemModel = symbolMeta.itemModel; // Color must be excluded.
        // Because symbol provide setColor individually to set fill and stroke

        var normalStyle = itemModel.getModel('itemStyle').getItemStyle(['color']);
        var hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();
        var cursorStyle = itemModel.getShallow('cursor');
        eachPath(bar, function (path) {
          // PENDING setColor should be before setStyle!!!
          path.setColor(color);
          path.setStyle(zrUtil.defaults({
            fill: color,
            opacity: symbolMeta.opacity
          }, normalStyle));
          graphic.setHoverStyle(path, hoverStyle);
          cursorStyle && (path.cursor = cursorStyle);
          path.z2 = symbolMeta.z2;
        });
        var barRectHoverStyle = {};
        var barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)];
        var barRect = bar.__pictorialBarRect;
        setLabel(barRect.style, barRectHoverStyle, itemModel, color, opt.seriesModel, dataIndex, barPositionOutside);
        graphic.setHoverStyle(barRect, barRectHoverStyle);
      }

      function toIntTimes(times) {
        var roundedTimes = Math.round(times); // Escapse accurate error

        return Math.abs(times - roundedTimes) < 1e-4 ? roundedTimes : Math.ceil(times);
      }

      var _default = BarView;
      module.exports = _default;
      /***/
    },

    /***/
    "N5BQ":
    /*!************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js ***!
      \************************************************************************/

    /*! no static exports found */

    /***/
    function N5BQ(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var DataZoomModel = __webpack_require__(
      /*! ./DataZoomModel */
      "OlYY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var SliderZoomModel = DataZoomModel.extend({
        type: 'dataZoom.slider',
        layoutMode: 'box',

        /**
         * @protected
         */
        defaultOption: {
          show: true,
          // ph => placeholder. Using placehoder here because
          // deault value can only be drived in view stage.
          right: 'ph',
          // Default align to grid rect.
          top: 'ph',
          // Default align to grid rect.
          width: 'ph',
          // Default align to grid rect.
          height: 'ph',
          // Default align to grid rect.
          left: null,
          // Default align to grid rect.
          bottom: null,
          // Default align to grid rect.
          backgroundColor: 'rgba(47,69,84,0)',
          // Background of slider zoom component.
          // dataBackgroundColor: '#ddd',         // Background coor of data shadow and border of box,
          // highest priority, remain for compatibility of
          // previous version, but not recommended any more.
          dataBackground: {
            lineStyle: {
              color: '#2f4554',
              width: 0.5,
              opacity: 0.3
            },
            areaStyle: {
              color: 'rgba(47,69,84,0.3)',
              opacity: 0.3
            }
          },
          borderColor: '#ddd',
          // border color of the box. For compatibility,
          // if dataBackgroundColor is set, borderColor
          // is ignored.
          fillerColor: 'rgba(167,183,204,0.4)',
          // Color of selected area.
          // handleColor: 'rgba(89,170,216,0.95)',     // Color of handle.
          // handleIcon: 'path://M4.9,17.8c0-1.4,4.5-10.5,5.5-12.4c0-0.1,0.6-1.1,0.9-1.1c0.4,0,0.9,1,0.9,1.1c1.1,2.2,5.4,11,5.4,12.4v17.8c0,1.5-0.6,2.1-1.3,2.1H6.1c-0.7,0-1.3-0.6-1.3-2.1V17.8z',

          /* eslint-disable */
          handleIcon: 'M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z',

          /* eslint-enable */
          // Percent of the slider height
          handleSize: '100%',
          handleStyle: {
            color: '#a7b7cc'
          },
          labelPrecision: null,
          labelFormatter: null,
          showDetail: true,
          showDataShadow: 'auto',
          // Default auto decision.
          realtime: true,
          zoomLock: false,
          // Whether disable zoom.
          textStyle: {
            color: '#333'
          }
        }
      });
      var _default = SliderZoomModel;
      module.exports = _default;
      /***/
    },

    /***/
    "NA0q":
    /*!*****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/sunburst/SunburstView.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function NA0q(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var ChartView = __webpack_require__(
      /*! ../../view/Chart */
      "6Ic6");

      var SunburstPiece = __webpack_require__(
      /*! ./SunburstPiece */
      "TkdX");

      var DataDiffer = __webpack_require__(
      /*! ../../data/DataDiffer */
      "gPAo");

      var _format = __webpack_require__(
      /*! ../../util/format */
      "7aKB");

      var windowOpen = _format.windowOpen;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var ROOT_TO_NODE_ACTION = 'sunburstRootToNode';
      var SunburstView = ChartView.extend({
        type: 'sunburst',
        init: function init() {},
        render: function render(seriesModel, ecModel, api, payload) {
          var that = this;
          this.seriesModel = seriesModel;
          this.api = api;
          this.ecModel = ecModel;
          var data = seriesModel.getData();
          var virtualRoot = data.tree.root;
          var newRoot = seriesModel.getViewRoot();
          var group = this.group;
          var renderLabelForZeroData = seriesModel.get('renderLabelForZeroData');
          var newChildren = [];
          newRoot.eachNode(function (node) {
            newChildren.push(node);
          });
          var oldChildren = this._oldChildren || [];
          dualTravel(newChildren, oldChildren);
          renderRollUp(virtualRoot, newRoot);

          if (payload && payload.highlight && payload.highlight.piece) {
            var highlightPolicy = seriesModel.getShallow('highlightPolicy');
            payload.highlight.piece.onEmphasis(highlightPolicy);
          } else if (payload && payload.unhighlight) {
            var piece = this.virtualPiece;

            if (!piece && virtualRoot.children.length) {
              piece = virtualRoot.children[0].piece;
            }

            if (piece) {
              piece.onNormal();
            }
          }

          this._initEvents();

          this._oldChildren = newChildren;

          function dualTravel(newChildren, oldChildren) {
            if (newChildren.length === 0 && oldChildren.length === 0) {
              return;
            }

            new DataDiffer(oldChildren, newChildren, getKey, getKey).add(processNode).update(processNode).remove(zrUtil.curry(processNode, null)).execute();

            function getKey(node) {
              return node.getId();
            }

            function processNode(newId, oldId) {
              var newNode = newId == null ? null : newChildren[newId];
              var oldNode = oldId == null ? null : oldChildren[oldId];
              doRenderNode(newNode, oldNode);
            }
          }

          function doRenderNode(newNode, oldNode) {
            if (!renderLabelForZeroData && newNode && !newNode.getValue()) {
              // Not render data with value 0
              newNode = null;
            }

            if (newNode !== virtualRoot && oldNode !== virtualRoot) {
              if (oldNode && oldNode.piece) {
                if (newNode) {
                  // Update
                  oldNode.piece.updateData(false, newNode, 'normal', seriesModel, ecModel); // For tooltip

                  data.setItemGraphicEl(newNode.dataIndex, oldNode.piece);
                } else {
                  // Remove
                  removeNode(oldNode);
                }
              } else if (newNode) {
                // Add
                var piece = new SunburstPiece(newNode, seriesModel, ecModel);
                group.add(piece); // For tooltip

                data.setItemGraphicEl(newNode.dataIndex, piece);
              }
            }
          }

          function removeNode(node) {
            if (!node) {
              return;
            }

            if (node.piece) {
              group.remove(node.piece);
              node.piece = null;
            }
          }

          function renderRollUp(virtualRoot, viewRoot) {
            if (viewRoot.depth > 0) {
              // Render
              if (that.virtualPiece) {
                // Update
                that.virtualPiece.updateData(false, virtualRoot, 'normal', seriesModel, ecModel);
              } else {
                // Add
                that.virtualPiece = new SunburstPiece(virtualRoot, seriesModel, ecModel);
                group.add(that.virtualPiece);
              }

              if (viewRoot.piece._onclickEvent) {
                viewRoot.piece.off('click', viewRoot.piece._onclickEvent);
              }

              var event = function event(e) {
                that._rootToNode(viewRoot.parentNode);
              };

              viewRoot.piece._onclickEvent = event;
              that.virtualPiece.on('click', event);
            } else if (that.virtualPiece) {
              // Remove
              group.remove(that.virtualPiece);
              that.virtualPiece = null;
            }
          }
        },
        dispose: function dispose() {},

        /**
         * @private
         */
        _initEvents: function _initEvents() {
          var that = this;

          var event = function event(e) {
            var targetFound = false;
            var viewRoot = that.seriesModel.getViewRoot();
            viewRoot.eachNode(function (node) {
              if (!targetFound && node.piece && node.piece.childAt(0) === e.target) {
                var nodeClick = node.getModel().get('nodeClick');

                if (nodeClick === 'rootToNode') {
                  that._rootToNode(node);
                } else if (nodeClick === 'link') {
                  var itemModel = node.getModel();
                  var link = itemModel.get('link');

                  if (link) {
                    var linkTarget = itemModel.get('target', true) || '_blank';
                    windowOpen(link, linkTarget);
                  }
                }

                targetFound = true;
              }
            });
          };

          if (this.group._onclickEvent) {
            this.group.off('click', this.group._onclickEvent);
          }

          this.group.on('click', event);
          this.group._onclickEvent = event;
        },

        /**
         * @private
         */
        _rootToNode: function _rootToNode(node) {
          if (node !== this.seriesModel.getViewRoot()) {
            this.api.dispatchAction({
              type: ROOT_TO_NODE_ACTION,
              from: this.uid,
              seriesId: this.seriesModel.id,
              targetNode: node
            });
          }
        },

        /**
         * @implement
         */
        containPoint: function containPoint(point, seriesModel) {
          var treeRoot = seriesModel.getData();
          var itemLayout = treeRoot.getItemLayout(0);

          if (itemLayout) {
            var dx = point[0] - itemLayout.cx;
            var dy = point[1] - itemLayout.cy;
            var radius = Math.sqrt(dx * dx + dy * dy);
            return radius <= itemLayout.r && radius >= itemLayout.r0;
          }
        }
      });
      var _default = SunburstView;
      module.exports = _default;
      /***/
    },

    /***/
    "NH9N":
    /*!***************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/timeline/SliderTimelineView.js ***!
      \***************************************************************************/

    /*! no static exports found */

    /***/
    function NH9N(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var BoundingRect = __webpack_require__(
      /*! zrender/lib/core/BoundingRect */
      "mFDi");

      var matrix = __webpack_require__(
      /*! zrender/lib/core/matrix */
      "Fofx");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var layout = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var TimelineView = __webpack_require__(
      /*! ./TimelineView */
      "kzvK");

      var TimelineAxis = __webpack_require__(
      /*! ./TimelineAxis */
      "CMP+");

      var _symbol = __webpack_require__(
      /*! ../../util/symbol */
      "oVpE");

      var createSymbol = _symbol.createSymbol;

      var axisHelper = __webpack_require__(
      /*! ../../coord/axisHelper */
      "aX7z");

      var numberUtil = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var _format = __webpack_require__(
      /*! ../../util/format */
      "7aKB");

      var encodeHTML = _format.encodeHTML;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var bind = zrUtil.bind;
      var each = zrUtil.each;
      var PI = Math.PI;

      var _default = TimelineView.extend({
        type: 'timeline.slider',
        init: function init(ecModel, api) {
          this.api = api;
          /**
           * @private
           * @type {module:echarts/component/timeline/TimelineAxis}
           */

          this._axis;
          /**
           * @private
           * @type {module:zrender/core/BoundingRect}
           */

          this._viewRect;
          /**
           * @type {number}
           */

          this._timer;
          /**
           * @type {module:zrender/Element}
           */

          this._currentPointer;
          /**
           * @type {module:zrender/container/Group}
           */

          this._mainGroup;
          /**
           * @type {module:zrender/container/Group}
           */

          this._labelGroup;
        },

        /**
         * @override
         */
        render: function render(timelineModel, ecModel, api, payload) {
          this.model = timelineModel;
          this.api = api;
          this.ecModel = ecModel;
          this.group.removeAll();

          if (timelineModel.get('show', true)) {
            var layoutInfo = this._layout(timelineModel, api);

            var mainGroup = this._createGroup('mainGroup');

            var labelGroup = this._createGroup('labelGroup');
            /**
             * @private
             * @type {module:echarts/component/timeline/TimelineAxis}
             */


            var axis = this._axis = this._createAxis(layoutInfo, timelineModel);

            timelineModel.formatTooltip = function (dataIndex) {
              return encodeHTML(axis.scale.getLabel(dataIndex));
            };

            each(['AxisLine', 'AxisTick', 'Control', 'CurrentPointer'], function (name) {
              this['_render' + name](layoutInfo, mainGroup, axis, timelineModel);
            }, this);

            this._renderAxisLabel(layoutInfo, labelGroup, axis, timelineModel);

            this._position(layoutInfo, timelineModel);
          }

          this._doPlayStop();
        },

        /**
         * @override
         */
        remove: function remove() {
          this._clearTimer();

          this.group.removeAll();
        },

        /**
         * @override
         */
        dispose: function dispose() {
          this._clearTimer();
        },
        _layout: function _layout(timelineModel, api) {
          var labelPosOpt = timelineModel.get('label.position');
          var orient = timelineModel.get('orient');
          var viewRect = getViewRect(timelineModel, api); // Auto label offset.

          if (labelPosOpt == null || labelPosOpt === 'auto') {
            labelPosOpt = orient === 'horizontal' ? viewRect.y + viewRect.height / 2 < api.getHeight() / 2 ? '-' : '+' : viewRect.x + viewRect.width / 2 < api.getWidth() / 2 ? '+' : '-';
          } else if (isNaN(labelPosOpt)) {
            labelPosOpt = {
              horizontal: {
                top: '-',
                bottom: '+'
              },
              vertical: {
                left: '-',
                right: '+'
              }
            }[orient][labelPosOpt];
          }

          var labelAlignMap = {
            horizontal: 'center',
            vertical: labelPosOpt >= 0 || labelPosOpt === '+' ? 'left' : 'right'
          };
          var labelBaselineMap = {
            horizontal: labelPosOpt >= 0 || labelPosOpt === '+' ? 'top' : 'bottom',
            vertical: 'middle'
          };
          var rotationMap = {
            horizontal: 0,
            vertical: PI / 2
          }; // Position

          var mainLength = orient === 'vertical' ? viewRect.height : viewRect.width;
          var controlModel = timelineModel.getModel('controlStyle');
          var showControl = controlModel.get('show', true);
          var controlSize = showControl ? controlModel.get('itemSize') : 0;
          var controlGap = showControl ? controlModel.get('itemGap') : 0;
          var sizePlusGap = controlSize + controlGap; // Special label rotate.

          var labelRotation = timelineModel.get('label.rotate') || 0;
          labelRotation = labelRotation * PI / 180; // To radian.

          var playPosition;
          var prevBtnPosition;
          var nextBtnPosition;
          var axisExtent;
          var controlPosition = controlModel.get('position', true);
          var showPlayBtn = showControl && controlModel.get('showPlayBtn', true);
          var showPrevBtn = showControl && controlModel.get('showPrevBtn', true);
          var showNextBtn = showControl && controlModel.get('showNextBtn', true);
          var xLeft = 0;
          var xRight = mainLength; // position[0] means left, position[1] means middle.

          if (controlPosition === 'left' || controlPosition === 'bottom') {
            showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap);
            showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap);
            showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
          } else {
            // 'top' 'right'
            showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
            showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap);
            showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
          }

          axisExtent = [xLeft, xRight];

          if (timelineModel.get('inverse')) {
            axisExtent.reverse();
          }

          return {
            viewRect: viewRect,
            mainLength: mainLength,
            orient: orient,
            rotation: rotationMap[orient],
            labelRotation: labelRotation,
            labelPosOpt: labelPosOpt,
            labelAlign: timelineModel.get('label.align') || labelAlignMap[orient],
            labelBaseline: timelineModel.get('label.verticalAlign') || timelineModel.get('label.baseline') || labelBaselineMap[orient],
            // Based on mainGroup.
            playPosition: playPosition,
            prevBtnPosition: prevBtnPosition,
            nextBtnPosition: nextBtnPosition,
            axisExtent: axisExtent,
            controlSize: controlSize,
            controlGap: controlGap
          };
        },
        _position: function _position(layoutInfo, timelineModel) {
          // Position is be called finally, because bounding rect is needed for
          // adapt content to fill viewRect (auto adapt offset).
          // Timeline may be not all in the viewRect when 'offset' is specified
          // as a number, because it is more appropriate that label aligns at
          // 'offset' but not the other edge defined by viewRect.
          var mainGroup = this._mainGroup;
          var labelGroup = this._labelGroup;
          var viewRect = layoutInfo.viewRect;

          if (layoutInfo.orient === 'vertical') {
            // transform to horizontal, inverse rotate by left-top point.
            var m = matrix.create();
            var rotateOriginX = viewRect.x;
            var rotateOriginY = viewRect.y + viewRect.height;
            matrix.translate(m, m, [-rotateOriginX, -rotateOriginY]);
            matrix.rotate(m, m, -PI / 2);
            matrix.translate(m, m, [rotateOriginX, rotateOriginY]);
            viewRect = viewRect.clone();
            viewRect.applyTransform(m);
          }

          var viewBound = getBound(viewRect);
          var mainBound = getBound(mainGroup.getBoundingRect());
          var labelBound = getBound(labelGroup.getBoundingRect());
          var mainPosition = mainGroup.position;
          var labelsPosition = labelGroup.position;
          labelsPosition[0] = mainPosition[0] = viewBound[0][0];
          var labelPosOpt = layoutInfo.labelPosOpt;

          if (isNaN(labelPosOpt)) {
            // '+' or '-'
            var mainBoundIdx = labelPosOpt === '+' ? 0 : 1;
            toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
            toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);
          } else {
            var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;
            toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
            labelsPosition[1] = mainPosition[1] + labelPosOpt;
          }

          mainGroup.attr('position', mainPosition);
          labelGroup.attr('position', labelsPosition);
          mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;
          setOrigin(mainGroup);
          setOrigin(labelGroup);

          function setOrigin(targetGroup) {
            var pos = targetGroup.position;
            targetGroup.origin = [viewBound[0][0] - pos[0], viewBound[1][0] - pos[1]];
          }

          function getBound(rect) {
            // [[xmin, xmax], [ymin, ymax]]
            return [[rect.x, rect.x + rect.width], [rect.y, rect.y + rect.height]];
          }

          function toBound(fromPos, from, to, dimIdx, boundIdx) {
            fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];
          }
        },
        _createAxis: function _createAxis(layoutInfo, timelineModel) {
          var data = timelineModel.getData();
          var axisType = timelineModel.get('axisType');
          var scale = axisHelper.createScaleByModel(timelineModel, axisType); // Customize scale. The `tickValue` is `dataIndex`.

          scale.getTicks = function () {
            return data.mapArray(['value'], function (value) {
              return value;
            });
          };

          var dataExtent = data.getDataExtent('value');
          scale.setExtent(dataExtent[0], dataExtent[1]);
          scale.niceTicks();
          var axis = new TimelineAxis('value', scale, layoutInfo.axisExtent, axisType);
          axis.model = timelineModel;
          return axis;
        },
        _createGroup: function _createGroup(name) {
          var newGroup = this['_' + name] = new graphic.Group();
          this.group.add(newGroup);
          return newGroup;
        },
        _renderAxisLine: function _renderAxisLine(layoutInfo, group, axis, timelineModel) {
          var axisExtent = axis.getExtent();

          if (!timelineModel.get('lineStyle.show')) {
            return;
          }

          group.add(new graphic.Line({
            shape: {
              x1: axisExtent[0],
              y1: 0,
              x2: axisExtent[1],
              y2: 0
            },
            style: zrUtil.extend({
              lineCap: 'round'
            }, timelineModel.getModel('lineStyle').getLineStyle()),
            silent: true,
            z2: 1
          }));
        },

        /**
         * @private
         */
        _renderAxisTick: function _renderAxisTick(layoutInfo, group, axis, timelineModel) {
          var data = timelineModel.getData(); // Show all ticks, despite ignoring strategy.

          var ticks = axis.scale.getTicks(); // The value is dataIndex, see the costomized scale.

          each(ticks, function (value) {
            var tickCoord = axis.dataToCoord(value);
            var itemModel = data.getItemModel(value);
            var itemStyleModel = itemModel.getModel('itemStyle');
            var hoverStyleModel = itemModel.getModel('emphasis.itemStyle');
            var symbolOpt = {
              position: [tickCoord, 0],
              onclick: bind(this._changeTimeline, this, value)
            };
            var el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt);
            graphic.setHoverStyle(el, hoverStyleModel.getItemStyle());

            if (itemModel.get('tooltip')) {
              el.dataIndex = value;
              el.dataModel = timelineModel;
            } else {
              el.dataIndex = el.dataModel = null;
            }
          }, this);
        },

        /**
         * @private
         */
        _renderAxisLabel: function _renderAxisLabel(layoutInfo, group, axis, timelineModel) {
          var labelModel = axis.getLabelModel();

          if (!labelModel.get('show')) {
            return;
          }

          var data = timelineModel.getData();
          var labels = axis.getViewLabels();
          each(labels, function (labelItem) {
            // The tickValue is dataIndex, see the costomized scale.
            var dataIndex = labelItem.tickValue;
            var itemModel = data.getItemModel(dataIndex);
            var normalLabelModel = itemModel.getModel('label');
            var hoverLabelModel = itemModel.getModel('emphasis.label');
            var tickCoord = axis.dataToCoord(labelItem.tickValue);
            var textEl = new graphic.Text({
              position: [tickCoord, 0],
              rotation: layoutInfo.labelRotation - layoutInfo.rotation,
              onclick: bind(this._changeTimeline, this, dataIndex),
              silent: false
            });
            graphic.setTextStyle(textEl.style, normalLabelModel, {
              text: labelItem.formattedLabel,
              textAlign: layoutInfo.labelAlign,
              textVerticalAlign: layoutInfo.labelBaseline
            });
            group.add(textEl);
            graphic.setHoverStyle(textEl, graphic.setTextStyle({}, hoverLabelModel));
          }, this);
        },

        /**
         * @private
         */
        _renderControl: function _renderControl(layoutInfo, group, axis, timelineModel) {
          var controlSize = layoutInfo.controlSize;
          var rotation = layoutInfo.rotation;
          var itemStyle = timelineModel.getModel('controlStyle').getItemStyle();
          var hoverStyle = timelineModel.getModel('emphasis.controlStyle').getItemStyle();
          var rect = [0, -controlSize / 2, controlSize, controlSize];
          var playState = timelineModel.getPlayState();
          var inverse = timelineModel.get('inverse', true);
          makeBtn(layoutInfo.nextBtnPosition, 'controlStyle.nextIcon', bind(this._changeTimeline, this, inverse ? '-' : '+'));
          makeBtn(layoutInfo.prevBtnPosition, 'controlStyle.prevIcon', bind(this._changeTimeline, this, inverse ? '+' : '-'));
          makeBtn(layoutInfo.playPosition, 'controlStyle.' + (playState ? 'stopIcon' : 'playIcon'), bind(this._handlePlayClick, this, !playState), true);

          function makeBtn(position, iconPath, onclick, willRotate) {
            if (!position) {
              return;
            }

            var opt = {
              position: position,
              origin: [controlSize / 2, 0],
              rotation: willRotate ? -rotation : 0,
              rectHover: true,
              style: itemStyle,
              onclick: onclick
            };
            var btn = makeIcon(timelineModel, iconPath, rect, opt);
            group.add(btn);
            graphic.setHoverStyle(btn, hoverStyle);
          }
        },
        _renderCurrentPointer: function _renderCurrentPointer(layoutInfo, group, axis, timelineModel) {
          var data = timelineModel.getData();
          var currentIndex = timelineModel.getCurrentIndex();
          var pointerModel = data.getItemModel(currentIndex).getModel('checkpointStyle');
          var me = this;
          var callback = {
            onCreate: function onCreate(pointer) {
              pointer.draggable = true;
              pointer.drift = bind(me._handlePointerDrag, me);
              pointer.ondragend = bind(me._handlePointerDragend, me);
              pointerMoveTo(pointer, currentIndex, axis, timelineModel, true);
            },
            onUpdate: function onUpdate(pointer) {
              pointerMoveTo(pointer, currentIndex, axis, timelineModel);
            }
          }; // Reuse when exists, for animation and drag.

          this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback);
        },
        _handlePlayClick: function _handlePlayClick(nextState) {
          this._clearTimer();

          this.api.dispatchAction({
            type: 'timelinePlayChange',
            playState: nextState,
            from: this.uid
          });
        },
        _handlePointerDrag: function _handlePointerDrag(dx, dy, e) {
          this._clearTimer();

          this._pointerChangeTimeline([e.offsetX, e.offsetY]);
        },
        _handlePointerDragend: function _handlePointerDragend(e) {
          this._pointerChangeTimeline([e.offsetX, e.offsetY], true);
        },
        _pointerChangeTimeline: function _pointerChangeTimeline(mousePos, trigger) {
          var toCoord = this._toAxisCoord(mousePos)[0];

          var axis = this._axis;
          var axisExtent = numberUtil.asc(axis.getExtent().slice());
          toCoord > axisExtent[1] && (toCoord = axisExtent[1]);
          toCoord < axisExtent[0] && (toCoord = axisExtent[0]);
          this._currentPointer.position[0] = toCoord;

          this._currentPointer.dirty();

          var targetDataIndex = this._findNearestTick(toCoord);

          var timelineModel = this.model;

          if (trigger || targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get('realtime')) {
            this._changeTimeline(targetDataIndex);
          }
        },
        _doPlayStop: function _doPlayStop() {
          this._clearTimer();

          if (this.model.getPlayState()) {
            this._timer = setTimeout(bind(handleFrame, this), this.model.get('playInterval'));
          }

          function handleFrame() {
            // Do not cache
            var timelineModel = this.model;

            this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get('rewind', true) ? -1 : 1));
          }
        },
        _toAxisCoord: function _toAxisCoord(vertex) {
          var trans = this._mainGroup.getLocalTransform();

          return graphic.applyTransform(vertex, trans, true);
        },
        _findNearestTick: function _findNearestTick(axisCoord) {
          var data = this.model.getData();
          var dist = Infinity;
          var targetDataIndex;
          var axis = this._axis;
          data.each(['value'], function (value, dataIndex) {
            var coord = axis.dataToCoord(value);
            var d = Math.abs(coord - axisCoord);

            if (d < dist) {
              dist = d;
              targetDataIndex = dataIndex;
            }
          });
          return targetDataIndex;
        },
        _clearTimer: function _clearTimer() {
          if (this._timer) {
            clearTimeout(this._timer);
            this._timer = null;
          }
        },
        _changeTimeline: function _changeTimeline(nextIndex) {
          var currentIndex = this.model.getCurrentIndex();

          if (nextIndex === '+') {
            nextIndex = currentIndex + 1;
          } else if (nextIndex === '-') {
            nextIndex = currentIndex - 1;
          }

          this.api.dispatchAction({
            type: 'timelineChange',
            currentIndex: nextIndex,
            from: this.uid
          });
        }
      });

      function getViewRect(model, api) {
        return layout.getLayoutRect(model.getBoxLayoutParams(), {
          width: api.getWidth(),
          height: api.getHeight()
        }, model.get('padding'));
      }

      function makeIcon(timelineModel, objPath, rect, opts) {
        var style = opts.style;
        var icon = graphic.createIcon(timelineModel.get(objPath), opts || {}, new BoundingRect(rect[0], rect[1], rect[2], rect[3])); // TODO createIcon won't use style in opt.

        if (style) {
          icon.setStyle(style);
        }

        return icon;
      }
      /**
       * Create symbol or update symbol
       * opt: basic position and event handlers
       */


      function giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) {
        var color = itemStyleModel.get('color');

        if (!symbol) {
          var symbolType = hostModel.get('symbol');
          symbol = createSymbol(symbolType, -1, -1, 2, 2, color);
          symbol.setStyle('strokeNoScale', true);
          group.add(symbol);
          callback && callback.onCreate(symbol);
        } else {
          symbol.setColor(color);
          group.add(symbol); // Group may be new, also need to add.

          callback && callback.onUpdate(symbol);
        } // Style


        var itemStyle = itemStyleModel.getItemStyle(['color', 'symbol', 'symbolSize']);
        symbol.setStyle(itemStyle); // Transform and events.

        opt = zrUtil.merge({
          rectHover: true,
          z2: 100
        }, opt, true);
        var symbolSize = hostModel.get('symbolSize');
        symbolSize = symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];
        symbolSize[0] /= 2;
        symbolSize[1] /= 2;
        opt.scale = symbolSize;
        var symbolOffset = hostModel.get('symbolOffset');

        if (symbolOffset) {
          var pos = opt.position = opt.position || [0, 0];
          pos[0] += numberUtil.parsePercent(symbolOffset[0], symbolSize[0]);
          pos[1] += numberUtil.parsePercent(symbolOffset[1], symbolSize[1]);
        }

        var symbolRotate = hostModel.get('symbolRotate');
        opt.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
        symbol.attr(opt); // FIXME
        // (1) When symbol.style.strokeNoScale is true and updateTransform is not performed,
        // getBoundingRect will return wrong result.
        // (This is supposed to be resolved in zrender, but it is a little difficult to
        // leverage performance and auto updateTransform)
        // (2) All of ancesters of symbol do not scale, so we can just updateTransform symbol.

        symbol.updateTransform();
        return symbol;
      }

      function pointerMoveTo(pointer, dataIndex, axis, timelineModel, noAnimation) {
        if (pointer.dragging) {
          return;
        }

        var pointerModel = timelineModel.getModel('checkpointStyle');
        var toCoord = axis.dataToCoord(timelineModel.getData().get(['value'], dataIndex));

        if (noAnimation || !pointerModel.get('animation', true)) {
          pointer.attr({
            position: [toCoord, 0]
          });
        } else {
          pointer.stopAnimation(true);
          pointer.animateTo({
            position: [toCoord, 0]
          }, pointerModel.get('animationDuration', true), pointerModel.get('animationEasing', true));
        }
      }

      module.exports = _default;
      /***/
    },

    /***/
    "OUJF":
    /*!***********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/timeline/timelineAction.js ***!
      \***********************************************************************/

    /*! no static exports found */

    /***/
    function OUJF(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      echarts.registerAction({
        type: 'timelineChange',
        event: 'timelineChanged',
        update: 'prepareAndUpdate'
      }, function (payload, ecModel) {
        var timelineModel = ecModel.getComponent('timeline');

        if (timelineModel && payload.currentIndex != null) {
          timelineModel.setCurrentIndex(payload.currentIndex);

          if (!timelineModel.get('loop', true) && timelineModel.isIndexMax()) {
            timelineModel.setPlayState(false);
          }
        } // Set normalized currentIndex to payload.


        ecModel.resetOption('timeline');
        return zrUtil.defaults({
          currentIndex: timelineModel.option.currentIndex
        }, payload);
      });
      echarts.registerAction({
        type: 'timelinePlayChange',
        event: 'timelinePlayChanged',
        update: 'update'
      }, function (payload, ecModel) {
        var timelineModel = ecModel.getComponent('timeline');

        if (timelineModel && payload.playState != null) {
          timelineModel.setPlayState(payload.playState);
        }
      });
      /***/
    },

    /***/
    "OXB0":
    /*!*****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/heatmap/HeatmapSeries.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function OXB0(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var SeriesModel = __webpack_require__(
      /*! ../../model/Series */
      "T4UG");

      var createListFromArray = __webpack_require__(
      /*! ../helper/createListFromArray */
      "MwEJ");

      var CoordinateSystem = __webpack_require__(
      /*! ../../CoordinateSystem */
      "IDmD");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = SeriesModel.extend({
        type: 'series.heatmap',
        getInitialData: function getInitialData(option, ecModel) {
          return createListFromArray(this.getSource(), this, {
            generateCoord: 'value'
          });
        },
        preventIncremental: function preventIncremental() {
          var coordSysCreator = CoordinateSystem.get(this.get('coordinateSystem'));

          if (coordSysCreator && coordSysCreator.dimensions) {
            return coordSysCreator.dimensions[0] === 'lng' && coordSysCreator.dimensions[1] === 'lat';
          }
        },
        defaultOption: {
          // Cartesian2D or geo
          coordinateSystem: 'cartesian2d',
          zlevel: 0,
          z: 2,
          // Cartesian coordinate system
          // xAxisIndex: 0,
          // yAxisIndex: 0,
          // Geo coordinate system
          geoIndex: 0,
          blurSize: 30,
          pointSize: 20,
          maxOpacity: 1,
          minOpacity: 0
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "OlYY":
    /*!**********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js ***!
      \**********************************************************************/

    /*! no static exports found */

    /***/
    function OlYY(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var env = __webpack_require__(
      /*! zrender/lib/core/env */
      "ItGF");

      var modelUtil = __webpack_require__(
      /*! ../../util/model */
      "4NO4");

      var helper = __webpack_require__(
      /*! ./helper */
      "UOVi");

      var AxisProxy = __webpack_require__(
      /*! ./AxisProxy */
      "zDms");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var each = zrUtil.each;
      var eachAxisDim = helper.eachAxisDim;
      var DataZoomModel = echarts.extendComponentModel({
        type: 'dataZoom',
        dependencies: ['xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series'],

        /**
         * @protected
         */
        defaultOption: {
          zlevel: 0,
          z: 4,
          // Higher than normal component (z: 2).
          orient: null,
          // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.
          xAxisIndex: null,
          // Default the first horizontal category axis.
          yAxisIndex: null,
          // Default the first vertical category axis.
          filterMode: 'filter',
          // Possible values: 'filter' or 'empty' or 'weakFilter'.
          // 'filter': data items which are out of window will be removed. This option is
          //          applicable when filtering outliers. For each data item, it will be
          //          filtered if one of the relevant dimensions is out of the window.
          // 'weakFilter': data items which are out of window will be removed. This option
          //          is applicable when filtering outliers. For each data item, it will be
          //          filtered only if all  of the relevant dimensions are out of the same
          //          side of the window.
          // 'empty': data items which are out of window will be set to empty.
          //          This option is applicable when user should not neglect
          //          that there are some data items out of window.
          // 'none': Do not filter.
          // Taking line chart as an example, line will be broken in
          // the filtered points when filterModel is set to 'empty', but
          // be connected when set to 'filter'.
          throttle: null,
          // Dispatch action by the fixed rate, avoid frequency.
          // default 100. Do not throttle when use null/undefined.
          // If animation === true and animationDurationUpdate > 0,
          // default value is 100, otherwise 20.
          start: 0,
          // Start percent. 0 ~ 100
          end: 100,
          // End percent. 0 ~ 100
          startValue: null,
          // Start value. If startValue specified, start is ignored.
          endValue: null,
          // End value. If endValue specified, end is ignored.
          minSpan: null,
          // 0 ~ 100
          maxSpan: null,
          // 0 ~ 100
          minValueSpan: null,
          // The range of dataZoom can not be smaller than that.
          maxValueSpan: null,
          // The range of dataZoom can not be larger than that.
          rangeMode: null // Array, can be 'value' or 'percent'.

        },

        /**
         * @override
         */
        init: function init(option, parentModel, ecModel) {
          /**
           * key like x_0, y_1
           * @private
           * @type {Object}
           */
          this._dataIntervalByAxis = {};
          /**
           * @private
           */

          this._dataInfo = {};
          /**
           * key like x_0, y_1
           * @private
           */

          this._axisProxies = {};
          /**
           * @readOnly
           */

          this.textStyleModel;
          /**
           * @private
           */

          this._autoThrottle = true;
          /**
           * It is `[rangeModeForMin, rangeModeForMax]`.
           * The optional values for `rangeMode`:
           * + `'value'` mode: the axis extent will always be determined by
           *     `dataZoom.startValue` and `dataZoom.endValue`, despite
           *     how data like and how `axis.min` and `axis.max` are.
           * + `'percent'` mode: `100` represents 100% of the `[dMin, dMax]`,
           *     where `dMin` is `axis.min` if `axis.min` specified, otherwise `data.extent[0]`,
           *     and `dMax` is `axis.max` if `axis.max` specified, otherwise `data.extent[1]`.
           *     Axis extent will be determined by the result of the percent of `[dMin, dMax]`.
           *
           * For example, when users are using dynamic data (update data periodically via `setOption`),
           * if in `'value`' mode, the window will be kept in a fixed value range despite how
           * data are appended, while if in `'percent'` mode, whe window range will be changed alone with
           * the appended data (suppose `axis.min` and `axis.max` are not specified).
           *
           * @private
           */

          this._rangePropMode = ['percent', 'percent'];
          var inputRawOption = retrieveRawOption(option);
          /**
           * Suppose a "main process" start at the point that model prepared (that is,
           * model initialized or merged or method called in `action`).
           * We should keep the `main process` idempotent, that is, given a set of values
           * on `option`, we get the same result.
           *
           * But sometimes, values on `option` will be updated for providing users
           * a "final calculated value" (`dataZoomProcessor` will do that). Those value
           * should not be the base/input of the `main process`.
           *
           * So in that case we should save and keep the input of the `main process`
           * separately, called `settledOption`.
           *
           * For example, consider the case:
           * (Step_1) brush zoom the grid by `toolbox.dataZoom`,
           *     where the original input `option.startValue`, `option.endValue` are earsed by
           *     calculated value.
           * (Step)2) click the legend to hide and show a series,
           *     where the new range is calculated by the earsed `startValue` and `endValue`,
           *     which brings incorrect result.
           *
           * @readOnly
           */

          this.settledOption = inputRawOption;
          this.mergeDefaultAndTheme(option, ecModel);
          this.doInit(inputRawOption);
        },

        /**
         * @override
         */
        mergeOption: function mergeOption(newOption) {
          var inputRawOption = retrieveRawOption(newOption); //FIX #2591

          zrUtil.merge(this.option, newOption, true);
          zrUtil.merge(this.settledOption, inputRawOption, true);
          this.doInit(inputRawOption);
        },

        /**
         * @protected
         */
        doInit: function doInit(inputRawOption) {
          var thisOption = this.option; // Disable realtime view update if canvas is not supported.

          if (!env.canvasSupported) {
            thisOption.realtime = false;
          }

          this._setDefaultThrottle(inputRawOption);

          updateRangeUse(this, inputRawOption);
          var settledOption = this.settledOption;
          each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {
            // start/end has higher priority over startValue/endValue if they
            // both set, but we should make chart.setOption({endValue: 1000})
            // effective, rather than chart.setOption({endValue: 1000, end: null}).
            if (this._rangePropMode[index] === 'value') {
              thisOption[names[0]] = settledOption[names[0]] = null;
            } // Otherwise do nothing and use the merge result.

          }, this);
          this.textStyleModel = this.getModel('textStyle');

          this._resetTarget();

          this._giveAxisProxies();
        },

        /**
         * @private
         */
        _giveAxisProxies: function _giveAxisProxies() {
          var axisProxies = this._axisProxies;
          this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {
            var axisModel = this.dependentModels[dimNames.axis][axisIndex]; // If exists, share axisProxy with other dataZoomModels.

            var axisProxy = axisModel.__dzAxisProxy || ( // Use the first dataZoomModel as the main model of axisProxy.
            axisModel.__dzAxisProxy = new AxisProxy(dimNames.name, axisIndex, this, ecModel)); // FIXME
            // dispose __dzAxisProxy

            axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;
          }, this);
        },

        /**
         * @private
         */
        _resetTarget: function _resetTarget() {
          var thisOption = this.option;

          var autoMode = this._judgeAutoMode();

          eachAxisDim(function (dimNames) {
            var axisIndexName = dimNames.axisIndex;
            thisOption[axisIndexName] = modelUtil.normalizeToArray(thisOption[axisIndexName]);
          }, this);

          if (autoMode === 'axisIndex') {
            this._autoSetAxisIndex();
          } else if (autoMode === 'orient') {
            this._autoSetOrient();
          }
        },

        /**
         * @private
         */
        _judgeAutoMode: function _judgeAutoMode() {
          // Auto set only works for setOption at the first time.
          // The following is user's reponsibility. So using merged
          // option is OK.
          var thisOption = this.option;
          var hasIndexSpecified = false;
          eachAxisDim(function (dimNames) {
            // When user set axisIndex as a empty array, we think that user specify axisIndex
            // but do not want use auto mode. Because empty array may be encountered when
            // some error occured.
            if (thisOption[dimNames.axisIndex] != null) {
              hasIndexSpecified = true;
            }
          }, this);
          var orient = thisOption.orient;

          if (orient == null && hasIndexSpecified) {
            return 'orient';
          } else if (!hasIndexSpecified) {
            if (orient == null) {
              thisOption.orient = 'horizontal';
            }

            return 'axisIndex';
          }
        },

        /**
         * @private
         */
        _autoSetAxisIndex: function _autoSetAxisIndex() {
          var autoAxisIndex = true;
          var orient = this.get('orient', true);
          var thisOption = this.option;
          var dependentModels = this.dependentModels;

          if (autoAxisIndex) {
            // Find axis that parallel to dataZoom as default.
            var dimName = orient === 'vertical' ? 'y' : 'x';

            if (dependentModels[dimName + 'Axis'].length) {
              thisOption[dimName + 'AxisIndex'] = [0];
              autoAxisIndex = false;
            } else {
              each(dependentModels.singleAxis, function (singleAxisModel) {
                if (autoAxisIndex && singleAxisModel.get('orient', true) === orient) {
                  thisOption.singleAxisIndex = [singleAxisModel.componentIndex];
                  autoAxisIndex = false;
                }
              });
            }
          }

          if (autoAxisIndex) {
            // Find the first category axis as default. (consider polar)
            eachAxisDim(function (dimNames) {
              if (!autoAxisIndex) {
                return;
              }

              var axisIndices = [];
              var axisModels = this.dependentModels[dimNames.axis];

              if (axisModels.length && !axisIndices.length) {
                for (var i = 0, len = axisModels.length; i < len; i++) {
                  if (axisModels[i].get('type') === 'category') {
                    axisIndices.push(i);
                  }
                }
              }

              thisOption[dimNames.axisIndex] = axisIndices;

              if (axisIndices.length) {
                autoAxisIndex = false;
              }
            }, this);
          }

          if (autoAxisIndex) {
            // FIXME
            // ec2xAxisIndexyAxisIndexscatterdataZoom
            // Grid.js#getScaleByOptiontimelogaxis type
            // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,
            // dataZoom component auto adopts series that reference to
            // both xAxis and yAxis which type is 'value'.
            this.ecModel.eachSeries(function (seriesModel) {
              if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {
                eachAxisDim(function (dimNames) {
                  var axisIndices = thisOption[dimNames.axisIndex];
                  var axisIndex = seriesModel.get(dimNames.axisIndex);
                  var axisId = seriesModel.get(dimNames.axisId);
                  var axisModel = seriesModel.ecModel.queryComponents({
                    mainType: dimNames.axis,
                    index: axisIndex,
                    id: axisId
                  })[0];
                  axisIndex = axisModel.componentIndex;

                  if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {
                    axisIndices.push(axisIndex);
                  }
                });
              }
            }, this);
          }
        },

        /**
         * @private
         */
        _autoSetOrient: function _autoSetOrient() {
          var dim; // Find the first axis

          this.eachTargetAxis(function (dimNames) {
            !dim && (dim = dimNames.name);
          }, this);
          this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';
        },

        /**
         * @private
         */
        _isSeriesHasAllAxesTypeOf: function _isSeriesHasAllAxesTypeOf(seriesModel, axisType) {
          // FIXME
          // seriesxAxisIndexyAxisIndex
          // series.type === scatter
          var is = true;
          eachAxisDim(function (dimNames) {
            var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);
            var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];

            if (!axisModel || axisModel.get('type') !== axisType) {
              is = false;
            }
          }, this);
          return is;
        },

        /**
         * @private
         */
        _setDefaultThrottle: function _setDefaultThrottle(inputRawOption) {
          // When first time user set throttle, auto throttle ends.
          if (inputRawOption.hasOwnProperty('throttle')) {
            this._autoThrottle = false;
          }

          if (this._autoThrottle) {
            var globalOption = this.ecModel.option;
            this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;
          }
        },

        /**
         * @public
         */
        getFirstTargetAxisModel: function getFirstTargetAxisModel() {
          var firstAxisModel;
          eachAxisDim(function (dimNames) {
            if (firstAxisModel == null) {
              var indices = this.get(dimNames.axisIndex);

              if (indices.length) {
                firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];
              }
            }
          }, this);
          return firstAxisModel;
        },

        /**
         * @public
         * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel
         */
        eachTargetAxis: function eachTargetAxis(callback, context) {
          var ecModel = this.ecModel;
          eachAxisDim(function (dimNames) {
            each(this.get(dimNames.axisIndex), function (axisIndex) {
              callback.call(context, dimNames, axisIndex, this, ecModel);
            }, this);
          }, this);
        },

        /**
         * @param {string} dimName
         * @param {number} axisIndex
         * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.
         */
        getAxisProxy: function getAxisProxy(dimName, axisIndex) {
          return this._axisProxies[dimName + '_' + axisIndex];
        },

        /**
         * @param {string} dimName
         * @param {number} axisIndex
         * @return {module:echarts/model/Model} If not found, return null/undefined.
         */
        getAxisModel: function getAxisModel(dimName, axisIndex) {
          var axisProxy = this.getAxisProxy(dimName, axisIndex);
          return axisProxy && axisProxy.getAxisModel();
        },

        /**
         * If not specified, set to undefined.
         *
         * @public
         * @param {Object} opt
         * @param {number} [opt.start]
         * @param {number} [opt.end]
         * @param {number} [opt.startValue]
         * @param {number} [opt.endValue]
         */
        setRawRange: function setRawRange(opt) {
          var thisOption = this.option;
          var settledOption = this.settledOption;
          each([['start', 'startValue'], ['end', 'endValue']], function (names) {
            // Consider the pair <start, startValue>:
            // If one has value and the other one is `null/undefined`, we both set them
            // to `settledOption`. This strategy enables the feature to clear the original
            // value in `settledOption` to `null/undefined`.
            // But if both of them are `null/undefined`, we do not set them to `settledOption`
            // and keep `settledOption` with the original value. This strategy enables users to
            // only set <end or endValue> but not set <start or startValue> when calling
            // `dispatchAction`.
            // The pair <end, endValue> is treated in the same way.
            if (opt[names[0]] != null || opt[names[1]] != null) {
              thisOption[names[0]] = settledOption[names[0]] = opt[names[0]];
              thisOption[names[1]] = settledOption[names[1]] = opt[names[1]];
            }
          }, this);
          updateRangeUse(this, opt);
        },

        /**
         * @public
         * @param {Object} opt
         * @param {number} [opt.start]
         * @param {number} [opt.end]
         * @param {number} [opt.startValue]
         * @param {number} [opt.endValue]
         */
        setCalculatedRange: function setCalculatedRange(opt) {
          var option = this.option;
          each(['start', 'startValue', 'end', 'endValue'], function (name) {
            option[name] = opt[name];
          });
        },

        /**
         * @public
         * @return {Array.<number>} [startPercent, endPercent]
         */
        getPercentRange: function getPercentRange() {
          var axisProxy = this.findRepresentativeAxisProxy();

          if (axisProxy) {
            return axisProxy.getDataPercentWindow();
          }
        },

        /**
         * @public
         * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);
         *
         * @param {string} [axisDimName]
         * @param {number} [axisIndex]
         * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.
         */
        getValueRange: function getValueRange(axisDimName, axisIndex) {
          if (axisDimName == null && axisIndex == null) {
            var axisProxy = this.findRepresentativeAxisProxy();

            if (axisProxy) {
              return axisProxy.getDataValueWindow();
            }
          } else {
            return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();
          }
        },

        /**
         * @public
         * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy
         *      corresponding to the axisModel
         * @return {module:echarts/component/dataZoom/AxisProxy}
         */
        findRepresentativeAxisProxy: function findRepresentativeAxisProxy(axisModel) {
          if (axisModel) {
            return axisModel.__dzAxisProxy;
          } // Find the first hosted axisProxy


          var axisProxies = this._axisProxies;

          for (var key in axisProxies) {
            if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {
              return axisProxies[key];
            }
          } // If no hosted axis find not hosted axisProxy.
          // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,
          // and the option.start or option.end settings are different. The percentRange
          // should follow axisProxy.
          // (We encounter this problem in toolbox data zoom.)


          for (var key in axisProxies) {
            if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {
              return axisProxies[key];
            }
          }
        },

        /**
         * @return {Array.<string>}
         */
        getRangePropMode: function getRangePropMode() {
          return this._rangePropMode.slice();
        }
      });
      /**
       * Retrieve the those raw params from option, which will be cached separately.
       * becasue they will be overwritten by normalized/calculated values in the main
       * process.
       */

      function retrieveRawOption(option) {
        var ret = {};
        each(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {
          option.hasOwnProperty(name) && (ret[name] = option[name]);
        });
        return ret;
      }

      function updateRangeUse(dataZoomModel, inputRawOption) {
        var rangePropMode = dataZoomModel._rangePropMode;
        var rangeModeInOption = dataZoomModel.get('rangeMode');
        each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {
          var percentSpecified = inputRawOption[names[0]] != null;
          var valueSpecified = inputRawOption[names[1]] != null;

          if (percentSpecified && !valueSpecified) {
            rangePropMode[index] = 'percent';
          } else if (!percentSpecified && valueSpecified) {
            rangePropMode[index] = 'value';
          } else if (rangeModeInOption) {
            rangePropMode[index] = rangeModeInOption[index];
          } else if (percentSpecified) {
            // percentSpecified && valueSpecified
            rangePropMode[index] = 'percent';
          } // else remain its original setting.

        });
      }

      var _default = DataZoomModel;
      module.exports = _default;
      /***/
    },

    /***/
    "P47w":
    /*!*************************************************!*\
      !*** ./node_modules/zrender/lib/svg/graphic.js ***!
      \*************************************************/

    /*! no static exports found */

    /***/
    function P47w(module, exports, __webpack_require__) {
      var _core = __webpack_require__(
      /*! ./core */
      "hydK");

      var createElement = _core.createElement;

      var PathProxy = __webpack_require__(
      /*! ../core/PathProxy */
      "IMiH");

      var BoundingRect = __webpack_require__(
      /*! ../core/BoundingRect */
      "mFDi");

      var matrix = __webpack_require__(
      /*! ../core/matrix */
      "Fofx");

      var textContain = __webpack_require__(
      /*! ../contain/text */
      "6GrX");

      var textHelper = __webpack_require__(
      /*! ../graphic/helper/text */
      "pzxd");

      var Text = __webpack_require__(
      /*! ../graphic/Text */
      "dqUG"); // TODO
      // 1. shadow
      // 2. Image: sx, sy, sw, sh


      var CMD = PathProxy.CMD;
      var arrayJoin = Array.prototype.join;
      var NONE = 'none';
      var mathRound = Math.round;
      var mathSin = Math.sin;
      var mathCos = Math.cos;
      var PI = Math.PI;
      var PI2 = Math.PI * 2;
      var degree = 180 / PI;
      var EPSILON = 1e-4;

      function round4(val) {
        return mathRound(val * 1e4) / 1e4;
      }

      function isAroundZero(val) {
        return val < EPSILON && val > -EPSILON;
      }

      function pathHasFill(style, isText) {
        var fill = isText ? style.textFill : style.fill;
        return fill != null && fill !== NONE;
      }

      function pathHasStroke(style, isText) {
        var stroke = isText ? style.textStroke : style.stroke;
        return stroke != null && stroke !== NONE;
      }

      function setTransform(svgEl, m) {
        if (m) {
          attr(svgEl, 'transform', 'matrix(' + arrayJoin.call(m, ',') + ')');
        }
      }

      function attr(el, key, val) {
        if (!val || val.type !== 'linear' && val.type !== 'radial') {
          // Don't set attribute for gradient, since it need new dom nodes
          el.setAttribute(key, val);
        }
      }

      function attrXLink(el, key, val) {
        el.setAttributeNS('http://www.w3.org/1999/xlink', key, val);
      }

      function bindStyle(svgEl, style, isText, el) {
        if (pathHasFill(style, isText)) {
          var fill = isText ? style.textFill : style.fill;
          fill = fill === 'transparent' ? NONE : fill;
          attr(svgEl, 'fill', fill);
          attr(svgEl, 'fill-opacity', style.fillOpacity != null ? style.fillOpacity * style.opacity : style.opacity);
        } else {
          attr(svgEl, 'fill', NONE);
        }

        if (pathHasStroke(style, isText)) {
          var stroke = isText ? style.textStroke : style.stroke;
          stroke = stroke === 'transparent' ? NONE : stroke;
          attr(svgEl, 'stroke', stroke);
          var strokeWidth = isText ? style.textStrokeWidth : style.lineWidth;
          var strokeScale = !isText && style.strokeNoScale ? el.getLineScale() : 1;
          attr(svgEl, 'stroke-width', strokeWidth / strokeScale); // stroke then fill for text; fill then stroke for others

          attr(svgEl, 'paint-order', isText ? 'stroke' : 'fill');
          attr(svgEl, 'stroke-opacity', style.strokeOpacity != null ? style.strokeOpacity : style.opacity);
          var lineDash = style.lineDash;

          if (lineDash) {
            attr(svgEl, 'stroke-dasharray', style.lineDash.join(','));
            attr(svgEl, 'stroke-dashoffset', mathRound(style.lineDashOffset || 0));
          } else {
            attr(svgEl, 'stroke-dasharray', '');
          } // PENDING


          style.lineCap && attr(svgEl, 'stroke-linecap', style.lineCap);
          style.lineJoin && attr(svgEl, 'stroke-linejoin', style.lineJoin);
          style.miterLimit && attr(svgEl, 'stroke-miterlimit', style.miterLimit);
        } else {
          attr(svgEl, 'stroke', NONE);
        }
      }
      /***************************************************
       * PATH
       **************************************************/


      function pathDataToString(path) {
        var str = [];
        var data = path.data;
        var dataLength = path.len();

        for (var i = 0; i < dataLength;) {
          var cmd = data[i++];
          var cmdStr = '';
          var nData = 0;

          switch (cmd) {
            case CMD.M:
              cmdStr = 'M';
              nData = 2;
              break;

            case CMD.L:
              cmdStr = 'L';
              nData = 2;
              break;

            case CMD.Q:
              cmdStr = 'Q';
              nData = 4;
              break;

            case CMD.C:
              cmdStr = 'C';
              nData = 6;
              break;

            case CMD.A:
              var cx = data[i++];
              var cy = data[i++];
              var rx = data[i++];
              var ry = data[i++];
              var theta = data[i++];
              var dTheta = data[i++];
              var psi = data[i++];
              var clockwise = data[i++];
              var dThetaPositive = Math.abs(dTheta);
              var isCircle = isAroundZero(dThetaPositive - PI2) || (clockwise ? dTheta >= PI2 : -dTheta >= PI2); // Mapping to 0~2PI

              var unifiedTheta = dTheta > 0 ? dTheta % PI2 : dTheta % PI2 + PI2;
              var large = false;

              if (isCircle) {
                large = true;
              } else if (isAroundZero(dThetaPositive)) {
                large = false;
              } else {
                large = unifiedTheta >= PI === !!clockwise;
              }

              var x0 = round4(cx + rx * mathCos(theta));
              var y0 = round4(cy + ry * mathSin(theta)); // It will not draw if start point and end point are exactly the same
              // We need to shift the end point with a small value
              // FIXME A better way to draw circle ?

              if (isCircle) {
                if (clockwise) {
                  dTheta = PI2 - 1e-4;
                } else {
                  dTheta = -PI2 + 1e-4;
                }

                large = true;

                if (i === 9) {
                  // Move to (x0, y0) only when CMD.A comes at the
                  // first position of a shape.
                  // For instance, when drawing a ring, CMD.A comes
                  // after CMD.M, so it's unnecessary to move to
                  // (x0, y0).
                  str.push('M', x0, y0);
                }
              }

              var x = round4(cx + rx * mathCos(theta + dTheta));
              var y = round4(cy + ry * mathSin(theta + dTheta)); // FIXME Ellipse

              str.push('A', round4(rx), round4(ry), mathRound(psi * degree), +large, +clockwise, x, y);
              break;

            case CMD.Z:
              cmdStr = 'Z';
              break;

            case CMD.R:
              var x = round4(data[i++]);
              var y = round4(data[i++]);
              var w = round4(data[i++]);
              var h = round4(data[i++]);
              str.push('M', x, y, 'L', x + w, y, 'L', x + w, y + h, 'L', x, y + h, 'L', x, y);
              break;
          }

          cmdStr && str.push(cmdStr);

          for (var j = 0; j < nData; j++) {
            // PENDING With scale
            str.push(round4(data[i++]));
          }
        }

        return str.join(' ');
      }

      var svgPath = {};

      svgPath.brush = function (el) {
        var style = el.style;
        var svgEl = el.__svgEl;

        if (!svgEl) {
          svgEl = createElement('path');
          el.__svgEl = svgEl;
        }

        if (!el.path) {
          el.createPathProxy();
        }

        var path = el.path;

        if (el.__dirtyPath) {
          path.beginPath();
          path.subPixelOptimize = false;
          el.buildPath(path, el.shape);
          el.__dirtyPath = false;
          var pathStr = pathDataToString(path);

          if (pathStr.indexOf('NaN') < 0) {
            // Ignore illegal path, which may happen such in out-of-range
            // data in Calendar series.
            attr(svgEl, 'd', pathStr);
          }
        }

        bindStyle(svgEl, style, false, el);
        setTransform(svgEl, el.transform);

        if (style.text != null) {
          svgTextDrawRectText(el, el.getBoundingRect());
        } else {
          removeOldTextNode(el);
        }
      };
      /***************************************************
       * IMAGE
       **************************************************/


      var svgImage = {};

      svgImage.brush = function (el) {
        var style = el.style;
        var image = style.image;

        if (image instanceof HTMLImageElement) {
          var src = image.src;
          image = src;
        }

        if (!image) {
          return;
        }

        var x = style.x || 0;
        var y = style.y || 0;
        var dw = style.width;
        var dh = style.height;
        var svgEl = el.__svgEl;

        if (!svgEl) {
          svgEl = createElement('image');
          el.__svgEl = svgEl;
        }

        if (image !== el.__imageSrc) {
          attrXLink(svgEl, 'href', image); // Caching image src

          el.__imageSrc = image;
        }

        attr(svgEl, 'width', dw);
        attr(svgEl, 'height', dh);
        attr(svgEl, 'x', x);
        attr(svgEl, 'y', y);
        setTransform(svgEl, el.transform);

        if (style.text != null) {
          svgTextDrawRectText(el, el.getBoundingRect());
        } else {
          removeOldTextNode(el);
        }
      };
      /***************************************************
       * TEXT
       **************************************************/


      var svgText = {};

      var _tmpTextHostRect = new BoundingRect();

      var _tmpTextBoxPos = {};
      var _tmpTextTransform = [];
      var TEXT_ALIGN_TO_ANCHRO = {
        left: 'start',
        right: 'end',
        center: 'middle',
        middle: 'middle'
      };
      /**
       * @param {module:zrender/Element} el
       * @param {Object|boolean} [hostRect] {x, y, width, height}
       *        If set false, rect text is not used.
       */

      var svgTextDrawRectText = function svgTextDrawRectText(el, hostRect) {
        var style = el.style;
        var elTransform = el.transform;
        var needTransformTextByHostEl = el instanceof Text || style.transformText;
        el.__dirty && textHelper.normalizeTextStyle(style, true);
        var text = style.text; // Convert to string

        text != null && (text += '');

        if (!textHelper.needDrawText(text, style)) {
          return;
        } // render empty text for svg if no text but need draw text.


        text == null && (text = ''); // Follow the setting in the canvas renderer, if not transform the
        // text, transform the hostRect, by which the text is located.

        if (!needTransformTextByHostEl && elTransform) {
          _tmpTextHostRect.copy(hostRect);

          _tmpTextHostRect.applyTransform(elTransform);

          hostRect = _tmpTextHostRect;
        }

        var textSvgEl = el.__textSvgEl;

        if (!textSvgEl) {
          textSvgEl = createElement('text');
          el.__textSvgEl = textSvgEl;
        } // style.font has been normalized by `normalizeTextStyle`.


        var textSvgElStyle = textSvgEl.style;
        var font = style.font || textContain.DEFAULT_FONT;
        var computedFont = textSvgEl.__computedFont;

        if (font !== textSvgEl.__styleFont) {
          textSvgElStyle.font = textSvgEl.__styleFont = font; // The computedFont might not be the orginal font if it is illegal font.

          computedFont = textSvgEl.__computedFont = textSvgElStyle.font;
        }

        var textPadding = style.textPadding;
        var textLineHeight = style.textLineHeight;
        var contentBlock = el.__textCotentBlock;

        if (!contentBlock || el.__dirtyText) {
          contentBlock = el.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);
        }

        var outerHeight = contentBlock.outerHeight;
        var lineHeight = contentBlock.lineHeight;
        textHelper.getBoxPosition(_tmpTextBoxPos, el, style, hostRect);
        var baseX = _tmpTextBoxPos.baseX;
        var baseY = _tmpTextBoxPos.baseY;
        var textAlign = _tmpTextBoxPos.textAlign || 'left';
        var textVerticalAlign = _tmpTextBoxPos.textVerticalAlign;
        setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY);
        var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
        var textX = baseX;
        var textY = boxY; // TODO needDrawBg

        if (textPadding) {
          textX = getTextXForPadding(baseX, textAlign, textPadding);
          textY += textPadding[0];
        } // `textBaseline` is set as 'middle'.


        textY += lineHeight / 2;
        bindStyle(textSvgEl, style, true, el); // FIXME
        // Add a <style> to reset all of the text font as inherit?
        // otherwise the outer <style> may set the unexpected style.
        // Font may affect position of each tspan elements

        var canCacheByTextString = contentBlock.canCacheByTextString;
        var tspanList = el.__tspanList || (el.__tspanList = []);
        var tspanOriginLen = tspanList.length; // Optimize for most cases, just compare text string to determine change.

        if (canCacheByTextString && el.__canCacheByTextString && el.__text === text) {
          if (el.__dirtyText && tspanOriginLen) {
            for (var idx = 0; idx < tspanOriginLen; ++idx) {
              updateTextLocation(tspanList[idx], textAlign, textX, textY + idx * lineHeight);
            }
          }
        } else {
          el.__text = text;
          el.__canCacheByTextString = canCacheByTextString;
          var textLines = contentBlock.lines;
          var nTextLines = textLines.length;
          var idx = 0;

          for (; idx < nTextLines; idx++) {
            // Using cached tspan elements
            var tspan = tspanList[idx];
            var singleLineText = textLines[idx];

            if (!tspan) {
              tspan = tspanList[idx] = createElement('tspan');
              textSvgEl.appendChild(tspan);
              tspan.appendChild(document.createTextNode(singleLineText));
            } else if (tspan.__zrText !== singleLineText) {
              tspan.innerHTML = '';
              tspan.appendChild(document.createTextNode(singleLineText));
            }

            updateTextLocation(tspan, textAlign, textX, textY + idx * lineHeight);
          } // Remove unused tspan elements


          if (tspanOriginLen > nTextLines) {
            for (; idx < tspanOriginLen; idx++) {
              textSvgEl.removeChild(tspanList[idx]);
            }

            tspanList.length = nTextLines;
          }
        }
      };

      function setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY) {
        matrix.identity(_tmpTextTransform);

        if (needTransformTextByHostEl && elTransform) {
          matrix.copy(_tmpTextTransform, elTransform);
        } // textRotation only apply in RectText.


        var textRotation = style.textRotation;

        if (hostRect && textRotation) {
          var origin = style.textOrigin;

          if (origin === 'center') {
            baseX = hostRect.width / 2 + hostRect.x;
            baseY = hostRect.height / 2 + hostRect.y;
          } else if (origin) {
            baseX = origin[0] + hostRect.x;
            baseY = origin[1] + hostRect.y;
          }

          _tmpTextTransform[4] -= baseX;
          _tmpTextTransform[5] -= baseY; // Positive: anticlockwise

          matrix.rotate(_tmpTextTransform, _tmpTextTransform, textRotation);
          _tmpTextTransform[4] += baseX;
          _tmpTextTransform[5] += baseY;
        } // See the definition in `Style.js#textOrigin`, the default
        // origin is from the result of `getBoxPosition`.


        setTransform(textSvgEl, _tmpTextTransform);
      } // FIXME merge the same code with `helper/text.js#getTextXForPadding`;


      function getTextXForPadding(x, textAlign, textPadding) {
        return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
      }

      function updateTextLocation(tspan, textAlign, x, y) {
        // Consider different font display differently in vertial align, we always
        // set vertialAlign as 'middle', and use 'y' to locate text vertically.
        attr(tspan, 'dominant-baseline', 'middle');
        attr(tspan, 'text-anchor', TEXT_ALIGN_TO_ANCHRO[textAlign]);
        attr(tspan, 'x', x);
        attr(tspan, 'y', y);
      }

      function removeOldTextNode(el) {
        if (el && el.__textSvgEl) {
          // textSvgEl may has no parentNode if el has been removed temporary.
          if (el.__textSvgEl.parentNode) {
            el.__textSvgEl.parentNode.removeChild(el.__textSvgEl);
          }

          el.__textSvgEl = null;
          el.__tspanList = [];
          el.__text = null;
        }
      }

      svgText.drawRectText = svgTextDrawRectText;

      svgText.brush = function (el) {
        var style = el.style;

        if (style.text != null) {
          svgTextDrawRectText(el, false);
        } else {
          removeOldTextNode(el);
        }
      };

      exports.path = svgPath;
      exports.image = svgImage;
      exports.text = svgText;
      /***/
    },

    /***/
    "PNag":
    /*!************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/visualMap/ContinuousView.js ***!
      \************************************************************************/

    /*! no static exports found */

    /***/
    function PNag(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var LinearGradient = __webpack_require__(
      /*! zrender/lib/graphic/LinearGradient */
      "SKnc");

      var eventTool = __webpack_require__(
      /*! zrender/lib/core/event */
      "YH21");

      var VisualMapView = __webpack_require__(
      /*! ./VisualMapView */
      "crZl");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var numberUtil = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var sliderMove = __webpack_require__(
      /*! ../helper/sliderMove */
      "72pK");

      var helper = __webpack_require__(
      /*! ./helper */
      "y7Aq");

      var modelUtil = __webpack_require__(
      /*! ../../util/model */
      "4NO4");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var linearMap = numberUtil.linearMap;
      var each = zrUtil.each;
      var mathMin = Math.min;
      var mathMax = Math.max; // Arbitrary value

      var HOVER_LINK_SIZE = 12;
      var HOVER_LINK_OUT = 6; // Notice:
      // Any "interval" should be by the order of [low, high].
      // "handle0" (handleIndex === 0) maps to
      // low data value: this._dataInterval[0] and has low coord.
      // "handle1" (handleIndex === 1) maps to
      // high data value: this._dataInterval[1] and has high coord.
      // The logic of transform is implemented in this._createBarGroup.

      var ContinuousView = VisualMapView.extend({
        type: 'visualMap.continuous',

        /**
         * @override
         */
        init: function init() {
          ContinuousView.superApply(this, 'init', arguments);
          /**
           * @private
           */

          this._shapes = {};
          /**
           * @private
           */

          this._dataInterval = [];
          /**
           * @private
           */

          this._handleEnds = [];
          /**
           * @private
           */

          this._orient;
          /**
           * @private
           */

          this._useHandle;
          /**
           * @private
           */

          this._hoverLinkDataIndices = [];
          /**
           * @private
           */

          this._dragging;
          /**
           * @private
           */

          this._hovering;
        },

        /**
         * @protected
         * @override
         */
        doRender: function doRender(visualMapModel, ecModel, api, payload) {
          if (!payload || payload.type !== 'selectDataRange' || payload.from !== this.uid) {
            this._buildView();
          }
        },

        /**
         * @private
         */
        _buildView: function _buildView() {
          this.group.removeAll();
          var visualMapModel = this.visualMapModel;
          var thisGroup = this.group;
          this._orient = visualMapModel.get('orient');
          this._useHandle = visualMapModel.get('calculable');

          this._resetInterval();

          this._renderBar(thisGroup);

          var dataRangeText = visualMapModel.get('text');

          this._renderEndsText(thisGroup, dataRangeText, 0);

          this._renderEndsText(thisGroup, dataRangeText, 1); // Do this for background size calculation.


          this._updateView(true); // After updating view, inner shapes is built completely,
          // and then background can be rendered.


          this.renderBackground(thisGroup); // Real update view

          this._updateView();

          this._enableHoverLinkToSeries();

          this._enableHoverLinkFromSeries();

          this.positionGroup(thisGroup);
        },

        /**
         * @private
         */
        _renderEndsText: function _renderEndsText(group, dataRangeText, endsIndex) {
          if (!dataRangeText) {
            return;
          } // Compatible with ec2, text[0] map to high value, text[1] map low value.


          var text = dataRangeText[1 - endsIndex];
          text = text != null ? text + '' : '';
          var visualMapModel = this.visualMapModel;
          var textGap = visualMapModel.get('textGap');
          var itemSize = visualMapModel.itemSize;
          var barGroup = this._shapes.barGroup;

          var position = this._applyTransform([itemSize[0] / 2, endsIndex === 0 ? -textGap : itemSize[1] + textGap], barGroup);

          var align = this._applyTransform(endsIndex === 0 ? 'bottom' : 'top', barGroup);

          var orient = this._orient;
          var textStyleModel = this.visualMapModel.textStyleModel;
          this.group.add(new graphic.Text({
            style: {
              x: position[0],
              y: position[1],
              textVerticalAlign: orient === 'horizontal' ? 'middle' : align,
              textAlign: orient === 'horizontal' ? align : 'center',
              text: text,
              textFont: textStyleModel.getFont(),
              textFill: textStyleModel.getTextColor()
            }
          }));
        },

        /**
         * @private
         */
        _renderBar: function _renderBar(targetGroup) {
          var visualMapModel = this.visualMapModel;
          var shapes = this._shapes;
          var itemSize = visualMapModel.itemSize;
          var orient = this._orient;
          var useHandle = this._useHandle;
          var itemAlign = helper.getItemAlign(visualMapModel, this.api, itemSize);

          var barGroup = shapes.barGroup = this._createBarGroup(itemAlign); // Bar


          barGroup.add(shapes.outOfRange = createPolygon());
          barGroup.add(shapes.inRange = createPolygon(null, useHandle ? getCursor(this._orient) : null, zrUtil.bind(this._dragHandle, this, 'all', false), zrUtil.bind(this._dragHandle, this, 'all', true)));
          var textRect = visualMapModel.textStyleModel.getTextRect('');
          var textSize = mathMax(textRect.width, textRect.height); // Handle

          if (useHandle) {
            shapes.handleThumbs = [];
            shapes.handleLabels = [];
            shapes.handleLabelPoints = [];

            this._createHandle(barGroup, 0, itemSize, textSize, orient, itemAlign);

            this._createHandle(barGroup, 1, itemSize, textSize, orient, itemAlign);
          }

          this._createIndicator(barGroup, itemSize, textSize, orient);

          targetGroup.add(barGroup);
        },

        /**
         * @private
         */
        _createHandle: function _createHandle(barGroup, handleIndex, itemSize, textSize, orient) {
          var onDrift = zrUtil.bind(this._dragHandle, this, handleIndex, false);
          var onDragEnd = zrUtil.bind(this._dragHandle, this, handleIndex, true);
          var handleThumb = createPolygon(createHandlePoints(handleIndex, textSize), getCursor(this._orient), onDrift, onDragEnd);
          handleThumb.position[0] = itemSize[0];
          barGroup.add(handleThumb); // Text is always horizontal layout but should not be effected by
          // transform (orient/inverse). So label is built separately but not
          // use zrender/graphic/helper/RectText, and is located based on view
          // group (according to handleLabelPoint) but not barGroup.

          var textStyleModel = this.visualMapModel.textStyleModel;
          var handleLabel = new graphic.Text({
            draggable: true,
            drift: onDrift,
            onmousemove: function onmousemove(e) {
              // Fot mobile devicem, prevent screen slider on the button.
              eventTool.stop(e.event);
            },
            ondragend: onDragEnd,
            style: {
              x: 0,
              y: 0,
              text: '',
              textFont: textStyleModel.getFont(),
              textFill: textStyleModel.getTextColor()
            }
          });
          this.group.add(handleLabel);
          var handleLabelPoint = [orient === 'horizontal' ? textSize / 2 : textSize * 1.5, orient === 'horizontal' ? handleIndex === 0 ? -(textSize * 1.5) : textSize * 1.5 : handleIndex === 0 ? -textSize / 2 : textSize / 2];
          var shapes = this._shapes;
          shapes.handleThumbs[handleIndex] = handleThumb;
          shapes.handleLabelPoints[handleIndex] = handleLabelPoint;
          shapes.handleLabels[handleIndex] = handleLabel;
        },

        /**
         * @private
         */
        _createIndicator: function _createIndicator(barGroup, itemSize, textSize, orient) {
          var indicator = createPolygon([[0, 0]], 'move');
          indicator.position[0] = itemSize[0];
          indicator.attr({
            invisible: true,
            silent: true
          });
          barGroup.add(indicator);
          var textStyleModel = this.visualMapModel.textStyleModel;
          var indicatorLabel = new graphic.Text({
            silent: true,
            invisible: true,
            style: {
              x: 0,
              y: 0,
              text: '',
              textFont: textStyleModel.getFont(),
              textFill: textStyleModel.getTextColor()
            }
          });
          this.group.add(indicatorLabel);
          var indicatorLabelPoint = [orient === 'horizontal' ? textSize / 2 : HOVER_LINK_OUT + 3, 0];
          var shapes = this._shapes;
          shapes.indicator = indicator;
          shapes.indicatorLabel = indicatorLabel;
          shapes.indicatorLabelPoint = indicatorLabelPoint;
        },

        /**
         * @private
         */
        _dragHandle: function _dragHandle(handleIndex, isEnd, dx, dy) {
          if (!this._useHandle) {
            return;
          }

          this._dragging = !isEnd;

          if (!isEnd) {
            // Transform dx, dy to bar coordination.
            var vertex = this._applyTransform([dx, dy], this._shapes.barGroup, true);

            this._updateInterval(handleIndex, vertex[1]); // Considering realtime, update view should be executed
            // before dispatch action.


            this._updateView();
          } // dragEnd do not dispatch action when realtime.


          if (isEnd === !this.visualMapModel.get('realtime')) {
            // jshint ignore:line
            this.api.dispatchAction({
              type: 'selectDataRange',
              from: this.uid,
              visualMapId: this.visualMapModel.id,
              selected: this._dataInterval.slice()
            });
          }

          if (isEnd) {
            !this._hovering && this._clearHoverLinkToSeries();
          } else if (useHoverLinkOnHandle(this.visualMapModel)) {
            this._doHoverLinkToSeries(this._handleEnds[handleIndex], false);
          }
        },

        /**
         * @private
         */
        _resetInterval: function _resetInterval() {
          var visualMapModel = this.visualMapModel;
          var dataInterval = this._dataInterval = visualMapModel.getSelected();
          var dataExtent = visualMapModel.getExtent();
          var sizeExtent = [0, visualMapModel.itemSize[1]];
          this._handleEnds = [linearMap(dataInterval[0], dataExtent, sizeExtent, true), linearMap(dataInterval[1], dataExtent, sizeExtent, true)];
        },

        /**
         * @private
         * @param {(number|string)} handleIndex 0 or 1 or 'all'
         * @param {number} dx
         * @param {number} dy
         */
        _updateInterval: function _updateInterval(handleIndex, delta) {
          delta = delta || 0;
          var visualMapModel = this.visualMapModel;
          var handleEnds = this._handleEnds;
          var sizeExtent = [0, visualMapModel.itemSize[1]];
          sliderMove(delta, handleEnds, sizeExtent, handleIndex, // cross is forbiden
          0);
          var dataExtent = visualMapModel.getExtent(); // Update data interval.

          this._dataInterval = [linearMap(handleEnds[0], sizeExtent, dataExtent, true), linearMap(handleEnds[1], sizeExtent, dataExtent, true)];
        },

        /**
         * @private
         */
        _updateView: function _updateView(forSketch) {
          var visualMapModel = this.visualMapModel;
          var dataExtent = visualMapModel.getExtent();
          var shapes = this._shapes;
          var outOfRangeHandleEnds = [0, visualMapModel.itemSize[1]];
          var inRangeHandleEnds = forSketch ? outOfRangeHandleEnds : this._handleEnds;

          var visualInRange = this._createBarVisual(this._dataInterval, dataExtent, inRangeHandleEnds, 'inRange');

          var visualOutOfRange = this._createBarVisual(dataExtent, dataExtent, outOfRangeHandleEnds, 'outOfRange');

          shapes.inRange.setStyle({
            fill: visualInRange.barColor,
            opacity: visualInRange.opacity
          }).setShape('points', visualInRange.barPoints);
          shapes.outOfRange.setStyle({
            fill: visualOutOfRange.barColor,
            opacity: visualOutOfRange.opacity
          }).setShape('points', visualOutOfRange.barPoints);

          this._updateHandle(inRangeHandleEnds, visualInRange);
        },

        /**
         * @private
         */
        _createBarVisual: function _createBarVisual(dataInterval, dataExtent, handleEnds, forceState) {
          var opts = {
            forceState: forceState,
            convertOpacityToAlpha: true
          };

          var colorStops = this._makeColorGradient(dataInterval, opts);

          var symbolSizes = [this.getControllerVisual(dataInterval[0], 'symbolSize', opts), this.getControllerVisual(dataInterval[1], 'symbolSize', opts)];

          var barPoints = this._createBarPoints(handleEnds, symbolSizes);

          return {
            barColor: new LinearGradient(0, 0, 0, 1, colorStops),
            barPoints: barPoints,
            handlesColor: [colorStops[0].color, colorStops[colorStops.length - 1].color]
          };
        },

        /**
         * @private
         */
        _makeColorGradient: function _makeColorGradient(dataInterval, opts) {
          // Considering colorHue, which is not linear, so we have to sample
          // to calculate gradient color stops, but not only caculate head
          // and tail.
          var sampleNumber = 100; // Arbitrary value.

          var colorStops = [];
          var step = (dataInterval[1] - dataInterval[0]) / sampleNumber;
          colorStops.push({
            color: this.getControllerVisual(dataInterval[0], 'color', opts),
            offset: 0
          });

          for (var i = 1; i < sampleNumber; i++) {
            var currValue = dataInterval[0] + step * i;

            if (currValue > dataInterval[1]) {
              break;
            }

            colorStops.push({
              color: this.getControllerVisual(currValue, 'color', opts),
              offset: i / sampleNumber
            });
          }

          colorStops.push({
            color: this.getControllerVisual(dataInterval[1], 'color', opts),
            offset: 1
          });
          return colorStops;
        },

        /**
         * @private
         */
        _createBarPoints: function _createBarPoints(handleEnds, symbolSizes) {
          var itemSize = this.visualMapModel.itemSize;
          return [[itemSize[0] - symbolSizes[0], handleEnds[0]], [itemSize[0], handleEnds[0]], [itemSize[0], handleEnds[1]], [itemSize[0] - symbolSizes[1], handleEnds[1]]];
        },

        /**
         * @private
         */
        _createBarGroup: function _createBarGroup(itemAlign) {
          var orient = this._orient;
          var inverse = this.visualMapModel.get('inverse');
          return new graphic.Group(orient === 'horizontal' && !inverse ? {
            scale: itemAlign === 'bottom' ? [1, 1] : [-1, 1],
            rotation: Math.PI / 2
          } : orient === 'horizontal' && inverse ? {
            scale: itemAlign === 'bottom' ? [-1, 1] : [1, 1],
            rotation: -Math.PI / 2
          } : orient === 'vertical' && !inverse ? {
            scale: itemAlign === 'left' ? [1, -1] : [-1, -1]
          } : {
            scale: itemAlign === 'left' ? [1, 1] : [-1, 1]
          });
        },

        /**
         * @private
         */
        _updateHandle: function _updateHandle(handleEnds, visualInRange) {
          if (!this._useHandle) {
            return;
          }

          var shapes = this._shapes;
          var visualMapModel = this.visualMapModel;
          var handleThumbs = shapes.handleThumbs;
          var handleLabels = shapes.handleLabels;
          each([0, 1], function (handleIndex) {
            var handleThumb = handleThumbs[handleIndex];
            handleThumb.setStyle('fill', visualInRange.handlesColor[handleIndex]);
            handleThumb.position[1] = handleEnds[handleIndex]; // Update handle label position.

            var textPoint = graphic.applyTransform(shapes.handleLabelPoints[handleIndex], graphic.getTransform(handleThumb, this.group));
            handleLabels[handleIndex].setStyle({
              x: textPoint[0],
              y: textPoint[1],
              text: visualMapModel.formatValueText(this._dataInterval[handleIndex]),
              textVerticalAlign: 'middle',
              textAlign: this._applyTransform(this._orient === 'horizontal' ? handleIndex === 0 ? 'bottom' : 'top' : 'left', shapes.barGroup)
            });
          }, this);
        },

        /**
         * @private
         * @param {number} cursorValue
         * @param {number} textValue
         * @param {string} [rangeSymbol]
         * @param {number} [halfHoverLinkSize]
         */
        _showIndicator: function _showIndicator(cursorValue, textValue, rangeSymbol, halfHoverLinkSize) {
          var visualMapModel = this.visualMapModel;
          var dataExtent = visualMapModel.getExtent();
          var itemSize = visualMapModel.itemSize;
          var sizeExtent = [0, itemSize[1]];
          var pos = linearMap(cursorValue, dataExtent, sizeExtent, true);
          var shapes = this._shapes;
          var indicator = shapes.indicator;

          if (!indicator) {
            return;
          }

          indicator.position[1] = pos;
          indicator.attr('invisible', false);
          indicator.setShape('points', createIndicatorPoints(!!rangeSymbol, halfHoverLinkSize, pos, itemSize[1]));
          var opts = {
            convertOpacityToAlpha: true
          };
          var color = this.getControllerVisual(cursorValue, 'color', opts);
          indicator.setStyle('fill', color); // Update handle label position.

          var textPoint = graphic.applyTransform(shapes.indicatorLabelPoint, graphic.getTransform(indicator, this.group));
          var indicatorLabel = shapes.indicatorLabel;
          indicatorLabel.attr('invisible', false);

          var align = this._applyTransform('left', shapes.barGroup);

          var orient = this._orient;
          indicatorLabel.setStyle({
            text: (rangeSymbol ? rangeSymbol : '') + visualMapModel.formatValueText(textValue),
            textVerticalAlign: orient === 'horizontal' ? align : 'middle',
            textAlign: orient === 'horizontal' ? 'center' : align,
            x: textPoint[0],
            y: textPoint[1]
          });
        },

        /**
         * @private
         */
        _enableHoverLinkToSeries: function _enableHoverLinkToSeries() {
          var self = this;

          this._shapes.barGroup.on('mousemove', function (e) {
            self._hovering = true;

            if (!self._dragging) {
              var itemSize = self.visualMapModel.itemSize;

              var pos = self._applyTransform([e.offsetX, e.offsetY], self._shapes.barGroup, true, true); // For hover link show when hover handle, which might be
              // below or upper than sizeExtent.


              pos[1] = mathMin(mathMax(0, pos[1]), itemSize[1]);

              self._doHoverLinkToSeries(pos[1], 0 <= pos[0] && pos[0] <= itemSize[0]);
            }
          }).on('mouseout', function () {
            // When mouse is out of handle, hoverLink still need
            // to be displayed when realtime is set as false.
            self._hovering = false;
            !self._dragging && self._clearHoverLinkToSeries();
          });
        },

        /**
         * @private
         */
        _enableHoverLinkFromSeries: function _enableHoverLinkFromSeries() {
          var zr = this.api.getZr();

          if (this.visualMapModel.option.hoverLink) {
            zr.on('mouseover', this._hoverLinkFromSeriesMouseOver, this);
            zr.on('mouseout', this._hideIndicator, this);
          } else {
            this._clearHoverLinkFromSeries();
          }
        },

        /**
         * @private
         */
        _doHoverLinkToSeries: function _doHoverLinkToSeries(cursorPos, hoverOnBar) {
          var visualMapModel = this.visualMapModel;
          var itemSize = visualMapModel.itemSize;

          if (!visualMapModel.option.hoverLink) {
            return;
          }

          var sizeExtent = [0, itemSize[1]];
          var dataExtent = visualMapModel.getExtent(); // For hover link show when hover handle, which might be below or upper than sizeExtent.

          cursorPos = mathMin(mathMax(sizeExtent[0], cursorPos), sizeExtent[1]);
          var halfHoverLinkSize = getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent);
          var hoverRange = [cursorPos - halfHoverLinkSize, cursorPos + halfHoverLinkSize];
          var cursorValue = linearMap(cursorPos, sizeExtent, dataExtent, true);
          var valueRange = [linearMap(hoverRange[0], sizeExtent, dataExtent, true), linearMap(hoverRange[1], sizeExtent, dataExtent, true)]; // Consider data range is out of visualMap range, see test/visualMap-continuous.html,
          // where china and india has very large population.

          hoverRange[0] < sizeExtent[0] && (valueRange[0] = -Infinity);
          hoverRange[1] > sizeExtent[1] && (valueRange[1] = Infinity); // Do not show indicator when mouse is over handle,
          // otherwise labels overlap, especially when dragging.

          if (hoverOnBar) {
            if (valueRange[0] === -Infinity) {
              this._showIndicator(cursorValue, valueRange[1], '< ', halfHoverLinkSize);
            } else if (valueRange[1] === Infinity) {
              this._showIndicator(cursorValue, valueRange[0], '> ', halfHoverLinkSize);
            } else {
              this._showIndicator(cursorValue, cursorValue, ' ', halfHoverLinkSize);
            }
          } // When realtime is set as false, handles, which are in barGroup,
          // also trigger hoverLink, which help user to realize where they
          // focus on when dragging. (see test/heatmap-large.html)
          // When realtime is set as true, highlight will not show when hover
          // handle, because the label on handle, which displays a exact value
          // but not range, might mislead users.


          var oldBatch = this._hoverLinkDataIndices;
          var newBatch = [];

          if (hoverOnBar || useHoverLinkOnHandle(visualMapModel)) {
            newBatch = this._hoverLinkDataIndices = visualMapModel.findTargetDataIndices(valueRange);
          }

          var resultBatches = modelUtil.compressBatches(oldBatch, newBatch);

          this._dispatchHighDown('downplay', helper.makeHighDownBatch(resultBatches[0], visualMapModel));

          this._dispatchHighDown('highlight', helper.makeHighDownBatch(resultBatches[1], visualMapModel));
        },

        /**
         * @private
         */
        _hoverLinkFromSeriesMouseOver: function _hoverLinkFromSeriesMouseOver(e) {
          var el = e.target;
          var visualMapModel = this.visualMapModel;

          if (!el || el.dataIndex == null) {
            return;
          }

          var dataModel = this.ecModel.getSeriesByIndex(el.seriesIndex);

          if (!visualMapModel.isTargetSeries(dataModel)) {
            return;
          }

          var data = dataModel.getData(el.dataType);
          var value = data.get(visualMapModel.getDataDimension(data), el.dataIndex, true);

          if (!isNaN(value)) {
            this._showIndicator(value, value);
          }
        },

        /**
         * @private
         */
        _hideIndicator: function _hideIndicator() {
          var shapes = this._shapes;
          shapes.indicator && shapes.indicator.attr('invisible', true);
          shapes.indicatorLabel && shapes.indicatorLabel.attr('invisible', true);
        },

        /**
         * @private
         */
        _clearHoverLinkToSeries: function _clearHoverLinkToSeries() {
          this._hideIndicator();

          var indices = this._hoverLinkDataIndices;

          this._dispatchHighDown('downplay', helper.makeHighDownBatch(indices, this.visualMapModel));

          indices.length = 0;
        },

        /**
         * @private
         */
        _clearHoverLinkFromSeries: function _clearHoverLinkFromSeries() {
          this._hideIndicator();

          var zr = this.api.getZr();
          zr.off('mouseover', this._hoverLinkFromSeriesMouseOver);
          zr.off('mouseout', this._hideIndicator);
        },

        /**
         * @private
         */
        _applyTransform: function _applyTransform(vertex, element, inverse, global) {
          var transform = graphic.getTransform(element, global ? null : this.group);
          return graphic[zrUtil.isArray(vertex) ? 'applyTransform' : 'transformDirection'](vertex, transform, inverse);
        },

        /**
         * @private
         */
        _dispatchHighDown: function _dispatchHighDown(type, batch) {
          batch && batch.length && this.api.dispatchAction({
            type: type,
            batch: batch
          });
        },

        /**
         * @override
         */
        dispose: function dispose() {
          this._clearHoverLinkFromSeries();

          this._clearHoverLinkToSeries();
        },

        /**
         * @override
         */
        remove: function remove() {
          this._clearHoverLinkFromSeries();

          this._clearHoverLinkToSeries();
        }
      });

      function createPolygon(points, cursor, onDrift, onDragEnd) {
        return new graphic.Polygon({
          shape: {
            points: points
          },
          draggable: !!onDrift,
          cursor: cursor,
          drift: onDrift,
          onmousemove: function onmousemove(e) {
            // Fot mobile devicem, prevent screen slider on the button.
            eventTool.stop(e.event);
          },
          ondragend: onDragEnd
        });
      }

      function createHandlePoints(handleIndex, textSize) {
        return handleIndex === 0 ? [[0, 0], [textSize, 0], [textSize, -textSize]] : [[0, 0], [textSize, 0], [textSize, textSize]];
      }

      function createIndicatorPoints(isRange, halfHoverLinkSize, pos, extentMax) {
        return isRange ? [// indicate range
        [0, -mathMin(halfHoverLinkSize, mathMax(pos, 0))], [HOVER_LINK_OUT, 0], [0, mathMin(halfHoverLinkSize, mathMax(extentMax - pos, 0))]] : [// indicate single value
        [0, 0], [5, -5], [5, 5]];
      }

      function getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent) {
        var halfHoverLinkSize = HOVER_LINK_SIZE / 2;
        var hoverLinkDataSize = visualMapModel.get('hoverLinkDataSize');

        if (hoverLinkDataSize) {
          halfHoverLinkSize = linearMap(hoverLinkDataSize, dataExtent, sizeExtent, true) / 2;
        }

        return halfHoverLinkSize;
      }

      function useHoverLinkOnHandle(visualMapModel) {
        var hoverLinkOnHandle = visualMapModel.get('hoverLinkOnHandle');
        return !!(hoverLinkOnHandle == null ? visualMapModel.get('realtime') : hoverLinkOnHandle);
      }

      function getCursor(orient) {
        return orient === 'vertical' ? 'ns-resize' : 'ew-resize';
      }

      var _default = ContinuousView;
      module.exports = _default;
      /***/
    },

    /***/
    "Q7if":
    /*!********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/marker/MarkAreaModel.js ***!
      \********************************************************************/

    /*! no static exports found */

    /***/
    function Q7if(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var MarkerModel = __webpack_require__(
      /*! ./MarkerModel */
      "JEkh");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = MarkerModel.extend({
        type: 'markArea',
        defaultOption: {
          zlevel: 0,
          // PENDING
          z: 1,
          tooltip: {
            trigger: 'item'
          },
          // markArea should fixed on the coordinate system
          animation: false,
          label: {
            show: true,
            position: 'top'
          },
          itemStyle: {
            // color and borderColor default to use color from series
            // color: 'auto'
            // borderColor: 'auto'
            borderWidth: 0
          },
          emphasis: {
            label: {
              show: true,
              position: 'top'
            }
          }
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "QUw5":
    /*!************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js ***!
      \************************************************************************/

    /*! no static exports found */

    /***/
    function QUw5(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var DataZoomModel = __webpack_require__(
      /*! ./DataZoomModel */
      "OlYY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = DataZoomModel.extend({
        type: 'dataZoom.select'
      });

      module.exports = _default;
      /***/
    },

    /***/
    "Qvb6":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/component/tooltip/TooltipView.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function Qvb6(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var env = __webpack_require__(
      /*! zrender/lib/core/env */
      "ItGF");

      var TooltipContent = __webpack_require__(
      /*! ./TooltipContent */
      "B9fm");

      var TooltipRichContent = __webpack_require__(
      /*! ./TooltipRichContent */
      "gvm7");

      var formatUtil = __webpack_require__(
      /*! ../../util/format */
      "7aKB");

      var numberUtil = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var findPointFromSeries = __webpack_require__(
      /*! ../axisPointer/findPointFromSeries */
      "Ez2D");

      var layoutUtil = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var Model = __webpack_require__(
      /*! ../../model/Model */
      "Qxkt");

      var globalListener = __webpack_require__(
      /*! ../axisPointer/globalListener */
      "F9bG");

      var axisHelper = __webpack_require__(
      /*! ../../coord/axisHelper */
      "aX7z");

      var axisPointerViewHelper = __webpack_require__(
      /*! ../axisPointer/viewHelper */
      "/y7N");

      var _model = __webpack_require__(
      /*! ../../util/model */
      "4NO4");

      var getTooltipRenderMode = _model.getTooltipRenderMode;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var bind = zrUtil.bind;
      var each = zrUtil.each;
      var parsePercent = numberUtil.parsePercent;
      var proxyRect = new graphic.Rect({
        shape: {
          x: -1,
          y: -1,
          width: 2,
          height: 2
        }
      });

      var _default = echarts.extendComponentView({
        type: 'tooltip',
        init: function init(ecModel, api) {
          if (env.node) {
            return;
          }

          var tooltipModel = ecModel.getComponent('tooltip');
          var renderMode = tooltipModel.get('renderMode');
          this._renderMode = getTooltipRenderMode(renderMode);
          var tooltipContent;

          if (this._renderMode === 'html') {
            tooltipContent = new TooltipContent(api.getDom(), api, {
              appendToBody: tooltipModel.get('appendToBody', true)
            });
            this._newLine = '<br/>';
          } else {
            tooltipContent = new TooltipRichContent(api);
            this._newLine = '\n';
          }

          this._tooltipContent = tooltipContent;
        },
        render: function render(tooltipModel, ecModel, api) {
          if (env.node) {
            return;
          } // Reset


          this.group.removeAll();
          /**
           * @private
           * @type {module:echarts/component/tooltip/TooltipModel}
           */

          this._tooltipModel = tooltipModel;
          /**
           * @private
           * @type {module:echarts/model/Global}
           */

          this._ecModel = ecModel;
          /**
           * @private
           * @type {module:echarts/ExtensionAPI}
           */

          this._api = api;
          /**
           * Should be cleaned when render.
           * @private
           * @type {Array.<Array.<Object>>}
           */

          this._lastDataByCoordSys = null;
          /**
           * @private
           * @type {boolean}
           */

          this._alwaysShowContent = tooltipModel.get('alwaysShowContent');
          var tooltipContent = this._tooltipContent;
          tooltipContent.update(tooltipModel);
          tooltipContent.setEnterable(tooltipModel.get('enterable'));

          this._initGlobalListener();

          this._keepShow();
        },
        _initGlobalListener: function _initGlobalListener() {
          var tooltipModel = this._tooltipModel;
          var triggerOn = tooltipModel.get('triggerOn');
          globalListener.register('itemTooltip', this._api, bind(function (currTrigger, e, dispatchAction) {
            // If 'none', it is not controlled by mouse totally.
            if (triggerOn !== 'none') {
              if (triggerOn.indexOf(currTrigger) >= 0) {
                this._tryShow(e, dispatchAction);
              } else if (currTrigger === 'leave') {
                this._hide(dispatchAction);
              }
            }
          }, this));
        },
        _keepShow: function _keepShow() {
          var tooltipModel = this._tooltipModel;
          var ecModel = this._ecModel;
          var api = this._api; // Try to keep the tooltip show when refreshing

          if (this._lastX != null && this._lastY != null // When user is willing to control tooltip totally using API,
          // self.manuallyShowTip({x, y}) might cause tooltip hide,
          // which is not expected.
          && tooltipModel.get('triggerOn') !== 'none') {
            var self = this;
            clearTimeout(this._refreshUpdateTimeout);
            this._refreshUpdateTimeout = setTimeout(function () {
              // Show tip next tick after other charts are rendered
              // In case highlight action has wrong result
              // FIXME
              !api.isDisposed() && self.manuallyShowTip(tooltipModel, ecModel, api, {
                x: self._lastX,
                y: self._lastY
              });
            });
          }
        },

        /**
         * Show tip manually by
         * dispatchAction({
         *     type: 'showTip',
         *     x: 10,
         *     y: 10
         * });
         * Or
         * dispatchAction({
         *      type: 'showTip',
         *      seriesIndex: 0,
         *      dataIndex or dataIndexInside or name
         * });
         *
         *  TODO Batch
         */
        manuallyShowTip: function manuallyShowTip(tooltipModel, ecModel, api, payload) {
          if (payload.from === this.uid || env.node) {
            return;
          }

          var dispatchAction = makeDispatchAction(payload, api); // Reset ticket

          this._ticket = ''; // When triggered from axisPointer.

          var dataByCoordSys = payload.dataByCoordSys;

          if (payload.tooltip && payload.x != null && payload.y != null) {
            var el = proxyRect;
            el.position = [payload.x, payload.y];
            el.update();
            el.tooltip = payload.tooltip; // Manually show tooltip while view is not using zrender elements.

            this._tryShow({
              offsetX: payload.x,
              offsetY: payload.y,
              target: el
            }, dispatchAction);
          } else if (dataByCoordSys) {
            this._tryShow({
              offsetX: payload.x,
              offsetY: payload.y,
              position: payload.position,
              dataByCoordSys: payload.dataByCoordSys,
              tooltipOption: payload.tooltipOption
            }, dispatchAction);
          } else if (payload.seriesIndex != null) {
            if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
              return;
            }

            var pointInfo = findPointFromSeries(payload, ecModel);
            var cx = pointInfo.point[0];
            var cy = pointInfo.point[1];

            if (cx != null && cy != null) {
              this._tryShow({
                offsetX: cx,
                offsetY: cy,
                position: payload.position,
                target: pointInfo.el
              }, dispatchAction);
            }
          } else if (payload.x != null && payload.y != null) {
            // FIXME
            // should wrap dispatchAction like `axisPointer/globalListener` ?
            api.dispatchAction({
              type: 'updateAxisPointer',
              x: payload.x,
              y: payload.y
            });

            this._tryShow({
              offsetX: payload.x,
              offsetY: payload.y,
              position: payload.position,
              target: api.getZr().findHover(payload.x, payload.y).target
            }, dispatchAction);
          }
        },
        manuallyHideTip: function manuallyHideTip(tooltipModel, ecModel, api, payload) {
          var tooltipContent = this._tooltipContent;

          if (!this._alwaysShowContent && this._tooltipModel) {
            tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));
          }

          this._lastX = this._lastY = null;

          if (payload.from !== this.uid) {
            this._hide(makeDispatchAction(payload, api));
          }
        },
        // Be compatible with previous design, that is, when tooltip.type is 'axis' and
        // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer
        // and tooltip.
        _manuallyAxisShowTip: function _manuallyAxisShowTip(tooltipModel, ecModel, api, payload) {
          var seriesIndex = payload.seriesIndex;
          var dataIndex = payload.dataIndex;
          var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;

          if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
            return;
          }

          var seriesModel = ecModel.getSeriesByIndex(seriesIndex);

          if (!seriesModel) {
            return;
          }

          var data = seriesModel.getData();
          var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel]);

          if (tooltipModel.get('trigger') !== 'axis') {
            return;
          }

          api.dispatchAction({
            type: 'updateAxisPointer',
            seriesIndex: seriesIndex,
            dataIndex: dataIndex,
            position: payload.position
          });
          return true;
        },
        _tryShow: function _tryShow(e, dispatchAction) {
          var el = e.target;
          var tooltipModel = this._tooltipModel;

          if (!tooltipModel) {
            return;
          } // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed


          this._lastX = e.offsetX;
          this._lastY = e.offsetY;
          var dataByCoordSys = e.dataByCoordSys;

          if (dataByCoordSys && dataByCoordSys.length) {
            this._showAxisTooltip(dataByCoordSys, e);
          } // Always show item tooltip if mouse is on the element with dataIndex
          else if (el && el.dataIndex != null) {
            this._lastDataByCoordSys = null;

            this._showSeriesItemTooltip(e, el, dispatchAction);
          } // Tooltip provided directly. Like legend.
          else if (el && el.tooltip) {
            this._lastDataByCoordSys = null;

            this._showComponentItemTooltip(e, el, dispatchAction);
          } else {
            this._lastDataByCoordSys = null;

            this._hide(dispatchAction);
          }
        },
        _showOrMove: function _showOrMove(tooltipModel, cb) {
          // showDelay is used in this case: tooltip.enterable is set
          // as true. User intent to move mouse into tooltip and click
          // something. `showDelay` makes it easier to enter the content
          // but tooltip do not move immediately.
          var delay = tooltipModel.get('showDelay');
          cb = zrUtil.bind(cb, this);
          clearTimeout(this._showTimout);
          delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
        },
        _showAxisTooltip: function _showAxisTooltip(dataByCoordSys, e) {
          var ecModel = this._ecModel;
          var globalTooltipModel = this._tooltipModel;
          var point = [e.offsetX, e.offsetY];
          var singleDefaultHTML = [];
          var singleParamsList = [];
          var singleTooltipModel = buildTooltipModel([e.tooltipOption, globalTooltipModel]);
          var renderMode = this._renderMode;
          var newLine = this._newLine;
          var markers = {};
          each(dataByCoordSys, function (itemCoordSys) {
            // var coordParamList = [];
            // var coordDefaultHTML = [];
            // var coordTooltipModel = buildTooltipModel([
            //     e.tooltipOption,
            //     itemCoordSys.tooltipOption,
            //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),
            //     globalTooltipModel
            // ]);
            // var displayMode = coordTooltipModel.get('displayMode');
            // var paramsList = displayMode === 'single' ? singleParamsList : [];
            each(itemCoordSys.dataByAxis, function (item) {
              var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);
              var axisValue = item.value;
              var seriesDefaultHTML = [];

              if (!axisModel || axisValue == null) {
                return;
              }

              var valueLabel = axisPointerViewHelper.getValueLabel(axisValue, axisModel.axis, ecModel, item.seriesDataIndices, item.valueLabelOpt);
              zrUtil.each(item.seriesDataIndices, function (idxItem) {
                var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
                var dataIndex = idxItem.dataIndexInside;
                var dataParams = series && series.getDataParams(dataIndex);
                dataParams.axisDim = item.axisDim;
                dataParams.axisIndex = item.axisIndex;
                dataParams.axisType = item.axisType;
                dataParams.axisId = item.axisId;
                dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);
                dataParams.axisValueLabel = valueLabel;

                if (dataParams) {
                  singleParamsList.push(dataParams);
                  var seriesTooltip = series.formatTooltip(dataIndex, true, null, renderMode);
                  var html;

                  if (zrUtil.isObject(seriesTooltip)) {
                    html = seriesTooltip.html;
                    var newMarkers = seriesTooltip.markers;
                    zrUtil.merge(markers, newMarkers);
                  } else {
                    html = seriesTooltip;
                  }

                  seriesDefaultHTML.push(html);
                }
              }); // Default tooltip content
              // FIXME
              // (1) should be the first data which has name?
              // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.

              var firstLine = valueLabel;

              if (renderMode !== 'html') {
                singleDefaultHTML.push(seriesDefaultHTML.join(newLine));
              } else {
                singleDefaultHTML.push((firstLine ? formatUtil.encodeHTML(firstLine) + newLine : '') + seriesDefaultHTML.join(newLine));
              }
            });
          }, this); // In most case, the second axis is shown upper than the first one.

          singleDefaultHTML.reverse();
          singleDefaultHTML = singleDefaultHTML.join(this._newLine + this._newLine);
          var positionExpr = e.position;

          this._showOrMove(singleTooltipModel, function () {
            if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {
              this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, singleParamsList);
            } else {
              this._showTooltipContent(singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(), point[0], point[1], positionExpr, undefined, markers);
            }
          }); // Do not trigger events here, because this branch only be entered
          // from dispatchAction.

        },
        _showSeriesItemTooltip: function _showSeriesItemTooltip(e, el, dispatchAction) {
          var ecModel = this._ecModel; // Use dataModel in element if possible
          // Used when mouseover on a element like markPoint or edge
          // In which case, the data is not main data in series.

          var seriesIndex = el.seriesIndex;
          var seriesModel = ecModel.getSeriesByIndex(seriesIndex); // For example, graph link.

          var dataModel = el.dataModel || seriesModel;
          var dataIndex = el.dataIndex;
          var dataType = el.dataType;
          var data = dataModel.getData(dataType);
          var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel]);
          var tooltipTrigger = tooltipModel.get('trigger');

          if (tooltipTrigger != null && tooltipTrigger !== 'item') {
            return;
          }

          var params = dataModel.getDataParams(dataIndex, dataType);
          var seriesTooltip = dataModel.formatTooltip(dataIndex, false, dataType, this._renderMode);
          var defaultHtml;
          var markers;

          if (zrUtil.isObject(seriesTooltip)) {
            defaultHtml = seriesTooltip.html;
            markers = seriesTooltip.markers;
          } else {
            defaultHtml = seriesTooltip;
            markers = null;
          }

          var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;

          this._showOrMove(tooltipModel, function () {
            this._showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target, markers);
          }); // FIXME
          // duplicated showtip if manuallyShowTip is called from dispatchAction.


          dispatchAction({
            type: 'showTip',
            dataIndexInside: dataIndex,
            dataIndex: data.getRawIndex(dataIndex),
            seriesIndex: seriesIndex,
            from: this.uid
          });
        },
        _showComponentItemTooltip: function _showComponentItemTooltip(e, el, dispatchAction) {
          var tooltipOpt = el.tooltip;

          if (typeof tooltipOpt === 'string') {
            var content = tooltipOpt;
            tooltipOpt = {
              content: content,
              // Fixed formatter
              formatter: content
            };
          }

          var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);
          var defaultHtml = subTooltipModel.get('content');
          var asyncTicket = Math.random(); // Do not check whether `trigger` is 'none' here, because `trigger`
          // only works on coordinate system. In fact, we have not found case
          // that requires setting `trigger` nothing on component yet.

          this._showOrMove(subTooltipModel, function () {
            this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el);
          }); // If not dispatch showTip, tip may be hide triggered by axis.


          dispatchAction({
            type: 'showTip',
            from: this.uid
          });
        },
        _showTooltipContent: function _showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el, markers) {
          // Reset ticket
          this._ticket = '';

          if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {
            return;
          }

          var tooltipContent = this._tooltipContent;
          var formatter = tooltipModel.get('formatter');
          positionExpr = positionExpr || tooltipModel.get('position');
          var html = defaultHtml;

          if (formatter && typeof formatter === 'string') {
            html = formatUtil.formatTpl(formatter, params, true);
          } else if (typeof formatter === 'function') {
            var callback = bind(function (cbTicket, html) {
              if (cbTicket === this._ticket) {
                tooltipContent.setContent(html, markers, tooltipModel);

                this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
              }
            }, this);
            this._ticket = asyncTicket;
            html = formatter(params, asyncTicket, callback);
          }

          tooltipContent.setContent(html, markers, tooltipModel);
          tooltipContent.show(tooltipModel);

          this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
        },

        /**
         * @param  {string|Function|Array.<number>|Object} positionExpr
         * @param  {number} x Mouse x
         * @param  {number} y Mouse y
         * @param  {boolean} confine Whether confine tooltip content in view rect.
         * @param  {Object|<Array.<Object>} params
         * @param  {module:zrender/Element} el target element
         * @param  {module:echarts/ExtensionAPI} api
         * @return {Array.<number>}
         */
        _updatePosition: function _updatePosition(tooltipModel, positionExpr, x, y, content, params, el) {
          var viewWidth = this._api.getWidth();

          var viewHeight = this._api.getHeight();

          positionExpr = positionExpr || tooltipModel.get('position');
          var contentSize = content.getSize();
          var align = tooltipModel.get('align');
          var vAlign = tooltipModel.get('verticalAlign');
          var rect = el && el.getBoundingRect().clone();
          el && rect.applyTransform(el.transform);

          if (typeof positionExpr === 'function') {
            // Callback of position can be an array or a string specify the position
            positionExpr = positionExpr([x, y], params, content.el, rect, {
              viewSize: [viewWidth, viewHeight],
              contentSize: contentSize.slice()
            });
          }

          if (zrUtil.isArray(positionExpr)) {
            x = parsePercent(positionExpr[0], viewWidth);
            y = parsePercent(positionExpr[1], viewHeight);
          } else if (zrUtil.isObject(positionExpr)) {
            positionExpr.width = contentSize[0];
            positionExpr.height = contentSize[1];
            var layoutRect = layoutUtil.getLayoutRect(positionExpr, {
              width: viewWidth,
              height: viewHeight
            });
            x = layoutRect.x;
            y = layoutRect.y;
            align = null; // When positionExpr is left/top/right/bottom,
            // align and verticalAlign will not work.

            vAlign = null;
          } // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element
          else if (typeof positionExpr === 'string' && el) {
            var pos = calcTooltipPosition(positionExpr, rect, contentSize);
            x = pos[0];
            y = pos[1];
          } else {
            var pos = refixTooltipPosition(x, y, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
            x = pos[0];
            y = pos[1];
          }

          align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);
          vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);

          if (tooltipModel.get('confine')) {
            var pos = confineTooltipPosition(x, y, content, viewWidth, viewHeight);
            x = pos[0];
            y = pos[1];
          }

          content.moveTo(x, y);
        },
        // FIXME
        // Should we remove this but leave this to user?
        _updateContentNotChangedOnAxis: function _updateContentNotChangedOnAxis(dataByCoordSys) {
          var lastCoordSys = this._lastDataByCoordSys;
          var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
          contentNotChanged && each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {
            var lastDataByAxis = lastItemCoordSys.dataByAxis || {};
            var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
            var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
            contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;
            contentNotChanged && each(lastDataByAxis, function (lastItem, indexAxis) {
              var thisItem = thisDataByAxis[indexAxis] || {};
              var lastIndices = lastItem.seriesDataIndices || [];
              var newIndices = thisItem.seriesDataIndices || [];
              contentNotChanged &= lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
              contentNotChanged && each(lastIndices, function (lastIdxItem, j) {
                var newIdxItem = newIndices[j];
                contentNotChanged &= lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
              });
            });
          });
          this._lastDataByCoordSys = dataByCoordSys;
          return !!contentNotChanged;
        },
        _hide: function _hide(dispatchAction) {
          // Do not directly hideLater here, because this behavior may be prevented
          // in dispatchAction when showTip is dispatched.
          // FIXME
          // duplicated hideTip if manuallyHideTip is called from dispatchAction.
          this._lastDataByCoordSys = null;
          dispatchAction({
            type: 'hideTip',
            from: this.uid
          });
        },
        dispose: function dispose(ecModel, api) {
          if (env.node) {
            return;
          }

          this._tooltipContent.dispose();

          globalListener.unregister('itemTooltip', api);
        }
      });
      /**
       * @param {Array.<Object|module:echarts/model/Model>} modelCascade
       * From top to bottom. (the last one should be globalTooltipModel);
       */


      function buildTooltipModel(modelCascade) {
        var resultModel = modelCascade.pop();

        while (modelCascade.length) {
          var tooltipOpt = modelCascade.pop();

          if (tooltipOpt) {
            if (Model.isInstance(tooltipOpt)) {
              tooltipOpt = tooltipOpt.get('tooltip', true);
            } // In each data item tooltip can be simply write:
            // {
            //  value: 10,
            //  tooltip: 'Something you need to know'
            // }


            if (typeof tooltipOpt === 'string') {
              tooltipOpt = {
                formatter: tooltipOpt
              };
            }

            resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);
          }
        }

        return resultModel;
      }

      function makeDispatchAction(payload, api) {
        return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);
      }

      function refixTooltipPosition(x, y, content, viewWidth, viewHeight, gapH, gapV) {
        var size = content.getOuterSize();
        var width = size.width;
        var height = size.height;

        if (gapH != null) {
          if (x + width + gapH > viewWidth) {
            x -= width + gapH;
          } else {
            x += gapH;
          }
        }

        if (gapV != null) {
          if (y + height + gapV > viewHeight) {
            y -= height + gapV;
          } else {
            y += gapV;
          }
        }

        return [x, y];
      }

      function confineTooltipPosition(x, y, content, viewWidth, viewHeight) {
        var size = content.getOuterSize();
        var width = size.width;
        var height = size.height;
        x = Math.min(x + width, viewWidth) - width;
        y = Math.min(y + height, viewHeight) - height;
        x = Math.max(x, 0);
        y = Math.max(y, 0);
        return [x, y];
      }

      function calcTooltipPosition(position, rect, contentSize) {
        var domWidth = contentSize[0];
        var domHeight = contentSize[1];
        var gap = 5;
        var x = 0;
        var y = 0;
        var rectWidth = rect.width;
        var rectHeight = rect.height;

        switch (position) {
          case 'inside':
            x = rect.x + rectWidth / 2 - domWidth / 2;
            y = rect.y + rectHeight / 2 - domHeight / 2;
            break;

          case 'top':
            x = rect.x + rectWidth / 2 - domWidth / 2;
            y = rect.y - domHeight - gap;
            break;

          case 'bottom':
            x = rect.x + rectWidth / 2 - domWidth / 2;
            y = rect.y + rectHeight + gap;
            break;

          case 'left':
            x = rect.x - domWidth - gap;
            y = rect.y + rectHeight / 2 - domHeight / 2;
            break;

          case 'right':
            x = rect.x + rectWidth + gap;
            y = rect.y + rectHeight / 2 - domHeight / 2;
        }

        return [x, y];
      }

      function isCenterAlign(align) {
        return align === 'center' || align === 'middle';
      }

      module.exports = _default;
      /***/
    },

    /***/
    "QzjZ":
    /*!****************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/single/singleCreator.js ***!
      \****************************************************************/

    /*! no static exports found */

    /***/
    function QzjZ(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var Single = __webpack_require__(
      /*! ./Single */
      "S/Yl");

      var CoordinateSystem = __webpack_require__(
      /*! ../../CoordinateSystem */
      "IDmD");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Single coordinate system creator.
       */

      /**
       * Create single coordinate system and inject it into seriesModel.
       *
       * @param {module:echarts/model/Global} ecModel
       * @param {module:echarts/ExtensionAPI} api
       * @return {Array.<module:echarts/coord/single/Single>}
       */


      function create(ecModel, api) {
        var singles = [];
        ecModel.eachComponent('singleAxis', function (axisModel, idx) {
          var single = new Single(axisModel, ecModel, api);
          single.name = 'single_' + idx;
          single.resize(axisModel, api);
          axisModel.coordinateSystem = single;
          singles.push(single);
        });
        ecModel.eachSeries(function (seriesModel) {
          if (seriesModel.get('coordinateSystem') === 'singleAxis') {
            var singleAxisModel = ecModel.queryComponents({
              mainType: 'singleAxis',
              index: seriesModel.get('singleAxisIndex'),
              id: seriesModel.get('singleAxisId')
            })[0];
            seriesModel.coordinateSystem = singleAxisModel && singleAxisModel.coordinateSystem;
          }
        });
        return singles;
      }

      CoordinateSystem.register('single', {
        create: create,
        dimensions: Single.prototype.dimensions
      });
      /***/
    },

    /***/
    "R4Th":
    /*!***************************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/effectScatter/EffectScatterView.js ***!
      \***************************************************************************/

    /*! no static exports found */

    /***/
    function R4Th(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var SymbolDraw = __webpack_require__(
      /*! ../helper/SymbolDraw */
      "9wZj");

      var EffectSymbol = __webpack_require__(
      /*! ../helper/EffectSymbol */
      "yO87");

      var matrix = __webpack_require__(
      /*! zrender/lib/core/matrix */
      "Fofx");

      var pointsLayout = __webpack_require__(
      /*! ../../layout/points */
      "h8O9");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = echarts.extendChartView({
        type: 'effectScatter',
        init: function init() {
          this._symbolDraw = new SymbolDraw(EffectSymbol);
        },
        render: function render(seriesModel, ecModel, api) {
          var data = seriesModel.getData();
          var effectSymbolDraw = this._symbolDraw;
          effectSymbolDraw.updateData(data);
          this.group.add(effectSymbolDraw.group);
        },
        updateTransform: function updateTransform(seriesModel, ecModel, api) {
          var data = seriesModel.getData();
          this.group.dirty();
          var res = pointsLayout().reset(seriesModel);

          if (res.progress) {
            res.progress({
              start: 0,
              end: data.count()
            }, data);
          }

          this._symbolDraw.updateLayout(data);
        },
        _updateGroupTransform: function _updateGroupTransform(seriesModel) {
          var coordSys = seriesModel.coordinateSystem;

          if (coordSys && coordSys.getRoamTransform) {
            this.group.transform = matrix.clone(coordSys.getRoamTransform());
            this.group.decomposeTransform();
          }
        },
        remove: function remove(ecModel, api) {
          this._symbolDraw && this._symbolDraw.remove(api);
        },
        dispose: function dispose() {}
      });

      module.exports = _default;
      /***/
    },

    /***/
    "RBEP":
    /*!*****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/treemap/treemapAction.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function RBEP(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var helper = __webpack_require__(
      /*! ../helper/treeHelper */
      "VaxA");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @file Treemap action
       */


      var noop = function noop() {};

      var actionTypes = ['treemapZoomToNode', 'treemapRender', 'treemapMove'];

      for (var i = 0; i < actionTypes.length; i++) {
        echarts.registerAction({
          type: actionTypes[i],
          update: 'updateView'
        }, noop);
      }

      echarts.registerAction({
        type: 'treemapRootToNode',
        update: 'updateView'
      }, function (payload, ecModel) {
        ecModel.eachComponent({
          mainType: 'series',
          subType: 'treemap',
          query: payload
        }, handleRootToNode);

        function handleRootToNode(model, index) {
          var types = ['treemapZoomToNode', 'treemapRootToNode'];
          var targetInfo = helper.retrieveTargetInfo(payload, types, model);

          if (targetInfo) {
            var originViewRoot = model.getViewRoot();

            if (originViewRoot) {
              payload.direction = helper.aboveViewRoot(originViewRoot, targetInfo.node) ? 'rollUp' : 'drillDown';
            }

            model.resetViewRoot(targetInfo.node);
          }
        }
      });
      /***/
    },

    /***/
    "RPvy":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/sunburst/sunburstAction.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function RPvy(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var helper = __webpack_require__(
      /*! ../helper/treeHelper */
      "VaxA");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @file Sunburst action
       */


      var ROOT_TO_NODE_ACTION = 'sunburstRootToNode';
      echarts.registerAction({
        type: ROOT_TO_NODE_ACTION,
        update: 'updateView'
      }, function (payload, ecModel) {
        ecModel.eachComponent({
          mainType: 'series',
          subType: 'sunburst',
          query: payload
        }, handleRootToNode);

        function handleRootToNode(model, index) {
          var targetInfo = helper.retrieveTargetInfo(payload, [ROOT_TO_NODE_ACTION], model);

          if (targetInfo) {
            var originViewRoot = model.getViewRoot();

            if (originViewRoot) {
              payload.direction = helper.aboveViewRoot(originViewRoot, targetInfo.node) ? 'rollUp' : 'drillDown';
            }

            model.resetViewRoot(targetInfo.node);
          }
        }
      });
      var HIGHLIGHT_ACTION = 'sunburstHighlight';
      echarts.registerAction({
        type: HIGHLIGHT_ACTION,
        update: 'updateView'
      }, function (payload, ecModel) {
        ecModel.eachComponent({
          mainType: 'series',
          subType: 'sunburst',
          query: payload
        }, handleHighlight);

        function handleHighlight(model, index) {
          var targetInfo = helper.retrieveTargetInfo(payload, [HIGHLIGHT_ACTION], model);

          if (targetInfo) {
            payload.highlight = targetInfo.node;
          }
        }
      });
      var UNHIGHLIGHT_ACTION = 'sunburstUnhighlight';
      echarts.registerAction({
        type: UNHIGHLIGHT_ACTION,
        update: 'updateView'
      }, function (payload, ecModel) {
        ecModel.eachComponent({
          mainType: 'series',
          subType: 'sunburst',
          query: payload
        }, handleUnhighlight);

        function handleUnhighlight(model, index) {
          payload.unhighlight = true;
        }
      });
      /***/
    },

    /***/
    "RSch":
    /*!***********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/helper/Polyline.js ***!
      \***********************************************************/

    /*! no static exports found */

    /***/
    function RSch(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @module echarts/chart/helper/Line
       */

      /**
       * @constructor
       * @extends {module:zrender/graphic/Group}
       * @alias {module:echarts/chart/helper/Polyline}
       */


      function Polyline(lineData, idx, seriesScope) {
        graphic.Group.call(this);

        this._createPolyline(lineData, idx, seriesScope);
      }

      var polylineProto = Polyline.prototype;

      polylineProto._createPolyline = function (lineData, idx, seriesScope) {
        // var seriesModel = lineData.hostModel;
        var points = lineData.getItemLayout(idx);
        var line = new graphic.Polyline({
          shape: {
            points: points
          }
        });
        this.add(line);

        this._updateCommonStl(lineData, idx, seriesScope);
      };

      polylineProto.updateData = function (lineData, idx, seriesScope) {
        var seriesModel = lineData.hostModel;
        var line = this.childAt(0);
        var target = {
          shape: {
            points: lineData.getItemLayout(idx)
          }
        };
        graphic.updateProps(line, target, seriesModel, idx);

        this._updateCommonStl(lineData, idx, seriesScope);
      };

      polylineProto._updateCommonStl = function (lineData, idx, seriesScope) {
        var line = this.childAt(0);
        var itemModel = lineData.getItemModel(idx);
        var visualColor = lineData.getItemVisual(idx, 'color');
        var lineStyle = seriesScope && seriesScope.lineStyle;
        var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;

        if (!seriesScope || lineData.hasItemOption) {
          lineStyle = itemModel.getModel('lineStyle').getLineStyle();
          hoverLineStyle = itemModel.getModel('emphasis.lineStyle').getLineStyle();
        }

        line.useStyle(zrUtil.defaults({
          strokeNoScale: true,
          fill: 'none',
          stroke: visualColor
        }, lineStyle));
        line.hoverStyle = hoverLineStyle;
        graphic.setHoverStyle(this);
      };

      polylineProto.updateLayout = function (lineData, idx) {
        var polyline = this.childAt(0);
        polyline.setShape('points', lineData.getItemLayout(idx));
      };

      zrUtil.inherits(Polyline, graphic.Group);
      var _default = Polyline;
      module.exports = _default;
      /***/
    },

    /***/
    "RlCK":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/component/legend/legendAction.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function RlCK(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function legendSelectActionHandler(methodName, payload, ecModel) {
        var selectedMap = {};
        var isToggleSelect = methodName === 'toggleSelected';
        var isSelected; // Update all legend components

        ecModel.eachComponent('legend', function (legendModel) {
          if (isToggleSelect && isSelected != null) {
            // Force other legend has same selected status
            // Or the first is toggled to true and other are toggled to false
            // In the case one legend has some item unSelected in option. And if other legend
            // doesn't has the item, they will assume it is selected.
            legendModel[isSelected ? 'select' : 'unSelect'](payload.name);
          } else if (methodName === 'allSelect' || methodName === 'inverseSelect') {
            legendModel[methodName]();
          } else {
            legendModel[methodName](payload.name);
            isSelected = legendModel.isSelected(payload.name);
          }

          var legendData = legendModel.getData();
          zrUtil.each(legendData, function (model) {
            var name = model.get('name'); // Wrap element

            if (name === '\n' || name === '') {
              return;
            }

            var isItemSelected = legendModel.isSelected(name);

            if (selectedMap.hasOwnProperty(name)) {
              // Unselected if any legend is unselected
              selectedMap[name] = selectedMap[name] && isItemSelected;
            } else {
              selectedMap[name] = isItemSelected;
            }
          });
        }); // Return the event explicitly

        return methodName === 'allSelect' || methodName === 'inverseSelect' ? {
          selected: selectedMap
        } : {
          name: payload.name,
          selected: selectedMap
        };
      }
      /**
       * @event legendToggleSelect
       * @type {Object}
       * @property {string} type 'legendToggleSelect'
       * @property {string} [from]
       * @property {string} name Series name or data item name
       */


      echarts.registerAction('legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));
      echarts.registerAction('legendAllSelect', 'legendselectall', zrUtil.curry(legendSelectActionHandler, 'allSelect'));
      echarts.registerAction('legendInverseSelect', 'legendinverseselect', zrUtil.curry(legendSelectActionHandler, 'inverseSelect'));
      /**
       * @event legendSelect
       * @type {Object}
       * @property {string} type 'legendSelect'
       * @property {string} name Series name or data item name
       */

      echarts.registerAction('legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));
      /**
       * @event legendUnSelect
       * @type {Object}
       * @property {string} type 'legendUnSelect'
       * @property {string} name Series name or data item name
       */

      echarts.registerAction('legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect'));
      /***/
    },

    /***/
    "Rx6q":
    /*!******************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/calendar/prepareCustom.js ***!
      \******************************************************************/

    /*! no static exports found */

    /***/
    function Rx6q(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      function _default(coordSys) {
        var rect = coordSys.getRect();
        var rangeInfo = coordSys.getRangeInfo();
        return {
          coordSys: {
            type: 'calendar',
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height,
            cellWidth: coordSys.getCellWidth(),
            cellHeight: coordSys.getCellHeight(),
            rangeInfo: {
              start: rangeInfo.start,
              end: rangeInfo.end,
              weeks: rangeInfo.weeks,
              dayCount: rangeInfo.allDay
            }
          },
          api: {
            coord: function coord(data, clamp) {
              return coordSys.dataToPoint(data, clamp);
            }
          }
        };
      }

      module.exports = _default;
      /***/
    },

    /***/
    "S/Yl":
    /*!*********************************************************!*\
      !*** ./node_modules/echarts/lib/coord/single/Single.js ***!
      \*********************************************************/

    /*! no static exports found */

    /***/
    function SYl(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var SingleAxis = __webpack_require__(
      /*! ./SingleAxis */
      "Zvw2");

      var axisHelper = __webpack_require__(
      /*! ../axisHelper */
      "aX7z");

      var _layout = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var getLayoutRect = _layout.getLayoutRect;

      var _util = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var each = _util.each;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Single coordinates system.
       */

      /**
       * Create a single coordinates system.
       *
       * @param {module:echarts/coord/single/AxisModel} axisModel
       * @param {module:echarts/model/Global} ecModel
       * @param {module:echarts/ExtensionAPI} api
       */

      function Single(axisModel, ecModel, api) {
        /**
         * @type {string}
         * @readOnly
         */
        this.dimension = 'single';
        /**
         * Add it just for draw tooltip.
         *
         * @type {Array.<string>}
         * @readOnly
         */

        this.dimensions = ['single'];
        /**
         * @private
         * @type {module:echarts/coord/single/SingleAxis}.
         */

        this._axis = null;
        /**
         * @private
         * @type {module:zrender/core/BoundingRect}
         */

        this._rect;

        this._init(axisModel, ecModel, api);
        /**
         * @type {module:echarts/coord/single/AxisModel}
         */


        this.model = axisModel;
      }

      Single.prototype = {
        type: 'singleAxis',
        axisPointerEnabled: true,
        constructor: Single,

        /**
         * Initialize single coordinate system.
         *
         * @param  {module:echarts/coord/single/AxisModel} axisModel
         * @param  {module:echarts/model/Global} ecModel
         * @param  {module:echarts/ExtensionAPI} api
         * @private
         */
        _init: function _init(axisModel, ecModel, api) {
          var dim = this.dimension;
          var axis = new SingleAxis(dim, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisModel.get('position'));
          var isCategory = axis.type === 'category';
          axis.onBand = isCategory && axisModel.get('boundaryGap');
          axis.inverse = axisModel.get('inverse');
          axis.orient = axisModel.get('orient');
          axisModel.axis = axis;
          axis.model = axisModel;
          axis.coordinateSystem = this;
          this._axis = axis;
        },

        /**
         * Update axis scale after data processed
         * @param  {module:echarts/model/Global} ecModel
         * @param  {module:echarts/ExtensionAPI} api
         */
        update: function update(ecModel, api) {
          ecModel.eachSeries(function (seriesModel) {
            if (seriesModel.coordinateSystem === this) {
              var data = seriesModel.getData();
              each(data.mapDimension(this.dimension, true), function (dim) {
                this._axis.scale.unionExtentFromData(data, dim);
              }, this);
              axisHelper.niceScaleExtent(this._axis.scale, this._axis.model);
            }
          }, this);
        },

        /**
         * Resize the single coordinate system.
         *
         * @param  {module:echarts/coord/single/AxisModel} axisModel
         * @param  {module:echarts/ExtensionAPI} api
         */
        resize: function resize(axisModel, api) {
          this._rect = getLayoutRect({
            left: axisModel.get('left'),
            top: axisModel.get('top'),
            right: axisModel.get('right'),
            bottom: axisModel.get('bottom'),
            width: axisModel.get('width'),
            height: axisModel.get('height')
          }, {
            width: api.getWidth(),
            height: api.getHeight()
          });

          this._adjustAxis();
        },

        /**
         * @return {module:zrender/core/BoundingRect}
         */
        getRect: function getRect() {
          return this._rect;
        },

        /**
         * @private
         */
        _adjustAxis: function _adjustAxis() {
          var rect = this._rect;
          var axis = this._axis;
          var isHorizontal = axis.isHorizontal();
          var extent = isHorizontal ? [0, rect.width] : [0, rect.height];
          var idx = axis.reverse ? 1 : 0;
          axis.setExtent(extent[idx], extent[1 - idx]);

          this._updateAxisTransform(axis, isHorizontal ? rect.x : rect.y);
        },

        /**
         * @param  {module:echarts/coord/single/SingleAxis} axis
         * @param  {number} coordBase
         */
        _updateAxisTransform: function _updateAxisTransform(axis, coordBase) {
          var axisExtent = axis.getExtent();
          var extentSum = axisExtent[0] + axisExtent[1];
          var isHorizontal = axis.isHorizontal();
          axis.toGlobalCoord = isHorizontal ? function (coord) {
            return coord + coordBase;
          } : function (coord) {
            return extentSum - coord + coordBase;
          };
          axis.toLocalCoord = isHorizontal ? function (coord) {
            return coord - coordBase;
          } : function (coord) {
            return extentSum - coord + coordBase;
          };
        },

        /**
         * Get axis.
         *
         * @return {module:echarts/coord/single/SingleAxis}
         */
        getAxis: function getAxis() {
          return this._axis;
        },

        /**
         * Get axis, add it just for draw tooltip.
         *
         * @return {[type]} [description]
         */
        getBaseAxis: function getBaseAxis() {
          return this._axis;
        },

        /**
         * @return {Array.<module:echarts/coord/Axis>}
         */
        getAxes: function getAxes() {
          return [this._axis];
        },

        /**
         * @return {Object} {baseAxes: [], otherAxes: []}
         */
        getTooltipAxes: function getTooltipAxes() {
          return {
            baseAxes: [this.getAxis()]
          };
        },

        /**
         * If contain point.
         *
         * @param  {Array.<number>} point
         * @return {boolean}
         */
        containPoint: function containPoint(point) {
          var rect = this.getRect();
          var axis = this.getAxis();
          var orient = axis.orient;

          if (orient === 'horizontal') {
            return axis.contain(axis.toLocalCoord(point[0])) && point[1] >= rect.y && point[1] <= rect.y + rect.height;
          } else {
            return axis.contain(axis.toLocalCoord(point[1])) && point[0] >= rect.y && point[0] <= rect.y + rect.height;
          }
        },

        /**
         * @param {Array.<number>} point
         * @return {Array.<number>}
         */
        pointToData: function pointToData(point) {
          var axis = this.getAxis();
          return [axis.coordToData(axis.toLocalCoord(point[axis.orient === 'horizontal' ? 0 : 1]))];
        },

        /**
         * Convert the series data to concrete point.
         *
         * @param  {number|Array.<number>} val
         * @return {Array.<number>}
         */
        dataToPoint: function dataToPoint(val) {
          var axis = this.getAxis();
          var rect = this.getRect();
          var pt = [];
          var idx = axis.orient === 'horizontal' ? 0 : 1;

          if (val instanceof Array) {
            val = val[0];
          }

          pt[idx] = axis.toGlobalCoord(axis.dataToCoord(+val));
          pt[1 - idx] = idx === 0 ? rect.y + rect.height / 2 : rect.x + rect.width / 2;
          return pt;
        }
      };
      var _default = Single;
      module.exports = _default;
      /***/
    },

    /***/
    "SA4+":
    /*!***************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/heatmap/HeatmapView.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function SA4(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var HeatmapLayer = __webpack_require__(
      /*! ./HeatmapLayer */
      "zYTA");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function getIsInPiecewiseRange(dataExtent, pieceList, selected) {
        var dataSpan = dataExtent[1] - dataExtent[0];
        pieceList = zrUtil.map(pieceList, function (piece) {
          return {
            interval: [(piece.interval[0] - dataExtent[0]) / dataSpan, (piece.interval[1] - dataExtent[0]) / dataSpan]
          };
        });
        var len = pieceList.length;
        var lastIndex = 0;
        return function (val) {
          // Try to find in the location of the last found
          for (var i = lastIndex; i < len; i++) {
            var interval = pieceList[i].interval;

            if (interval[0] <= val && val <= interval[1]) {
              lastIndex = i;
              break;
            }
          }

          if (i === len) {
            // Not found, back interation
            for (var i = lastIndex - 1; i >= 0; i--) {
              var interval = pieceList[i].interval;

              if (interval[0] <= val && val <= interval[1]) {
                lastIndex = i;
                break;
              }
            }
          }

          return i >= 0 && i < len && selected[i];
        };
      }

      function getIsInContinuousRange(dataExtent, range) {
        var dataSpan = dataExtent[1] - dataExtent[0];
        range = [(range[0] - dataExtent[0]) / dataSpan, (range[1] - dataExtent[0]) / dataSpan];
        return function (val) {
          return val >= range[0] && val <= range[1];
        };
      }

      function isGeoCoordSys(coordSys) {
        var dimensions = coordSys.dimensions; // Not use coorSys.type === 'geo' because coordSys maybe extended

        return dimensions[0] === 'lng' && dimensions[1] === 'lat';
      }

      var _default = echarts.extendChartView({
        type: 'heatmap',
        render: function render(seriesModel, ecModel, api) {
          var visualMapOfThisSeries;
          ecModel.eachComponent('visualMap', function (visualMap) {
            visualMap.eachTargetSeries(function (targetSeries) {
              if (targetSeries === seriesModel) {
                visualMapOfThisSeries = visualMap;
              }
            });
          });
          this.group.removeAll();
          this._incrementalDisplayable = null;
          var coordSys = seriesModel.coordinateSystem;

          if (coordSys.type === 'cartesian2d' || coordSys.type === 'calendar') {
            this._renderOnCartesianAndCalendar(seriesModel, api, 0, seriesModel.getData().count());
          } else if (isGeoCoordSys(coordSys)) {
            this._renderOnGeo(coordSys, seriesModel, visualMapOfThisSeries, api);
          }
        },
        incrementalPrepareRender: function incrementalPrepareRender(seriesModel, ecModel, api) {
          this.group.removeAll();
        },
        incrementalRender: function incrementalRender(params, seriesModel, ecModel, api) {
          var coordSys = seriesModel.coordinateSystem;

          if (coordSys) {
            this._renderOnCartesianAndCalendar(seriesModel, api, params.start, params.end, true);
          }
        },
        _renderOnCartesianAndCalendar: function _renderOnCartesianAndCalendar(seriesModel, api, start, end, incremental) {
          var coordSys = seriesModel.coordinateSystem;
          var width;
          var height;

          if (coordSys.type === 'cartesian2d') {
            var xAxis = coordSys.getAxis('x');
            var yAxis = coordSys.getAxis('y');
            width = xAxis.getBandWidth();
            height = yAxis.getBandWidth();
          }

          var group = this.group;
          var data = seriesModel.getData();
          var itemStyleQuery = 'itemStyle';
          var hoverItemStyleQuery = 'emphasis.itemStyle';
          var labelQuery = 'label';
          var hoverLabelQuery = 'emphasis.label';
          var style = seriesModel.getModel(itemStyleQuery).getItemStyle(['color']);
          var hoverStl = seriesModel.getModel(hoverItemStyleQuery).getItemStyle();
          var labelModel = seriesModel.getModel(labelQuery);
          var hoverLabelModel = seriesModel.getModel(hoverLabelQuery);
          var coordSysType = coordSys.type;
          var dataDims = coordSysType === 'cartesian2d' ? [data.mapDimension('x'), data.mapDimension('y'), data.mapDimension('value')] : [data.mapDimension('time'), data.mapDimension('value')];

          for (var idx = start; idx < end; idx++) {
            var rect;

            if (coordSysType === 'cartesian2d') {
              // Ignore empty data
              if (isNaN(data.get(dataDims[2], idx))) {
                continue;
              }

              var point = coordSys.dataToPoint([data.get(dataDims[0], idx), data.get(dataDims[1], idx)]);
              rect = new graphic.Rect({
                shape: {
                  x: Math.floor(Math.round(point[0]) - width / 2),
                  y: Math.floor(Math.round(point[1]) - height / 2),
                  width: Math.ceil(width),
                  height: Math.ceil(height)
                },
                style: {
                  fill: data.getItemVisual(idx, 'color'),
                  opacity: data.getItemVisual(idx, 'opacity')
                }
              });
            } else {
              // Ignore empty data
              if (isNaN(data.get(dataDims[1], idx))) {
                continue;
              }

              rect = new graphic.Rect({
                z2: 1,
                shape: coordSys.dataToRect([data.get(dataDims[0], idx)]).contentShape,
                style: {
                  fill: data.getItemVisual(idx, 'color'),
                  opacity: data.getItemVisual(idx, 'opacity')
                }
              });
            }

            var itemModel = data.getItemModel(idx); // Optimization for large datset

            if (data.hasItemOption) {
              style = itemModel.getModel(itemStyleQuery).getItemStyle(['color']);
              hoverStl = itemModel.getModel(hoverItemStyleQuery).getItemStyle();
              labelModel = itemModel.getModel(labelQuery);
              hoverLabelModel = itemModel.getModel(hoverLabelQuery);
            }

            var rawValue = seriesModel.getRawValue(idx);
            var defaultText = '-';

            if (rawValue && rawValue[2] != null) {
              defaultText = rawValue[2];
            }

            graphic.setLabelStyle(style, hoverStl, labelModel, hoverLabelModel, {
              labelFetcher: seriesModel,
              labelDataIndex: idx,
              defaultText: defaultText,
              isRectText: true
            });
            rect.setStyle(style);
            graphic.setHoverStyle(rect, data.hasItemOption ? hoverStl : zrUtil.extend({}, hoverStl));
            rect.incremental = incremental; // PENDING

            if (incremental) {
              // Rect must use hover layer if it's incremental.
              rect.useHoverLayer = true;
            }

            group.add(rect);
            data.setItemGraphicEl(idx, rect);
          }
        },
        _renderOnGeo: function _renderOnGeo(geo, seriesModel, visualMapModel, api) {
          var inRangeVisuals = visualMapModel.targetVisuals.inRange;
          var outOfRangeVisuals = visualMapModel.targetVisuals.outOfRange; // if (!visualMapping) {
          //     throw new Error('Data range must have color visuals');
          // }

          var data = seriesModel.getData();
          var hmLayer = this._hmLayer || this._hmLayer || new HeatmapLayer();
          hmLayer.blurSize = seriesModel.get('blurSize');
          hmLayer.pointSize = seriesModel.get('pointSize');
          hmLayer.minOpacity = seriesModel.get('minOpacity');
          hmLayer.maxOpacity = seriesModel.get('maxOpacity');
          var rect = geo.getViewRect().clone();
          var roamTransform = geo.getRoamTransform();
          rect.applyTransform(roamTransform); // Clamp on viewport

          var x = Math.max(rect.x, 0);
          var y = Math.max(rect.y, 0);
          var x2 = Math.min(rect.width + rect.x, api.getWidth());
          var y2 = Math.min(rect.height + rect.y, api.getHeight());
          var width = x2 - x;
          var height = y2 - y;
          var dims = [data.mapDimension('lng'), data.mapDimension('lat'), data.mapDimension('value')];
          var points = data.mapArray(dims, function (lng, lat, value) {
            var pt = geo.dataToPoint([lng, lat]);
            pt[0] -= x;
            pt[1] -= y;
            pt.push(value);
            return pt;
          });
          var dataExtent = visualMapModel.getExtent();
          var isInRange = visualMapModel.type === 'visualMap.continuous' ? getIsInContinuousRange(dataExtent, visualMapModel.option.range) : getIsInPiecewiseRange(dataExtent, visualMapModel.getPieceList(), visualMapModel.option.selected);
          hmLayer.update(points, width, height, inRangeVisuals.color.getNormalizer(), {
            inRange: inRangeVisuals.color.getColorMapper(),
            outOfRange: outOfRangeVisuals.color.getColorMapper()
          }, isInRange);
          var img = new graphic.Image({
            style: {
              width: width,
              height: height,
              x: x,
              y: y,
              image: hmLayer.canvas
            },
            silent: true
          });
          this.group.add(img);
        },
        dispose: function dispose() {}
      });

      module.exports = _default;
      /***/
    },

    /***/
    "SA8n":
    /*!************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/graph/adjustEdge.js ***!
      \************************************************************/

    /*! no static exports found */

    /***/
    function SA8n(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var curveTool = __webpack_require__(
      /*! zrender/lib/core/curve */
      "Sj9i");

      var vec2 = __webpack_require__(
      /*! zrender/lib/core/vector */
      "QBsz");

      var _graphHelper = __webpack_require__(
      /*! ./graphHelper */
      "U/Mo");

      var getSymbolSize = _graphHelper.getSymbolSize;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var v1 = [];
      var v2 = [];
      var v3 = [];
      var quadraticAt = curveTool.quadraticAt;
      var v2DistSquare = vec2.distSquare;
      var mathAbs = Math.abs;

      function intersectCurveCircle(curvePoints, center, radius) {
        var p0 = curvePoints[0];
        var p1 = curvePoints[1];
        var p2 = curvePoints[2];
        var d = Infinity;
        var t;
        var radiusSquare = radius * radius;
        var interval = 0.1;

        for (var _t = 0.1; _t <= 0.9; _t += 0.1) {
          v1[0] = quadraticAt(p0[0], p1[0], p2[0], _t);
          v1[1] = quadraticAt(p0[1], p1[1], p2[1], _t);
          var diff = mathAbs(v2DistSquare(v1, center) - radiusSquare);

          if (diff < d) {
            d = diff;
            t = _t;
          }
        } // Assume the segment is monotoneFind root through Bisection method
        // At most 32 iteration


        for (var i = 0; i < 32; i++) {
          // var prev = t - interval;
          var next = t + interval; // v1[0] = quadraticAt(p0[0], p1[0], p2[0], prev);
          // v1[1] = quadraticAt(p0[1], p1[1], p2[1], prev);

          v2[0] = quadraticAt(p0[0], p1[0], p2[0], t);
          v2[1] = quadraticAt(p0[1], p1[1], p2[1], t);
          v3[0] = quadraticAt(p0[0], p1[0], p2[0], next);
          v3[1] = quadraticAt(p0[1], p1[1], p2[1], next);
          var diff = v2DistSquare(v2, center) - radiusSquare;

          if (mathAbs(diff) < 1e-2) {
            break;
          } // var prevDiff = v2DistSquare(v1, center) - radiusSquare;


          var nextDiff = v2DistSquare(v3, center) - radiusSquare;
          interval /= 2;

          if (diff < 0) {
            if (nextDiff >= 0) {
              t = t + interval;
            } else {
              t = t - interval;
            }
          } else {
            if (nextDiff >= 0) {
              t = t - interval;
            } else {
              t = t + interval;
            }
          }
        }

        return t;
      } // Adjust edge to avoid


      function _default(graph, scale) {
        var tmp0 = [];
        var quadraticSubdivide = curveTool.quadraticSubdivide;
        var pts = [[], [], []];
        var pts2 = [[], []];
        var v = [];
        scale /= 2;
        graph.eachEdge(function (edge, idx) {
          var linePoints = edge.getLayout();
          var fromSymbol = edge.getVisual('fromSymbol');
          var toSymbol = edge.getVisual('toSymbol');

          if (!linePoints.__original) {
            linePoints.__original = [vec2.clone(linePoints[0]), vec2.clone(linePoints[1])];

            if (linePoints[2]) {
              linePoints.__original.push(vec2.clone(linePoints[2]));
            }
          }

          var originalPoints = linePoints.__original; // Quadratic curve

          if (linePoints[2] != null) {
            vec2.copy(pts[0], originalPoints[0]);
            vec2.copy(pts[1], originalPoints[2]);
            vec2.copy(pts[2], originalPoints[1]);

            if (fromSymbol && fromSymbol !== 'none') {
              var symbolSize = getSymbolSize(edge.node1);
              var t = intersectCurveCircle(pts, originalPoints[0], symbolSize * scale); // Subdivide and get the second

              quadraticSubdivide(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
              pts[0][0] = tmp0[3];
              pts[1][0] = tmp0[4];
              quadraticSubdivide(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
              pts[0][1] = tmp0[3];
              pts[1][1] = tmp0[4];
            }

            if (toSymbol && toSymbol !== 'none') {
              var symbolSize = getSymbolSize(edge.node2);
              var t = intersectCurveCircle(pts, originalPoints[1], symbolSize * scale); // Subdivide and get the first

              quadraticSubdivide(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
              pts[1][0] = tmp0[1];
              pts[2][0] = tmp0[2];
              quadraticSubdivide(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
              pts[1][1] = tmp0[1];
              pts[2][1] = tmp0[2];
            } // Copy back to layout


            vec2.copy(linePoints[0], pts[0]);
            vec2.copy(linePoints[1], pts[2]);
            vec2.copy(linePoints[2], pts[1]);
          } // Line
          else {
            vec2.copy(pts2[0], originalPoints[0]);
            vec2.copy(pts2[1], originalPoints[1]);
            vec2.sub(v, pts2[1], pts2[0]);
            vec2.normalize(v, v);

            if (fromSymbol && fromSymbol !== 'none') {
              var symbolSize = getSymbolSize(edge.node1);
              vec2.scaleAndAdd(pts2[0], pts2[0], v, symbolSize * scale);
            }

            if (toSymbol && toSymbol !== 'none') {
              var symbolSize = getSymbolSize(edge.node2);
              vec2.scaleAndAdd(pts2[1], pts2[1], v, -symbolSize * scale);
            }

            vec2.copy(linePoints[0], pts2[0]);
            vec2.copy(linePoints[1], pts2[1]);
          }
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "SKx+":
    /*!****************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js ***!
      \****************************************************************************/

    /*! no static exports found */

    /***/
    function SKx(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var AxisPointerModel = echarts.extendComponentModel({
        type: 'axisPointer',
        coordSysAxesInfo: null,
        defaultOption: {
          // 'auto' means that show when triggered by tooltip or handle.
          show: 'auto',
          // 'click' | 'mousemove' | 'none'
          triggerOn: null,
          // set default in AxisPonterView.js
          zlevel: 0,
          z: 50,
          type: 'line',
          // 'line' 'shadow' 'cross' 'none'.
          // axispointer triggered by tootip determine snap automatically,
          // see `modelHelper`.
          snap: false,
          triggerTooltip: true,
          value: null,
          status: null,
          // Init value depends on whether handle is used.
          // [group0, group1, ...]
          // Each group can be: {
          //      mapper: function () {},
          //      singleTooltip: 'multiple',  // 'multiple' or 'single'
          //      xAxisId: ...,
          //      yAxisName: ...,
          //      angleAxisIndex: ...
          // }
          // mapper: can be ignored.
          //      input: {axisInfo, value}
          //      output: {axisInfo, value}
          link: [],
          // Do not set 'auto' here, otherwise global animation: false
          // will not effect at this axispointer.
          animation: null,
          animationDurationUpdate: 200,
          lineStyle: {
            color: '#aaa',
            width: 1,
            type: 'solid'
          },
          shadowStyle: {
            color: 'rgba(150,150,150,0.3)'
          },
          label: {
            show: true,
            formatter: null,
            // string | Function
            precision: 'auto',
            // Or a number like 0, 1, 2 ...
            margin: 3,
            color: '#fff',
            padding: [5, 7, 5, 7],
            backgroundColor: 'auto',
            // default: axis line color
            borderColor: null,
            borderWidth: 0,
            shadowBlur: 3,
            shadowColor: '#aaa' // Considering applicability, common style should
            // better not have shadowOffset.
            // shadowOffsetX: 0,
            // shadowOffsetY: 2

          },
          handle: {
            show: false,

            /* eslint-disable */
            icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',
            // jshint ignore:line

            /* eslint-enable */
            size: 45,
            // handle margin is from symbol center to axis, which is stable when circular move.
            margin: 50,
            // color: '#1b8bbd'
            // color: '#2f4554'
            color: '#333',
            shadowBlur: 3,
            shadowColor: '#aaa',
            shadowOffsetX: 0,
            shadowOffsetY: 2,
            // For mobile performance
            throttle: 40
          }
        }
      });
      var _default = AxisPointerModel;
      module.exports = _default;
      /***/
    },

    /***/
    "SMc4":
    /*!***************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/cartesian/AxisModel.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function SMc4(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var ComponentModel = __webpack_require__(
      /*! ../../model/Component */
      "bLfw");

      var axisModelCreator = __webpack_require__(
      /*! ../axisModelCreator */
      "nkfE");

      var axisModelCommonMixin = __webpack_require__(
      /*! ../axisModelCommonMixin */
      "ICMv");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var AxisModel = ComponentModel.extend({
        type: 'cartesian2dAxis',

        /**
         * @type {module:echarts/coord/cartesian/Axis2D}
         */
        axis: null,

        /**
         * @override
         */
        init: function init() {
          AxisModel.superApply(this, 'init', arguments);
          this.resetRange();
        },

        /**
         * @override
         */
        mergeOption: function mergeOption() {
          AxisModel.superApply(this, 'mergeOption', arguments);
          this.resetRange();
        },

        /**
         * @override
         */
        restoreData: function restoreData() {
          AxisModel.superApply(this, 'restoreData', arguments);
          this.resetRange();
        },

        /**
         * @override
         * @return {module:echarts/model/Component}
         */
        getCoordSysModel: function getCoordSysModel() {
          return this.ecModel.queryComponents({
            mainType: 'grid',
            index: this.option.gridIndex,
            id: this.option.gridId
          })[0];
        }
      });

      function getAxisType(axisDim, option) {
        // Default axis with data is category axis
        return option.type || (option.data ? 'category' : 'value');
      }

      zrUtil.merge(AxisModel.prototype, axisModelCommonMixin);
      var extraOption = {
        // gridIndex: 0,
        // gridId: '',
        // Offset is for multiple axis on the same position
        offset: 0
      };
      axisModelCreator('x', AxisModel, getAxisType, extraOption);
      axisModelCreator('y', AxisModel, getAxisType, extraOption);
      var _default = AxisModel;
      module.exports = _default;
      /***/
    },

    /***/
    "SehX":
    /*!****************************************************!*\
      !*** ./node_modules/echarts/lib/action/geoRoam.js ***!
      \****************************************************/

    /*! no static exports found */

    /***/
    function SehX(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _roamHelper = __webpack_require__(
      /*! ./roamHelper */
      "2B6p");

      var updateCenterAndZoom = _roamHelper.updateCenterAndZoom;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @payload
       * @property {string} [componentType=series]
       * @property {number} [dx]
       * @property {number} [dy]
       * @property {number} [zoom]
       * @property {number} [originX]
       * @property {number} [originY]
       */

      echarts.registerAction({
        type: 'geoRoam',
        event: 'geoRoam',
        update: 'updateTransform'
      }, function (payload, ecModel) {
        var componentType = payload.componentType || 'series';
        ecModel.eachComponent({
          mainType: componentType,
          query: payload
        }, function (componentModel) {
          var geo = componentModel.coordinateSystem;

          if (geo.type !== 'geo') {
            return;
          }

          var res = updateCenterAndZoom(geo, payload, componentModel.get('scaleLimit'));
          componentModel.setCenter && componentModel.setCenter(res.center);
          componentModel.setZoom && componentModel.setZoom(res.zoom); // All map series with same `map` use the same geo coordinate system
          // So the center and zoom must be in sync. Include the series not selected by legend

          if (componentType === 'series') {
            zrUtil.each(componentModel.seriesGroup, function (seriesModel) {
              seriesModel.setCenter(res.center);
              seriesModel.setZoom(res.zoom);
            });
          }
        });
      });
      /***/
    },

    /***/
    "SgGq":
    /*!*********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/helper/RoamController.js ***!
      \*********************************************************************/

    /*! no static exports found */

    /***/
    function SgGq(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var Eventful = __webpack_require__(
      /*! zrender/lib/mixin/Eventful */
      "H6uX");

      var eventTool = __webpack_require__(
      /*! zrender/lib/core/event */
      "YH21");

      var interactionMutex = __webpack_require__(
      /*! ./interactionMutex */
      "pP6R");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @alias module:echarts/component/helper/RoamController
       * @constructor
       * @mixin {module:zrender/mixin/Eventful}
       *
       * @param {module:zrender/zrender~ZRender} zr
       */


      function RoamController(zr) {
        /**
         * @type {Function}
         */
        this.pointerChecker;
        /**
         * @type {module:zrender}
         */

        this._zr = zr;
        /**
         * @type {Object}
         */

        this._opt = {}; // Avoid two roamController bind the same handler

        var bind = zrUtil.bind;
        var mousedownHandler = bind(mousedown, this);
        var mousemoveHandler = bind(mousemove, this);
        var mouseupHandler = bind(mouseup, this);
        var mousewheelHandler = bind(mousewheel, this);
        var pinchHandler = bind(pinch, this);
        Eventful.call(this);
        /**
         * @param {Function} pointerChecker
         *                   input: x, y
         *                   output: boolean
         */

        this.setPointerChecker = function (pointerChecker) {
          this.pointerChecker = pointerChecker;
        };
        /**
         * Notice: only enable needed types. For example, if 'zoom'
         * is not needed, 'zoom' should not be enabled, otherwise
         * default mousewheel behaviour (scroll page) will be disabled.
         *
         * @param  {boolean|string} [controlType=true] Specify the control type,
         *                          which can be null/undefined or true/false
         *                          or 'pan/move' or 'zoom'/'scale'
         * @param {Object} [opt]
         * @param {Object} [opt.zoomOnMouseWheel=true] The value can be: true / false / 'shift' / 'ctrl' / 'alt'.
         * @param {Object} [opt.moveOnMouseMove=true] The value can be: true / false / 'shift' / 'ctrl' / 'alt'.
         * @param {Object} [opt.moveOnMouseWheel=false] The value can be: true / false / 'shift' / 'ctrl' / 'alt'.
         * @param {Object} [opt.preventDefaultMouseMove=true] When pan.
         */


        this.enable = function (controlType, opt) {
          // Disable previous first
          this.disable();
          this._opt = zrUtil.defaults(zrUtil.clone(opt) || {}, {
            zoomOnMouseWheel: true,
            moveOnMouseMove: true,
            // By default, wheel do not trigger move.
            moveOnMouseWheel: false,
            preventDefaultMouseMove: true
          });

          if (controlType == null) {
            controlType = true;
          }

          if (controlType === true || controlType === 'move' || controlType === 'pan') {
            zr.on('mousedown', mousedownHandler);
            zr.on('mousemove', mousemoveHandler);
            zr.on('mouseup', mouseupHandler);
          }

          if (controlType === true || controlType === 'scale' || controlType === 'zoom') {
            zr.on('mousewheel', mousewheelHandler);
            zr.on('pinch', pinchHandler);
          }
        };

        this.disable = function () {
          zr.off('mousedown', mousedownHandler);
          zr.off('mousemove', mousemoveHandler);
          zr.off('mouseup', mouseupHandler);
          zr.off('mousewheel', mousewheelHandler);
          zr.off('pinch', pinchHandler);
        };

        this.dispose = this.disable;

        this.isDragging = function () {
          return this._dragging;
        };

        this.isPinching = function () {
          return this._pinching;
        };
      }

      zrUtil.mixin(RoamController, Eventful);

      function mousedown(e) {
        if (eventTool.isMiddleOrRightButtonOnMouseUpDown(e) || e.target && e.target.draggable) {
          return;
        }

        var x = e.offsetX;
        var y = e.offsetY; // Only check on mosedown, but not mousemove.
        // Mouse can be out of target when mouse moving.

        if (this.pointerChecker && this.pointerChecker(e, x, y)) {
          this._x = x;
          this._y = y;
          this._dragging = true;
        }
      }

      function mousemove(e) {
        if (!this._dragging || !isAvailableBehavior('moveOnMouseMove', e, this._opt) || e.gestureEvent === 'pinch' || interactionMutex.isTaken(this._zr, 'globalPan')) {
          return;
        }

        var x = e.offsetX;
        var y = e.offsetY;
        var oldX = this._x;
        var oldY = this._y;
        var dx = x - oldX;
        var dy = y - oldY;
        this._x = x;
        this._y = y;
        this._opt.preventDefaultMouseMove && eventTool.stop(e.event);
        trigger(this, 'pan', 'moveOnMouseMove', e, {
          dx: dx,
          dy: dy,
          oldX: oldX,
          oldY: oldY,
          newX: x,
          newY: y
        });
      }

      function mouseup(e) {
        if (!eventTool.isMiddleOrRightButtonOnMouseUpDown(e)) {
          this._dragging = false;
        }
      }

      function mousewheel(e) {
        var shouldZoom = isAvailableBehavior('zoomOnMouseWheel', e, this._opt);
        var shouldMove = isAvailableBehavior('moveOnMouseWheel', e, this._opt);
        var wheelDelta = e.wheelDelta;
        var absWheelDeltaDelta = Math.abs(wheelDelta);
        var originX = e.offsetX;
        var originY = e.offsetY; // wheelDelta maybe -0 in chrome mac.

        if (wheelDelta === 0 || !shouldZoom && !shouldMove) {
          return;
        } // If both `shouldZoom` and `shouldMove` is true, trigger
        // their event both, and the final behavior is determined
        // by event listener themselves.


        if (shouldZoom) {
          // Convenience:
          // Mac and VM Windows on Mac: scroll up: zoom out.
          // Windows: scroll up: zoom in.
          // FIXME: Should do more test in different environment.
          // wheelDelta is too complicated in difference nvironment
          // (https://developer.mozilla.org/en-US/docs/Web/Events/mousewheel),
          // although it has been normallized by zrender.
          // wheelDelta of mouse wheel is bigger than touch pad.
          var factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;
          var scale = wheelDelta > 0 ? factor : 1 / factor;
          checkPointerAndTrigger(this, 'zoom', 'zoomOnMouseWheel', e, {
            scale: scale,
            originX: originX,
            originY: originY
          });
        }

        if (shouldMove) {
          // FIXME: Should do more test in different environment.
          var absDelta = Math.abs(wheelDelta); // wheelDelta of mouse wheel is bigger than touch pad.

          var scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05);
          checkPointerAndTrigger(this, 'scrollMove', 'moveOnMouseWheel', e, {
            scrollDelta: scrollDelta,
            originX: originX,
            originY: originY
          });
        }
      }

      function pinch(e) {
        if (interactionMutex.isTaken(this._zr, 'globalPan')) {
          return;
        }

        var scale = e.pinchScale > 1 ? 1.1 : 1 / 1.1;
        checkPointerAndTrigger(this, 'zoom', null, e, {
          scale: scale,
          originX: e.pinchX,
          originY: e.pinchY
        });
      }

      function checkPointerAndTrigger(controller, eventName, behaviorToCheck, e, contollerEvent) {
        if (controller.pointerChecker && controller.pointerChecker(e, contollerEvent.originX, contollerEvent.originY)) {
          // When mouse is out of roamController rect,
          // default befavoius should not be be disabled, otherwise
          // page sliding is disabled, contrary to expectation.
          eventTool.stop(e.event);
          trigger(controller, eventName, behaviorToCheck, e, contollerEvent);
        }
      }

      function trigger(controller, eventName, behaviorToCheck, e, contollerEvent) {
        // Also provide behavior checker for event listener, for some case that
        // multiple components share one listener.
        contollerEvent.isAvailableBehavior = zrUtil.bind(isAvailableBehavior, null, behaviorToCheck, e);
        controller.trigger(eventName, contollerEvent);
      } // settings: {
      //     zoomOnMouseWheel
      //     moveOnMouseMove
      //     moveOnMouseWheel
      // }
      // The value can be: true / false / 'shift' / 'ctrl' / 'alt'.


      function isAvailableBehavior(behaviorToCheck, e, settings) {
        var setting = settings[behaviorToCheck];
        return !behaviorToCheck || setting && (!zrUtil.isString(setting) || e.event[setting + 'Key']);
      }

      var _default = RoamController;
      module.exports = _default;
      /***/
    },

    /***/
    "Sp2Z":
    /*!********************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js ***!
      \********************************************************************************/

    /*! no static exports found */

    /***/
    function Sp2Z(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var BaseAxisPointer = __webpack_require__(
      /*! ./BaseAxisPointer */
      "3LNs");

      var viewHelper = __webpack_require__(
      /*! ./viewHelper */
      "/y7N");

      var cartesianAxisHelper = __webpack_require__(
      /*! ../../coord/cartesian/cartesianAxisHelper */
      "AVZG");

      var AxisView = __webpack_require__(
      /*! ../axis/AxisView */
      "Znkb");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var CartesianAxisPointer = BaseAxisPointer.extend({
        /**
         * @override
         */
        makeElOption: function makeElOption(elOption, value, axisModel, axisPointerModel, api) {
          var axis = axisModel.axis;
          var grid = axis.grid;
          var axisPointerType = axisPointerModel.get('type');
          var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
          var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));

          if (axisPointerType && axisPointerType !== 'none') {
            var elStyle = viewHelper.buildElStyle(axisPointerModel);
            var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
            pointerOption.style = elStyle;
            elOption.graphicKey = pointerOption.type;
            elOption.pointer = pointerOption;
          }

          var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);
          viewHelper.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
        },

        /**
         * @override
         */
        getHandleTransform: function getHandleTransform(value, axisModel, axisPointerModel) {
          var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {
            labelInside: false
          });
          layoutInfo.labelMargin = axisPointerModel.get('handle.margin');
          return {
            position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),
            rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
          };
        },

        /**
         * @override
         */
        updateHandleTransform: function updateHandleTransform(transform, delta, axisModel, axisPointerModel) {
          var axis = axisModel.axis;
          var grid = axis.grid;
          var axisExtent = axis.getGlobalExtent(true);
          var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
          var dimIndex = axis.dim === 'x' ? 0 : 1;
          var currPosition = transform.position;
          currPosition[dimIndex] += delta[dimIndex];
          currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
          currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
          var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
          var cursorPoint = [cursorOtherValue, cursorOtherValue];
          cursorPoint[dimIndex] = currPosition[dimIndex]; // Make tooltip do not overlap axisPointer and in the middle of the grid.

          var tooltipOptions = [{
            verticalAlign: 'middle'
          }, {
            align: 'center'
          }];
          return {
            position: currPosition,
            rotation: transform.rotation,
            cursorPoint: cursorPoint,
            tooltipOption: tooltipOptions[dimIndex]
          };
        }
      });

      function getCartesian(grid, axis) {
        var opt = {};
        opt[axis.dim + 'AxisIndex'] = axis.index;
        return grid.getCartesian(opt);
      }

      var pointerShapeBuilder = {
        line: function line(axis, pixelValue, otherExtent) {
          var targetShape = viewHelper.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
          return {
            type: 'Line',
            subPixelOptimize: true,
            shape: targetShape
          };
        },
        shadow: function shadow(axis, pixelValue, otherExtent) {
          var bandWidth = Math.max(1, axis.getBandWidth());
          var span = otherExtent[1] - otherExtent[0];
          return {
            type: 'Rect',
            shape: viewHelper.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
          };
        }
      };

      function getAxisDimIndex(axis) {
        return axis.dim === 'x' ? 0 : 1;
      }

      AxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);
      var _default = CartesianAxisPointer;
      module.exports = _default;
      /***/
    },

    /***/
    "SrGk":
    /*!**********************************************************!*\
      !*** ./node_modules/zrender/lib/svg/helper/Definable.js ***!
      \**********************************************************/

    /*! no static exports found */

    /***/
    function SrGk(module, exports, __webpack_require__) {
      var _core = __webpack_require__(
      /*! ../core */
      "hydK");

      var createElement = _core.createElement;

      var zrUtil = __webpack_require__(
      /*! ../../core/util */
      "bYtY");

      var Path = __webpack_require__(
      /*! ../../graphic/Path */
      "y+Vt");

      var ZImage = __webpack_require__(
      /*! ../../graphic/Image */
      "Dagg");

      var ZText = __webpack_require__(
      /*! ../../graphic/Text */
      "dqUG");

      var _graphic = __webpack_require__(
      /*! ../graphic */
      "P47w");

      var svgPath = _graphic.path;
      var svgImage = _graphic.image;
      var svgText = _graphic.text;
      /**
       * @file Manages elements that can be defined in <defs> in SVG,
       *       e.g., gradients, clip path, etc.
       * @author Zhang Wenli
       */

      var MARK_UNUSED = '0';
      var MARK_USED = '1';
      /**
       * Manages elements that can be defined in <defs> in SVG,
       * e.g., gradients, clip path, etc.
       *
       * @class
       * @param {number}          zrId      zrender instance id
       * @param {SVGElement}      svgRoot   root of SVG document
       * @param {string|string[]} tagNames  possible tag names
       * @param {string}          markLabel label name to make if the element
       *                                    is used
       */

      function Definable(zrId, svgRoot, tagNames, markLabel, domName) {
        this._zrId = zrId;
        this._svgRoot = svgRoot;
        this._tagNames = typeof tagNames === 'string' ? [tagNames] : tagNames;
        this._markLabel = markLabel;
        this._domName = domName || '_dom';
        this.nextId = 0;
      }

      Definable.prototype.createElement = createElement;
      /**
       * Get the <defs> tag for svgRoot; optionally creates one if not exists.
       *
       * @param {boolean} isForceCreating if need to create when not exists
       * @return {SVGDefsElement} SVG <defs> element, null if it doesn't
       * exist and isForceCreating is false
       */

      Definable.prototype.getDefs = function (isForceCreating) {
        var svgRoot = this._svgRoot;

        var defs = this._svgRoot.getElementsByTagName('defs');

        if (defs.length === 0) {
          // Not exist
          if (isForceCreating) {
            defs = svgRoot.insertBefore(this.createElement('defs'), // Create new tag
            svgRoot.firstChild // Insert in the front of svg
            );

            if (!defs.contains) {
              // IE doesn't support contains method
              defs.contains = function (el) {
                var children = defs.children;

                if (!children) {
                  return false;
                }

                for (var i = children.length - 1; i >= 0; --i) {
                  if (children[i] === el) {
                    return true;
                  }
                }

                return false;
              };
            }

            return defs;
          } else {
            return null;
          }
        } else {
          return defs[0];
        }
      };
      /**
       * Update DOM element if necessary.
       *
       * @param {Object|string} element style element. e.g., for gradient,
       *                                it may be '#ccc' or {type: 'linear', ...}
       * @param {Function|undefined} onUpdate update callback
       */


      Definable.prototype.update = function (element, onUpdate) {
        if (!element) {
          return;
        }

        var defs = this.getDefs(false);

        if (element[this._domName] && defs.contains(element[this._domName])) {
          // Update DOM
          if (typeof onUpdate === 'function') {
            onUpdate(element);
          }
        } else {
          // No previous dom, create new
          var dom = this.add(element);

          if (dom) {
            element[this._domName] = dom;
          }
        }
      };
      /**
       * Add gradient dom to defs
       *
       * @param {SVGElement} dom DOM to be added to <defs>
       */


      Definable.prototype.addDom = function (dom) {
        var defs = this.getDefs(true);
        defs.appendChild(dom);
      };
      /**
       * Remove DOM of a given element.
       *
       * @param {SVGElement} element element to remove dom
       */


      Definable.prototype.removeDom = function (element) {
        var defs = this.getDefs(false);

        if (defs && element[this._domName]) {
          defs.removeChild(element[this._domName]);
          element[this._domName] = null;
        }
      };
      /**
       * Get DOMs of this element.
       *
       * @return {HTMLDomElement} doms of this defineable elements in <defs>
       */


      Definable.prototype.getDoms = function () {
        var defs = this.getDefs(false);

        if (!defs) {
          // No dom when defs is not defined
          return [];
        }

        var doms = [];
        zrUtil.each(this._tagNames, function (tagName) {
          var tags = defs.getElementsByTagName(tagName); // Note that tags is HTMLCollection, which is array-like
          // rather than real array.
          // So `doms.concat(tags)` add tags as one object.

          doms = doms.concat([].slice.call(tags));
        });
        return doms;
      };
      /**
       * Mark DOMs to be unused before painting, and clear unused ones at the end
       * of the painting.
       */


      Definable.prototype.markAllUnused = function () {
        var doms = this.getDoms();
        var that = this;
        zrUtil.each(doms, function (dom) {
          dom[that._markLabel] = MARK_UNUSED;
        });
      };
      /**
       * Mark a single DOM to be used.
       *
       * @param {SVGElement} dom DOM to mark
       */


      Definable.prototype.markUsed = function (dom) {
        if (dom) {
          dom[this._markLabel] = MARK_USED;
        }
      };
      /**
       * Remove unused DOMs defined in <defs>
       */


      Definable.prototype.removeUnused = function () {
        var defs = this.getDefs(false);

        if (!defs) {
          // Nothing to remove
          return;
        }

        var doms = this.getDoms();
        var that = this;
        zrUtil.each(doms, function (dom) {
          if (dom[that._markLabel] !== MARK_USED) {
            // Remove gradient
            defs.removeChild(dom);
          }
        });
      };
      /**
       * Get SVG proxy.
       *
       * @param {Displayable} displayable displayable element
       * @return {Path|Image|Text} svg proxy of given element
       */


      Definable.prototype.getSvgProxy = function (displayable) {
        if (displayable instanceof Path) {
          return svgPath;
        } else if (displayable instanceof ZImage) {
          return svgImage;
        } else if (displayable instanceof ZText) {
          return svgText;
        } else {
          return svgPath;
        }
      };
      /**
       * Get text SVG element.
       *
       * @param {Displayable} displayable displayable element
       * @return {SVGElement} SVG element of text
       */


      Definable.prototype.getTextSvgElement = function (displayable) {
        return displayable.__textSvgEl;
      };
      /**
       * Get SVG element.
       *
       * @param {Displayable} displayable displayable element
       * @return {SVGElement} SVG element
       */


      Definable.prototype.getSvgElement = function (displayable) {
        return displayable.__svgEl;
      };

      var _default = Definable;
      module.exports = _default;
      /***/
    },

    /***/
    "Swgg":
    /*!***********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/dataZoom/SelectZoomView.js ***!
      \***********************************************************************/

    /*! no static exports found */

    /***/
    function Swgg(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var DataZoomView = __webpack_require__(
      /*! ./DataZoomView */
      "fc+c");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = DataZoomView.extend({
        type: 'dataZoom.select'
      });

      module.exports = _default;
      /***/
    },

    /***/
    "TIY9":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/geo/geoJSONLoader.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function TIY9(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _util = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var each = _util.each;

      var parseGeoJson = __webpack_require__(
      /*! ./parseGeoJson */
      "vafp");

      var _model = __webpack_require__(
      /*! ../../util/model */
      "4NO4");

      var makeInner = _model.makeInner;

      var fixNanhai = __webpack_require__(
      /*! ./fix/nanhai */
      "Mgri");

      var fixTextCoord = __webpack_require__(
      /*! ./fix/textCoord */
      "F5Ls");

      var fixGeoCoord = __webpack_require__(
      /*! ./fix/geoCoord */
      "a9QJ");

      var fixDiaoyuIsland = __webpack_require__(
      /*! ./fix/diaoyuIsland */
      "p/La");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // Built-in GEO fixer.


      var inner = makeInner();
      var _default = {
        /**
         * @param {string} mapName
         * @param {Object} mapRecord {specialAreas, geoJSON}
         * @param {string} nameProperty
         * @return {Object} {regions, boundingRect}
         */
        load: function load(mapName, mapRecord, nameProperty) {
          var parsed = inner(mapRecord).parsed;

          if (parsed) {
            return parsed;
          }

          var specialAreas = mapRecord.specialAreas || {};
          var geoJSON = mapRecord.geoJSON;
          var regions; // https://jsperf.com/try-catch-performance-overhead

          try {
            regions = geoJSON ? parseGeoJson(geoJSON, nameProperty) : [];
          } catch (e) {
            throw new Error('Invalid geoJson format\n' + e.message);
          }

          fixNanhai(mapName, regions);
          each(regions, function (region) {
            var regionName = region.name;
            fixTextCoord(mapName, region);
            fixGeoCoord(mapName, region);
            fixDiaoyuIsland(mapName, region); // Some area like Alaska in USA map needs to be tansformed
            // to look better

            var specialArea = specialAreas[regionName];

            if (specialArea) {
              region.transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);
            }
          });
          return inner(mapRecord).parsed = {
            regions: regions,
            boundingRect: getBoundingRect(regions)
          };
        }
      };

      function getBoundingRect(regions) {
        var rect;

        for (var i = 0; i < regions.length; i++) {
          var regionRect = regions[i].getBoundingRect();
          rect = rect || regionRect.clone();
          rect.union(regionRect);
        }

        return rect;
      }

      module.exports = _default;
      /***/
    },

    /***/
    "TJmX":
    /*!*************************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/candlestick/candlestickVisual.js ***!
      \*************************************************************************/

    /*! no static exports found */

    /***/
    function TJmX(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var createRenderPlanner = __webpack_require__(
      /*! ../helper/createRenderPlanner */
      "zM3Q");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var positiveBorderColorQuery = ['itemStyle', 'borderColor'];
      var negativeBorderColorQuery = ['itemStyle', 'borderColor0'];
      var positiveColorQuery = ['itemStyle', 'color'];
      var negativeColorQuery = ['itemStyle', 'color0'];
      var _default = {
        seriesType: 'candlestick',
        plan: createRenderPlanner(),
        // For legend.
        performRawSeries: true,
        reset: function reset(seriesModel, ecModel) {
          var data = seriesModel.getData();
          data.setVisual({
            legendSymbol: 'roundRect',
            colorP: getColor(1, seriesModel),
            colorN: getColor(-1, seriesModel),
            borderColorP: getBorderColor(1, seriesModel),
            borderColorN: getBorderColor(-1, seriesModel)
          }); // Only visible series has each data be visual encoded

          if (ecModel.isSeriesFiltered(seriesModel)) {
            return;
          }

          var isLargeRender = seriesModel.pipelineContext.large;
          return !isLargeRender && {
            progress: progress
          };

          function progress(params, data) {
            var dataIndex;

            while ((dataIndex = params.next()) != null) {
              var itemModel = data.getItemModel(dataIndex);
              var sign = data.getItemLayout(dataIndex).sign;
              data.setItemVisual(dataIndex, {
                color: getColor(sign, itemModel),
                borderColor: getBorderColor(sign, itemModel)
              });
            }
          }

          function getColor(sign, model) {
            return model.get(sign > 0 ? positiveColorQuery : negativeColorQuery);
          }

          function getBorderColor(sign, model) {
            return model.get(sign > 0 ? positiveBorderColorQuery : negativeBorderColorQuery);
          }
        }
      };
      module.exports = _default;
      /***/
    },

    /***/
    "TWL2":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/funnel/FunnelView.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function TWL2(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var ChartView = __webpack_require__(
      /*! ../../view/Chart */
      "6Ic6");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Piece of pie including Sector, Label, LabelLine
       * @constructor
       * @extends {module:zrender/graphic/Group}
       */


      function FunnelPiece(data, idx) {
        graphic.Group.call(this);
        var polygon = new graphic.Polygon();
        var labelLine = new graphic.Polyline();
        var text = new graphic.Text();
        this.add(polygon);
        this.add(labelLine);
        this.add(text);

        this.highDownOnUpdate = function (fromState, toState) {
          if (toState === 'emphasis') {
            labelLine.ignore = labelLine.hoverIgnore;
            text.ignore = text.hoverIgnore;
          } else {
            labelLine.ignore = labelLine.normalIgnore;
            text.ignore = text.normalIgnore;
          }
        };

        this.updateData(data, idx, true);
      }

      var funnelPieceProto = FunnelPiece.prototype;
      var opacityAccessPath = ['itemStyle', 'opacity'];

      funnelPieceProto.updateData = function (data, idx, firstCreate) {
        var polygon = this.childAt(0);
        var seriesModel = data.hostModel;
        var itemModel = data.getItemModel(idx);
        var layout = data.getItemLayout(idx);
        var opacity = data.getItemModel(idx).get(opacityAccessPath);
        opacity = opacity == null ? 1 : opacity; // Reset style

        polygon.useStyle({});

        if (firstCreate) {
          polygon.setShape({
            points: layout.points
          });
          polygon.setStyle({
            opacity: 0
          });
          graphic.initProps(polygon, {
            style: {
              opacity: opacity
            }
          }, seriesModel, idx);
        } else {
          graphic.updateProps(polygon, {
            style: {
              opacity: opacity
            },
            shape: {
              points: layout.points
            }
          }, seriesModel, idx);
        } // Update common style


        var itemStyleModel = itemModel.getModel('itemStyle');
        var visualColor = data.getItemVisual(idx, 'color');
        polygon.setStyle(zrUtil.defaults({
          lineJoin: 'round',
          fill: visualColor
        }, itemStyleModel.getItemStyle(['opacity'])));
        polygon.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();

        this._updateLabel(data, idx);

        graphic.setHoverStyle(this);
      };

      funnelPieceProto._updateLabel = function (data, idx) {
        var labelLine = this.childAt(1);
        var labelText = this.childAt(2);
        var seriesModel = data.hostModel;
        var itemModel = data.getItemModel(idx);
        var layout = data.getItemLayout(idx);
        var labelLayout = layout.label;
        var visualColor = data.getItemVisual(idx, 'color');
        graphic.updateProps(labelLine, {
          shape: {
            points: labelLayout.linePoints || labelLayout.linePoints
          }
        }, seriesModel, idx);
        graphic.updateProps(labelText, {
          style: {
            x: labelLayout.x,
            y: labelLayout.y
          }
        }, seriesModel, idx);
        labelText.attr({
          rotation: labelLayout.rotation,
          origin: [labelLayout.x, labelLayout.y],
          z2: 10
        });
        var labelModel = itemModel.getModel('label');
        var labelHoverModel = itemModel.getModel('emphasis.label');
        var labelLineModel = itemModel.getModel('labelLine');
        var labelLineHoverModel = itemModel.getModel('emphasis.labelLine');
        var visualColor = data.getItemVisual(idx, 'color');
        graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {
          labelFetcher: data.hostModel,
          labelDataIndex: idx,
          defaultText: data.getName(idx),
          autoColor: visualColor,
          useInsideStyle: !!labelLayout.inside
        }, {
          textAlign: labelLayout.textAlign,
          textVerticalAlign: labelLayout.verticalAlign
        });
        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');
        labelText.hoverIgnore = !labelHoverModel.get('show');
        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');
        labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color

        labelLine.setStyle({
          stroke: visualColor
        });
        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());
        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();
      };

      zrUtil.inherits(FunnelPiece, graphic.Group);
      var FunnelView = ChartView.extend({
        type: 'funnel',
        render: function render(seriesModel, ecModel, api) {
          var data = seriesModel.getData();
          var oldData = this._data;
          var group = this.group;
          data.diff(oldData).add(function (idx) {
            var funnelPiece = new FunnelPiece(data, idx);
            data.setItemGraphicEl(idx, funnelPiece);
            group.add(funnelPiece);
          }).update(function (newIdx, oldIdx) {
            var piePiece = oldData.getItemGraphicEl(oldIdx);
            piePiece.updateData(data, newIdx);
            group.add(piePiece);
            data.setItemGraphicEl(newIdx, piePiece);
          }).remove(function (idx) {
            var piePiece = oldData.getItemGraphicEl(idx);
            group.remove(piePiece);
          }).execute();
          this._data = data;
        },
        remove: function remove() {
          this.group.removeAll();
          this._data = null;
        },
        dispose: function dispose() {}
      });
      var _default = FunnelView;
      module.exports = _default;
      /***/
    },

    /***/
    "TYVI":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/gauge/GaugeSeries.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function TYVI(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var createListSimply = __webpack_require__(
      /*! ../helper/createListSimply */
      "5GtS");

      var SeriesModel = __webpack_require__(
      /*! ../../model/Series */
      "T4UG");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var GaugeSeries = SeriesModel.extend({
        type: 'series.gauge',
        getInitialData: function getInitialData(option, ecModel) {
          return createListSimply(this, ['value']);
        },
        defaultOption: {
          zlevel: 0,
          z: 2,
          // 
          center: ['50%', '50%'],
          legendHoverLink: true,
          radius: '75%',
          startAngle: 225,
          endAngle: -45,
          clockwise: true,
          // 
          min: 0,
          // 
          max: 100,
          // 10
          splitNumber: 10,
          // 
          axisLine: {
            // show
            show: true,
            lineStyle: {
              // lineStyle
              color: [[0.2, '#91c7ae'], [0.8, '#63869e'], [1, '#c23531']],
              width: 30
            }
          },
          // 
          splitLine: {
            // show
            show: true,
            // length
            length: 30,
            // lineStylelineStyle
            lineStyle: {
              color: '#eee',
              width: 2,
              type: 'solid'
            }
          },
          // 
          axisTick: {
            // show
            show: true,
            // split
            splitNumber: 5,
            // length
            length: 8,
            // lineStyle
            lineStyle: {
              color: '#eee',
              width: 1,
              type: 'solid'
            }
          },
          axisLabel: {
            show: true,
            distance: 5,
            // formatter: null,
            color: 'auto'
          },
          pointer: {
            show: true,
            length: '80%',
            width: 8
          },
          itemStyle: {
            color: 'auto'
          },
          title: {
            show: true,
            // x, ypx
            offsetCenter: [0, '-40%'],
            // TEXTSTYLE
            color: '#333',
            fontSize: 15
          },
          detail: {
            show: true,
            backgroundColor: 'rgba(0,0,0,0)',
            borderWidth: 0,
            borderColor: '#ccc',
            width: 100,
            height: null,
            // self-adaption
            padding: [5, 10],
            // x, ypx
            offsetCenter: [0, '40%'],
            // formatter: null,
            // TEXTSTYLE
            color: 'auto',
            fontSize: 30
          }
        }
      });
      var _default = GaugeSeries;
      module.exports = _default;
      /***/
    },

    /***/
    "ThAp":
    /*!*********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/map/MapSeries.js ***!
      \*********************************************************/

    /*! no static exports found */

    /***/
    function ThAp(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var createListSimply = __webpack_require__(
      /*! ../helper/createListSimply */
      "5GtS");

      var SeriesModel = __webpack_require__(
      /*! ../../model/Series */
      "T4UG");

      var _format = __webpack_require__(
      /*! ../../util/format */
      "7aKB");

      var encodeHTML = _format.encodeHTML;
      var addCommas = _format.addCommas;

      var dataSelectableMixin = __webpack_require__(
      /*! ../../component/helper/selectableMixin */
      "cCMj");

      var _dataProvider = __webpack_require__(
      /*! ../../data/helper/dataProvider */
      "KxfA");

      var retrieveRawAttr = _dataProvider.retrieveRawAttr;

      var geoSourceManager = __webpack_require__(
      /*! ../../coord/geo/geoSourceManager */
      "W4dC");

      var _sourceHelper = __webpack_require__(
      /*! ../../data/helper/sourceHelper */
      "D5nY");

      var makeSeriesEncodeForNameBased = _sourceHelper.makeSeriesEncodeForNameBased;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var MapSeries = SeriesModel.extend({
        type: 'series.map',
        dependencies: ['geo'],
        layoutMode: 'box',

        /**
         * Only first map series of same mapType will drawMap
         * @type {boolean}
         */
        needsDrawMap: false,

        /**
         * Group of all map series with same mapType
         * @type {boolean}
         */
        seriesGroup: [],
        getInitialData: function getInitialData(option) {
          var data = createListSimply(this, {
            coordDimensions: ['value'],
            encodeDefaulter: zrUtil.curry(makeSeriesEncodeForNameBased, this)
          });
          var valueDim = data.mapDimension('value');
          var dataNameMap = zrUtil.createHashMap();
          var selectTargetList = [];
          var toAppendNames = [];

          for (var i = 0, len = data.count(); i < len; i++) {
            var name = data.getName(i);
            dataNameMap.set(name, true);
            selectTargetList.push({
              name: name,
              value: data.get(valueDim, i),
              selected: retrieveRawAttr(data, i, 'selected')
            });
          }

          var geoSource = geoSourceManager.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
          zrUtil.each(geoSource.regions, function (region) {
            var name = region.name;

            if (!dataNameMap.get(name)) {
              selectTargetList.push({
                name: name
              });
              toAppendNames.push(name);
            }
          });
          this.updateSelectedMap(selectTargetList); // Complete data with missing regions. The consequent processes (like visual
          // map and render) can not be performed without a "full data". For example,
          // find `dataIndex` by name.

          data.appendValues([], toAppendNames);
          return data;
        },

        /**
         * If no host geo model, return null, which means using a
         * inner exclusive geo model.
         */
        getHostGeoModel: function getHostGeoModel() {
          var geoIndex = this.option.geoIndex;
          return geoIndex != null ? this.dependentModels.geo[geoIndex] : null;
        },
        getMapType: function getMapType() {
          return (this.getHostGeoModel() || this).option.map;
        },
        // _fillOption: function (option, mapName) {
        // Shallow clone
        // option = zrUtil.extend({}, option);
        // option.data = geoCreator.getFilledRegions(option.data, mapName, option.nameMap);
        // return option;
        // },
        getRawValue: function getRawValue(dataIndex) {
          // Use value stored in data instead because it is calculated from multiple series
          // FIXME Provide all value of multiple series ?
          var data = this.getData();
          return data.get(data.mapDimension('value'), dataIndex);
        },

        /**
         * Get model of region
         * @param  {string} name
         * @return {module:echarts/model/Model}
         */
        getRegionModel: function getRegionModel(regionName) {
          var data = this.getData();
          return data.getItemModel(data.indexOfName(regionName));
        },

        /**
         * Map tooltip formatter
         *
         * @param {number} dataIndex
         */
        formatTooltip: function formatTooltip(dataIndex, multipleSeries, dataType, renderMode) {
          // FIXME orignalData and data is a bit confusing
          var data = this.getData();
          var formattedValue = addCommas(this.getRawValue(dataIndex));
          var name = data.getName(dataIndex);
          var seriesGroup = this.seriesGroup;
          var seriesNames = [];

          for (var i = 0; i < seriesGroup.length; i++) {
            var otherIndex = seriesGroup[i].originalData.indexOfName(name);
            var valueDim = data.mapDimension('value');

            if (!isNaN(seriesGroup[i].originalData.get(valueDim, otherIndex))) {
              seriesNames.push(encodeHTML(seriesGroup[i].name));
            }
          }

          var newLine = renderMode === 'html' ? '<br/>' : '\n';
          return seriesNames.join(', ') + newLine + encodeHTML(name + ' : ' + formattedValue);
        },

        /**
         * @implement
         */
        getTooltipPosition: function getTooltipPosition(dataIndex) {
          if (dataIndex != null) {
            var name = this.getData().getName(dataIndex);
            var geo = this.coordinateSystem;
            var region = geo.getRegion(name);
            return region && geo.dataToPoint(region.center);
          }
        },
        setZoom: function setZoom(zoom) {
          this.option.zoom = zoom;
        },
        setCenter: function setCenter(center) {
          this.option.center = center;
        },
        defaultOption: {
          // 
          zlevel: 0,
          // 
          z: 2,
          coordinateSystem: 'geo',
          // map should be explicitly specified since ec3.
          map: '',
          // If `geoIndex` is not specified, a exclusive geo will be
          // created. Otherwise use the specified geo component, and
          // `map` and `mapType` are ignored.
          // geoIndex: 0,
          // 'center' | 'left' | 'right' | 'x%' | {number}
          left: 'center',
          // 'center' | 'top' | 'bottom' | 'x%' | {number}
          top: 'center',
          // right
          // bottom
          // width:
          // height
          // Aspect is width / height. Inited to be geoJson bbox aspect
          // This parameter is used for scale this aspect
          aspectScale: 0.75,
          ///// Layout with center and size
          // If you wan't to put map in a fixed size box with right aspect ratio
          // This two properties may more conveninet
          // layoutCenter: [50%, 50%]
          // layoutSize: 100
          // 
          // 'sum' | 'average' | 'max' | 'min'
          // mapValueCalculation: 'sum',
          // 
          // mapValuePrecision: 0,
          // 
          showLegendSymbol: true,
          // singlemultiple
          // selectedMode: false,
          dataRangeHoverLink: true,
          // 
          // roam: false,
          // Define left-top, right-bottom coords to control view
          // For example, [ [180, 90], [-180, -90] ],
          // higher priority than center and zoom
          boundingCoords: null,
          // Default on center of map
          center: null,
          zoom: 1,
          scaleLimit: null,
          label: {
            show: false,
            color: '#000'
          },
          // scaleLimit: null,
          itemStyle: {
            borderWidth: 0.5,
            borderColor: '#444',
            areaColor: '#eee'
          },
          emphasis: {
            label: {
              show: true,
              color: 'rgb(100,0,0)'
            },
            itemStyle: {
              areaColor: 'rgba(255,215,0,0.8)'
            }
          },
          nameProperty: 'name'
        }
      });
      zrUtil.mixin(MapSeries, dataSelectableMixin);
      var _default = MapSeries;
      module.exports = _default;
      /***/
    },

    /***/
    "TkdX":
    /*!******************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/sunburst/SunburstPiece.js ***!
      \******************************************************************/

    /*! no static exports found */

    /***/
    function TkdX(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var NodeHighlightPolicy = {
        NONE: 'none',
        // not downplay others
        DESCENDANT: 'descendant',
        ANCESTOR: 'ancestor',
        SELF: 'self'
      };
      var DEFAULT_SECTOR_Z = 2;
      var DEFAULT_TEXT_Z = 4;
      /**
       * Sunburstce of Sunburst including Sector, Label, LabelLine
       * @constructor
       * @extends {module:zrender/graphic/Group}
       */

      function SunburstPiece(node, seriesModel, ecModel) {
        graphic.Group.call(this);
        var sector = new graphic.Sector({
          z2: DEFAULT_SECTOR_Z
        });
        sector.seriesIndex = seriesModel.seriesIndex;
        var text = new graphic.Text({
          z2: DEFAULT_TEXT_Z,
          silent: node.getModel('label').get('silent')
        });
        this.add(sector);
        this.add(text);
        this.updateData(true, node, 'normal', seriesModel, ecModel); // Hover to change label and labelLine

        function onEmphasis() {
          text.ignore = text.hoverIgnore;
        }

        function onNormal() {
          text.ignore = text.normalIgnore;
        }

        this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);
      }

      var SunburstPieceProto = SunburstPiece.prototype;

      SunburstPieceProto.updateData = function (firstCreate, node, state, seriesModel, ecModel) {
        this.node = node;
        node.piece = this;
        seriesModel = seriesModel || this._seriesModel;
        ecModel = ecModel || this._ecModel;
        var sector = this.childAt(0);
        sector.dataIndex = node.dataIndex;
        var itemModel = node.getModel();
        var layout = node.getLayout(); // if (!layout) {
        //     console.log(node.getLayout());
        // }

        var sectorShape = zrUtil.extend({}, layout);
        sectorShape.label = null;
        var visualColor = getNodeColor(node, seriesModel, ecModel);
        fillDefaultColor(node, seriesModel, visualColor);
        var normalStyle = itemModel.getModel('itemStyle').getItemStyle();
        var style;

        if (state === 'normal') {
          style = normalStyle;
        } else {
          var stateStyle = itemModel.getModel(state + '.itemStyle').getItemStyle();
          style = zrUtil.merge(stateStyle, normalStyle);
        }

        style = zrUtil.defaults({
          lineJoin: 'bevel',
          fill: style.fill || visualColor
        }, style);

        if (firstCreate) {
          sector.setShape(sectorShape);
          sector.shape.r = layout.r0;
          graphic.updateProps(sector, {
            shape: {
              r: layout.r
            }
          }, seriesModel, node.dataIndex);
          sector.useStyle(style);
        } else if (typeof style.fill === 'object' && style.fill.type || typeof sector.style.fill === 'object' && sector.style.fill.type) {
          // Disable animation for gradient since no interpolation method
          // is supported for gradient
          graphic.updateProps(sector, {
            shape: sectorShape
          }, seriesModel);
          sector.useStyle(style);
        } else {
          graphic.updateProps(sector, {
            shape: sectorShape,
            style: style
          }, seriesModel);
        }

        this._updateLabel(seriesModel, visualColor, state);

        var cursorStyle = itemModel.getShallow('cursor');
        cursorStyle && sector.attr('cursor', cursorStyle);

        if (firstCreate) {
          var highlightPolicy = seriesModel.getShallow('highlightPolicy');

          this._initEvents(sector, node, seriesModel, highlightPolicy);
        }

        this._seriesModel = seriesModel || this._seriesModel;
        this._ecModel = ecModel || this._ecModel;
        graphic.setHoverStyle(this);
      };

      SunburstPieceProto.onEmphasis = function (highlightPolicy) {
        var that = this;
        this.node.hostTree.root.eachNode(function (n) {
          if (n.piece) {
            if (that.node === n) {
              n.piece.updateData(false, n, 'emphasis');
            } else if (isNodeHighlighted(n, that.node, highlightPolicy)) {
              n.piece.childAt(0).trigger('highlight');
            } else if (highlightPolicy !== NodeHighlightPolicy.NONE) {
              n.piece.childAt(0).trigger('downplay');
            }
          }
        });
      };

      SunburstPieceProto.onNormal = function () {
        this.node.hostTree.root.eachNode(function (n) {
          if (n.piece) {
            n.piece.updateData(false, n, 'normal');
          }
        });
      };

      SunburstPieceProto.onHighlight = function () {
        this.updateData(false, this.node, 'highlight');
      };

      SunburstPieceProto.onDownplay = function () {
        this.updateData(false, this.node, 'downplay');
      };

      SunburstPieceProto._updateLabel = function (seriesModel, visualColor, state) {
        var itemModel = this.node.getModel();
        var normalModel = itemModel.getModel('label');
        var labelModel = state === 'normal' || state === 'emphasis' ? normalModel : itemModel.getModel(state + '.label');
        var labelHoverModel = itemModel.getModel('emphasis.label');
        var labelFormatter = labelModel.get('formatter'); // Use normal formatter if no state formatter is defined

        var labelState = labelFormatter ? state : 'normal';
        var text = zrUtil.retrieve(seriesModel.getFormattedLabel(this.node.dataIndex, labelState, null, null, 'label'), this.node.name);

        if (getLabelAttr('show') === false) {
          text = '';
        }

        var layout = this.node.getLayout();
        var labelMinAngle = labelModel.get('minAngle');

        if (labelMinAngle == null) {
          labelMinAngle = normalModel.get('minAngle');
        }

        labelMinAngle = labelMinAngle / 180 * Math.PI;
        var angle = layout.endAngle - layout.startAngle;

        if (labelMinAngle != null && Math.abs(angle) < labelMinAngle) {
          // Not displaying text when angle is too small
          text = '';
        }

        var label = this.childAt(1);
        graphic.setLabelStyle(label.style, label.hoverStyle || {}, normalModel, labelHoverModel, {
          defaultText: labelModel.getShallow('show') ? text : null,
          autoColor: visualColor,
          useInsideStyle: true
        });
        var midAngle = (layout.startAngle + layout.endAngle) / 2;
        var dx = Math.cos(midAngle);
        var dy = Math.sin(midAngle);
        var r;
        var labelPosition = getLabelAttr('position');
        var labelPadding = getLabelAttr('distance') || 0;
        var textAlign = getLabelAttr('align');

        if (labelPosition === 'outside') {
          r = layout.r + labelPadding;
          textAlign = midAngle > Math.PI / 2 ? 'right' : 'left';
        } else {
          if (!textAlign || textAlign === 'center') {
            r = (layout.r + layout.r0) / 2;
            textAlign = 'center';
          } else if (textAlign === 'left') {
            r = layout.r0 + labelPadding;

            if (midAngle > Math.PI / 2) {
              textAlign = 'right';
            }
          } else if (textAlign === 'right') {
            r = layout.r - labelPadding;

            if (midAngle > Math.PI / 2) {
              textAlign = 'left';
            }
          }
        }

        label.attr('style', {
          text: text,
          textAlign: textAlign,
          textVerticalAlign: getLabelAttr('verticalAlign') || 'middle',
          opacity: getLabelAttr('opacity')
        });
        var textX = r * dx + layout.cx;
        var textY = r * dy + layout.cy;
        label.attr('position', [textX, textY]);
        var rotateType = getLabelAttr('rotate');
        var rotate = 0;

        if (rotateType === 'radial') {
          rotate = -midAngle;

          if (rotate < -Math.PI / 2) {
            rotate += Math.PI;
          }
        } else if (rotateType === 'tangential') {
          rotate = Math.PI / 2 - midAngle;

          if (rotate > Math.PI / 2) {
            rotate -= Math.PI;
          } else if (rotate < -Math.PI / 2) {
            rotate += Math.PI;
          }
        } else if (typeof rotateType === 'number') {
          rotate = rotateType * Math.PI / 180;
        }

        label.attr('rotation', rotate);

        function getLabelAttr(name) {
          var stateAttr = labelModel.get(name);

          if (stateAttr == null) {
            return normalModel.get(name);
          } else {
            return stateAttr;
          }
        }
      };

      SunburstPieceProto._initEvents = function (sector, node, seriesModel, highlightPolicy) {
        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');
        var that = this;

        var onEmphasis = function onEmphasis() {
          that.onEmphasis(highlightPolicy);
        };

        var onNormal = function onNormal() {
          that.onNormal();
        };

        var onDownplay = function onDownplay() {
          that.onDownplay();
        };

        var onHighlight = function onHighlight() {
          that.onHighlight();
        };

        if (seriesModel.isAnimationEnabled()) {
          sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal).on('downplay', onDownplay).on('highlight', onHighlight);
        }
      };

      zrUtil.inherits(SunburstPiece, graphic.Group);
      var _default = SunburstPiece;
      /**
       * Get node color
       *
       * @param {TreeNode} node the node to get color
       * @param {module:echarts/model/Series} seriesModel series
       * @param {module:echarts/model/Global} ecModel echarts defaults
       */

      function getNodeColor(node, seriesModel, ecModel) {
        // Color from visualMap
        var visualColor = node.getVisual('color');
        var visualMetaList = node.getVisual('visualMeta');

        if (!visualMetaList || visualMetaList.length === 0) {
          // Use first-generation color if has no visualMap
          visualColor = null;
        } // Self color or level color


        var color = node.getModel('itemStyle').get('color');

        if (color) {
          return color;
        } else if (visualColor) {
          // Color mapping
          return visualColor;
        } else if (node.depth === 0) {
          // Virtual root node
          return ecModel.option.color[0];
        } else {
          // First-generation color
          var length = ecModel.option.color.length;
          color = ecModel.option.color[getRootId(node) % length];
        }

        return color;
      }
      /**
       * Get index of root in sorted order
       *
       * @param {TreeNode} node current node
       * @return {number} index in root
       */


      function getRootId(node) {
        var ancestor = node;

        while (ancestor.depth > 1) {
          ancestor = ancestor.parentNode;
        }

        var virtualRoot = node.getAncestors()[0];
        return zrUtil.indexOf(virtualRoot.children, ancestor);
      }

      function isNodeHighlighted(node, activeNode, policy) {
        if (policy === NodeHighlightPolicy.NONE) {
          return false;
        } else if (policy === NodeHighlightPolicy.SELF) {
          return node === activeNode;
        } else if (policy === NodeHighlightPolicy.ANCESTOR) {
          return node === activeNode || node.isAncestorOf(activeNode);
        } else {
          return node === activeNode || node.isDescendantOf(activeNode);
        }
      } // Fix tooltip callback function params.color incorrect when pick a default color


      function fillDefaultColor(node, seriesModel, color) {
        var data = seriesModel.getData();
        data.setItemVisual(node.dataIndex, 'color', color);
      }

      module.exports = _default;
      /***/
    },

    /***/
    "Tp9H":
    /*!***************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js ***!
      \***************************************************************************/

    /*! no static exports found */

    /***/
    function Tp9H(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var env = __webpack_require__(
      /*! zrender/lib/core/env */
      "ItGF");

      var lang = __webpack_require__(
      /*! ../../../lang */
      "Kagy");

      var featureManager = __webpack_require__(
      /*! ../featureManager */
      "IUWy");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /* global Uint8Array */


      var saveAsImageLang = lang.toolbox.saveAsImage;

      function SaveAsImage(model) {
        this.model = model;
      }

      SaveAsImage.defaultOption = {
        show: true,
        icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',
        title: saveAsImageLang.title,
        type: 'png',
        // Default use option.backgroundColor
        // backgroundColor: '#fff',
        connectedBackgroundColor: '#fff',
        name: '',
        excludeComponents: ['toolbox'],
        pixelRatio: 1,
        lang: saveAsImageLang.lang.slice()
      };
      SaveAsImage.prototype.unusable = !env.canvasSupported;
      var proto = SaveAsImage.prototype;

      proto.onclick = function (ecModel, api) {
        var model = this.model;
        var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';
        var isSvg = api.getZr().painter.getType() === 'svg';
        var type = isSvg ? 'svg' : model.get('type', true) || 'png';
        var url = api.getConnectedDataURL({
          type: type,
          backgroundColor: model.get('backgroundColor', true) || ecModel.get('backgroundColor') || '#fff',
          connectedBackgroundColor: model.get('connectedBackgroundColor'),
          excludeComponents: model.get('excludeComponents'),
          pixelRatio: model.get('pixelRatio')
        }); // Chrome and Firefox

        if (typeof MouseEvent === 'function' && !env.browser.ie && !env.browser.edge) {
          var $a = document.createElement('a');
          $a.download = title + '.' + type;
          $a.target = '_blank';
          $a.href = url;
          var evt = new MouseEvent('click', {
            // some micro front-end framework window maybe is a Proxy
            view: document.defaultView,
            bubbles: true,
            cancelable: false
          });
          $a.dispatchEvent(evt);
        } // IE
        else {
          if (window.navigator.msSaveOrOpenBlob) {
            var bstr = atob(url.split(',')[1]);
            var n = bstr.length;
            var u8arr = new Uint8Array(n);

            while (n--) {
              u8arr[n] = bstr.charCodeAt(n);
            }

            var blob = new Blob([u8arr]);
            window.navigator.msSaveOrOpenBlob(blob, title + '.' + type);
          } else {
            var lang = model.get('lang');
            var html = '' + '<body style="margin:0;">' + '<img src="' + url + '" style="max-width:100%;" title="' + (lang && lang[0] || '') + '" />' + '</body>';
            var tab = window.open();
            tab.document.write(html);
          }
        }
      };

      featureManager.register('saveAsImage', SaveAsImage);
      var _default = SaveAsImage;
      module.exports = _default;
      /***/
    },

    /***/
    "U/Mo":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/graph/graphHelper.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function UMo(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      function getNodeGlobalScale(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;

        if (coordSys.type !== 'view') {
          return 1;
        }

        var nodeScaleRatio = seriesModel.option.nodeScaleRatio;
        var groupScale = coordSys.scale;
        var groupZoom = groupScale && groupScale[0] || 1; // Scale node when zoom changes

        var roamZoom = coordSys.getZoom();
        var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
        return nodeScale / groupZoom;
      }

      function getSymbolSize(node) {
        var symbolSize = node.getVisual('symbolSize');

        if (symbolSize instanceof Array) {
          symbolSize = (symbolSize[0] + symbolSize[1]) / 2;
        }

        return +symbolSize;
      }

      exports.getNodeGlobalScale = getNodeGlobalScale;
      exports.getSymbolSize = getSymbolSize;
      /***/
    },

    /***/
    "UOVi":
    /*!***************************************************************!*\
      !*** ./node_modules/echarts/lib/component/dataZoom/helper.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function UOVi(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var formatUtil = __webpack_require__(
      /*! ../../util/format */
      "7aKB");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle', 'single']; // Supported coords.

      var COORDS = ['cartesian2d', 'polar', 'singleAxis'];
      /**
       * @param {string} coordType
       * @return {boolean}
       */

      function isCoordSupported(coordType) {
        return zrUtil.indexOf(COORDS, coordType) >= 0;
      }
      /**
       * Create "each" method to iterate names.
       *
       * @pubilc
       * @param  {Array.<string>} names
       * @param  {Array.<string>=} attrs
       * @return {Function}
       */


      function createNameEach(names, attrs) {
        names = names.slice();
        var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);
        attrs = (attrs || []).slice();
        var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);
        return function (callback, context) {
          zrUtil.each(names, function (name, index) {
            var nameObj = {
              name: name,
              capital: capitalNames[index]
            };

            for (var j = 0; j < attrs.length; j++) {
              nameObj[attrs[j]] = name + capitalAttrs[j];
            }

            callback.call(context, nameObj);
          });
        };
      }
      /**
       * Iterate each dimension name.
       *
       * @public
       * @param {Function} callback The parameter is like:
       *                            {
       *                                name: 'angle',
       *                                capital: 'Angle',
       *                                axis: 'angleAxis',
       *                                axisIndex: 'angleAixs',
       *                                index: 'angleIndex'
       *                            }
       * @param {Object} context
       */


      var eachAxisDim = createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);
      /**
       * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.
       * dataZoomModels and 'links' make up one or more graphics.
       * This function finds the graphic where the source dataZoomModel is in.
       *
       * @public
       * @param {Function} forEachNode Node iterator.
       * @param {Function} forEachEdgeType edgeType iterator
       * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.
       * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}
       */

      function createLinkedNodesFinder(forEachNode, forEachEdgeType, edgeIdGetter) {
        return function (sourceNode) {
          var result = {
            nodes: [],
            records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean).

          };
          forEachEdgeType(function (edgeType) {
            result.records[edgeType.name] = {};
          });

          if (!sourceNode) {
            return result;
          }

          absorb(sourceNode, result);
          var existsLink;

          do {
            existsLink = false;
            forEachNode(processSingleNode);
          } while (existsLink);

          function processSingleNode(node) {
            if (!isNodeAbsorded(node, result) && isLinked(node, result)) {
              absorb(node, result);
              existsLink = true;
            }
          }

          return result;
        };

        function isNodeAbsorded(node, result) {
          return zrUtil.indexOf(result.nodes, node) >= 0;
        }

        function isLinked(node, result) {
          var hasLink = false;
          forEachEdgeType(function (edgeType) {
            zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {
              result.records[edgeType.name][edgeId] && (hasLink = true);
            });
          });
          return hasLink;
        }

        function absorb(node, result) {
          result.nodes.push(node);
          forEachEdgeType(function (edgeType) {
            zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {
              result.records[edgeType.name][edgeId] = true;
            });
          });
        }
      }

      exports.isCoordSupported = isCoordSupported;
      exports.createNameEach = createNameEach;
      exports.eachAxisDim = eachAxisDim;
      exports.createLinkedNodesFinder = createLinkedNodesFinder;
      /***/
    },

    /***/
    "UnoB":
    /*!***********************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/themeRiver/themeRiverLayout.js ***!
      \***********************************************************************/

    /*! no static exports found */

    /***/
    function UnoB(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var numberUtil = __webpack_require__(
      /*! ../../util/number */
      "OELB");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function _default(ecModel, api) {
        ecModel.eachSeriesByType('themeRiver', function (seriesModel) {
          var data = seriesModel.getData();
          var single = seriesModel.coordinateSystem;
          var layoutInfo = {}; // use the axis boundingRect for view

          var rect = single.getRect();
          layoutInfo.rect = rect;
          var boundaryGap = seriesModel.get('boundaryGap');
          var axis = single.getAxis();
          layoutInfo.boundaryGap = boundaryGap;

          if (axis.orient === 'horizontal') {
            boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], rect.height);
            boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], rect.height);
            var height = rect.height - boundaryGap[0] - boundaryGap[1];
            themeRiverLayout(data, seriesModel, height);
          } else {
            boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], rect.width);
            boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], rect.width);
            var width = rect.width - boundaryGap[0] - boundaryGap[1];
            themeRiverLayout(data, seriesModel, width);
          }

          data.setLayout('layoutInfo', layoutInfo);
        });
      }
      /**
       * The layout information about themeriver
       *
       * @param {module:echarts/data/List} data  data in the series
       * @param {module:echarts/model/Series} seriesModel  the model object of themeRiver series
       * @param {number} height  value used to compute every series height
       */


      function themeRiverLayout(data, seriesModel, height) {
        if (!data.count()) {
          return;
        }

        var coordSys = seriesModel.coordinateSystem; // the data in each layer are organized into a series.

        var layerSeries = seriesModel.getLayerSeries(); // the points in each layer.

        var timeDim = data.mapDimension('single');
        var valueDim = data.mapDimension('value');
        var layerPoints = zrUtil.map(layerSeries, function (singleLayer) {
          return zrUtil.map(singleLayer.indices, function (idx) {
            var pt = coordSys.dataToPoint(data.get(timeDim, idx));
            pt[1] = data.get(valueDim, idx);
            return pt;
          });
        });
        var base = computeBaseline(layerPoints);
        var baseLine = base.y0;
        var ky = height / base.max; // set layout information for each item.

        var n = layerSeries.length;
        var m = layerSeries[0].indices.length;
        var baseY0;

        for (var j = 0; j < m; ++j) {
          baseY0 = baseLine[j] * ky;
          data.setItemLayout(layerSeries[0].indices[j], {
            layerIndex: 0,
            x: layerPoints[0][j][0],
            y0: baseY0,
            y: layerPoints[0][j][1] * ky
          });

          for (var i = 1; i < n; ++i) {
            baseY0 += layerPoints[i - 1][j][1] * ky;
            data.setItemLayout(layerSeries[i].indices[j], {
              layerIndex: i,
              x: layerPoints[i][j][0],
              y0: baseY0,
              y: layerPoints[i][j][1] * ky
            });
          }
        }
      }
      /**
       * Compute the baseLine of the rawdata
       * Inspired by Lee Byron's paper Stacked Graphs - Geometry & Aesthetics
       *
       * @param  {Array.<Array>} data  the points in each layer
       * @return {Object}
       */


      function computeBaseline(data) {
        var layerNum = data.length;
        var pointNum = data[0].length;
        var sums = [];
        var y0 = [];
        var max = 0;
        var temp;
        var base = {};

        for (var i = 0; i < pointNum; ++i) {
          for (var j = 0, temp = 0; j < layerNum; ++j) {
            temp += data[j][i][1];
          }

          if (temp > max) {
            max = temp;
          }

          sums.push(temp);
        }

        for (var k = 0; k < pointNum; ++k) {
          y0[k] = (max - sums[k]) / 2;
        }

        max = 0;

        for (var l = 0; l < pointNum; ++l) {
          var sum = sums[l] + y0[l];

          if (sum > max) {
            max = sum;
          }
        }

        base.y0 = y0;
        base.max = max;
        return base;
      }

      module.exports = _default;
      /***/
    },

    /***/
    "VFCP":
    /*!*********************************************************!*\
      !*** ./node_modules/echarts/lib/component/visualMap.js ***!
      \*********************************************************/

    /*! no static exports found */

    /***/
    function VFCP(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      __webpack_require__(
      /*! ./visualMapContinuous */
      "dBmv");

      __webpack_require__(
      /*! ./visualMapPiecewise */
      "KamJ");
      /***/

    },

    /***/
    "VPsl":
    /*!*********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/map/mapVisual.js ***!
      \*********************************************************/

    /*! no static exports found */

    /***/
    function VPsl(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      function _default(ecModel) {
        ecModel.eachSeriesByType('map', function (seriesModel) {
          var colorList = seriesModel.get('color');
          var itemStyleModel = seriesModel.getModel('itemStyle');
          var areaColor = itemStyleModel.get('areaColor');
          var color = itemStyleModel.get('color') || colorList[seriesModel.seriesIndex % colorList.length];
          seriesModel.getData().setVisual({
            'areaColor': areaColor,
            'color': color
          });
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "VSLf":
    /*!*****************************************************!*\
      !*** ./node_modules/echarts/lib/component/radar.js ***!
      \*****************************************************/

    /*! no static exports found */

    /***/
    function VSLf(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      __webpack_require__(
      /*! ../coord/radar/Radar */
      "I+Bx");

      __webpack_require__(
      /*! ../coord/radar/RadarModel */
      "F0hE");

      __webpack_require__(
      /*! ./radar/RadarView */
      "bBKM");
      /***/

    },

    /***/
    "VXYp":
    /*!**************************************************************!*\
      !*** ./node_modules/echarts/lib/component/dataZoom/roams.js ***!
      \**************************************************************/

    /*! no static exports found */

    /***/
    function VXYp(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var RoamController = __webpack_require__(
      /*! ../../component/helper/RoamController */
      "SgGq");

      var throttleUtil = __webpack_require__(
      /*! ../../util/throttle */
      "iLNv");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // Only create one roam controller for each coordinate system.
      // one roam controller might be refered by two inside data zoom
      // components (for example, one for x and one for y). When user
      // pan or zoom, only dispatch one action for those data zoom
      // components.


      var ATTR = '\0_ec_dataZoom_roams';
      /**
       * @public
       * @param {module:echarts/ExtensionAPI} api
       * @param {Object} dataZoomInfo
       * @param {string} dataZoomInfo.coordId
       * @param {Function} dataZoomInfo.containsPoint
       * @param {Array.<string>} dataZoomInfo.allCoordIds
       * @param {string} dataZoomInfo.dataZoomId
       * @param {Object} dataZoomInfo.getRange
       * @param {Function} dataZoomInfo.getRange.pan
       * @param {Function} dataZoomInfo.getRange.zoom
       * @param {Function} dataZoomInfo.getRange.scrollMove
       * @param {boolean} dataZoomInfo.dataZoomModel
       */

      function register(api, dataZoomInfo) {
        var store = giveStore(api);
        var theDataZoomId = dataZoomInfo.dataZoomId;
        var theCoordId = dataZoomInfo.coordId; // Do clean when a dataZoom changes its target coordnate system.
        // Avoid memory leak, dispose all not-used-registered.

        zrUtil.each(store, function (record, coordId) {
          var dataZoomInfos = record.dataZoomInfos;

          if (dataZoomInfos[theDataZoomId] && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0) {
            delete dataZoomInfos[theDataZoomId];
            record.count--;
          }
        });
        cleanStore(store);
        var record = store[theCoordId]; // Create if needed.

        if (!record) {
          record = store[theCoordId] = {
            coordId: theCoordId,
            dataZoomInfos: {},
            count: 0
          };
          record.controller = createController(api, record);
          record.dispatchAction = zrUtil.curry(dispatchAction, api);
        } // Update reference of dataZoom.


        !record.dataZoomInfos[theDataZoomId] && record.count++;
        record.dataZoomInfos[theDataZoomId] = dataZoomInfo;
        var controllerParams = mergeControllerParams(record.dataZoomInfos);
        record.controller.enable(controllerParams.controlType, controllerParams.opt); // Consider resize, area should be always updated.

        record.controller.setPointerChecker(dataZoomInfo.containsPoint); // Update throttle.

        throttleUtil.createOrUpdate(record, 'dispatchAction', dataZoomInfo.dataZoomModel.get('throttle', true), 'fixRate');
      }
      /**
       * @public
       * @param {module:echarts/ExtensionAPI} api
       * @param {string} dataZoomId
       */


      function unregister(api, dataZoomId) {
        var store = giveStore(api);
        zrUtil.each(store, function (record) {
          record.controller.dispose();
          var dataZoomInfos = record.dataZoomInfos;

          if (dataZoomInfos[dataZoomId]) {
            delete dataZoomInfos[dataZoomId];
            record.count--;
          }
        });
        cleanStore(store);
      }
      /**
       * @public
       */


      function generateCoordId(coordModel) {
        return coordModel.type + '\0_' + coordModel.id;
      }
      /**
       * Key: coordId, value: {dataZoomInfos: [], count, controller}
       * @type {Array.<Object>}
       */


      function giveStore(api) {
        // Mount store on zrender instance, so that we do not
        // need to worry about dispose.
        var zr = api.getZr();
        return zr[ATTR] || (zr[ATTR] = {});
      }

      function createController(api, newRecord) {
        var controller = new RoamController(api.getZr());
        zrUtil.each(['pan', 'zoom', 'scrollMove'], function (eventName) {
          controller.on(eventName, function (event) {
            var batch = [];
            zrUtil.each(newRecord.dataZoomInfos, function (info) {
              // Check whether the behaviors (zoomOnMouseWheel, moveOnMouseMove,
              // moveOnMouseWheel, ...) enabled.
              if (!event.isAvailableBehavior(info.dataZoomModel.option)) {
                return;
              }

              var method = (info.getRange || {})[eventName];
              var range = method && method(newRecord.controller, event);
              !info.dataZoomModel.get('disabled', true) && range && batch.push({
                dataZoomId: info.dataZoomId,
                start: range[0],
                end: range[1]
              });
            });
            batch.length && newRecord.dispatchAction(batch);
          });
        });
        return controller;
      }

      function cleanStore(store) {
        zrUtil.each(store, function (record, coordId) {
          if (!record.count) {
            record.controller.dispose();
            delete store[coordId];
          }
        });
      }
      /**
       * This action will be throttled.
       */


      function dispatchAction(api, batch) {
        api.dispatchAction({
          type: 'dataZoom',
          batch: batch
        });
      }
      /**
       * Merge roamController settings when multiple dataZooms share one roamController.
       */


      function mergeControllerParams(dataZoomInfos) {
        var controlType; // DO NOT use reserved word (true, false, undefined) as key literally. Even if encapsulated
        // as string, it is probably revert to reserved word by compress tool. See #7411.

        var prefix = 'type_';
        var typePriority = {
          'type_true': 2,
          'type_move': 1,
          'type_false': 0,
          'type_undefined': -1
        };
        var preventDefaultMouseMove = true;
        zrUtil.each(dataZoomInfos, function (dataZoomInfo) {
          var dataZoomModel = dataZoomInfo.dataZoomModel;
          var oneType = dataZoomModel.get('disabled', true) ? false : dataZoomModel.get('zoomLock', true) ? 'move' : true;

          if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {
            controlType = oneType;
          } // Prevent default move event by default. If one false, do not prevent. Otherwise
          // users may be confused why it does not work when multiple insideZooms exist.


          preventDefaultMouseMove &= dataZoomModel.get('preventDefaultMouseMove', true);
        });
        return {
          controlType: controlType,
          opt: {
            // RoamController will enable all of these functionalities,
            // and the final behavior is determined by its event listener
            // provided by each inside zoom.
            zoomOnMouseWheel: true,
            moveOnMouseMove: true,
            moveOnMouseWheel: true,
            preventDefaultMouseMove: !!preventDefaultMouseMove
          }
        };
      }

      exports.register = register;
      exports.unregister = unregister;
      exports.generateCoordId = generateCoordId;
      /***/
    },

    /***/
    "VaxA":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/helper/treeHelper.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function VaxA(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function retrieveTargetInfo(payload, validPayloadTypes, seriesModel) {
        if (payload && zrUtil.indexOf(validPayloadTypes, payload.type) >= 0) {
          var root = seriesModel.getData().tree.root;
          var targetNode = payload.targetNode;

          if (typeof targetNode === 'string') {
            targetNode = root.getNodeById(targetNode);
          }

          if (targetNode && root.contains(targetNode)) {
            return {
              node: targetNode
            };
          }

          var targetNodeId = payload.targetNodeId;

          if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {
            return {
              node: targetNode
            };
          }
        }
      } // Not includes the given node at the last item.


      function getPathToRoot(node) {
        var path = [];

        while (node) {
          node = node.parentNode;
          node && path.push(node);
        }

        return path.reverse();
      }

      function aboveViewRoot(viewRoot, node) {
        var viewPath = getPathToRoot(viewRoot);
        return zrUtil.indexOf(viewPath, node) >= 0;
      } // From root to the input node (the input node will be included).


      function wrapTreePathInfo(node, seriesModel) {
        var treePathInfo = [];

        while (node) {
          var nodeDataIndex = node.dataIndex;
          treePathInfo.push({
            name: node.name,
            dataIndex: nodeDataIndex,
            value: seriesModel.getRawValue(nodeDataIndex)
          });
          node = node.parentNode;
        }

        treePathInfo.reverse();
        return treePathInfo;
      }

      exports.retrieveTargetInfo = retrieveTargetInfo;
      exports.getPathToRoot = getPathToRoot;
      exports.aboveViewRoot = aboveViewRoot;
      exports.wrapTreePathInfo = wrapTreePathInfo;
      /***/
    },

    /***/
    "W2nI":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/sankey/SankeyView.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function W2nI(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var nodeOpacityPath = ['itemStyle', 'opacity'];
      var hoverNodeOpacityPath = ['emphasis', 'itemStyle', 'opacity'];
      var lineOpacityPath = ['lineStyle', 'opacity'];
      var hoverLineOpacityPath = ['emphasis', 'lineStyle', 'opacity'];

      function getItemOpacity(item, opacityPath) {
        return item.getVisual('opacity') || item.getModel().get(opacityPath);
      }

      function fadeOutItem(item, opacityPath, opacityRatio) {
        var el = item.getGraphicEl();
        var opacity = getItemOpacity(item, opacityPath);

        if (opacityRatio != null) {
          opacity == null && (opacity = 1);
          opacity *= opacityRatio;
        }

        el.downplay && el.downplay();
        el.traverse(function (child) {
          if (child.type !== 'group') {
            child.setStyle('opacity', opacity);
          }
        });
      }

      function fadeInItem(item, opacityPath) {
        var opacity = getItemOpacity(item, opacityPath);
        var el = item.getGraphicEl();
        el.traverse(function (child) {
          if (child.type !== 'group') {
            child.setStyle('opacity', opacity);
          }
        }); // Support emphasis here.

        el.highlight && el.highlight();
      }

      var SankeyShape = graphic.extendShape({
        shape: {
          x1: 0,
          y1: 0,
          x2: 0,
          y2: 0,
          cpx1: 0,
          cpy1: 0,
          cpx2: 0,
          cpy2: 0,
          extent: 0,
          orient: ''
        },
        buildPath: function buildPath(ctx, shape) {
          var extent = shape.extent;
          ctx.moveTo(shape.x1, shape.y1);
          ctx.bezierCurveTo(shape.cpx1, shape.cpy1, shape.cpx2, shape.cpy2, shape.x2, shape.y2);

          if (shape.orient === 'vertical') {
            ctx.lineTo(shape.x2 + extent, shape.y2);
            ctx.bezierCurveTo(shape.cpx2 + extent, shape.cpy2, shape.cpx1 + extent, shape.cpy1, shape.x1 + extent, shape.y1);
          } else {
            ctx.lineTo(shape.x2, shape.y2 + extent);
            ctx.bezierCurveTo(shape.cpx2, shape.cpy2 + extent, shape.cpx1, shape.cpy1 + extent, shape.x1, shape.y1 + extent);
          }

          ctx.closePath();
        },
        highlight: function highlight() {
          this.trigger('emphasis');
        },
        downplay: function downplay() {
          this.trigger('normal');
        }
      });

      var _default = echarts.extendChartView({
        type: 'sankey',

        /**
         * @private
         * @type {module:echarts/chart/sankey/SankeySeries}
         */
        _model: null,

        /**
         * @private
         * @type {boolean}
         */
        _focusAdjacencyDisabled: false,
        render: function render(seriesModel, ecModel, api) {
          var sankeyView = this;
          var graph = seriesModel.getGraph();
          var group = this.group;
          var layoutInfo = seriesModel.layoutInfo; // view width

          var width = layoutInfo.width; // view height

          var height = layoutInfo.height;
          var nodeData = seriesModel.getData();
          var edgeData = seriesModel.getData('edge');
          var orient = seriesModel.get('orient');
          this._model = seriesModel;
          group.removeAll();
          group.attr('position', [layoutInfo.x, layoutInfo.y]); // generate a bezire Curve for each edge

          graph.eachEdge(function (edge) {
            var curve = new SankeyShape();
            curve.dataIndex = edge.dataIndex;
            curve.seriesIndex = seriesModel.seriesIndex;
            curve.dataType = 'edge';
            var lineStyleModel = edge.getModel('lineStyle');
            var curvature = lineStyleModel.get('curveness');
            var n1Layout = edge.node1.getLayout();
            var node1Model = edge.node1.getModel();
            var dragX1 = node1Model.get('localX');
            var dragY1 = node1Model.get('localY');
            var n2Layout = edge.node2.getLayout();
            var node2Model = edge.node2.getModel();
            var dragX2 = node2Model.get('localX');
            var dragY2 = node2Model.get('localY');
            var edgeLayout = edge.getLayout();
            var x1;
            var y1;
            var x2;
            var y2;
            var cpx1;
            var cpy1;
            var cpx2;
            var cpy2;
            curve.shape.extent = Math.max(1, edgeLayout.dy);
            curve.shape.orient = orient;

            if (orient === 'vertical') {
              x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + edgeLayout.sy;
              y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + n1Layout.dy;
              x2 = (dragX2 != null ? dragX2 * width : n2Layout.x) + edgeLayout.ty;
              y2 = dragY2 != null ? dragY2 * height : n2Layout.y;
              cpx1 = x1;
              cpy1 = y1 * (1 - curvature) + y2 * curvature;
              cpx2 = x2;
              cpy2 = y1 * curvature + y2 * (1 - curvature);
            } else {
              x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + n1Layout.dx;
              y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + edgeLayout.sy;
              x2 = dragX2 != null ? dragX2 * width : n2Layout.x;
              y2 = (dragY2 != null ? dragY2 * height : n2Layout.y) + edgeLayout.ty;
              cpx1 = x1 * (1 - curvature) + x2 * curvature;
              cpy1 = y1;
              cpx2 = x1 * curvature + x2 * (1 - curvature);
              cpy2 = y2;
            }

            curve.setShape({
              x1: x1,
              y1: y1,
              x2: x2,
              y2: y2,
              cpx1: cpx1,
              cpy1: cpy1,
              cpx2: cpx2,
              cpy2: cpy2
            });
            curve.setStyle(lineStyleModel.getItemStyle()); // Special color, use source node color or target node color

            switch (curve.style.fill) {
              case 'source':
                curve.style.fill = edge.node1.getVisual('color');
                break;

              case 'target':
                curve.style.fill = edge.node2.getVisual('color');
                break;
            }

            graphic.setHoverStyle(curve, edge.getModel('emphasis.lineStyle').getItemStyle());
            group.add(curve);
            edgeData.setItemGraphicEl(edge.dataIndex, curve);
          }); // Generate a rect for each node

          graph.eachNode(function (node) {
            var layout = node.getLayout();
            var itemModel = node.getModel();
            var dragX = itemModel.get('localX');
            var dragY = itemModel.get('localY');
            var labelModel = itemModel.getModel('label');
            var labelHoverModel = itemModel.getModel('emphasis.label');
            var rect = new graphic.Rect({
              shape: {
                x: dragX != null ? dragX * width : layout.x,
                y: dragY != null ? dragY * height : layout.y,
                width: layout.dx,
                height: layout.dy
              },
              style: itemModel.getModel('itemStyle').getItemStyle()
            });
            var hoverStyle = node.getModel('emphasis.itemStyle').getItemStyle();
            graphic.setLabelStyle(rect.style, hoverStyle, labelModel, labelHoverModel, {
              labelFetcher: seriesModel,
              labelDataIndex: node.dataIndex,
              defaultText: node.id,
              isRectText: true
            });
            rect.setStyle('fill', node.getVisual('color'));
            graphic.setHoverStyle(rect, hoverStyle);
            group.add(rect);
            nodeData.setItemGraphicEl(node.dataIndex, rect);
            rect.dataType = 'node';
          });
          nodeData.eachItemGraphicEl(function (el, dataIndex) {
            var itemModel = nodeData.getItemModel(dataIndex);

            if (itemModel.get('draggable')) {
              el.drift = function (dx, dy) {
                sankeyView._focusAdjacencyDisabled = true;
                this.shape.x += dx;
                this.shape.y += dy;
                this.dirty();
                api.dispatchAction({
                  type: 'dragNode',
                  seriesId: seriesModel.id,
                  dataIndex: nodeData.getRawIndex(dataIndex),
                  localX: this.shape.x / width,
                  localY: this.shape.y / height
                });
              };

              el.ondragend = function () {
                sankeyView._focusAdjacencyDisabled = false;
              };

              el.draggable = true;
              el.cursor = 'move';
            }

            el.highlight = function () {
              this.trigger('emphasis');
            };

            el.downplay = function () {
              this.trigger('normal');
            };

            el.focusNodeAdjHandler && el.off('mouseover', el.focusNodeAdjHandler);
            el.unfocusNodeAdjHandler && el.off('mouseout', el.unfocusNodeAdjHandler);

            if (itemModel.get('focusNodeAdjacency')) {
              el.on('mouseover', el.focusNodeAdjHandler = function () {
                if (!sankeyView._focusAdjacencyDisabled) {
                  sankeyView._clearTimer();

                  api.dispatchAction({
                    type: 'focusNodeAdjacency',
                    seriesId: seriesModel.id,
                    dataIndex: el.dataIndex
                  });
                }
              });
              el.on('mouseout', el.unfocusNodeAdjHandler = function () {
                if (!sankeyView._focusAdjacencyDisabled) {
                  sankeyView._dispatchUnfocus(api);
                }
              });
            }
          });
          edgeData.eachItemGraphicEl(function (el, dataIndex) {
            var edgeModel = edgeData.getItemModel(dataIndex);
            el.focusNodeAdjHandler && el.off('mouseover', el.focusNodeAdjHandler);
            el.unfocusNodeAdjHandler && el.off('mouseout', el.unfocusNodeAdjHandler);

            if (edgeModel.get('focusNodeAdjacency')) {
              el.on('mouseover', el.focusNodeAdjHandler = function () {
                if (!sankeyView._focusAdjacencyDisabled) {
                  sankeyView._clearTimer();

                  api.dispatchAction({
                    type: 'focusNodeAdjacency',
                    seriesId: seriesModel.id,
                    edgeDataIndex: el.dataIndex
                  });
                }
              });
              el.on('mouseout', el.unfocusNodeAdjHandler = function () {
                if (!sankeyView._focusAdjacencyDisabled) {
                  sankeyView._dispatchUnfocus(api);
                }
              });
            }
          });

          if (!this._data && seriesModel.get('animation')) {
            group.setClipPath(createGridClipShape(group.getBoundingRect(), seriesModel, function () {
              group.removeClipPath();
            }));
          }

          this._data = seriesModel.getData();
        },
        dispose: function dispose() {
          this._clearTimer();
        },
        _dispatchUnfocus: function _dispatchUnfocus(api) {
          var self = this;

          this._clearTimer();

          this._unfocusDelayTimer = setTimeout(function () {
            self._unfocusDelayTimer = null;
            api.dispatchAction({
              type: 'unfocusNodeAdjacency',
              seriesId: self._model.id
            });
          }, 500);
        },
        _clearTimer: function _clearTimer() {
          if (this._unfocusDelayTimer) {
            clearTimeout(this._unfocusDelayTimer);
            this._unfocusDelayTimer = null;
          }
        },
        focusNodeAdjacency: function focusNodeAdjacency(seriesModel, ecModel, api, payload) {
          var data = seriesModel.getData();
          var graph = data.graph;
          var dataIndex = payload.dataIndex;
          var itemModel = data.getItemModel(dataIndex);
          var edgeDataIndex = payload.edgeDataIndex;

          if (dataIndex == null && edgeDataIndex == null) {
            return;
          }

          var node = graph.getNodeByIndex(dataIndex);
          var edge = graph.getEdgeByIndex(edgeDataIndex);
          graph.eachNode(function (node) {
            fadeOutItem(node, nodeOpacityPath, 0.1);
          });
          graph.eachEdge(function (edge) {
            fadeOutItem(edge, lineOpacityPath, 0.1);
          });

          if (node) {
            fadeInItem(node, hoverNodeOpacityPath);
            var focusNodeAdj = itemModel.get('focusNodeAdjacency');

            if (focusNodeAdj === 'outEdges') {
              zrUtil.each(node.outEdges, function (edge) {
                if (edge.dataIndex < 0) {
                  return;
                }

                fadeInItem(edge, hoverLineOpacityPath);
                fadeInItem(edge.node2, hoverNodeOpacityPath);
              });
            } else if (focusNodeAdj === 'inEdges') {
              zrUtil.each(node.inEdges, function (edge) {
                if (edge.dataIndex < 0) {
                  return;
                }

                fadeInItem(edge, hoverLineOpacityPath);
                fadeInItem(edge.node1, hoverNodeOpacityPath);
              });
            } else if (focusNodeAdj === 'allEdges') {
              zrUtil.each(node.edges, function (edge) {
                if (edge.dataIndex < 0) {
                  return;
                }

                fadeInItem(edge, hoverLineOpacityPath);
                edge.node1 !== node && fadeInItem(edge.node1, hoverNodeOpacityPath);
                edge.node2 !== node && fadeInItem(edge.node2, hoverNodeOpacityPath);
              });
            }
          }

          if (edge) {
            fadeInItem(edge, hoverLineOpacityPath);
            fadeInItem(edge.node1, hoverNodeOpacityPath);
            fadeInItem(edge.node2, hoverNodeOpacityPath);
          }
        },
        unfocusNodeAdjacency: function unfocusNodeAdjacency(seriesModel, ecModel, api, payload) {
          var graph = seriesModel.getGraph();
          graph.eachNode(function (node) {
            fadeOutItem(node, nodeOpacityPath);
          });
          graph.eachEdge(function (edge) {
            fadeOutItem(edge, lineOpacityPath);
          });
        }
      }); // Add animation to the view


      function createGridClipShape(rect, seriesModel, cb) {
        var rectEl = new graphic.Rect({
          shape: {
            x: rect.x - 10,
            y: rect.y - 10,
            width: 0,
            height: rect.height + 20
          }
        });
        graphic.initProps(rectEl, {
          shape: {
            width: rect.width + 20
          }
        }, seriesModel, cb);
        return rectEl;
      }

      module.exports = _default;
      /***/
    },

    /***/
    "W4dC":
    /*!****************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/geo/geoSourceManager.js ***!
      \****************************************************************/

    /*! no static exports found */

    /***/
    function W4dC(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var _util = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var each = _util.each;
      var createHashMap = _util.createHashMap;

      var mapDataStorage = __webpack_require__(
      /*! ./mapDataStorage */
      "7DRL");

      var geoJSONLoader = __webpack_require__(
      /*! ./geoJSONLoader */
      "TIY9");

      var geoSVGLoader = __webpack_require__(
      /*! ./geoSVGLoader */
      "yS9w");

      var BoundingRect = __webpack_require__(
      /*! zrender/lib/core/BoundingRect */
      "mFDi");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var loaders = {
        geoJSON: geoJSONLoader,
        svg: geoSVGLoader
      };
      var _default = {
        /**
         * @param {string} mapName
         * @param {Object} nameMap
         * @param {string} nameProperty
         * @return {Object} source {regions, regionsMap, nameCoordMap, boundingRect}
         */
        load: function load(mapName, nameMap, nameProperty) {
          var regions = [];
          var regionsMap = createHashMap();
          var nameCoordMap = createHashMap();
          var boundingRect;
          var mapRecords = retrieveMap(mapName);
          each(mapRecords, function (record) {
            var singleSource = loaders[record.type].load(mapName, record, nameProperty);
            each(singleSource.regions, function (region) {
              var regionName = region.name; // Try use the alias in geoNameMap

              if (nameMap && nameMap.hasOwnProperty(regionName)) {
                region = region.cloneShallow(regionName = nameMap[regionName]);
              }

              regions.push(region);
              regionsMap.set(regionName, region);
              nameCoordMap.set(regionName, region.center);
            });
            var rect = singleSource.boundingRect;

            if (rect) {
              boundingRect ? boundingRect.union(rect) : boundingRect = rect.clone();
            }
          });
          return {
            regions: regions,
            regionsMap: regionsMap,
            nameCoordMap: nameCoordMap,
            // FIXME Always return new ?
            boundingRect: boundingRect || new BoundingRect(0, 0, 0, 0)
          };
        },

        /**
         * @param {string} mapName
         * @param {string} hostKey For cache.
         * @return {Array.<module:zrender/Element>} Roots.
         */
        makeGraphic: makeInvoker('makeGraphic'),

        /**
         * @param {string} mapName
         * @param {string} hostKey For cache.
         */
        removeGraphic: makeInvoker('removeGraphic')
      };

      function makeInvoker(methodName) {
        return function (mapName, hostKey) {
          var mapRecords = retrieveMap(mapName);
          var results = [];
          each(mapRecords, function (record) {
            var method = loaders[record.type][methodName];
            method && results.push(method(mapName, record, hostKey));
          });
          return results;
        };
      }

      function mapNotExistsError(mapName) {}

      function retrieveMap(mapName) {
        var mapRecords = mapDataStorage.retrieveMap(mapName) || [];
        return mapRecords;
      }

      module.exports = _default;
      /***/
    },

    /***/
    "WGYa":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/graph/forceLayout.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function WGYa(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _forceHelper = __webpack_require__(
      /*! ./forceHelper */
      "7yuC");

      var forceLayout = _forceHelper.forceLayout;

      var _simpleLayoutHelper = __webpack_require__(
      /*! ./simpleLayoutHelper */
      "HF/U");

      var simpleLayout = _simpleLayoutHelper.simpleLayout;

      var _circularLayoutHelper = __webpack_require__(
      /*! ./circularLayoutHelper */
      "lOQZ");

      var circularLayout = _circularLayoutHelper.circularLayout;

      var _number = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var linearMap = _number.linearMap;

      var vec2 = __webpack_require__(
      /*! zrender/lib/core/vector */
      "QBsz");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _multipleGraphEdgeHelper = __webpack_require__(
      /*! ../helper/multipleGraphEdgeHelper */
      "DDd/");

      var getCurvenessForEdge = _multipleGraphEdgeHelper.getCurvenessForEdge;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      function _default(ecModel) {
        ecModel.eachSeriesByType('graph', function (graphSeries) {
          var coordSys = graphSeries.coordinateSystem;

          if (coordSys && coordSys.type !== 'view') {
            return;
          }

          if (graphSeries.get('layout') === 'force') {
            var preservedPoints = graphSeries.preservedPoints || {};
            var graph = graphSeries.getGraph();
            var nodeData = graph.data;
            var edgeData = graph.edgeData;
            var forceModel = graphSeries.getModel('force');
            var initLayout = forceModel.get('initLayout');

            if (graphSeries.preservedPoints) {
              nodeData.each(function (idx) {
                var id = nodeData.getId(idx);
                nodeData.setItemLayout(idx, preservedPoints[id] || [NaN, NaN]);
              });
            } else if (!initLayout || initLayout === 'none') {
              simpleLayout(graphSeries);
            } else if (initLayout === 'circular') {
              circularLayout(graphSeries, 'value');
            }

            var nodeDataExtent = nodeData.getDataExtent('value');
            var edgeDataExtent = edgeData.getDataExtent('value'); // var edgeDataExtent = edgeData.getDataExtent('value');

            var repulsion = forceModel.get('repulsion');
            var edgeLength = forceModel.get('edgeLength');

            if (!zrUtil.isArray(repulsion)) {
              repulsion = [repulsion, repulsion];
            }

            if (!zrUtil.isArray(edgeLength)) {
              edgeLength = [edgeLength, edgeLength];
            } // Larger value has smaller length


            edgeLength = [edgeLength[1], edgeLength[0]];
            var nodes = nodeData.mapArray('value', function (value, idx) {
              var point = nodeData.getItemLayout(idx);
              var rep = linearMap(value, nodeDataExtent, repulsion);

              if (isNaN(rep)) {
                rep = (repulsion[0] + repulsion[1]) / 2;
              }

              return {
                w: rep,
                rep: rep,
                fixed: nodeData.getItemModel(idx).get('fixed'),
                p: !point || isNaN(point[0]) || isNaN(point[1]) ? null : point
              };
            });
            var edges = edgeData.mapArray('value', function (value, idx) {
              var edge = graph.getEdgeByIndex(idx);
              var d = linearMap(value, edgeDataExtent, edgeLength);

              if (isNaN(d)) {
                d = (edgeLength[0] + edgeLength[1]) / 2;
              }

              var edgeModel = edge.getModel();
              var curveness = zrUtil.retrieve3(edgeModel.get('lineStyle.curveness'), -getCurvenessForEdge(edge, graphSeries, idx, true), 0);
              return {
                n1: nodes[edge.node1.dataIndex],
                n2: nodes[edge.node2.dataIndex],
                d: d,
                curveness: curveness,
                ignoreForceLayout: edgeModel.get('ignoreForceLayout')
              };
            });
            var coordSys = graphSeries.coordinateSystem;
            var rect = coordSys.getBoundingRect();
            var forceInstance = forceLayout(nodes, edges, {
              rect: rect,
              gravity: forceModel.get('gravity'),
              friction: forceModel.get('friction')
            });
            var oldStep = forceInstance.step;

            forceInstance.step = function (cb) {
              for (var i = 0, l = nodes.length; i < l; i++) {
                if (nodes[i].fixed) {
                  // Write back to layout instance
                  vec2.copy(nodes[i].p, graph.getNodeByIndex(i).getLayout());
                }
              }

              oldStep(function (nodes, edges, stopped) {
                for (var i = 0, l = nodes.length; i < l; i++) {
                  if (!nodes[i].fixed) {
                    graph.getNodeByIndex(i).setLayout(nodes[i].p);
                  }

                  preservedPoints[nodeData.getId(i)] = nodes[i].p;
                }

                for (var i = 0, l = edges.length; i < l; i++) {
                  var e = edges[i];
                  var edge = graph.getEdgeByIndex(i);
                  var p1 = e.n1.p;
                  var p2 = e.n2.p;
                  var points = edge.getLayout();
                  points = points ? points.slice() : [];
                  points[0] = points[0] || [];
                  points[1] = points[1] || [];
                  vec2.copy(points[0], p1);
                  vec2.copy(points[1], p2);

                  if (+e.curveness) {
                    points[2] = [(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e.curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e.curveness];
                  }

                  edge.setLayout(points);
                } // Update layout


                cb && cb(stopped);
              });
            };

            graphSeries.forceLayout = forceInstance;
            graphSeries.preservedPoints = preservedPoints; // Step to get the layout

            forceInstance.step();
          } else {
            // Remove prev injected forceLayout instance
            graphSeries.forceLayout = null;
          }
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "WN+l":
    /*!********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/axis/axisSplitHelper.js ***!
      \********************************************************************/

    /*! no static exports found */

    /***/
    function WNL(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {
        var axis = axisModel.axis;

        if (axis.scale.isBlank()) {
          return;
        }

        var splitAreaModel = axisModel.getModel('splitArea');
        var areaStyleModel = splitAreaModel.getModel('areaStyle');
        var areaColors = areaStyleModel.get('color');
        var gridRect = gridModel.coordinateSystem.getRect();
        var ticksCoords = axis.getTicksCoords({
          tickModel: splitAreaModel,
          clamp: true
        });

        if (!ticksCoords.length) {
          return;
        } // For Making appropriate splitArea animation, the color and anid
        // should be corresponding to previous one if possible.


        var areaColorsLen = areaColors.length;
        var lastSplitAreaColors = axisView.__splitAreaColors;
        var newSplitAreaColors = zrUtil.createHashMap();
        var colorIndex = 0;

        if (lastSplitAreaColors) {
          for (var i = 0; i < ticksCoords.length; i++) {
            var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);

            if (cIndex != null) {
              colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;
              break;
            }
          }
        }

        var prev = axis.toGlobalCoord(ticksCoords[0].coord);
        var areaStyle = areaStyleModel.getAreaStyle();
        areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];

        for (var i = 1; i < ticksCoords.length; i++) {
          var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
          var x;
          var y;
          var width;
          var height;

          if (axis.isHorizontal()) {
            x = prev;
            y = gridRect.y;
            width = tickCoord - x;
            height = gridRect.height;
            prev = x + width;
          } else {
            x = gridRect.x;
            y = prev;
            width = gridRect.width;
            height = tickCoord - y;
            prev = y + height;
          }

          var tickValue = ticksCoords[i - 1].tickValue;
          tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);
          axisGroup.add(new graphic.Rect({
            anid: tickValue != null ? 'area_' + tickValue : null,
            shape: {
              x: x,
              y: y,
              width: width,
              height: height
            },
            style: zrUtil.defaults({
              fill: areaColors[colorIndex]
            }, areaStyle),
            silent: true
          }));
          colorIndex = (colorIndex + 1) % areaColorsLen;
        }

        axisView.__splitAreaColors = newSplitAreaColors;
      }

      function rectCoordAxisHandleRemove(axisView) {
        axisView.__splitAreaColors = null;
      }

      exports.rectCoordAxisBuildSplitArea = rectCoordAxisBuildSplitArea;
      exports.rectCoordAxisHandleRemove = rectCoordAxisHandleRemove;
      /***/
    },

    /***/
    "Wqna":
    /*!**********************************************************!*\
      !*** ./node_modules/echarts/lib/coord/cartesian/Grid.js ***!
      \**********************************************************/

    /*! no static exports found */

    /***/
    function Wqna(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var _util = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var isObject = _util.isObject;
      var each = _util.each;
      var map = _util.map;
      var indexOf = _util.indexOf;
      var retrieve = _util.retrieve;

      var _layout = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var getLayoutRect = _layout.getLayoutRect;

      var _axisHelper = __webpack_require__(
      /*! ../../coord/axisHelper */
      "aX7z");

      var createScaleByModel = _axisHelper.createScaleByModel;
      var ifAxisCrossZero = _axisHelper.ifAxisCrossZero;
      var niceScaleExtent = _axisHelper.niceScaleExtent;
      var estimateLabelUnionRect = _axisHelper.estimateLabelUnionRect;

      var Cartesian2D = __webpack_require__(
      /*! ./Cartesian2D */
      "y+lR");

      var Axis2D = __webpack_require__(
      /*! ./Axis2D */
      "7AJT");

      var CoordinateSystem = __webpack_require__(
      /*! ../../CoordinateSystem */
      "IDmD");

      var _dataStackHelper = __webpack_require__(
      /*! ../../data/helper/dataStackHelper */
      "7hqr");

      var getStackedDimension = _dataStackHelper.getStackedDimension;

      __webpack_require__(
      /*! ./GridModel */
      "jtI2");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Grid is a region which contains at most 4 cartesian systems
       *
       * TODO Default cartesian
       */
      // Depends on GridModel, AxisModel, which performs preprocess.

      /**
       * Check if the axis is used in the specified grid
       * @inner
       */


      function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {
        return axisModel.getCoordSysModel() === gridModel;
      }

      function Grid(gridModel, ecModel, api) {
        /**
         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}
         * @private
         */
        this._coordsMap = {};
        /**
         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}
         * @private
         */

        this._coordsList = [];
        /**
         * @type {Object.<string, Array.<module:echarts/coord/cartesian/Axis2D>>}
         * @private
         */

        this._axesMap = {};
        /**
         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}
         * @private
         */

        this._axesList = [];

        this._initCartesian(gridModel, ecModel, api);

        this.model = gridModel;
      }

      var gridProto = Grid.prototype;
      gridProto.type = 'grid';
      gridProto.axisPointerEnabled = true;

      gridProto.getRect = function () {
        return this._rect;
      };

      gridProto.update = function (ecModel, api) {
        var axesMap = this._axesMap;

        this._updateScale(ecModel, this.model);

        each(axesMap.x, function (xAxis) {
          niceScaleExtent(xAxis.scale, xAxis.model);
        });
        each(axesMap.y, function (yAxis) {
          niceScaleExtent(yAxis.scale, yAxis.model);
        }); // Key: axisDim_axisIndex, value: boolean, whether onZero target.

        var onZeroRecords = {};
        each(axesMap.x, function (xAxis) {
          fixAxisOnZero(axesMap, 'y', xAxis, onZeroRecords);
        });
        each(axesMap.y, function (yAxis) {
          fixAxisOnZero(axesMap, 'x', yAxis, onZeroRecords);
        }); // Resize again if containLabel is enabled
        // FIXME It may cause getting wrong grid size in data processing stage

        this.resize(this.model, api);
      };

      function fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {
        axis.getAxesOnZeroOf = function () {
          // TODO: onZero of multiple axes.
          return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
        }; // onZero can not be enabled in these two situations:
        // 1. When any other axis is a category axis.
        // 2. When no axis is cross 0 point.


        var otherAxes = axesMap[otherAxisDim];
        var otherAxisOnZeroOf;
        var axisModel = axis.model;
        var onZero = axisModel.get('axisLine.onZero');
        var onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex');

        if (!onZero) {
          return;
        } // If target axis is specified.


        if (onZeroAxisIndex != null) {
          if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
            otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
          }
        } else {
          // Find the first available other axis.
          for (var idx in otherAxes) {
            if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) // Consider that two Y axes on one value axis,
            // if both onZero, the two Y axes overlap.
            && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
              otherAxisOnZeroOf = otherAxes[idx];
              break;
            }
          }
        }

        if (otherAxisOnZeroOf) {
          onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
        }

        function getOnZeroRecordKey(axis) {
          return axis.dim + '_' + axis.index;
        }
      }

      function canOnZeroToAxis(axis) {
        return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero(axis);
      }
      /**
       * Resize the grid
       * @param {module:echarts/coord/cartesian/GridModel} gridModel
       * @param {module:echarts/ExtensionAPI} api
       */


      gridProto.resize = function (gridModel, api, ignoreContainLabel) {
        var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {
          width: api.getWidth(),
          height: api.getHeight()
        });
        this._rect = gridRect;
        var axesList = this._axesList;
        adjustAxes(); // Minus label size

        if (!ignoreContainLabel && gridModel.get('containLabel')) {
          each(axesList, function (axis) {
            if (!axis.model.get('axisLabel.inside')) {
              var labelUnionRect = estimateLabelUnionRect(axis);

              if (labelUnionRect) {
                var dim = axis.isHorizontal() ? 'height' : 'width';
                var margin = axis.model.get('axisLabel.margin');
                gridRect[dim] -= labelUnionRect[dim] + margin;

                if (axis.position === 'top') {
                  gridRect.y += labelUnionRect.height + margin;
                } else if (axis.position === 'left') {
                  gridRect.x += labelUnionRect.width + margin;
                }
              }
            }
          });
          adjustAxes();
        }

        function adjustAxes() {
          each(axesList, function (axis) {
            var isHorizontal = axis.isHorizontal();
            var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
            var idx = axis.inverse ? 1 : 0;
            axis.setExtent(extent[idx], extent[1 - idx]);
            updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);
          });
        }
      };
      /**
       * @param {string} axisType
       * @param {number} [axisIndex]
       */


      gridProto.getAxis = function (axisType, axisIndex) {
        var axesMapOnDim = this._axesMap[axisType];

        if (axesMapOnDim != null) {
          if (axisIndex == null) {
            // Find first axis
            for (var name in axesMapOnDim) {
              if (axesMapOnDim.hasOwnProperty(name)) {
                return axesMapOnDim[name];
              }
            }
          }

          return axesMapOnDim[axisIndex];
        }
      };
      /**
       * @return {Array.<module:echarts/coord/Axis>}
       */


      gridProto.getAxes = function () {
        return this._axesList.slice();
      };
      /**
       * Usage:
       *      grid.getCartesian(xAxisIndex, yAxisIndex);
       *      grid.getCartesian(xAxisIndex);
       *      grid.getCartesian(null, yAxisIndex);
       *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});
       *
       * @param {number|Object} [xAxisIndex]
       * @param {number} [yAxisIndex]
       */


      gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {
        if (xAxisIndex != null && yAxisIndex != null) {
          var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
          return this._coordsMap[key];
        }

        if (isObject(xAxisIndex)) {
          yAxisIndex = xAxisIndex.yAxisIndex;
          xAxisIndex = xAxisIndex.xAxisIndex;
        } // When only xAxisIndex or yAxisIndex given, find its first cartesian.


        for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
          if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {
            return coordList[i];
          }
        }
      };

      gridProto.getCartesians = function () {
        return this._coordsList.slice();
      };
      /**
       * @implements
       * see {module:echarts/CoodinateSystem}
       */


      gridProto.convertToPixel = function (ecModel, finder, value) {
        var target = this._findConvertTarget(ecModel, finder);

        return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
      };
      /**
       * @implements
       * see {module:echarts/CoodinateSystem}
       */


      gridProto.convertFromPixel = function (ecModel, finder, value) {
        var target = this._findConvertTarget(ecModel, finder);

        return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
      };
      /**
       * @inner
       */


      gridProto._findConvertTarget = function (ecModel, finder) {
        var seriesModel = finder.seriesModel;
        var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];
        var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];
        var gridModel = finder.gridModel;
        var coordsList = this._coordsList;
        var cartesian;
        var axis;

        if (seriesModel) {
          cartesian = seriesModel.coordinateSystem;
          indexOf(coordsList, cartesian) < 0 && (cartesian = null);
        } else if (xAxisModel && yAxisModel) {
          cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
        } else if (xAxisModel) {
          axis = this.getAxis('x', xAxisModel.componentIndex);
        } else if (yAxisModel) {
          axis = this.getAxis('y', yAxisModel.componentIndex);
        } // Lowest priority.
        else if (gridModel) {
          var grid = gridModel.coordinateSystem;

          if (grid === this) {
            cartesian = this._coordsList[0];
          }
        }

        return {
          cartesian: cartesian,
          axis: axis
        };
      };
      /**
       * @implements
       * see {module:echarts/CoodinateSystem}
       */


      gridProto.containPoint = function (point) {
        var coord = this._coordsList[0];

        if (coord) {
          return coord.containPoint(point);
        }
      };
      /**
       * Initialize cartesian coordinate systems
       * @private
       */


      gridProto._initCartesian = function (gridModel, ecModel, api) {
        var axisPositionUsed = {
          left: false,
          right: false,
          top: false,
          bottom: false
        };
        var axesMap = {
          x: {},
          y: {}
        };
        var axesCount = {
          x: 0,
          y: 0
        }; /// Create axis

        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);
        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);

        if (!axesCount.x || !axesCount.y) {
          // Roll back when there no either x or y axis
          this._axesMap = {};
          this._axesList = [];
          return;
        }

        this._axesMap = axesMap; /// Create cartesian2d

        each(axesMap.x, function (xAxis, xAxisIndex) {
          each(axesMap.y, function (yAxis, yAxisIndex) {
            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
            var cartesian = new Cartesian2D(key);
            cartesian.grid = this;
            cartesian.model = gridModel;
            this._coordsMap[key] = cartesian;

            this._coordsList.push(cartesian);

            cartesian.addAxis(xAxis);
            cartesian.addAxis(yAxis);
          }, this);
        }, this);

        function createAxisCreator(axisType) {
          return function (axisModel, idx) {
            if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {
              return;
            }

            var axisPosition = axisModel.get('position');

            if (axisType === 'x') {
              // Fix position
              if (axisPosition !== 'top' && axisPosition !== 'bottom') {
                // Default bottom of X
                axisPosition = axisPositionUsed.bottom ? 'top' : 'bottom';
              }
            } else {
              // Fix position
              if (axisPosition !== 'left' && axisPosition !== 'right') {
                // Default left of Y
                axisPosition = axisPositionUsed.left ? 'right' : 'left';
              }
            }

            axisPositionUsed[axisPosition] = true;
            var axis = new Axis2D(axisType, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);
            var isCategory = axis.type === 'category';
            axis.onBand = isCategory && axisModel.get('boundaryGap');
            axis.inverse = axisModel.get('inverse'); // Inject axis into axisModel

            axisModel.axis = axis; // Inject axisModel into axis

            axis.model = axisModel; // Inject grid info axis

            axis.grid = this; // Index of axis, can be used as key

            axis.index = idx;

            this._axesList.push(axis);

            axesMap[axisType][idx] = axis;
            axesCount[axisType]++;
          };
        }
      };
      /**
       * Update cartesian properties from series
       * @param  {module:echarts/model/Option} option
       * @private
       */


      gridProto._updateScale = function (ecModel, gridModel) {
        // Reset scale
        each(this._axesList, function (axis) {
          axis.scale.setExtent(Infinity, -Infinity);
        });
        ecModel.eachSeries(function (seriesModel) {
          if (isCartesian2D(seriesModel)) {
            var axesModels = findAxesModels(seriesModel, ecModel);
            var xAxisModel = axesModels[0];
            var yAxisModel = axesModels[1];

            if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {
              return;
            }

            var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
            var data = seriesModel.getData();
            var xAxis = cartesian.getAxis('x');
            var yAxis = cartesian.getAxis('y');

            if (data.type === 'list') {
              unionExtent(data, xAxis, seriesModel);
              unionExtent(data, yAxis, seriesModel);
            }
          }
        }, this);

        function unionExtent(data, axis, seriesModel) {
          each(data.mapDimension(axis.dim, true), function (dim) {
            axis.scale.unionExtentFromData( // For example, the extent of the orginal dimension
            // is [0.1, 0.5], the extent of the `stackResultDimension`
            // is [7, 9], the final extent should not include [0.1, 0.5].
            data, getStackedDimension(data, dim));
          });
        }
      };
      /**
       * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined
       * @return {Object} {baseAxes: [], otherAxes: []}
       */


      gridProto.getTooltipAxes = function (dim) {
        var baseAxes = [];
        var otherAxes = [];
        each(this.getCartesians(), function (cartesian) {
          var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
          var otherAxis = cartesian.getOtherAxis(baseAxis);
          indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
          indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
        });
        return {
          baseAxes: baseAxes,
          otherAxes: otherAxes
        };
      };
      /**
       * @inner
       */


      function updateAxisTransform(axis, coordBase) {
        var axisExtent = axis.getExtent();
        var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform

        axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {
          return coord + coordBase;
        } : function (coord) {
          return axisExtentSum - coord + coordBase;
        };
        axis.toLocalCoord = axis.dim === 'x' ? function (coord) {
          return coord - coordBase;
        } : function (coord) {
          return axisExtentSum - coord + coordBase;
        };
      }

      var axesTypes = ['xAxis', 'yAxis'];
      /**
       * @inner
       */

      function findAxesModels(seriesModel, ecModel) {
        return map(axesTypes, function (axisType) {
          var axisModel = seriesModel.getReferringComponents(axisType)[0];
          return axisModel;
        });
      }
      /**
       * @inner
       */


      function isCartesian2D(seriesModel) {
        return seriesModel.get('coordinateSystem') === 'cartesian2d';
      }

      Grid.create = function (ecModel, api) {
        var grids = [];
        ecModel.eachComponent('grid', function (gridModel, idx) {
          var grid = new Grid(gridModel, ecModel, api);
          grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize
          // should be performed in create stage.

          grid.resize(gridModel, api, true);
          gridModel.coordinateSystem = grid;
          grids.push(grid);
        }); // Inject the coordinateSystems into seriesModel

        ecModel.eachSeries(function (seriesModel) {
          if (!isCartesian2D(seriesModel)) {
            return;
          }

          var axesModels = findAxesModels(seriesModel, ecModel);
          var xAxisModel = axesModels[0];
          var yAxisModel = axesModels[1];
          var gridModel = xAxisModel.getCoordSysModel();
          var grid = gridModel.coordinateSystem;
          seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
        });
        return grids;
      }; // For deciding which dimensions to use when creating list data


      Grid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;
      CoordinateSystem.register('cartesian2d', Grid);
      var _default = Grid;
      module.exports = _default;
      /***/
    },

    /***/
    "XOKv":
    /*!***************************************************!*\
      !*** ./node_modules/echarts/lib/chart/heatmap.js ***!
      \***************************************************/

    /*! no static exports found */

    /***/
    function XOKv(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      __webpack_require__(
      /*! ./heatmap/HeatmapSeries */
      "OXB0");

      __webpack_require__(
      /*! ./heatmap/HeatmapView */
      "SA4+");
      /***/

    },

    /***/
    "XpcN":
    /*!*****************************************************************!*\
      !*** ./node_modules/echarts/lib/component/legend/LegendView.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function XpcN(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _symbol = __webpack_require__(
      /*! ../../util/symbol */
      "oVpE");

      var createSymbol = _symbol.createSymbol;

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var _listComponent = __webpack_require__(
      /*! ../helper/listComponent */
      "eRkO");

      var makeBackground = _listComponent.makeBackground;

      var layoutUtil = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var curry = zrUtil.curry;
      var each = zrUtil.each;
      var Group = graphic.Group;

      var _default = echarts.extendComponentView({
        type: 'legend.plain',
        newlineDisabled: false,

        /**
         * @override
         */
        init: function init() {
          /**
           * @private
           * @type {module:zrender/container/Group}
           */
          this.group.add(this._contentGroup = new Group());
          /**
           * @private
           * @type {module:zrender/Element}
           */

          this._backgroundEl;
          /**
           * @private
           * @type {module:zrender/container/Group}
           */

          this.group.add(this._selectorGroup = new Group());
          /**
           * If first rendering, `contentGroup.position` is [0, 0], which
           * does not make sense and may cause unexepcted animation if adopted.
           * @private
           * @type {boolean}
           */

          this._isFirstRender = true;
        },

        /**
         * @protected
         */
        getContentGroup: function getContentGroup() {
          return this._contentGroup;
        },

        /**
         * @protected
         */
        getSelectorGroup: function getSelectorGroup() {
          return this._selectorGroup;
        },

        /**
         * @override
         */
        render: function render(legendModel, ecModel, api) {
          var isFirstRender = this._isFirstRender;
          this._isFirstRender = false;
          this.resetInner();

          if (!legendModel.get('show', true)) {
            return;
          }

          var itemAlign = legendModel.get('align');
          var orient = legendModel.get('orient');

          if (!itemAlign || itemAlign === 'auto') {
            itemAlign = legendModel.get('left') === 'right' && orient === 'vertical' ? 'right' : 'left';
          }

          var selector = legendModel.get('selector', true);
          var selectorPosition = legendModel.get('selectorPosition', true);

          if (selector && (!selectorPosition || selectorPosition === 'auto')) {
            selectorPosition = orient === 'horizontal' ? 'end' : 'start';
          }

          this.renderInner(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition); // Perform layout.

          var positionInfo = legendModel.getBoxLayoutParams();
          var viewportSize = {
            width: api.getWidth(),
            height: api.getHeight()
          };
          var padding = legendModel.get('padding');
          var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);
          var mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition); // Place mainGroup, based on the calculated `mainRect`.

          var layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({
            width: mainRect.width,
            height: mainRect.height
          }, positionInfo), viewportSize, padding);
          this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]); // Render background after group is layout.

          this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));
        },

        /**
         * @protected
         */
        resetInner: function resetInner() {
          this.getContentGroup().removeAll();
          this._backgroundEl && this.group.remove(this._backgroundEl);
          this.getSelectorGroup().removeAll();
        },

        /**
         * @protected
         */
        renderInner: function renderInner(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
          var contentGroup = this.getContentGroup();
          var legendDrawnMap = zrUtil.createHashMap();
          var selectMode = legendModel.get('selectedMode');
          var excludeSeriesId = [];
          ecModel.eachRawSeries(function (seriesModel) {
            !seriesModel.get('legendHoverLink') && excludeSeriesId.push(seriesModel.id);
          });
          each(legendModel.getData(), function (itemModel, dataIndex) {
            var name = itemModel.get('name'); // Use empty string or \n as a newline string

            if (!this.newlineDisabled && (name === '' || name === '\n')) {
              contentGroup.add(new Group({
                newline: true
              }));
              return;
            } // Representitive series.


            var seriesModel = ecModel.getSeriesByName(name)[0];

            if (legendDrawnMap.get(name)) {
              // Have been drawed
              return;
            } // Legend to control series.


            if (seriesModel) {
              var data = seriesModel.getData();
              var color = data.getVisual('color');
              var borderColor = data.getVisual('borderColor'); // If color is a callback function

              if (typeof color === 'function') {
                // Use the first data
                color = color(seriesModel.getDataParams(0));
              } // If borderColor is a callback function


              if (typeof borderColor === 'function') {
                // Use the first data
                borderColor = borderColor(seriesModel.getDataParams(0));
              } // Using rect symbol defaultly


              var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';
              var symbolType = data.getVisual('symbol');

              var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, borderColor, selectMode);

              itemGroup.on('click', curry(dispatchSelectAction, name, null, api, excludeSeriesId)).on('mouseover', curry(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on('mouseout', curry(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId));
              legendDrawnMap.set(name, true);
            } else {
              // Legend to control data. In pie and funnel.
              ecModel.eachRawSeries(function (seriesModel) {
                // In case multiple series has same data name
                if (legendDrawnMap.get(name)) {
                  return;
                }

                if (seriesModel.legendVisualProvider) {
                  var provider = seriesModel.legendVisualProvider;

                  if (!provider.containName(name)) {
                    return;
                  }

                  var idx = provider.indexOfName(name);
                  var color = provider.getItemVisual(idx, 'color');
                  var borderColor = provider.getItemVisual(idx, 'borderColor');
                  var legendSymbolType = 'roundRect';

                  var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, borderColor, selectMode); // FIXME: consider different series has items with the same name.


                  itemGroup.on('click', curry(dispatchSelectAction, null, name, api, excludeSeriesId)) // Should not specify the series name, consider legend controls
                  // more than one pie series.
                  .on('mouseover', curry(dispatchHighlightAction, null, name, api, excludeSeriesId)).on('mouseout', curry(dispatchDownplayAction, null, name, api, excludeSeriesId));
                  legendDrawnMap.set(name, true);
                }
              }, this);
            }
          }, this);

          if (selector) {
            this._createSelector(selector, legendModel, api, orient, selectorPosition);
          }
        },
        _createSelector: function _createSelector(selector, legendModel, api, orient, selectorPosition) {
          var selectorGroup = this.getSelectorGroup();
          each(selector, function (selectorItem) {
            createSelectorButton(selectorItem);
          });

          function createSelectorButton(selectorItem) {
            var type = selectorItem.type;
            var labelText = new graphic.Text({
              style: {
                x: 0,
                y: 0,
                align: 'center',
                verticalAlign: 'middle'
              },
              onclick: function onclick() {
                api.dispatchAction({
                  type: type === 'all' ? 'legendAllSelect' : 'legendInverseSelect'
                });
              }
            });
            selectorGroup.add(labelText);
            var labelModel = legendModel.getModel('selectorLabel');
            var emphasisLabelModel = legendModel.getModel('emphasis.selectorLabel');
            graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, emphasisLabelModel, {
              defaultText: selectorItem.title,
              isRectText: false
            });
            graphic.setHoverStyle(labelText);
          }
        },
        _createItem: function _createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, borderColor, selectMode) {
          var itemWidth = legendModel.get('itemWidth');
          var itemHeight = legendModel.get('itemHeight');
          var inactiveColor = legendModel.get('inactiveColor');
          var inactiveBorderColor = legendModel.get('inactiveBorderColor');
          var symbolKeepAspect = legendModel.get('symbolKeepAspect');
          var legendModelItemStyle = legendModel.getModel('itemStyle');
          var isSelected = legendModel.isSelected(name);
          var itemGroup = new Group();
          var textStyleModel = itemModel.getModel('textStyle');
          var itemIcon = itemModel.get('icon');
          var tooltipModel = itemModel.getModel('tooltip');
          var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first

          legendSymbolType = itemIcon || legendSymbolType;
          var legendSymbol = createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, // symbolKeepAspect default true for legend
          symbolKeepAspect == null ? true : symbolKeepAspect);
          itemGroup.add(setSymbolStyle(legendSymbol, legendSymbolType, legendModelItemStyle, borderColor, inactiveBorderColor, isSelected)); // Compose symbols
          // PENDING

          if (!itemIcon && symbolType // At least show one symbol, can't be all none
          && (symbolType !== legendSymbolType || symbolType === 'none')) {
            var size = itemHeight * 0.8;

            if (symbolType === 'none') {
              symbolType = 'circle';
            }

            var legendSymbolCenter = createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor, // symbolKeepAspect default true for legend
            symbolKeepAspect == null ? true : symbolKeepAspect); // Put symbol in the center

            itemGroup.add(setSymbolStyle(legendSymbolCenter, symbolType, legendModelItemStyle, borderColor, inactiveBorderColor, isSelected));
          }

          var textX = itemAlign === 'left' ? itemWidth + 5 : -5;
          var textAlign = itemAlign;
          var formatter = legendModel.get('formatter');
          var content = name;

          if (typeof formatter === 'string' && formatter) {
            content = formatter.replace('{name}', name != null ? name : '');
          } else if (typeof formatter === 'function') {
            content = formatter(name);
          }

          itemGroup.add(new graphic.Text({
            style: graphic.setTextStyle({}, textStyleModel, {
              text: content,
              x: textX,
              y: itemHeight / 2,
              textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,
              textAlign: textAlign,
              textVerticalAlign: 'middle'
            })
          })); // Add a invisible rect to increase the area of mouse hover

          var hitRect = new graphic.Rect({
            shape: itemGroup.getBoundingRect(),
            invisible: true,
            tooltip: tooltipModel.get('show') ? zrUtil.extend({
              content: name,
              // Defaul formatter
              formatter: legendGlobalTooltipModel.get('formatter', true) || function () {
                return name;
              },
              formatterParams: {
                componentType: 'legend',
                legendIndex: legendModel.componentIndex,
                name: name,
                $vars: ['name']
              }
            }, tooltipModel.option) : null
          });
          itemGroup.add(hitRect);
          itemGroup.eachChild(function (child) {
            child.silent = true;
          });
          hitRect.silent = !selectMode;
          this.getContentGroup().add(itemGroup);
          graphic.setHoverStyle(itemGroup);
          itemGroup.__legendDataIndex = dataIndex;
          return itemGroup;
        },

        /**
         * @protected
         */
        layoutInner: function layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
          var contentGroup = this.getContentGroup();
          var selectorGroup = this.getSelectorGroup(); // Place items in contentGroup.

          layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);
          var contentRect = contentGroup.getBoundingRect();
          var contentPos = [-contentRect.x, -contentRect.y];

          if (selector) {
            // Place buttons in selectorGroup
            layoutUtil.box( // Buttons in selectorGroup always layout horizontally
            'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));
            var selectorRect = selectorGroup.getBoundingRect();
            var selectorPos = [-selectorRect.x, -selectorRect.y];
            var selectorButtonGap = legendModel.get('selectorButtonGap', true);
            var orientIdx = legendModel.getOrient().index;
            var wh = orientIdx === 0 ? 'width' : 'height';
            var hw = orientIdx === 0 ? 'height' : 'width';
            var yx = orientIdx === 0 ? 'y' : 'x';

            if (selectorPosition === 'end') {
              selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;
            } else {
              contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;
            } //Always align selector to content as 'middle'


            selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;
            selectorGroup.attr('position', selectorPos);
            contentGroup.attr('position', contentPos);
            var mainRect = {
              x: 0,
              y: 0
            };
            mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];
            mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);
            mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);
            return mainRect;
          } else {
            contentGroup.attr('position', contentPos);
            return this.group.getBoundingRect();
          }
        },

        /**
         * @protected
         */
        remove: function remove() {
          this.getContentGroup().removeAll();
          this._isFirstRender = true;
        }
      });

      function setSymbolStyle(symbol, symbolType, legendModelItemStyle, borderColor, inactiveBorderColor, isSelected) {
        var itemStyle;

        if (symbolType !== 'line' && symbolType.indexOf('empty') < 0) {
          itemStyle = legendModelItemStyle.getItemStyle();
          symbol.style.stroke = borderColor;

          if (!isSelected) {
            itemStyle.stroke = inactiveBorderColor;
          }
        } else {
          itemStyle = legendModelItemStyle.getItemStyle(['borderWidth', 'borderColor']);
        }

        return symbol.setStyle(itemStyle);
      }

      function dispatchSelectAction(seriesName, dataName, api, excludeSeriesId) {
        // downplay before unselect
        dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId);
        api.dispatchAction({
          type: 'legendToggleSelect',
          name: seriesName != null ? seriesName : dataName
        }); // highlight after select

        dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId);
      }

      function dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId) {
        // If element hover will move to a hoverLayer.
        var el = api.getZr().storage.getDisplayList()[0];

        if (!(el && el.useHoverLayer)) {
          api.dispatchAction({
            type: 'highlight',
            seriesName: seriesName,
            name: dataName,
            excludeSeriesId: excludeSeriesId
          });
        }
      }

      function dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId) {
        // If element hover will move to a hoverLayer.
        var el = api.getZr().storage.getDisplayList()[0];

        if (!(el && el.useHoverLayer)) {
          api.dispatchAction({
            type: 'downplay',
            seriesName: seriesName,
            name: dataName,
            excludeSeriesId: excludeSeriesId
          });
        }
      }

      module.exports = _default;
      /***/
    },

    /***/
    "XxSj":
    /*!**********************************************************!*\
      !*** ./node_modules/echarts/lib/visual/VisualMapping.js ***!
      \**********************************************************/

    /*! no static exports found */

    /***/
    function XxSj(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var zrColor = __webpack_require__(
      /*! zrender/lib/tool/color */
      "Qe9p");

      var _number = __webpack_require__(
      /*! ../util/number */
      "OELB");

      var linearMap = _number.linearMap;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var each = zrUtil.each;
      var isObject = zrUtil.isObject;
      var CATEGORY_DEFAULT_VISUAL_INDEX = -1;
      /**
       * @param {Object} option
       * @param {string} [option.type] See visualHandlers.
       * @param {string} [option.mappingMethod] 'linear' or 'piecewise' or 'category' or 'fixed'
       * @param {Array.<number>=} [option.dataExtent] [minExtent, maxExtent],
       *                                              required when mappingMethod is 'linear'
       * @param {Array.<Object>=} [option.pieceList] [
       *                                             {value: someValue},
       *                                             {interval: [min1, max1], visual: {...}},
       *                                             {interval: [min2, max2]}
       *                                             ],
       *                                            required when mappingMethod is 'piecewise'.
       *                                            Visual for only each piece can be specified.
       * @param {Array.<string|Object>=} [option.categories] ['cate1', 'cate2']
       *                                            required when mappingMethod is 'category'.
       *                                            If no option.categories, categories is set
       *                                            as [0, 1, 2, ...].
       * @param {boolean} [option.loop=false] Whether loop mapping when mappingMethod is 'category'.
       * @param {(Array|Object|*)} [option.visual]  Visual data.
       *                                            when mappingMethod is 'category',
       *                                            visual data can be array or object
       *                                            (like: {cate1: '#222', none: '#fff'})
       *                                            or primary types (which represents
       *                                            default category visual), otherwise visual
       *                                            can be array or primary (which will be
       *                                            normalized to array).
       *
       */

      var VisualMapping = function VisualMapping(option) {
        var mappingMethod = option.mappingMethod;
        var visualType = option.type;
        /**
         * @readOnly
         * @type {Object}
         */

        var thisOption = this.option = zrUtil.clone(option);
        /**
         * @readOnly
         * @type {string}
         */

        this.type = visualType;
        /**
         * @readOnly
         * @type {string}
         */

        this.mappingMethod = mappingMethod;
        /**
         * @private
         * @type {Function}
         */

        this._normalizeData = normalizers[mappingMethod];
        var visualHandler = visualHandlers[visualType];
        /**
         * @public
         * @type {Function}
         */

        this.applyVisual = visualHandler.applyVisual;
        /**
         * @public
         * @type {Function}
         */

        this.getColorMapper = visualHandler.getColorMapper;
        /**
         * @private
         * @type {Function}
         */

        this._doMap = visualHandler._doMap[mappingMethod];

        if (mappingMethod === 'piecewise') {
          normalizeVisualRange(thisOption);
          preprocessForPiecewise(thisOption);
        } else if (mappingMethod === 'category') {
          thisOption.categories ? preprocessForSpecifiedCategory(thisOption) // categories is ordinal when thisOption.categories not specified,
          // which need no more preprocess except normalize visual.
          : normalizeVisualRange(thisOption, true);
        } else {
          // mappingMethod === 'linear' or 'fixed'
          zrUtil.assert(mappingMethod !== 'linear' || thisOption.dataExtent);
          normalizeVisualRange(thisOption);
        }
      };

      VisualMapping.prototype = {
        constructor: VisualMapping,
        mapValueToVisual: function mapValueToVisual(value) {
          var normalized = this._normalizeData(value);

          return this._doMap(normalized, value);
        },
        getNormalizer: function getNormalizer() {
          return zrUtil.bind(this._normalizeData, this);
        }
      };
      var visualHandlers = VisualMapping.visualHandlers = {
        color: {
          applyVisual: makeApplyVisual('color'),

          /**
           * Create a mapper function
           * @return {Function}
           */
          getColorMapper: function getColorMapper() {
            var thisOption = this.option;
            return zrUtil.bind(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {
              !isNormalized && (value = this._normalizeData(value));
              return doMapCategory.call(this, value);
            } : function (value, isNormalized, out) {
              // If output rgb array
              // which will be much faster and useful in pixel manipulation
              var returnRGBArray = !!out;
              !isNormalized && (value = this._normalizeData(value));
              out = zrColor.fastLerp(value, thisOption.parsedVisual, out);
              return returnRGBArray ? out : zrColor.stringify(out, 'rgba');
            }, this);
          },
          _doMap: {
            linear: function linear(normalized) {
              return zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');
            },
            category: doMapCategory,
            piecewise: function piecewise(normalized, value) {
              var result = getSpecifiedVisual.call(this, value);

              if (result == null) {
                result = zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');
              }

              return result;
            },
            fixed: doMapFixed
          }
        },
        colorHue: makePartialColorVisualHandler(function (color, value) {
          return zrColor.modifyHSL(color, value);
        }),
        colorSaturation: makePartialColorVisualHandler(function (color, value) {
          return zrColor.modifyHSL(color, null, value);
        }),
        colorLightness: makePartialColorVisualHandler(function (color, value) {
          return zrColor.modifyHSL(color, null, null, value);
        }),
        colorAlpha: makePartialColorVisualHandler(function (color, value) {
          return zrColor.modifyAlpha(color, value);
        }),
        opacity: {
          applyVisual: makeApplyVisual('opacity'),
          _doMap: makeDoMap([0, 1])
        },
        liftZ: {
          applyVisual: makeApplyVisual('liftZ'),
          _doMap: {
            linear: doMapFixed,
            category: doMapFixed,
            piecewise: doMapFixed,
            fixed: doMapFixed
          }
        },
        symbol: {
          applyVisual: function applyVisual(value, getter, setter) {
            var symbolCfg = this.mapValueToVisual(value);

            if (zrUtil.isString(symbolCfg)) {
              setter('symbol', symbolCfg);
            } else if (isObject(symbolCfg)) {
              for (var name in symbolCfg) {
                if (symbolCfg.hasOwnProperty(name)) {
                  setter(name, symbolCfg[name]);
                }
              }
            }
          },
          _doMap: {
            linear: doMapToArray,
            category: doMapCategory,
            piecewise: function piecewise(normalized, value) {
              var result = getSpecifiedVisual.call(this, value);

              if (result == null) {
                result = doMapToArray.call(this, normalized);
              }

              return result;
            },
            fixed: doMapFixed
          }
        },
        symbolSize: {
          applyVisual: makeApplyVisual('symbolSize'),
          _doMap: makeDoMap([0, 1])
        }
      };

      function preprocessForPiecewise(thisOption) {
        var pieceList = thisOption.pieceList;
        thisOption.hasSpecialVisual = false;
        zrUtil.each(pieceList, function (piece, index) {
          piece.originIndex = index; // piece.visual is "result visual value" but not
          // a visual range, so it does not need to be normalized.

          if (piece.visual != null) {
            thisOption.hasSpecialVisual = true;
          }
        });
      }

      function preprocessForSpecifiedCategory(thisOption) {
        // Hash categories.
        var categories = thisOption.categories;
        var visual = thisOption.visual;
        var categoryMap = thisOption.categoryMap = {};
        each(categories, function (cate, index) {
          categoryMap[cate] = index;
        }); // Process visual map input.

        if (!zrUtil.isArray(visual)) {
          var visualArr = [];

          if (zrUtil.isObject(visual)) {
            each(visual, function (v, cate) {
              var index = categoryMap[cate];
              visualArr[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;
            });
          } else {
            // Is primary type, represents default visual.
            visualArr[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;
          }

          visual = setVisualToOption(thisOption, visualArr);
        } // Remove categories that has no visual,
        // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.


        for (var i = categories.length - 1; i >= 0; i--) {
          if (visual[i] == null) {
            delete categoryMap[categories[i]];
            categories.pop();
          }
        }
      }

      function normalizeVisualRange(thisOption, isCategory) {
        var visual = thisOption.visual;
        var visualArr = [];

        if (zrUtil.isObject(visual)) {
          each(visual, function (v) {
            visualArr.push(v);
          });
        } else if (visual != null) {
          visualArr.push(visual);
        }

        var doNotNeedPair = {
          color: 1,
          symbol: 1
        };

        if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {
          // Do not care visualArr.length === 0, which is illegal.
          visualArr[1] = visualArr[0];
        }

        setVisualToOption(thisOption, visualArr);
      }

      function makePartialColorVisualHandler(applyValue) {
        return {
          applyVisual: function applyVisual(value, getter, setter) {
            value = this.mapValueToVisual(value); // Must not be array value

            setter('color', applyValue(getter('color'), value));
          },
          _doMap: makeDoMap([0, 1])
        };
      }

      function doMapToArray(normalized) {
        var visual = this.option.visual;
        return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {};
      }

      function makeApplyVisual(visualType) {
        return function (value, getter, setter) {
          setter(visualType, this.mapValueToVisual(value));
        };
      }

      function doMapCategory(normalized) {
        var visual = this.option.visual;
        return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];
      }

      function doMapFixed() {
        return this.option.visual[0];
      }

      function makeDoMap(sourceExtent) {
        return {
          linear: function linear(normalized) {
            return linearMap(normalized, sourceExtent, this.option.visual, true);
          },
          category: doMapCategory,
          piecewise: function piecewise(normalized, value) {
            var result = getSpecifiedVisual.call(this, value);

            if (result == null) {
              result = linearMap(normalized, sourceExtent, this.option.visual, true);
            }

            return result;
          },
          fixed: doMapFixed
        };
      }

      function getSpecifiedVisual(value) {
        var thisOption = this.option;
        var pieceList = thisOption.pieceList;

        if (thisOption.hasSpecialVisual) {
          var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);
          var piece = pieceList[pieceIndex];

          if (piece && piece.visual) {
            return piece.visual[this.type];
          }
        }
      }

      function setVisualToOption(thisOption, visualArr) {
        thisOption.visual = visualArr;

        if (thisOption.type === 'color') {
          thisOption.parsedVisual = zrUtil.map(visualArr, function (item) {
            return zrColor.parse(item);
          });
        }

        return visualArr;
      }
      /**
       * Normalizers by mapping methods.
       */


      var normalizers = {
        linear: function linear(value) {
          return linearMap(value, this.option.dataExtent, [0, 1], true);
        },
        piecewise: function piecewise(value) {
          var pieceList = this.option.pieceList;
          var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);

          if (pieceIndex != null) {
            return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);
          }
        },
        category: function category(value) {
          var index = this.option.categories ? this.option.categoryMap[value] : value; // ordinal

          return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;
        },
        fixed: zrUtil.noop
      };
      /**
       * List available visual types.
       *
       * @public
       * @return {Array.<string>}
       */

      VisualMapping.listVisualTypes = function () {
        var visualTypes = [];
        zrUtil.each(visualHandlers, function (handler, key) {
          visualTypes.push(key);
        });
        return visualTypes;
      };
      /**
       * @public
       */


      VisualMapping.addVisualHandler = function (name, handler) {
        visualHandlers[name] = handler;
      };
      /**
       * @public
       */


      VisualMapping.isValidType = function (visualType) {
        return visualHandlers.hasOwnProperty(visualType);
      };
      /**
       * Convinent method.
       * Visual can be Object or Array or primary type.
       *
       * @public
       */


      VisualMapping.eachVisual = function (visual, callback, context) {
        if (zrUtil.isObject(visual)) {
          zrUtil.each(visual, callback, context);
        } else {
          callback.call(context, visual);
        }
      };

      VisualMapping.mapVisual = function (visual, callback, context) {
        var isPrimary;
        var newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = true, null);
        VisualMapping.eachVisual(visual, function (v, key) {
          var newVal = callback.call(context, v, key);
          isPrimary ? newVisual = newVal : newVisual[key] = newVal;
        });
        return newVisual;
      };
      /**
       * @public
       * @param {Object} obj
       * @return {Object} new object containers visual values.
       *                 If no visuals, return null.
       */


      VisualMapping.retrieveVisuals = function (obj) {
        var ret = {};
        var hasVisual;
        obj && each(visualHandlers, function (h, visualType) {
          if (obj.hasOwnProperty(visualType)) {
            ret[visualType] = obj[visualType];
            hasVisual = true;
          }
        });
        return hasVisual ? ret : null;
      };
      /**
       * Give order to visual types, considering colorSaturation, colorAlpha depends on color.
       *
       * @public
       * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}
       *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']
       * @return {Array.<string>} Sorted visual types.
       */


      VisualMapping.prepareVisualTypes = function (visualTypes) {
        if (isObject(visualTypes)) {
          var types = [];
          each(visualTypes, function (item, type) {
            types.push(type);
          });
          visualTypes = types;
        } else if (zrUtil.isArray(visualTypes)) {
          visualTypes = visualTypes.slice();
        } else {
          return [];
        }

        visualTypes.sort(function (type1, type2) {
          // color should be front of colorSaturation, colorAlpha, ...
          // symbol and symbolSize do not matter.
          return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;
        });
        return visualTypes;
      };
      /**
       * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.
       * Other visuals are only depends on themself.
       *
       * @public
       * @param {string} visualType1
       * @param {string} visualType2
       * @return {boolean}
       */


      VisualMapping.dependsOn = function (visualType1, visualType2) {
        return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;
      };
      /**
       * @param {number} value
       * @param {Array.<Object>} pieceList [{value: ..., interval: [min, max]}, ...]
       *                         Always from small to big.
       * @param {boolean} [findClosestWhenOutside=false]
       * @return {number} index
       */


      VisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {
        var possibleI;
        var abs = Infinity; // value has the higher priority.

        for (var i = 0, len = pieceList.length; i < len; i++) {
          var pieceValue = pieceList[i].value;

          if (pieceValue != null) {
            if (pieceValue === value // FIXME
            // It is supposed to compare value according to value type of dimension,
            // but currently value type can exactly be string or number.
            // Compromise for numeric-like string (like '12'), especially
            // in the case that visualMap.categories is ['22', '33'].
            || typeof pieceValue === 'string' && pieceValue === value + '') {
              return i;
            }

            findClosestWhenOutside && updatePossible(pieceValue, i);
          }
        }

        for (var i = 0, len = pieceList.length; i < len; i++) {
          var piece = pieceList[i];
          var interval = piece.interval;
          var close = piece.close;

          if (interval) {
            if (interval[0] === -Infinity) {
              if (littleThan(close[1], value, interval[1])) {
                return i;
              }
            } else if (interval[1] === Infinity) {
              if (littleThan(close[0], interval[0], value)) {
                return i;
              }
            } else if (littleThan(close[0], interval[0], value) && littleThan(close[1], value, interval[1])) {
              return i;
            }

            findClosestWhenOutside && updatePossible(interval[0], i);
            findClosestWhenOutside && updatePossible(interval[1], i);
          }
        }

        if (findClosestWhenOutside) {
          return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;
        }

        function updatePossible(val, index) {
          var newAbs = Math.abs(val - value);

          if (newAbs < abs) {
            abs = newAbs;
            possibleI = index;
          }
        }
      };

      function littleThan(close, a, b) {
        return close ? a <= b : a < b;
      }

      var _default = VisualMapping;
      module.exports = _default;
      /***/
    },

    /***/
    "YNf1":
    /*!*****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/parallel/ParallelView.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function YNf1(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var ChartView = __webpack_require__(
      /*! ../../view/Chart */
      "6Ic6");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var DEFAULT_SMOOTH = 0.3;
      var ParallelView = ChartView.extend({
        type: 'parallel',
        init: function init() {
          /**
           * @type {module:zrender/container/Group}
           * @private
           */
          this._dataGroup = new graphic.Group();
          this.group.add(this._dataGroup);
          /**
           * @type {module:echarts/data/List}
           */

          this._data;
          /**
           * @type {boolean}
           */

          this._initialized;
        },

        /**
         * @override
         */
        render: function render(seriesModel, ecModel, api, payload) {
          var dataGroup = this._dataGroup;
          var data = seriesModel.getData();
          var oldData = this._data;
          var coordSys = seriesModel.coordinateSystem;
          var dimensions = coordSys.dimensions;
          var seriesScope = makeSeriesScope(seriesModel);
          data.diff(oldData).add(add).update(update).remove(remove).execute();

          function add(newDataIndex) {
            var line = addEl(data, dataGroup, newDataIndex, dimensions, coordSys);
            updateElCommon(line, data, newDataIndex, seriesScope);
          }

          function update(newDataIndex, oldDataIndex) {
            var line = oldData.getItemGraphicEl(oldDataIndex);
            var points = createLinePoints(data, newDataIndex, dimensions, coordSys);
            data.setItemGraphicEl(newDataIndex, line);
            var animationModel = payload && payload.animation === false ? null : seriesModel;
            graphic.updateProps(line, {
              shape: {
                points: points
              }
            }, animationModel, newDataIndex);
            updateElCommon(line, data, newDataIndex, seriesScope);
          }

          function remove(oldDataIndex) {
            var line = oldData.getItemGraphicEl(oldDataIndex);
            dataGroup.remove(line);
          } // First create


          if (!this._initialized) {
            this._initialized = true;
            var clipPath = createGridClipShape(coordSys, seriesModel, function () {
              // Callback will be invoked immediately if there is no animation
              setTimeout(function () {
                dataGroup.removeClipPath();
              });
            });
            dataGroup.setClipPath(clipPath);
          }

          this._data = data;
        },
        incrementalPrepareRender: function incrementalPrepareRender(seriesModel, ecModel, api) {
          this._initialized = true;
          this._data = null;

          this._dataGroup.removeAll();
        },
        incrementalRender: function incrementalRender(taskParams, seriesModel, ecModel) {
          var data = seriesModel.getData();
          var coordSys = seriesModel.coordinateSystem;
          var dimensions = coordSys.dimensions;
          var seriesScope = makeSeriesScope(seriesModel);

          for (var dataIndex = taskParams.start; dataIndex < taskParams.end; dataIndex++) {
            var line = addEl(data, this._dataGroup, dataIndex, dimensions, coordSys);
            line.incremental = true;
            updateElCommon(line, data, dataIndex, seriesScope);
          }
        },
        dispose: function dispose() {},
        // _renderForProgressive: function (seriesModel) {
        //     var dataGroup = this._dataGroup;
        //     var data = seriesModel.getData();
        //     var oldData = this._data;
        //     var coordSys = seriesModel.coordinateSystem;
        //     var dimensions = coordSys.dimensions;
        //     var option = seriesModel.option;
        //     var progressive = option.progressive;
        //     var smooth = option.smooth ? SMOOTH : null;
        //     // In progressive animation is disabled, so use simple data diff,
        //     // which effects performance less.
        //     // (Typically performance for data with length 7000+ like:
        //     // simpleDiff: 60ms, addEl: 184ms,
        //     // in RMBP 2.4GHz intel i7, OSX 10.9 chrome 50.0.2661.102 (64-bit))
        //     if (simpleDiff(oldData, data, dimensions)) {
        //         dataGroup.removeAll();
        //         data.each(function (dataIndex) {
        //             addEl(data, dataGroup, dataIndex, dimensions, coordSys);
        //         });
        //     }
        //     updateElCommon(data, progressive, smooth);
        //     // Consider switch between progressive and not.
        //     data.__plProgressive = true;
        //     this._data = data;
        // },

        /**
         * @override
         */
        remove: function remove() {
          this._dataGroup && this._dataGroup.removeAll();
          this._data = null;
        }
      });

      function createGridClipShape(coordSys, seriesModel, cb) {
        var parallelModel = coordSys.model;
        var rect = coordSys.getRect();
        var rectEl = new graphic.Rect({
          shape: {
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height
          }
        });
        var dim = parallelModel.get('layout') === 'horizontal' ? 'width' : 'height';
        rectEl.setShape(dim, 0);
        graphic.initProps(rectEl, {
          shape: {
            width: rect.width,
            height: rect.height
          }
        }, seriesModel, cb);
        return rectEl;
      }

      function createLinePoints(data, dataIndex, dimensions, coordSys) {
        var points = [];

        for (var i = 0; i < dimensions.length; i++) {
          var dimName = dimensions[i];
          var value = data.get(data.mapDimension(dimName), dataIndex);

          if (!isEmptyValue(value, coordSys.getAxis(dimName).type)) {
            points.push(coordSys.dataToPoint(value, dimName));
          }
        }

        return points;
      }

      function addEl(data, dataGroup, dataIndex, dimensions, coordSys) {
        var points = createLinePoints(data, dataIndex, dimensions, coordSys);
        var line = new graphic.Polyline({
          shape: {
            points: points
          },
          silent: true,
          z2: 10
        });
        dataGroup.add(line);
        data.setItemGraphicEl(dataIndex, line);
        return line;
      }

      function makeSeriesScope(seriesModel) {
        var smooth = seriesModel.get('smooth', true);
        smooth === true && (smooth = DEFAULT_SMOOTH);
        return {
          lineStyle: seriesModel.getModel('lineStyle').getLineStyle(),
          smooth: smooth != null ? smooth : DEFAULT_SMOOTH
        };
      }

      function updateElCommon(el, data, dataIndex, seriesScope) {
        var lineStyle = seriesScope.lineStyle;

        if (data.hasItemOption) {
          var lineStyleModel = data.getItemModel(dataIndex).getModel('lineStyle');
          lineStyle = lineStyleModel.getLineStyle();
        }

        el.useStyle(lineStyle);
        var elStyle = el.style;
        elStyle.fill = null; // lineStyle.color have been set to itemVisual in module:echarts/visual/seriesColor.

        elStyle.stroke = data.getItemVisual(dataIndex, 'color'); // lineStyle.opacity have been set to itemVisual in parallelVisual.

        elStyle.opacity = data.getItemVisual(dataIndex, 'opacity');
        seriesScope.smooth && (el.shape.smooth = seriesScope.smooth);
      } // function simpleDiff(oldData, newData, dimensions) {
      //     var oldLen;
      //     if (!oldData
      //         || !oldData.__plProgressive
      //         || (oldLen = oldData.count()) !== newData.count()
      //     ) {
      //         return true;
      //     }
      //     var dimLen = dimensions.length;
      //     for (var i = 0; i < oldLen; i++) {
      //         for (var j = 0; j < dimLen; j++) {
      //             if (oldData.get(dimensions[j], i) !== newData.get(dimensions[j], i)) {
      //                 return true;
      //             }
      //         }
      //     }
      //     return false;
      // }
      // FIXME
      // ?


      function isEmptyValue(val, axisType) {
        return axisType === 'category' ? val == null : val == null || isNaN(val); // axisType === 'value'
      }

      var _default = ParallelView;
      module.exports = _default;
      /***/
    },

    /***/
    "YOMW":
    /*!**********************************************************!*\
      !*** ./node_modules/echarts/lib/visual/visualDefault.js ***!
      \**********************************************************/

    /*! no static exports found */

    /***/
    function YOMW(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @file Visual mapping.
       */


      var visualDefault = {
        /**
         * @public
         */
        get: function get(visualType, key, isCategory) {
          var value = zrUtil.clone((defaultOption[visualType] || {})[key]);
          return isCategory ? zrUtil.isArray(value) ? value[value.length - 1] : value : value;
        }
      };
      var defaultOption = {
        color: {
          active: ['#006edd', '#e0ffff'],
          inactive: ['rgba(0,0,0,0)']
        },
        colorHue: {
          active: [0, 360],
          inactive: [0, 0]
        },
        colorSaturation: {
          active: [0.3, 1],
          inactive: [0, 0]
        },
        colorLightness: {
          active: [0.9, 0.5],
          inactive: [0, 0]
        },
        colorAlpha: {
          active: [0.3, 1],
          inactive: [0, 0]
        },
        opacity: {
          active: [0.3, 1],
          inactive: [0, 0]
        },
        symbol: {
          active: ['circle', 'roundRect', 'diamond'],
          inactive: ['none']
        },
        symbolSize: {
          active: [10, 50],
          inactive: [0, 0]
        }
      };
      var _default = visualDefault;
      module.exports = _default;
      /***/
    },

    /***/
    "Ynxi":
    /*!*****************************************************!*\
      !*** ./node_modules/echarts/lib/component/title.js ***!
      \*****************************************************/

    /*! no static exports found */

    /***/
    function Ynxi(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      var graphic = __webpack_require__(
      /*! ../util/graphic */
      "IwbS");

      var _layout = __webpack_require__(
      /*! ../util/layout */
      "+TT/");

      var getLayoutRect = _layout.getLayoutRect;

      var _format = __webpack_require__(
      /*! ../util/format */
      "7aKB");

      var windowOpen = _format.windowOpen;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // Model

      echarts.extendComponentModel({
        type: 'title',
        layoutMode: {
          type: 'box',
          ignoreSize: true
        },
        defaultOption: {
          // 
          zlevel: 0,
          // 
          z: 6,
          show: true,
          text: '',
          // 
          // link: null,
          // self | blank
          target: 'blank',
          subtext: '',
          // 
          // sublink: null,
          // self | blank
          subtarget: 'blank',
          // 'center'  'left'  'right'
          //  {number}xpx
          left: 0,
          // 'top'  'bottom'  'center'
          //  {number}ypx
          top: 0,
          // 
          // 'auto' | 'left' | 'right' | 'center'
          //  left 
          // textAlign: null
          //
          // 
          // 'auto' | 'top' | 'bottom' | 'middle'
          //  top 
          // textVerticalAlign: null
          // textBaseline: null // The same as textVerticalAlign.
          backgroundColor: 'rgba(0,0,0,0)',
          // 
          borderColor: '#ccc',
          // px0
          borderWidth: 0,
          // px5
          // css
          padding: 5,
          // px10
          itemGap: 10,
          textStyle: {
            fontSize: 18,
            fontWeight: 'bolder',
            color: '#333'
          },
          subtextStyle: {
            color: '#aaa'
          }
        }
      }); // View

      echarts.extendComponentView({
        type: 'title',
        render: function render(titleModel, ecModel, api) {
          this.group.removeAll();

          if (!titleModel.get('show')) {
            return;
          }

          var group = this.group;
          var textStyleModel = titleModel.getModel('textStyle');
          var subtextStyleModel = titleModel.getModel('subtextStyle');
          var textAlign = titleModel.get('textAlign');
          var textVerticalAlign = zrUtil.retrieve2(titleModel.get('textBaseline'), titleModel.get('textVerticalAlign'));
          var textEl = new graphic.Text({
            style: graphic.setTextStyle({}, textStyleModel, {
              text: titleModel.get('text'),
              textFill: textStyleModel.getTextColor()
            }, {
              disableBox: true
            }),
            z2: 10
          });
          var textRect = textEl.getBoundingRect();
          var subText = titleModel.get('subtext');
          var subTextEl = new graphic.Text({
            style: graphic.setTextStyle({}, subtextStyleModel, {
              text: subText,
              textFill: subtextStyleModel.getTextColor(),
              y: textRect.height + titleModel.get('itemGap'),
              textVerticalAlign: 'top'
            }, {
              disableBox: true
            }),
            z2: 10
          });
          var link = titleModel.get('link');
          var sublink = titleModel.get('sublink');
          var triggerEvent = titleModel.get('triggerEvent', true);
          textEl.silent = !link && !triggerEvent;
          subTextEl.silent = !sublink && !triggerEvent;

          if (link) {
            textEl.on('click', function () {
              windowOpen(link, '_' + titleModel.get('target'));
            });
          }

          if (sublink) {
            subTextEl.on('click', function () {
              windowOpen(sublink, '_' + titleModel.get('subtarget'));
            });
          }

          textEl.eventData = subTextEl.eventData = triggerEvent ? {
            componentType: 'title',
            componentIndex: titleModel.componentIndex
          } : null;
          group.add(textEl);
          subText && group.add(subTextEl); // If no subText, but add subTextEl, there will be an empty line.

          var groupRect = group.getBoundingRect();
          var layoutOption = titleModel.getBoxLayoutParams();
          layoutOption.width = groupRect.width;
          layoutOption.height = groupRect.height;
          var layoutRect = getLayoutRect(layoutOption, {
            width: api.getWidth(),
            height: api.getHeight()
          }, titleModel.get('padding')); // Adjust text align based on position

          if (!textAlign) {
            // Align left if title is on the left. center and right is same
            textAlign = titleModel.get('left') || titleModel.get('right');

            if (textAlign === 'middle') {
              textAlign = 'center';
            } // Adjust layout by text align


            if (textAlign === 'right') {
              layoutRect.x += layoutRect.width;
            } else if (textAlign === 'center') {
              layoutRect.x += layoutRect.width / 2;
            }
          }

          if (!textVerticalAlign) {
            textVerticalAlign = titleModel.get('top') || titleModel.get('bottom');

            if (textVerticalAlign === 'center') {
              textVerticalAlign = 'middle';
            }

            if (textVerticalAlign === 'bottom') {
              layoutRect.y += layoutRect.height;
            } else if (textVerticalAlign === 'middle') {
              layoutRect.y += layoutRect.height / 2;
            }

            textVerticalAlign = textVerticalAlign || 'top';
          }

          group.attr('position', [layoutRect.x, layoutRect.y]);
          var alignStyle = {
            textAlign: textAlign,
            textVerticalAlign: textVerticalAlign
          };
          textEl.setStyle(alignStyle);
          subTextEl.setStyle(alignStyle); // Render background
          // Get groupRect again because textAlign has been changed

          groupRect = group.getBoundingRect();
          var padding = layoutRect.margin;
          var style = titleModel.getItemStyle(['color', 'opacity']);
          style.fill = titleModel.get('backgroundColor');
          var rect = new graphic.Rect({
            shape: {
              x: groupRect.x - padding[3],
              y: groupRect.y - padding[0],
              width: groupRect.width + padding[1] + padding[3],
              height: groupRect.height + padding[0] + padding[2],
              r: titleModel.get('borderRadius')
            },
            style: style,
            subPixelOptimize: true,
            silent: true
          });
          group.add(rect);
        }
      });
      /***/
    },

    /***/
    "Z1r0":
    /*!****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/graph/categoryFilter.js ***!
      \****************************************************************/

    /*! no static exports found */

    /***/
    function Z1r0(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      function _default(ecModel) {
        var legendModels = ecModel.findComponents({
          mainType: 'legend'
        });

        if (!legendModels || !legendModels.length) {
          return;
        }

        ecModel.eachSeriesByType('graph', function (graphSeries) {
          var categoriesData = graphSeries.getCategoriesData();
          var graph = graphSeries.getGraph();
          var data = graph.data;
          var categoryNames = categoriesData.mapArray(categoriesData.getName);
          data.filterSelf(function (idx) {
            var model = data.getItemModel(idx);
            var category = model.getShallow('category');

            if (category != null) {
              if (typeof category === 'number') {
                category = categoryNames[category];
              } // If in any legend component the status is not selected.


              for (var i = 0; i < legendModels.length; i++) {
                if (!legendModels[i].isSelected(category)) {
                  return false;
                }
              }
            }

            return true;
          });
        }, this);
      }

      module.exports = _default;
      /***/
    },

    /***/
    "Z1wy":
    /*!***********************************************!*\
      !*** ./node_modules/echarts/lib/chart/map.js ***!
      \***********************************************/

    /*! no static exports found */

    /***/
    function Z1wy(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ./map/MapSeries */
      "ThAp");

      __webpack_require__(
      /*! ./map/MapView */
      "pmaE");

      __webpack_require__(
      /*! ../action/geoRoam */
      "SehX");

      __webpack_require__(
      /*! ../coord/geo/geoCreator */
      "7uqq");

      var mapSymbolLayout = __webpack_require__(
      /*! ./map/mapSymbolLayout */
      "zuHt");

      var mapVisual = __webpack_require__(
      /*! ./map/mapVisual */
      "VPsl");

      var mapDataStatistic = __webpack_require__(
      /*! ./map/mapDataStatistic */
      "9u0u");

      var backwardCompat = __webpack_require__(
      /*! ./map/backwardCompat */
      "lELe");

      var createDataSelectAction = __webpack_require__(
      /*! ../action/createDataSelectAction */
      "d4KN");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      echarts.registerLayout(mapSymbolLayout);
      echarts.registerVisual(mapVisual);
      echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, mapDataStatistic);
      echarts.registerPreprocessor(backwardCompat);
      createDataSelectAction('map', [{
        type: 'mapToggleSelect',
        event: 'mapselectchanged',
        method: 'toggleSelected'
      }, {
        type: 'mapSelect',
        event: 'mapselected',
        method: 'select'
      }, {
        type: 'mapUnSelect',
        event: 'mapunselected',
        method: 'unSelect'
      }]);
      /***/
    },

    /***/
    "Z6js":
    /*!*****************************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/effectScatter/EffectScatterSeries.js ***!
      \*****************************************************************************/

    /*! no static exports found */

    /***/
    function Z6js(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var createListFromArray = __webpack_require__(
      /*! ../helper/createListFromArray */
      "MwEJ");

      var SeriesModel = __webpack_require__(
      /*! ../../model/Series */
      "T4UG");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = SeriesModel.extend({
        type: 'series.effectScatter',
        dependencies: ['grid', 'polar'],
        getInitialData: function getInitialData(option, ecModel) {
          return createListFromArray(this.getSource(), this, {
            useEncodeDefaulter: true
          });
        },
        brushSelector: 'point',
        defaultOption: {
          coordinateSystem: 'cartesian2d',
          zlevel: 0,
          z: 2,
          legendHoverLink: true,
          effectType: 'ripple',
          progressive: 0,
          // When to show the effect, option: 'render'|'emphasis'
          showEffectOn: 'render',
          // Ripple effect config
          rippleEffect: {
            period: 4,
            // Scale of ripple
            scale: 2.5,
            // Brush type can be fill or stroke
            brushType: 'fill'
          },
          // Cartesian coordinate system
          // xAxisIndex: 0,
          // yAxisIndex: 0,
          // Polar coordinate system
          // polarIndex: 0,
          // Geo coordinate system
          // geoIndex: 0,
          // symbol: null,        // 
          symbolSize: 10 // symbolSize * 2
          // symbolRotate: null,  // 
          // large: false,
          // Available when large is true
          // largeThreshold: 2000,
          // itemStyle: {
          //     opacity: 1
          // }

        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "Z8zF":
    /*!*******************************************************!*\
      !*** ./node_modules/echarts/lib/chart/bar/BarView.js ***!
      \*******************************************************/

    /*! no static exports found */

    /***/
    function Z8zF(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var _helper = __webpack_require__(
      /*! ./helper */
      "56rv");

      var setLabel = _helper.setLabel;

      var Model = __webpack_require__(
      /*! ../../model/Model */
      "Qxkt");

      var barItemStyle = __webpack_require__(
      /*! ./barItemStyle */
      "tceW");

      var Path = __webpack_require__(
      /*! zrender/lib/graphic/Path */
      "y+Vt");

      var Group = __webpack_require__(
      /*! zrender/lib/container/Group */
      "4fz+");

      var _throttle = __webpack_require__(
      /*! ../../util/throttle */
      "iLNv");

      var throttle = _throttle.throttle;

      var _createClipPathFromCoordSys = __webpack_require__(
      /*! ../helper/createClipPathFromCoordSys */
      "sK/D");

      var createClipPath = _createClipPathFromCoordSys.createClipPath;

      var Sausage = __webpack_require__(
      /*! ../../util/shape/sausage */
      "wr5s");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'barBorderWidth'];
      var _eventPos = [0, 0]; // FIXME
      // Just for compatible with ec2.

      zrUtil.extend(Model.prototype, barItemStyle);

      function getClipArea(coord, data) {
        var coordSysClipArea = coord.getArea && coord.getArea();

        if (coord.type === 'cartesian2d') {
          var baseAxis = coord.getBaseAxis(); // When boundaryGap is false or using time axis. bar may exceed the grid.
          // We should not clip this part.
          // See test/bar2.html

          if (baseAxis.type !== 'category' || !baseAxis.onBand) {
            var expandWidth = data.getLayout('bandWidth');

            if (baseAxis.isHorizontal()) {
              coordSysClipArea.x -= expandWidth;
              coordSysClipArea.width += expandWidth * 2;
            } else {
              coordSysClipArea.y -= expandWidth;
              coordSysClipArea.height += expandWidth * 2;
            }
          }
        }

        return coordSysClipArea;
      }

      var _default = echarts.extendChartView({
        type: 'bar',
        render: function render(seriesModel, ecModel, api) {
          this._updateDrawMode(seriesModel);

          var coordinateSystemType = seriesModel.get('coordinateSystem');

          if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {
            this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api);
          } else {}

          return this.group;
        },
        incrementalPrepareRender: function incrementalPrepareRender(seriesModel, ecModel, api) {
          this._clear();

          this._updateDrawMode(seriesModel);
        },
        incrementalRender: function incrementalRender(params, seriesModel, ecModel, api) {
          // Do not support progressive in normal mode.
          this._incrementalRenderLarge(params, seriesModel);
        },
        _updateDrawMode: function _updateDrawMode(seriesModel) {
          var isLargeDraw = seriesModel.pipelineContext.large;

          if (this._isLargeDraw == null || isLargeDraw ^ this._isLargeDraw) {
            this._isLargeDraw = isLargeDraw;

            this._clear();
          }
        },
        _renderNormal: function _renderNormal(seriesModel, ecModel, api) {
          var group = this.group;
          var data = seriesModel.getData();
          var oldData = this._data;
          var coord = seriesModel.coordinateSystem;
          var baseAxis = coord.getBaseAxis();
          var isHorizontalOrRadial;

          if (coord.type === 'cartesian2d') {
            isHorizontalOrRadial = baseAxis.isHorizontal();
          } else if (coord.type === 'polar') {
            isHorizontalOrRadial = baseAxis.dim === 'angle';
          }

          var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
          var needsClip = seriesModel.get('clip', true);
          var coordSysClipArea = getClipArea(coord, data); // If there is clipPath created in large mode. Remove it.

          group.removeClipPath(); // We don't use clipPath in normal mode because we needs a perfect animation
          // And don't want the label are clipped.

          var roundCap = seriesModel.get('roundCap', true);
          var drawBackground = seriesModel.get('showBackground', true);
          var backgroundModel = seriesModel.getModel('backgroundStyle');
          var barBorderRadius = backgroundModel.get('barBorderRadius') || 0;
          var bgEls = [];
          var oldBgEls = this._backgroundEls || [];

          var createBackground = function createBackground(dataIndex) {
            var bgLayout = getLayout[coord.type](data, dataIndex);
            var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);
            bgEl.useStyle(backgroundModel.getBarItemStyle()); // Only cartesian2d support borderRadius.

            if (coord.type === 'cartesian2d') {
              bgEl.setShape('r', barBorderRadius);
            }

            bgEls[dataIndex] = bgEl;
            return bgEl;
          };

          data.diff(oldData).add(function (dataIndex) {
            var itemModel = data.getItemModel(dataIndex);
            var layout = getLayout[coord.type](data, dataIndex, itemModel);

            if (drawBackground) {
              createBackground(dataIndex);
            } // If dataZoom in filteMode: 'empty', the baseValue can be set as NaN in "axisProxy".


            if (!data.hasValue(dataIndex)) {
              return;
            }

            if (needsClip) {
              // Clip will modify the layout params.
              // And return a boolean to determine if the shape are fully clipped.
              var isClipped = clip[coord.type](coordSysClipArea, layout);

              if (isClipped) {
                group.remove(el);
                return;
              }
            }

            var el = elementCreator[coord.type](dataIndex, layout, isHorizontalOrRadial, animationModel, false, roundCap);
            data.setItemGraphicEl(dataIndex, el);
            group.add(el);
            updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');
          }).update(function (newIndex, oldIndex) {
            var itemModel = data.getItemModel(newIndex);
            var layout = getLayout[coord.type](data, newIndex, itemModel);

            if (drawBackground) {
              var bgEl;

              if (oldBgEls.length === 0) {
                bgEl = createBackground(oldIndex);
              } else {
                bgEl = oldBgEls[oldIndex];
                bgEl.useStyle(backgroundModel.getBarItemStyle()); // Only cartesian2d support borderRadius.

                if (coord.type === 'cartesian2d') {
                  bgEl.setShape('r', barBorderRadius);
                }

                bgEls[newIndex] = bgEl;
              }

              var bgLayout = getLayout[coord.type](data, newIndex);
              var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);
              graphic.updateProps(bgEl, {
                shape: shape
              }, animationModel, newIndex);
            }

            var el = oldData.getItemGraphicEl(oldIndex);

            if (!data.hasValue(newIndex)) {
              group.remove(el);
              return;
            }

            if (needsClip) {
              var isClipped = clip[coord.type](coordSysClipArea, layout);

              if (isClipped) {
                group.remove(el);
                return;
              }
            }

            if (el) {
              graphic.updateProps(el, {
                shape: layout
              }, animationModel, newIndex);
            } else {
              el = elementCreator[coord.type](newIndex, layout, isHorizontalOrRadial, animationModel, true, roundCap);
            }

            data.setItemGraphicEl(newIndex, el); // Add back

            group.add(el);
            updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');
          }).remove(function (dataIndex) {
            var el = oldData.getItemGraphicEl(dataIndex);

            if (coord.type === 'cartesian2d') {
              el && removeRect(dataIndex, animationModel, el);
            } else {
              el && removeSector(dataIndex, animationModel, el);
            }
          }).execute();
          var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group());
          bgGroup.removeAll();

          for (var i = 0; i < bgEls.length; ++i) {
            bgGroup.add(bgEls[i]);
          }

          group.add(bgGroup);
          this._backgroundEls = bgEls;
          this._data = data;
        },
        _renderLarge: function _renderLarge(seriesModel, ecModel, api) {
          this._clear();

          createLarge(seriesModel, this.group); // Use clipPath in large mode.

          var clipPath = seriesModel.get('clip', true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;

          if (clipPath) {
            this.group.setClipPath(clipPath);
          } else {
            this.group.removeClipPath();
          }
        },
        _incrementalRenderLarge: function _incrementalRenderLarge(params, seriesModel) {
          this._removeBackground();

          createLarge(seriesModel, this.group, true);
        },
        dispose: zrUtil.noop,
        remove: function remove(ecModel) {
          this._clear(ecModel);
        },
        _clear: function _clear(ecModel) {
          var group = this.group;
          var data = this._data;

          if (ecModel && ecModel.get('animation') && data && !this._isLargeDraw) {
            this._removeBackground();

            this._backgroundEls = [];
            data.eachItemGraphicEl(function (el) {
              if (el.type === 'sector') {
                removeSector(el.dataIndex, ecModel, el);
              } else {
                removeRect(el.dataIndex, ecModel, el);
              }
            });
          } else {
            group.removeAll();
          }

          this._data = null;
        },
        _removeBackground: function _removeBackground() {
          this.group.remove(this._backgroundGroup);
          this._backgroundGroup = null;
        }
      });

      var mathMax = Math.max;
      var mathMin = Math.min;
      var clip = {
        cartesian2d: function cartesian2d(coordSysBoundingRect, layout) {
          var signWidth = layout.width < 0 ? -1 : 1;
          var signHeight = layout.height < 0 ? -1 : 1; // Needs positive width and height

          if (signWidth < 0) {
            layout.x += layout.width;
            layout.width = -layout.width;
          }

          if (signHeight < 0) {
            layout.y += layout.height;
            layout.height = -layout.height;
          }

          var x = mathMax(layout.x, coordSysBoundingRect.x);
          var x2 = mathMin(layout.x + layout.width, coordSysBoundingRect.x + coordSysBoundingRect.width);
          var y = mathMax(layout.y, coordSysBoundingRect.y);
          var y2 = mathMin(layout.y + layout.height, coordSysBoundingRect.y + coordSysBoundingRect.height);
          layout.x = x;
          layout.y = y;
          layout.width = x2 - x;
          layout.height = y2 - y;
          var clipped = layout.width < 0 || layout.height < 0; // Reverse back

          if (signWidth < 0) {
            layout.x += layout.width;
            layout.width = -layout.width;
          }

          if (signHeight < 0) {
            layout.y += layout.height;
            layout.height = -layout.height;
          }

          return clipped;
        },
        polar: function polar(coordSysClipArea, layout) {
          var signR = layout.r0 <= layout.r ? 1 : -1; // Make sure r is larger than r0

          if (signR < 0) {
            var r = layout.r;
            layout.r = layout.r0;
            layout.r0 = r;
          }

          var r = mathMin(layout.r, coordSysClipArea.r);
          var r0 = mathMax(layout.r0, coordSysClipArea.r0);
          layout.r = r;
          layout.r0 = r0;
          var clipped = r - r0 < 0; // Reverse back

          if (signR < 0) {
            var r = layout.r;
            layout.r = layout.r0;
            layout.r0 = r;
          }

          return clipped;
        }
      };
      var elementCreator = {
        cartesian2d: function cartesian2d(dataIndex, layout, isHorizontal, animationModel, isUpdate) {
          var rect = new graphic.Rect({
            shape: zrUtil.extend({}, layout),
            z2: 1
          });
          rect.name = 'item'; // Animation

          if (animationModel) {
            var rectShape = rect.shape;
            var animateProperty = isHorizontal ? 'height' : 'width';
            var animateTarget = {};
            rectShape[animateProperty] = 0;
            animateTarget[animateProperty] = layout[animateProperty];
            graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {
              shape: animateTarget
            }, animationModel, dataIndex);
          }

          return rect;
        },
        polar: function polar(dataIndex, layout, isRadial, animationModel, isUpdate, roundCap) {
          // Keep the same logic with bar in catesion: use end value to control
          // direction. Notice that if clockwise is true (by default), the sector
          // will always draw clockwisely, no matter whether endAngle is greater
          // or less than startAngle.
          var clockwise = layout.startAngle < layout.endAngle;
          var ShapeClass = !isRadial && roundCap ? Sausage : graphic.Sector;
          var sector = new ShapeClass({
            shape: zrUtil.defaults({
              clockwise: clockwise
            }, layout),
            z2: 1
          });
          sector.name = 'item'; // Animation

          if (animationModel) {
            var sectorShape = sector.shape;
            var animateProperty = isRadial ? 'r' : 'endAngle';
            var animateTarget = {};
            sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;
            animateTarget[animateProperty] = layout[animateProperty];
            graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {
              shape: animateTarget
            }, animationModel, dataIndex);
          }

          return sector;
        }
      };

      function removeRect(dataIndex, animationModel, el) {
        // Not show text when animating
        el.style.text = null;
        graphic.updateProps(el, {
          shape: {
            width: 0
          }
        }, animationModel, dataIndex, function () {
          el.parent && el.parent.remove(el);
        });
      }

      function removeSector(dataIndex, animationModel, el) {
        // Not show text when animating
        el.style.text = null;
        graphic.updateProps(el, {
          shape: {
            r: el.shape.r0
          }
        }, animationModel, dataIndex, function () {
          el.parent && el.parent.remove(el);
        });
      }

      var getLayout = {
        // itemModel is only used to get borderWidth, which is not needed
        // when calculating bar background layout.
        cartesian2d: function cartesian2d(data, dataIndex, itemModel) {
          var layout = data.getItemLayout(dataIndex);
          var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout) : 0; // fix layout with lineWidth

          var signX = layout.width > 0 ? 1 : -1;
          var signY = layout.height > 0 ? 1 : -1;
          return {
            x: layout.x + signX * fixedLineWidth / 2,
            y: layout.y + signY * fixedLineWidth / 2,
            width: layout.width - signX * fixedLineWidth,
            height: layout.height - signY * fixedLineWidth
          };
        },
        polar: function polar(data, dataIndex, itemModel) {
          var layout = data.getItemLayout(dataIndex);
          return {
            cx: layout.cx,
            cy: layout.cy,
            r0: layout.r0,
            r: layout.r,
            startAngle: layout.startAngle,
            endAngle: layout.endAngle
          };
        }
      };

      function isZeroOnPolar(layout) {
        return layout.startAngle != null && layout.endAngle != null && layout.startAngle === layout.endAngle;
      }

      function updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {
        var color = data.getItemVisual(dataIndex, 'color');
        var opacity = data.getItemVisual(dataIndex, 'opacity');
        var stroke = data.getVisual('borderColor');
        var itemStyleModel = itemModel.getModel('itemStyle');
        var hoverStyle = itemModel.getModel('emphasis.itemStyle').getBarItemStyle();

        if (!isPolar) {
          el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);
        }

        el.useStyle(zrUtil.defaults({
          stroke: isZeroOnPolar(layout) ? 'none' : stroke,
          fill: isZeroOnPolar(layout) ? 'none' : color,
          opacity: opacity
        }, itemStyleModel.getBarItemStyle()));
        var cursorStyle = itemModel.getShallow('cursor');
        cursorStyle && el.attr('cursor', cursorStyle);
        var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';

        if (!isPolar) {
          setLabel(el.style, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside);
        }

        if (isZeroOnPolar(layout)) {
          hoverStyle.fill = hoverStyle.stroke = 'none';
        }

        graphic.setHoverStyle(el, hoverStyle);
      } // In case width or height are too small.


      function getLineWidth(itemModel, rawLayout) {
        var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0; // width or height may be NaN for empty data

        var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);
        var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);
        return Math.min(lineWidth, width, height);
      }

      var LargePath = Path.extend({
        type: 'largeBar',
        shape: {
          points: []
        },
        buildPath: function buildPath(ctx, shape) {
          // Drawing lines is more efficient than drawing
          // a whole line or drawing rects.
          var points = shape.points;
          var startPoint = this.__startPoint;
          var baseDimIdx = this.__baseDimIdx;

          for (var i = 0; i < points.length; i += 2) {
            startPoint[baseDimIdx] = points[i + baseDimIdx];
            ctx.moveTo(startPoint[0], startPoint[1]);
            ctx.lineTo(points[i], points[i + 1]);
          }
        }
      });

      function createLarge(seriesModel, group, incremental) {
        // TODO support polar
        var data = seriesModel.getData();
        var startPoint = [];
        var baseDimIdx = data.getLayout('valueAxisHorizontal') ? 1 : 0;
        startPoint[1 - baseDimIdx] = data.getLayout('valueAxisStart');
        var largeDataIndices = data.getLayout('largeDataIndices');
        var barWidth = data.getLayout('barWidth');
        var backgroundModel = seriesModel.getModel('backgroundStyle');
        var drawBackground = seriesModel.get('showBackground', true);

        if (drawBackground) {
          var points = data.getLayout('largeBackgroundPoints');
          var backgroundStartPoint = [];
          backgroundStartPoint[1 - baseDimIdx] = data.getLayout('backgroundStart');
          var bgEl = new LargePath({
            shape: {
              points: points
            },
            incremental: !!incremental,
            __startPoint: backgroundStartPoint,
            __baseDimIdx: baseDimIdx,
            __largeDataIndices: largeDataIndices,
            __barWidth: barWidth,
            silent: true,
            z2: 0
          });
          setLargeBackgroundStyle(bgEl, backgroundModel, data);
          group.add(bgEl);
        }

        var el = new LargePath({
          shape: {
            points: data.getLayout('largePoints')
          },
          incremental: !!incremental,
          __startPoint: startPoint,
          __baseDimIdx: baseDimIdx,
          __largeDataIndices: largeDataIndices,
          __barWidth: barWidth
        });
        group.add(el);
        setLargeStyle(el, seriesModel, data); // Enable tooltip and user mouse/touch event handlers.

        el.seriesIndex = seriesModel.seriesIndex;

        if (!seriesModel.get('silent')) {
          el.on('mousedown', largePathUpdateDataIndex);
          el.on('mousemove', largePathUpdateDataIndex);
        }
      } // Use throttle to avoid frequently traverse to find dataIndex.


      var largePathUpdateDataIndex = throttle(function (event) {
        var largePath = this;
        var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);
        largePath.dataIndex = dataIndex >= 0 ? dataIndex : null;
      }, 30, false);

      function largePathFindDataIndex(largePath, x, y) {
        var baseDimIdx = largePath.__baseDimIdx;
        var valueDimIdx = 1 - baseDimIdx;
        var points = largePath.shape.points;
        var largeDataIndices = largePath.__largeDataIndices;
        var barWidthHalf = Math.abs(largePath.__barWidth / 2);
        var startValueVal = largePath.__startPoint[valueDimIdx];
        _eventPos[0] = x;
        _eventPos[1] = y;
        var pointerBaseVal = _eventPos[baseDimIdx];
        var pointerValueVal = _eventPos[1 - baseDimIdx];
        var baseLowerBound = pointerBaseVal - barWidthHalf;
        var baseUpperBound = pointerBaseVal + barWidthHalf;

        for (var i = 0, len = points.length / 2; i < len; i++) {
          var ii = i * 2;
          var barBaseVal = points[ii + baseDimIdx];
          var barValueVal = points[ii + valueDimIdx];

          if (barBaseVal >= baseLowerBound && barBaseVal <= baseUpperBound && (startValueVal <= barValueVal ? pointerValueVal >= startValueVal && pointerValueVal <= barValueVal : pointerValueVal >= barValueVal && pointerValueVal <= startValueVal)) {
            return largeDataIndices[i];
          }
        }

        return -1;
      }

      function setLargeStyle(el, seriesModel, data) {
        var borderColor = data.getVisual('borderColor') || data.getVisual('color');
        var itemStyle = seriesModel.getModel('itemStyle').getItemStyle(['color', 'borderColor']);
        el.useStyle(itemStyle);
        el.style.fill = null;
        el.style.stroke = borderColor;
        el.style.lineWidth = data.getLayout('barWidth');
      }

      function setLargeBackgroundStyle(el, backgroundModel, data) {
        var borderColor = backgroundModel.get('borderColor') || backgroundModel.get('color');
        var itemStyle = backgroundModel.getItemStyle(['color', 'borderColor']);
        el.useStyle(itemStyle);
        el.style.fill = null;
        el.style.stroke = borderColor;
        el.style.lineWidth = data.getLayout('barWidth');
      }

      function createBackgroundShape(isHorizontalOrRadial, layout, coord) {
        var coordLayout;
        var isPolar = coord.type === 'polar';

        if (isPolar) {
          coordLayout = coord.getArea();
        } else {
          coordLayout = coord.grid.getRect();
        }

        if (isPolar) {
          return {
            cx: coordLayout.cx,
            cy: coordLayout.cy,
            r0: isHorizontalOrRadial ? coordLayout.r0 : layout.r0,
            r: isHorizontalOrRadial ? coordLayout.r : layout.r,
            startAngle: isHorizontalOrRadial ? layout.startAngle : 0,
            endAngle: isHorizontalOrRadial ? layout.endAngle : Math.PI * 2
          };
        } else {
          return {
            x: isHorizontalOrRadial ? layout.x : coordLayout.x,
            y: isHorizontalOrRadial ? coordLayout.y : layout.y,
            width: isHorizontalOrRadial ? layout.width : coordLayout.width,
            height: isHorizontalOrRadial ? coordLayout.height : layout.height
          };
        }
      }

      function createBackgroundEl(coord, isHorizontalOrRadial, layout) {
        var ElementClz = coord.type === 'polar' ? graphic.Sector : graphic.Rect;
        return new ElementClz({
          shape: createBackgroundShape(isHorizontalOrRadial, layout, coord),
          silent: true,
          z2: 0
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "ZWlE":
    /*!*************************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/parallel/parallelPreprocessor.js ***!
      \*************************************************************************/

    /*! no static exports found */

    /***/
    function ZWlE(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var modelUtil = __webpack_require__(
      /*! ../../util/model */
      "4NO4");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function _default(option) {
        createParallelIfNeeded(option);
        mergeAxisOptionFromParallel(option);
      }
      /**
       * Create a parallel coordinate if not exists.
       * @inner
       */


      function createParallelIfNeeded(option) {
        if (option.parallel) {
          return;
        }

        var hasParallelSeries = false;
        zrUtil.each(option.series, function (seriesOpt) {
          if (seriesOpt && seriesOpt.type === 'parallel') {
            hasParallelSeries = true;
          }
        });

        if (hasParallelSeries) {
          option.parallel = [{}];
        }
      }
      /**
       * Merge aixs definition from parallel option (if exists) to axis option.
       * @inner
       */


      function mergeAxisOptionFromParallel(option) {
        var axes = modelUtil.normalizeToArray(option.parallelAxis);
        zrUtil.each(axes, function (axisOption) {
          if (!zrUtil.isObject(axisOption)) {
            return;
          }

          var parallelIndex = axisOption.parallelIndex || 0;
          var parallelOption = modelUtil.normalizeToArray(option.parallel)[parallelIndex];

          if (parallelOption && parallelOption.parallelAxisDefault) {
            zrUtil.merge(axisOption, parallelOption.parallelAxisDefault, false);
          }
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "ZYIC":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/lines/linesLayout.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function ZYIC(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var createRenderPlanner = __webpack_require__(
      /*! ../helper/createRenderPlanner */
      "zM3Q");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /* global Float32Array */


      var _default = {
        seriesType: 'lines',
        plan: createRenderPlanner(),
        reset: function reset(seriesModel) {
          var coordSys = seriesModel.coordinateSystem;
          var isPolyline = seriesModel.get('polyline');
          var isLarge = seriesModel.pipelineContext.large;

          function progress(params, lineData) {
            var lineCoords = [];

            if (isLarge) {
              var points;
              var segCount = params.end - params.start;

              if (isPolyline) {
                var totalCoordsCount = 0;

                for (var i = params.start; i < params.end; i++) {
                  totalCoordsCount += seriesModel.getLineCoordsCount(i);
                }

                points = new Float32Array(segCount + totalCoordsCount * 2);
              } else {
                points = new Float32Array(segCount * 4);
              }

              var offset = 0;
              var pt = [];

              for (var i = params.start; i < params.end; i++) {
                var len = seriesModel.getLineCoords(i, lineCoords);

                if (isPolyline) {
                  points[offset++] = len;
                }

                for (var k = 0; k < len; k++) {
                  pt = coordSys.dataToPoint(lineCoords[k], false, pt);
                  points[offset++] = pt[0];
                  points[offset++] = pt[1];
                }
              }

              lineData.setLayout('linesPoints', points);
            } else {
              for (var i = params.start; i < params.end; i++) {
                var itemModel = lineData.getItemModel(i);
                var len = seriesModel.getLineCoords(i, lineCoords);
                var pts = [];

                if (isPolyline) {
                  for (var j = 0; j < len; j++) {
                    pts.push(coordSys.dataToPoint(lineCoords[j]));
                  }
                } else {
                  pts[0] = coordSys.dataToPoint(lineCoords[0]);
                  pts[1] = coordSys.dataToPoint(lineCoords[1]);
                  var curveness = itemModel.get('lineStyle.curveness');

                  if (+curveness) {
                    pts[2] = [(pts[0][0] + pts[1][0]) / 2 - (pts[0][1] - pts[1][1]) * curveness, (pts[0][1] + pts[1][1]) / 2 - (pts[1][0] - pts[0][0]) * curveness];
                  }
                }

                lineData.setItemLayout(i, pts);
              }
            }
          }

          return {
            progress: progress
          };
        }
      };
      module.exports = _default;
      /***/
    },

    /***/
    "Znkb":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/component/axis/AxisView.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function Znkb(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var axisPointerModelHelper = __webpack_require__(
      /*! ../axisPointer/modelHelper */
      "zTMp");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Base class of AxisView.
       */


      var AxisView = echarts.extendComponentView({
        type: 'axis',

        /**
         * @private
         */
        _axisPointer: null,

        /**
         * @protected
         * @type {string}
         */
        axisPointerClass: null,

        /**
         * @override
         */
        render: function render(axisModel, ecModel, api, payload) {
          // FIXME
          // This process should proformed after coordinate systems updated
          // (axis scale updated), and should be performed each time update.
          // So put it here temporarily, although it is not appropriate to
          // put a model-writing procedure in `view`.
          this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);
          AxisView.superApply(this, 'render', arguments);

          _updateAxisPointer(this, axisModel, ecModel, api, payload, true);
        },

        /**
         * Action handler.
         * @public
         * @param {module:echarts/coord/cartesian/AxisModel} axisModel
         * @param {module:echarts/model/Global} ecModel
         * @param {module:echarts/ExtensionAPI} api
         * @param {Object} payload
         */
        updateAxisPointer: function updateAxisPointer(axisModel, ecModel, api, payload, force) {
          _updateAxisPointer(this, axisModel, ecModel, api, payload, false);
        },

        /**
         * @override
         */
        remove: function remove(ecModel, api) {
          var axisPointer = this._axisPointer;
          axisPointer && axisPointer.remove(api);
          AxisView.superApply(this, 'remove', arguments);
        },

        /**
         * @override
         */
        dispose: function dispose(ecModel, api) {
          disposeAxisPointer(this, api);
          AxisView.superApply(this, 'dispose', arguments);
        }
      });

      function _updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {
        var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);

        if (!Clazz) {
          return;
        }

        var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);
        axisPointerModel ? (axisView._axisPointer || (axisView._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : disposeAxisPointer(axisView, api);
      }

      function disposeAxisPointer(axisView, ecModel, api) {
        var axisPointer = axisView._axisPointer;
        axisPointer && axisPointer.dispose(ecModel, api);
        axisView._axisPointer = null;
      }

      var axisPointerClazz = [];

      AxisView.registerAxisPointerClass = function (type, clazz) {
        axisPointerClazz[type] = clazz;
      };

      AxisView.getAxisPointerClass = function (type) {
        return type && axisPointerClazz[type];
      };

      var _default = AxisView;
      module.exports = _default;
      /***/
    },

    /***/
    "ZqQs":
    /*!*********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/timeline/preprocessor.js ***!
      \*********************************************************************/

    /*! no static exports found */

    /***/
    function ZqQs(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function _default(option) {
        var timelineOpt = option && option.timeline;

        if (!zrUtil.isArray(timelineOpt)) {
          timelineOpt = timelineOpt ? [timelineOpt] : [];
        }

        zrUtil.each(timelineOpt, function (opt) {
          if (!opt) {
            return;
          }

          compatibleEC2(opt);
        });
      }

      function compatibleEC2(opt) {
        var type = opt.type;
        var ec2Types = {
          'number': 'value',
          'time': 'time'
        }; // Compatible with ec2

        if (ec2Types[type]) {
          opt.axisType = ec2Types[type];
          delete opt.type;
        }

        transferItem(opt);

        if (has(opt, 'controlPosition')) {
          var controlStyle = opt.controlStyle || (opt.controlStyle = {});

          if (!has(controlStyle, 'position')) {
            controlStyle.position = opt.controlPosition;
          }

          if (controlStyle.position === 'none' && !has(controlStyle, 'show')) {
            controlStyle.show = false;
            delete controlStyle.position;
          }

          delete opt.controlPosition;
        }

        zrUtil.each(opt.data || [], function (dataItem) {
          if (zrUtil.isObject(dataItem) && !zrUtil.isArray(dataItem)) {
            if (!has(dataItem, 'value') && has(dataItem, 'name')) {
              // In ec2, using name as value.
              dataItem.value = dataItem.name;
            }

            transferItem(dataItem);
          }
        });
      }

      function transferItem(opt) {
        var itemStyle = opt.itemStyle || (opt.itemStyle = {});
        var itemStyleEmphasis = itemStyle.emphasis || (itemStyle.emphasis = {}); // Transfer label out

        var label = opt.label || opt.label || {};
        var labelNormal = label.normal || (label.normal = {});
        var excludeLabelAttr = {
          normal: 1,
          emphasis: 1
        };
        zrUtil.each(label, function (value, name) {
          if (!excludeLabelAttr[name] && !has(labelNormal, name)) {
            labelNormal[name] = value;
          }
        });

        if (itemStyleEmphasis.label && !has(label, 'emphasis')) {
          label.emphasis = itemStyleEmphasis.label;
          delete itemStyleEmphasis.label;
        }
      }

      function has(obj, attr) {
        return obj.hasOwnProperty(attr);
      }

      module.exports = _default;
      /***/
    },

    /***/
    "Zvw2":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/single/SingleAxis.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function Zvw2(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var Axis = __webpack_require__(
      /*! ../Axis */
      "hM6l");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @constructor  module:echarts/coord/single/SingleAxis
       * @extends {module:echarts/coord/Axis}
       * @param {string} dim
       * @param {*} scale
       * @param {Array.<number>} coordExtent
       * @param {string} axisType
       * @param {string} position
       */


      var SingleAxis = function SingleAxis(dim, scale, coordExtent, axisType, position) {
        Axis.call(this, dim, scale, coordExtent);
        /**
         * Axis type
         * - 'category'
         * - 'value'
         * - 'time'
         * - 'log'
         * @type {string}
         */

        this.type = axisType || 'value';
        /**
         * Axis position
         *  - 'top'
         *  - 'bottom'
         *  - 'left'
         *  - 'right'
         *  @type {string}
         */

        this.position = position || 'bottom';
        /**
         * Axis orient
         *  - 'horizontal'
         *  - 'vertical'
         * @type {[type]}
         */

        this.orient = null;
      };

      SingleAxis.prototype = {
        constructor: SingleAxis,

        /**
         * Axis model
         * @type {module:echarts/coord/single/AxisModel}
         */
        model: null,

        /**
         * Judge the orient of the axis.
         * @return {boolean}
         */
        isHorizontal: function isHorizontal() {
          var position = this.position;
          return position === 'top' || position === 'bottom';
        },

        /**
         * @override
         */
        pointToData: function pointToData(point, clamp) {
          return this.coordinateSystem.pointToData(point, clamp)[0];
        },

        /**
         * Convert the local coord(processed by dataToCoord())
         * to global coord(concrete pixel coord).
         * designated by module:echarts/coord/single/Single.
         * @type {Function}
         */
        toGlobalCoord: null,

        /**
         * Convert the global coord to local coord.
         * designated by module:echarts/coord/single/Single.
         * @type {Function}
         */
        toLocalCoord: null
      };
      zrUtil.inherits(SingleAxis, Axis);
      var _default = SingleAxis;
      module.exports = _default;
      /***/
    },

    /***/
    "a9QJ":
    /*!************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/geo/fix/geoCoord.js ***!
      \************************************************************/

    /*! no static exports found */

    /***/
    function a9QJ(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var geoCoordMap = {
        'Russia': [100, 60],
        'United States': [-99, 38],
        'United States of America': [-99, 38]
      };

      function _default(mapType, region) {
        if (mapType === 'world') {
          var geoCoord = geoCoordMap[region.name];

          if (geoCoord) {
            var cp = region.center;
            cp[0] = geoCoord[0];
            cp[1] = geoCoord[1];
          }
        }
      }

      module.exports = _default;
      /***/
    },

    /***/
    "aTJb":
    /*!**********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/dataZoom/typeDefaulter.js ***!
      \**********************************************************************/

    /*! no static exports found */

    /***/
    function aTJb(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var Component = __webpack_require__(
      /*! ../../model/Component */
      "bLfw");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      Component.registerSubTypeDefaulter('dataZoom', function () {
        // Default 'slider' when no type specified.
        return 'slider';
      });
      /***/
    },

    /***/
    "akwb":
    /*!*****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/helper/EffectPolyline.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function akwb(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var Polyline = __webpack_require__(
      /*! ./Polyline */
      "RSch");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var EffectLine = __webpack_require__(
      /*! ./EffectLine */
      "D9ME");

      var vec2 = __webpack_require__(
      /*! zrender/lib/core/vector */
      "QBsz");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Provide effect for line
       * @module echarts/chart/helper/EffectLine
       */

      /**
       * @constructor
       * @extends {module:echarts/chart/helper/EffectLine}
       * @alias {module:echarts/chart/helper/Polyline}
       */


      function EffectPolyline(lineData, idx, seriesScope) {
        EffectLine.call(this, lineData, idx, seriesScope);
        this._lastFrame = 0;
        this._lastFramePercent = 0;
      }

      var effectPolylineProto = EffectPolyline.prototype; // Overwrite

      effectPolylineProto.createLine = function (lineData, idx, seriesScope) {
        return new Polyline(lineData, idx, seriesScope);
      }; // Overwrite


      effectPolylineProto.updateAnimationPoints = function (symbol, points) {
        this._points = points;
        var accLenArr = [0];
        var len = 0;

        for (var i = 1; i < points.length; i++) {
          var p1 = points[i - 1];
          var p2 = points[i];
          len += vec2.dist(p1, p2);
          accLenArr.push(len);
        }

        if (len === 0) {
          return;
        }

        for (var i = 0; i < accLenArr.length; i++) {
          accLenArr[i] /= len;
        }

        this._offsets = accLenArr;
        this._length = len;
      }; // Overwrite


      effectPolylineProto.getLineLength = function (symbol) {
        return this._length;
      }; // Overwrite


      effectPolylineProto.updateSymbolPosition = function (symbol) {
        var t = symbol.__t;
        var points = this._points;
        var offsets = this._offsets;
        var len = points.length;

        if (!offsets) {
          // Has length 0
          return;
        }

        var lastFrame = this._lastFrame;
        var frame;

        if (t < this._lastFramePercent) {
          // Start from the next frame
          // PENDING start from lastFrame ?
          var start = Math.min(lastFrame + 1, len - 1);

          for (frame = start; frame >= 0; frame--) {
            if (offsets[frame] <= t) {
              break;
            }
          } // PENDING really need to do this ?


          frame = Math.min(frame, len - 2);
        } else {
          for (var frame = lastFrame; frame < len; frame++) {
            if (offsets[frame] > t) {
              break;
            }
          }

          frame = Math.min(frame - 1, len - 2);
        }

        vec2.lerp(symbol.position, points[frame], points[frame + 1], (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame]));
        var tx = points[frame + 1][0] - points[frame][0];
        var ty = points[frame + 1][1] - points[frame][1];
        symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
        this._lastFrame = frame;
        this._lastFramePercent = t;
        symbol.ignore = false;
      };

      zrUtil.inherits(EffectPolyline, EffectLine);
      var _default = EffectPolyline;
      module.exports = _default;
      /***/
    },

    /***/
    "as94":
    /*!****************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/axisPointer/PolarAxisPointer.js ***!
      \****************************************************************************/

    /*! no static exports found */

    /***/
    function as94(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var formatUtil = __webpack_require__(
      /*! ../../util/format */
      "7aKB");

      var BaseAxisPointer = __webpack_require__(
      /*! ./BaseAxisPointer */
      "3LNs");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var viewHelper = __webpack_require__(
      /*! ./viewHelper */
      "/y7N");

      var matrix = __webpack_require__(
      /*! zrender/lib/core/matrix */
      "Fofx");

      var AxisBuilder = __webpack_require__(
      /*! ../axis/AxisBuilder */
      "+rIm");

      var AxisView = __webpack_require__(
      /*! ../axis/AxisView */
      "Znkb");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var PolarAxisPointer = BaseAxisPointer.extend({
        /**
         * @override
         */
        makeElOption: function makeElOption(elOption, value, axisModel, axisPointerModel, api) {
          var axis = axisModel.axis;

          if (axis.dim === 'angle') {
            this.animationThreshold = Math.PI / 18;
          }

          var polar = axis.polar;
          var otherAxis = polar.getOtherAxis(axis);
          var otherExtent = otherAxis.getExtent();
          var coordValue;
          coordValue = axis['dataTo' + formatUtil.capitalFirst(axis.dim)](value);
          var axisPointerType = axisPointerModel.get('type');

          if (axisPointerType && axisPointerType !== 'none') {
            var elStyle = viewHelper.buildElStyle(axisPointerModel);
            var pointerOption = pointerShapeBuilder[axisPointerType](axis, polar, coordValue, otherExtent, elStyle);
            pointerOption.style = elStyle;
            elOption.graphicKey = pointerOption.type;
            elOption.pointer = pointerOption;
          }

          var labelMargin = axisPointerModel.get('label.margin');
          var labelPos = getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin);
          viewHelper.buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos);
        } // Do not support handle, utill any user requires it.

      });

      function getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin) {
        var axis = axisModel.axis;
        var coord = axis.dataToCoord(value);
        var axisAngle = polar.getAngleAxis().getExtent()[0];
        axisAngle = axisAngle / 180 * Math.PI;
        var radiusExtent = polar.getRadiusAxis().getExtent();
        var position;
        var align;
        var verticalAlign;

        if (axis.dim === 'radius') {
          var transform = matrix.create();
          matrix.rotate(transform, transform, axisAngle);
          matrix.translate(transform, transform, [polar.cx, polar.cy]);
          position = graphic.applyTransform([coord, -labelMargin], transform);
          var labelRotation = axisModel.getModel('axisLabel').get('rotate') || 0;
          var labelLayout = AxisBuilder.innerTextLayout(axisAngle, labelRotation * Math.PI / 180, -1);
          align = labelLayout.textAlign;
          verticalAlign = labelLayout.textVerticalAlign;
        } else {
          // angle axis
          var r = radiusExtent[1];
          position = polar.coordToPoint([r + labelMargin, coord]);
          var cx = polar.cx;
          var cy = polar.cy;
          align = Math.abs(position[0] - cx) / r < 0.3 ? 'center' : position[0] > cx ? 'left' : 'right';
          verticalAlign = Math.abs(position[1] - cy) / r < 0.3 ? 'middle' : position[1] > cy ? 'top' : 'bottom';
        }

        return {
          position: position,
          align: align,
          verticalAlign: verticalAlign
        };
      }

      var pointerShapeBuilder = {
        line: function line(axis, polar, coordValue, otherExtent, elStyle) {
          return axis.dim === 'angle' ? {
            type: 'Line',
            shape: viewHelper.makeLineShape(polar.coordToPoint([otherExtent[0], coordValue]), polar.coordToPoint([otherExtent[1], coordValue]))
          } : {
            type: 'Circle',
            shape: {
              cx: polar.cx,
              cy: polar.cy,
              r: coordValue
            }
          };
        },
        shadow: function shadow(axis, polar, coordValue, otherExtent, elStyle) {
          var bandWidth = Math.max(1, axis.getBandWidth());
          var radian = Math.PI / 180;
          return axis.dim === 'angle' ? {
            type: 'Sector',
            shape: viewHelper.makeSectorShape(polar.cx, polar.cy, otherExtent[0], otherExtent[1], // In ECharts y is negative if angle is positive
            (-coordValue - bandWidth / 2) * radian, (-coordValue + bandWidth / 2) * radian)
          } : {
            type: 'Sector',
            shape: viewHelper.makeSectorShape(polar.cx, polar.cy, coordValue - bandWidth / 2, coordValue + bandWidth / 2, 0, Math.PI * 2)
          };
        }
      };
      AxisView.registerAxisPointerClass('PolarAxisPointer', PolarAxisPointer);
      var _default = PolarAxisPointer;
      module.exports = _default;
      /***/
    },

    /***/
    "b9oc":
    /*!****************************************************************!*\
      !*** ./node_modules/echarts/lib/component/dataZoom/history.js ***!
      \****************************************************************/

    /*! no static exports found */

    /***/
    function b9oc(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var each = zrUtil.each;
      var ATTR = '\0_ec_hist_store';
      /**
       * @param {module:echarts/model/Global} ecModel
       * @param {Object} newSnapshot {dataZoomId, batch: [payloadInfo, ...]}
       */

      function push(ecModel, newSnapshot) {
        var store = giveStore(ecModel); // If previous dataZoom can not be found,
        // complete an range with current range.

        each(newSnapshot, function (batchItem, dataZoomId) {
          var i = store.length - 1;

          for (; i >= 0; i--) {
            var snapshot = store[i];

            if (snapshot[dataZoomId]) {
              break;
            }
          }

          if (i < 0) {
            // No origin range set, create one by current range.
            var dataZoomModel = ecModel.queryComponents({
              mainType: 'dataZoom',
              subType: 'select',
              id: dataZoomId
            })[0];

            if (dataZoomModel) {
              var percentRange = dataZoomModel.getPercentRange();
              store[0][dataZoomId] = {
                dataZoomId: dataZoomId,
                start: percentRange[0],
                end: percentRange[1]
              };
            }
          }
        });
        store.push(newSnapshot);
      }
      /**
       * @param {module:echarts/model/Global} ecModel
       * @return {Object} snapshot
       */


      function pop(ecModel) {
        var store = giveStore(ecModel);
        var head = store[store.length - 1];
        store.length > 1 && store.pop(); // Find top for all dataZoom.

        var snapshot = {};
        each(head, function (batchItem, dataZoomId) {
          for (var i = store.length - 1; i >= 0; i--) {
            var batchItem = store[i][dataZoomId];

            if (batchItem) {
              snapshot[dataZoomId] = batchItem;
              break;
            }
          }
        });
        return snapshot;
      }
      /**
       * @param {module:echarts/model/Global} ecModel
       */


      function clear(ecModel) {
        ecModel[ATTR] = null;
      }
      /**
       * @param {module:echarts/model/Global} ecModel
       * @return {number} records. always >= 1.
       */


      function count(ecModel) {
        return giveStore(ecModel).length;
      }
      /**
       * [{key: dataZoomId, value: {dataZoomId, range}}, ...]
       * History length of each dataZoom may be different.
       * this._history[0] is used to store origin range.
       * @type {Array.<Object>}
       */


      function giveStore(ecModel) {
        var store = ecModel[ATTR];

        if (!store) {
          store = ecModel[ATTR] = [{}];
        }

        return store;
      }

      exports.push = push;
      exports.pop = pop;
      exports.clear = clear;
      exports.count = count;
      /***/
    },

    /***/
    "bBKM":
    /*!***************************************************************!*\
      !*** ./node_modules/echarts/lib/component/radar/RadarView.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function bBKM(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var AxisBuilder = __webpack_require__(
      /*! ../axis/AxisBuilder */
      "+rIm");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];

      var _default = echarts.extendComponentView({
        type: 'radar',
        render: function render(radarModel, ecModel, api) {
          var group = this.group;
          group.removeAll();

          this._buildAxes(radarModel);

          this._buildSplitLineAndArea(radarModel);
        },
        _buildAxes: function _buildAxes(radarModel) {
          var radar = radarModel.coordinateSystem;
          var indicatorAxes = radar.getIndicatorAxes();
          var axisBuilders = zrUtil.map(indicatorAxes, function (indicatorAxis) {
            var axisBuilder = new AxisBuilder(indicatorAxis.model, {
              position: [radar.cx, radar.cy],
              rotation: indicatorAxis.angle,
              labelDirection: -1,
              tickDirection: -1,
              nameDirection: 1
            });
            return axisBuilder;
          });
          zrUtil.each(axisBuilders, function (axisBuilder) {
            zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
            this.group.add(axisBuilder.getGroup());
          }, this);
        },
        _buildSplitLineAndArea: function _buildSplitLineAndArea(radarModel) {
          var radar = radarModel.coordinateSystem;
          var indicatorAxes = radar.getIndicatorAxes();

          if (!indicatorAxes.length) {
            return;
          }

          var shape = radarModel.get('shape');
          var splitLineModel = radarModel.getModel('splitLine');
          var splitAreaModel = radarModel.getModel('splitArea');
          var lineStyleModel = splitLineModel.getModel('lineStyle');
          var areaStyleModel = splitAreaModel.getModel('areaStyle');
          var showSplitLine = splitLineModel.get('show');
          var showSplitArea = splitAreaModel.get('show');
          var splitLineColors = lineStyleModel.get('color');
          var splitAreaColors = areaStyleModel.get('color');
          splitLineColors = zrUtil.isArray(splitLineColors) ? splitLineColors : [splitLineColors];
          splitAreaColors = zrUtil.isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];
          var splitLines = [];
          var splitAreas = [];

          function getColorIndex(areaOrLine, areaOrLineColorList, idx) {
            var colorIndex = idx % areaOrLineColorList.length;
            areaOrLine[colorIndex] = areaOrLine[colorIndex] || [];
            return colorIndex;
          }

          if (shape === 'circle') {
            var ticksRadius = indicatorAxes[0].getTicksCoords();
            var cx = radar.cx;
            var cy = radar.cy;

            for (var i = 0; i < ticksRadius.length; i++) {
              if (showSplitLine) {
                var colorIndex = getColorIndex(splitLines, splitLineColors, i);
                splitLines[colorIndex].push(new graphic.Circle({
                  shape: {
                    cx: cx,
                    cy: cy,
                    r: ticksRadius[i].coord
                  }
                }));
              }

              if (showSplitArea && i < ticksRadius.length - 1) {
                var colorIndex = getColorIndex(splitAreas, splitAreaColors, i);
                splitAreas[colorIndex].push(new graphic.Ring({
                  shape: {
                    cx: cx,
                    cy: cy,
                    r0: ticksRadius[i].coord,
                    r: ticksRadius[i + 1].coord
                  }
                }));
              }
            }
          } // Polyyon
          else {
            var realSplitNumber;
            var axesTicksPoints = zrUtil.map(indicatorAxes, function (indicatorAxis, idx) {
              var ticksCoords = indicatorAxis.getTicksCoords();
              realSplitNumber = realSplitNumber == null ? ticksCoords.length - 1 : Math.min(ticksCoords.length - 1, realSplitNumber);
              return zrUtil.map(ticksCoords, function (tickCoord) {
                return radar.coordToPoint(tickCoord.coord, idx);
              });
            });
            var prevPoints = [];

            for (var i = 0; i <= realSplitNumber; i++) {
              var points = [];

              for (var j = 0; j < indicatorAxes.length; j++) {
                points.push(axesTicksPoints[j][i]);
              } // Close


              if (points[0]) {
                points.push(points[0].slice());
              } else {}

              if (showSplitLine) {
                var colorIndex = getColorIndex(splitLines, splitLineColors, i);
                splitLines[colorIndex].push(new graphic.Polyline({
                  shape: {
                    points: points
                  }
                }));
              }

              if (showSplitArea && prevPoints) {
                var colorIndex = getColorIndex(splitAreas, splitAreaColors, i - 1);
                splitAreas[colorIndex].push(new graphic.Polygon({
                  shape: {
                    points: points.concat(prevPoints)
                  }
                }));
              }

              prevPoints = points.slice().reverse();
            }
          }

          var lineStyle = lineStyleModel.getLineStyle();
          var areaStyle = areaStyleModel.getAreaStyle(); // Add splitArea before splitLine

          zrUtil.each(splitAreas, function (splitAreas, idx) {
            this.group.add(graphic.mergePath(splitAreas, {
              style: zrUtil.defaults({
                stroke: 'none',
                fill: splitAreaColors[idx % splitAreaColors.length]
              }, areaStyle),
              silent: true
            }));
          }, this);
          zrUtil.each(splitLines, function (splitLines, idx) {
            this.group.add(graphic.mergePath(splitLines, {
              style: zrUtil.defaults({
                fill: 'none',
                stroke: splitLineColors[idx % splitLineColors.length]
              }, lineStyle),
              silent: true
            }));
          }, this);
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "bBL8":
    /*!******************************************************!*\
      !*** ./node_modules/echarts/lib/chart/themeRiver.js ***!
      \******************************************************/

    /*! no static exports found */

    /***/
    function bBL8(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ../component/singleAxis */
      "LPzL");

      __webpack_require__(
      /*! ./themeRiver/ThemeRiverSeries */
      "rfSb");

      __webpack_require__(
      /*! ./themeRiver/ThemeRiverView */
      "JVwQ");

      var themeRiverLayout = __webpack_require__(
      /*! ./themeRiver/themeRiverLayout */
      "UnoB");

      var themeRiverVisual = __webpack_require__(
      /*! ./themeRiver/themeRiverVisual */
      "cbJ4");

      var dataFilter = __webpack_require__(
      /*! ../processor/dataFilter */
      "0/Rx");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      echarts.registerLayout(themeRiverLayout);
      echarts.registerVisual(themeRiverVisual);
      echarts.registerProcessor(dataFilter('themeRiver'));
      /***/
    },

    /***/
    "bMXI":
    /*!************************************************!*\
      !*** ./node_modules/echarts/lib/coord/View.js ***!
      \************************************************/

    /*! no static exports found */

    /***/
    function bMXI(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var vector = __webpack_require__(
      /*! zrender/lib/core/vector */
      "QBsz");

      var matrix = __webpack_require__(
      /*! zrender/lib/core/matrix */
      "Fofx");

      var BoundingRect = __webpack_require__(
      /*! zrender/lib/core/BoundingRect */
      "mFDi");

      var Transformable = __webpack_require__(
      /*! zrender/lib/mixin/Transformable */
      "DN4a");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Simple view coordinate system
       * Mapping given x, y to transformd view x, y
       */


      var v2ApplyTransform = vector.applyTransform; // Dummy transform node

      function TransformDummy() {
        Transformable.call(this);
      }

      zrUtil.mixin(TransformDummy, Transformable);

      function View(name) {
        /**
         * @type {string}
         */
        this.name = name;
        /**
         * @type {Object}
         */

        this.zoomLimit;
        Transformable.call(this);
        this._roamTransformable = new TransformDummy();
        this._rawTransformable = new TransformDummy();
        this._center;
        this._zoom;
      }

      View.prototype = {
        constructor: View,
        type: 'view',

        /**
         * @param {Array.<string>}
         * @readOnly
         */
        dimensions: ['x', 'y'],

        /**
         * Set bounding rect
         * @param {number} x
         * @param {number} y
         * @param {number} width
         * @param {number} height
         */
        // PENDING to getRect
        setBoundingRect: function setBoundingRect(x, y, width, height) {
          this._rect = new BoundingRect(x, y, width, height);
          return this._rect;
        },

        /**
         * @return {module:zrender/core/BoundingRect}
         */
        // PENDING to getRect
        getBoundingRect: function getBoundingRect() {
          return this._rect;
        },

        /**
         * @param {number} x
         * @param {number} y
         * @param {number} width
         * @param {number} height
         */
        setViewRect: function setViewRect(x, y, width, height) {
          this.transformTo(x, y, width, height);
          this._viewRect = new BoundingRect(x, y, width, height);
        },

        /**
         * Transformed to particular position and size
         * @param {number} x
         * @param {number} y
         * @param {number} width
         * @param {number} height
         */
        transformTo: function transformTo(x, y, width, height) {
          var rect = this.getBoundingRect();
          var rawTransform = this._rawTransformable;
          rawTransform.transform = rect.calculateTransform(new BoundingRect(x, y, width, height));
          rawTransform.decomposeTransform();

          this._updateTransform();
        },

        /**
         * Set center of view
         * @param {Array.<number>} [centerCoord]
         */
        setCenter: function setCenter(centerCoord) {
          if (!centerCoord) {
            return;
          }

          this._center = centerCoord;

          this._updateCenterAndZoom();
        },

        /**
         * @param {number} zoom
         */
        setZoom: function setZoom(zoom) {
          zoom = zoom || 1;
          var zoomLimit = this.zoomLimit;

          if (zoomLimit) {
            if (zoomLimit.max != null) {
              zoom = Math.min(zoomLimit.max, zoom);
            }

            if (zoomLimit.min != null) {
              zoom = Math.max(zoomLimit.min, zoom);
            }
          }

          this._zoom = zoom;

          this._updateCenterAndZoom();
        },

        /**
         * Get default center without roam
         */
        getDefaultCenter: function getDefaultCenter() {
          // Rect before any transform
          var rawRect = this.getBoundingRect();
          var cx = rawRect.x + rawRect.width / 2;
          var cy = rawRect.y + rawRect.height / 2;
          return [cx, cy];
        },
        getCenter: function getCenter() {
          return this._center || this.getDefaultCenter();
        },
        getZoom: function getZoom() {
          return this._zoom || 1;
        },

        /**
         * @return {Array.<number}
         */
        getRoamTransform: function getRoamTransform() {
          return this._roamTransformable.getLocalTransform();
        },

        /**
         * Remove roam
         */
        _updateCenterAndZoom: function _updateCenterAndZoom() {
          // Must update after view transform updated
          var rawTransformMatrix = this._rawTransformable.getLocalTransform();

          var roamTransform = this._roamTransformable;
          var defaultCenter = this.getDefaultCenter();
          var center = this.getCenter();
          var zoom = this.getZoom();
          center = vector.applyTransform([], center, rawTransformMatrix);
          defaultCenter = vector.applyTransform([], defaultCenter, rawTransformMatrix);
          roamTransform.origin = center;
          roamTransform.position = [defaultCenter[0] - center[0], defaultCenter[1] - center[1]];
          roamTransform.scale = [zoom, zoom];

          this._updateTransform();
        },

        /**
         * Update transform from roam and mapLocation
         * @private
         */
        _updateTransform: function _updateTransform() {
          var roamTransformable = this._roamTransformable;
          var rawTransformable = this._rawTransformable;
          rawTransformable.parent = roamTransformable;
          roamTransformable.updateTransform();
          rawTransformable.updateTransform();
          matrix.copy(this.transform || (this.transform = []), rawTransformable.transform || matrix.create());
          this._rawTransform = rawTransformable.getLocalTransform();
          this.invTransform = this.invTransform || [];
          matrix.invert(this.invTransform, this.transform);
          this.decomposeTransform();
        },
        getTransformInfo: function getTransformInfo() {
          var roamTransform = this._roamTransformable.transform;
          var rawTransformable = this._rawTransformable;
          return {
            roamTransform: roamTransform ? zrUtil.slice(roamTransform) : matrix.create(),
            rawScale: zrUtil.slice(rawTransformable.scale),
            rawPosition: zrUtil.slice(rawTransformable.position)
          };
        },

        /**
         * @return {module:zrender/core/BoundingRect}
         */
        getViewRect: function getViewRect() {
          return this._viewRect;
        },

        /**
         * Get view rect after roam transform
         * @return {module:zrender/core/BoundingRect}
         */
        getViewRectAfterRoam: function getViewRectAfterRoam() {
          var rect = this.getBoundingRect().clone();
          rect.applyTransform(this.transform);
          return rect;
        },

        /**
         * Convert a single (lon, lat) data item to (x, y) point.
         * @param {Array.<number>} data
         * @param {boolean} noRoam
         * @param {Array.<number>} [out]
         * @return {Array.<number>}
         */
        dataToPoint: function dataToPoint(data, noRoam, out) {
          var transform = noRoam ? this._rawTransform : this.transform;
          out = out || [];
          return transform ? v2ApplyTransform(out, data, transform) : vector.copy(out, data);
        },

        /**
         * Convert a (x, y) point to (lon, lat) data
         * @param {Array.<number>} point
         * @return {Array.<number>}
         */
        pointToData: function pointToData(point) {
          var invTransform = this.invTransform;
          return invTransform ? v2ApplyTransform([], point, invTransform) : [point[0], point[1]];
        },

        /**
         * @implements
         * see {module:echarts/CoodinateSystem}
         */
        convertToPixel: zrUtil.curry(doConvert, 'dataToPoint'),

        /**
         * @implements
         * see {module:echarts/CoodinateSystem}
         */
        convertFromPixel: zrUtil.curry(doConvert, 'pointToData'),

        /**
         * @implements
         * see {module:echarts/CoodinateSystem}
         */
        containPoint: function containPoint(point) {
          return this.getViewRectAfterRoam().contain(point[0], point[1]);
        }
        /**
         * @return {number}
         */
        // getScalarScale: function () {
        //     // Use determinant square root of transform to mutiply scalar
        //     var m = this.transform;
        //     var det = Math.sqrt(Math.abs(m[0] * m[3] - m[2] * m[1]));
        //     return det;
        // }

      };
      zrUtil.mixin(View, Transformable);

      function doConvert(methodName, ecModel, finder, value) {
        var seriesModel = finder.seriesModel;
        var coordSys = seriesModel ? seriesModel.coordinateSystem : null; // e.g., graph.

        return coordSys === this ? coordSys[methodName](value) : null;
      }

      var _default = View;
      module.exports = _default;
      /***/
    },

    /***/
    "bNin":
    /*!*********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/tree/TreeView.js ***!
      \*********************************************************/

    /*! no static exports found */

    /***/
    function bNin(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var SymbolClz = __webpack_require__(
      /*! ../helper/Symbol */
      "FBjb");

      var _layoutHelper = __webpack_require__(
      /*! ./layoutHelper */
      "Itpr");

      var radialCoordinate = _layoutHelper.radialCoordinate;

      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var bbox = __webpack_require__(
      /*! zrender/lib/core/bbox */
      "4mN7");

      var View = __webpack_require__(
      /*! ../../coord/View */
      "bMXI");

      var roamHelper = __webpack_require__(
      /*! ../../component/helper/roamHelper */
      "Ae+d");

      var RoamController = __webpack_require__(
      /*! ../../component/helper/RoamController */
      "SgGq");

      var _cursorHelper = __webpack_require__(
      /*! ../../component/helper/cursorHelper */
      "xSat");

      var onIrrelevantElement = _cursorHelper.onIrrelevantElement;

      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var _number = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var parsePercent = _number.parsePercent;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var TreeShape = graphic.extendShape({
        shape: {
          parentPoint: [],
          childPoints: [],
          orient: '',
          forkPosition: ''
        },
        style: {
          stroke: '#000',
          fill: null
        },
        buildPath: function buildPath(ctx, shape) {
          var childPoints = shape.childPoints;
          var childLen = childPoints.length;
          var parentPoint = shape.parentPoint;
          var firstChildPos = childPoints[0];
          var lastChildPos = childPoints[childLen - 1];

          if (childLen === 1) {
            ctx.moveTo(parentPoint[0], parentPoint[1]);
            ctx.lineTo(firstChildPos[0], firstChildPos[1]);
            return;
          }

          var orient = shape.orient;
          var forkDim = orient === 'TB' || orient === 'BT' ? 0 : 1;
          var otherDim = 1 - forkDim;
          var forkPosition = parsePercent(shape.forkPosition, 1);
          var tmpPoint = [];
          tmpPoint[forkDim] = parentPoint[forkDim];
          tmpPoint[otherDim] = parentPoint[otherDim] + (lastChildPos[otherDim] - parentPoint[otherDim]) * forkPosition;
          ctx.moveTo(parentPoint[0], parentPoint[1]);
          ctx.lineTo(tmpPoint[0], tmpPoint[1]);
          ctx.moveTo(firstChildPos[0], firstChildPos[1]);
          tmpPoint[forkDim] = firstChildPos[forkDim];
          ctx.lineTo(tmpPoint[0], tmpPoint[1]);
          tmpPoint[forkDim] = lastChildPos[forkDim];
          ctx.lineTo(tmpPoint[0], tmpPoint[1]);
          ctx.lineTo(lastChildPos[0], lastChildPos[1]);

          for (var i = 1; i < childLen - 1; i++) {
            var point = childPoints[i];
            ctx.moveTo(point[0], point[1]);
            tmpPoint[forkDim] = point[forkDim];
            ctx.lineTo(tmpPoint[0], tmpPoint[1]);
          }
        }
      });

      var _default = echarts.extendChartView({
        type: 'tree',

        /**
         * Init the chart
         * @override
         * @param  {module:echarts/model/Global} ecModel
         * @param  {module:echarts/ExtensionAPI} api
         */
        init: function init(ecModel, api) {
          /**
           * @private
           * @type {module:echarts/data/Tree}
           */
          this._oldTree;
          /**
           * @private
           * @type {module:zrender/container/Group}
           */

          this._mainGroup = new graphic.Group();
          /**
           * @private
           * @type {module:echarts/componet/helper/RoamController}
           */

          this._controller = new RoamController(api.getZr());
          this._controllerHost = {
            target: this.group
          };
          this.group.add(this._mainGroup);
        },
        render: function render(seriesModel, ecModel, api, payload) {
          var data = seriesModel.getData();
          var layoutInfo = seriesModel.layoutInfo;
          var group = this._mainGroup;
          var layout = seriesModel.get('layout');

          if (layout === 'radial') {
            group.attr('position', [layoutInfo.x + layoutInfo.width / 2, layoutInfo.y + layoutInfo.height / 2]);
          } else {
            group.attr('position', [layoutInfo.x, layoutInfo.y]);
          }

          this._updateViewCoordSys(seriesModel, layoutInfo, layout);

          this._updateController(seriesModel, ecModel, api);

          var oldData = this._data;
          var seriesScope = {
            expandAndCollapse: seriesModel.get('expandAndCollapse'),
            layout: layout,
            edgeShape: seriesModel.get('edgeShape'),
            edgeForkPosition: seriesModel.get('edgeForkPosition'),
            orient: seriesModel.getOrient(),
            curvature: seriesModel.get('lineStyle.curveness'),
            symbolRotate: seriesModel.get('symbolRotate'),
            symbolOffset: seriesModel.get('symbolOffset'),
            hoverAnimation: seriesModel.get('hoverAnimation'),
            useNameLabel: true,
            fadeIn: true
          };
          data.diff(oldData).add(function (newIdx) {
            if (symbolNeedsDraw(data, newIdx)) {
              // Create node and edge
              updateNode(data, newIdx, null, group, seriesModel, seriesScope);
            }
          }).update(function (newIdx, oldIdx) {
            var symbolEl = oldData.getItemGraphicEl(oldIdx);

            if (!symbolNeedsDraw(data, newIdx)) {
              symbolEl && removeNode(oldData, oldIdx, symbolEl, group, seriesModel, seriesScope);
              return;
            } // Update node and edge


            updateNode(data, newIdx, symbolEl, group, seriesModel, seriesScope);
          }).remove(function (oldIdx) {
            var symbolEl = oldData.getItemGraphicEl(oldIdx); // When remove a collapsed node of subtree, since the collapsed
            // node haven't been initialized with a symbol element,
            // you can't found it's symbol element through index.
            // so if we want to remove the symbol element we should insure
            // that the symbol element is not null.

            if (symbolEl) {
              removeNode(oldData, oldIdx, symbolEl, group, seriesModel, seriesScope);
            }
          }).execute();
          this._nodeScaleRatio = seriesModel.get('nodeScaleRatio');

          this._updateNodeAndLinkScale(seriesModel);

          if (seriesScope.expandAndCollapse === true) {
            data.eachItemGraphicEl(function (el, dataIndex) {
              el.off('click').on('click', function () {
                api.dispatchAction({
                  type: 'treeExpandAndCollapse',
                  seriesId: seriesModel.id,
                  dataIndex: dataIndex
                });
              });
            });
          }

          this._data = data;
        },
        _updateViewCoordSys: function _updateViewCoordSys(seriesModel) {
          var data = seriesModel.getData();
          var points = [];
          data.each(function (idx) {
            var layout = data.getItemLayout(idx);

            if (layout && !isNaN(layout.x) && !isNaN(layout.y)) {
              points.push([+layout.x, +layout.y]);
            }
          });
          var min = [];
          var max = [];
          bbox.fromPoints(points, min, max); // If don't Store min max when collapse the root node after roam,
          // the root node will disappear.

          var oldMin = this._min;
          var oldMax = this._max; // If width or height is 0

          if (max[0] - min[0] === 0) {
            min[0] = oldMin ? oldMin[0] : min[0] - 1;
            max[0] = oldMax ? oldMax[0] : max[0] + 1;
          }

          if (max[1] - min[1] === 0) {
            min[1] = oldMin ? oldMin[1] : min[1] - 1;
            max[1] = oldMax ? oldMax[1] : max[1] + 1;
          }

          var viewCoordSys = seriesModel.coordinateSystem = new View();
          viewCoordSys.zoomLimit = seriesModel.get('scaleLimit');
          viewCoordSys.setBoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
          viewCoordSys.setCenter(seriesModel.get('center'));
          viewCoordSys.setZoom(seriesModel.get('zoom')); // Here we use viewCoordSys just for computing the 'position' and 'scale' of the group

          this.group.attr({
            position: viewCoordSys.position,
            scale: viewCoordSys.scale
          });
          this._viewCoordSys = viewCoordSys;
          this._min = min;
          this._max = max;
        },
        _updateController: function _updateController(seriesModel, ecModel, api) {
          var controller = this._controller;
          var controllerHost = this._controllerHost;
          var group = this.group;
          controller.setPointerChecker(function (e, x, y) {
            var rect = group.getBoundingRect();
            rect.applyTransform(group.transform);
            return rect.contain(x, y) && !onIrrelevantElement(e, api, seriesModel);
          });
          controller.enable(seriesModel.get('roam'));
          controllerHost.zoomLimit = seriesModel.get('scaleLimit');
          controllerHost.zoom = seriesModel.coordinateSystem.getZoom();
          controller.off('pan').off('zoom').on('pan', function (e) {
            roamHelper.updateViewOnPan(controllerHost, e.dx, e.dy);
            api.dispatchAction({
              seriesId: seriesModel.id,
              type: 'treeRoam',
              dx: e.dx,
              dy: e.dy
            });
          }, this).on('zoom', function (e) {
            roamHelper.updateViewOnZoom(controllerHost, e.scale, e.originX, e.originY);
            api.dispatchAction({
              seriesId: seriesModel.id,
              type: 'treeRoam',
              zoom: e.scale,
              originX: e.originX,
              originY: e.originY
            });

            this._updateNodeAndLinkScale(seriesModel);
          }, this);
        },
        _updateNodeAndLinkScale: function _updateNodeAndLinkScale(seriesModel) {
          var data = seriesModel.getData();

          var nodeScale = this._getNodeGlobalScale(seriesModel);

          var invScale = [nodeScale, nodeScale];
          data.eachItemGraphicEl(function (el, idx) {
            el.attr('scale', invScale);
          });
        },
        _getNodeGlobalScale: function _getNodeGlobalScale(seriesModel) {
          var coordSys = seriesModel.coordinateSystem;

          if (coordSys.type !== 'view') {
            return 1;
          }

          var nodeScaleRatio = this._nodeScaleRatio;
          var groupScale = coordSys.scale;
          var groupZoom = groupScale && groupScale[0] || 1; // Scale node when zoom changes

          var roamZoom = coordSys.getZoom();
          var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
          return nodeScale / groupZoom;
        },
        dispose: function dispose() {
          this._controller && this._controller.dispose();
          this._controllerHost = {};
        },
        remove: function remove() {
          this._mainGroup.removeAll();

          this._data = null;
        }
      });

      function symbolNeedsDraw(data, dataIndex) {
        var layout = data.getItemLayout(dataIndex);
        return layout && !isNaN(layout.x) && !isNaN(layout.y) && data.getItemVisual(dataIndex, 'symbol') !== 'none';
      }

      function getTreeNodeStyle(node, itemModel, seriesScope) {
        seriesScope.itemModel = itemModel;
        seriesScope.itemStyle = itemModel.getModel('itemStyle').getItemStyle();
        seriesScope.hoverItemStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();
        seriesScope.lineStyle = itemModel.getModel('lineStyle').getLineStyle();
        seriesScope.labelModel = itemModel.getModel('label');
        seriesScope.hoverLabelModel = itemModel.getModel('emphasis.label');

        if (node.isExpand === false && node.children.length !== 0) {
          seriesScope.symbolInnerColor = seriesScope.itemStyle.fill;
        } else {
          seriesScope.symbolInnerColor = '#fff';
        }

        return seriesScope;
      }

      function updateNode(data, dataIndex, symbolEl, group, seriesModel, seriesScope) {
        var isInit = !symbolEl;
        var node = data.tree.getNodeByDataIndex(dataIndex);
        var itemModel = node.getModel();
        var seriesScope = getTreeNodeStyle(node, itemModel, seriesScope);
        var virtualRoot = data.tree.root;
        var source = node.parentNode === virtualRoot ? node : node.parentNode || node;
        var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);
        var sourceLayout = source.getLayout();
        var sourceOldLayout = sourceSymbolEl ? {
          x: sourceSymbolEl.position[0],
          y: sourceSymbolEl.position[1],
          rawX: sourceSymbolEl.__radialOldRawX,
          rawY: sourceSymbolEl.__radialOldRawY
        } : sourceLayout;
        var targetLayout = node.getLayout();

        if (isInit) {
          symbolEl = new SymbolClz(data, dataIndex, seriesScope);
          symbolEl.attr('position', [sourceOldLayout.x, sourceOldLayout.y]);
        } else {
          symbolEl.updateData(data, dataIndex, seriesScope);
        }

        symbolEl.__radialOldRawX = symbolEl.__radialRawX;
        symbolEl.__radialOldRawY = symbolEl.__radialRawY;
        symbolEl.__radialRawX = targetLayout.rawX;
        symbolEl.__radialRawY = targetLayout.rawY;
        group.add(symbolEl);
        data.setItemGraphicEl(dataIndex, symbolEl);
        graphic.updateProps(symbolEl, {
          position: [targetLayout.x, targetLayout.y]
        }, seriesModel);
        var symbolPath = symbolEl.getSymbolPath();

        if (seriesScope.layout === 'radial') {
          var realRoot = virtualRoot.children[0];
          var rootLayout = realRoot.getLayout();
          var length = realRoot.children.length;
          var rad;
          var isLeft;

          if (targetLayout.x === rootLayout.x && node.isExpand === true) {
            var center = {};
            center.x = (realRoot.children[0].getLayout().x + realRoot.children[length - 1].getLayout().x) / 2;
            center.y = (realRoot.children[0].getLayout().y + realRoot.children[length - 1].getLayout().y) / 2;
            rad = Math.atan2(center.y - rootLayout.y, center.x - rootLayout.x);

            if (rad < 0) {
              rad = Math.PI * 2 + rad;
            }

            isLeft = center.x < rootLayout.x;

            if (isLeft) {
              rad = rad - Math.PI;
            }
          } else {
            rad = Math.atan2(targetLayout.y - rootLayout.y, targetLayout.x - rootLayout.x);

            if (rad < 0) {
              rad = Math.PI * 2 + rad;
            }

            if (node.children.length === 0 || node.children.length !== 0 && node.isExpand === false) {
              isLeft = targetLayout.x < rootLayout.x;

              if (isLeft) {
                rad = rad - Math.PI;
              }
            } else {
              isLeft = targetLayout.x > rootLayout.x;

              if (!isLeft) {
                rad = rad - Math.PI;
              }
            }
          }

          var textPosition = isLeft ? 'left' : 'right';
          var rotate = seriesScope.labelModel.get('rotate');
          var labelRotateRadian = rotate * (Math.PI / 180);
          symbolPath.setStyle({
            textPosition: seriesScope.labelModel.get('position') || textPosition,
            textRotation: rotate == null ? -rad : labelRotateRadian,
            textOrigin: 'center',
            verticalAlign: 'middle'
          });
        }

        drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group, seriesScope);
      }

      function drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group, seriesScope) {
        var edgeShape = seriesScope.edgeShape;
        var edge = symbolEl.__edge;

        if (edgeShape === 'curve') {
          if (node.parentNode && node.parentNode !== virtualRoot) {
            if (!edge) {
              edge = symbolEl.__edge = new graphic.BezierCurve({
                shape: getEdgeShape(seriesScope, sourceOldLayout, sourceOldLayout),
                style: zrUtil.defaults({
                  opacity: 0,
                  strokeNoScale: true
                }, seriesScope.lineStyle)
              });
            }

            graphic.updateProps(edge, {
              shape: getEdgeShape(seriesScope, sourceLayout, targetLayout),
              style: zrUtil.defaults({
                opacity: 1
              }, seriesScope.lineStyle)
            }, seriesModel);
          }
        } else if (edgeShape === 'polyline') {
          if (seriesScope.layout === 'orthogonal') {
            if (node !== virtualRoot && node.children && node.children.length !== 0 && node.isExpand === true) {
              var children = node.children;
              var childPoints = [];

              for (var i = 0; i < children.length; i++) {
                var childLayout = children[i].getLayout();
                childPoints.push([childLayout.x, childLayout.y]);
              }

              if (!edge) {
                edge = symbolEl.__edge = new TreeShape({
                  shape: {
                    parentPoint: [targetLayout.x, targetLayout.y],
                    childPoints: [[targetLayout.x, targetLayout.y]],
                    orient: seriesScope.orient,
                    forkPosition: seriesScope.edgeForkPosition
                  },
                  style: zrUtil.defaults({
                    opacity: 0,
                    strokeNoScale: true
                  }, seriesScope.lineStyle)
                });
              }

              graphic.updateProps(edge, {
                shape: {
                  parentPoint: [targetLayout.x, targetLayout.y],
                  childPoints: childPoints
                },
                style: zrUtil.defaults({
                  opacity: 1
                }, seriesScope.lineStyle)
              }, seriesModel);
            }
          } else {}
        }

        group.add(edge);
      }

      function removeNode(data, dataIndex, symbolEl, group, seriesModel, seriesScope) {
        var node = data.tree.getNodeByDataIndex(dataIndex);
        var virtualRoot = data.tree.root;
        var itemModel = node.getModel();
        var seriesScope = getTreeNodeStyle(node, itemModel, seriesScope);
        var source = node.parentNode === virtualRoot ? node : node.parentNode || node;
        var edgeShape = seriesScope.edgeShape;
        var sourceLayout;

        while (sourceLayout = source.getLayout(), sourceLayout == null) {
          source = source.parentNode === virtualRoot ? source : source.parentNode || source;
        }

        graphic.updateProps(symbolEl, {
          position: [sourceLayout.x + 1, sourceLayout.y + 1]
        }, seriesModel, function () {
          group.remove(symbolEl);
          data.setItemGraphicEl(dataIndex, null);
        });
        symbolEl.fadeOut(null, {
          keepLabel: true
        });
        var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);
        var sourceEdge = sourceSymbolEl.__edge; // 1. when expand the sub tree, delete the children node should delete the edge of
        // the source at the same time. because the polyline edge shape is only owned by the source.
        // 2.when the node is the only children of the source, delete the node should delete the edge of
        // the source at the same time. the same reason as above.

        var edge = symbolEl.__edge || (source.isExpand === false || source.children.length === 1 ? sourceEdge : undefined);
        var edgeShape = seriesScope.edgeShape;

        if (edge) {
          if (edgeShape === 'curve') {
            graphic.updateProps(edge, {
              shape: getEdgeShape(seriesScope, sourceLayout, sourceLayout),
              style: {
                opacity: 0
              }
            }, seriesModel, function () {
              group.remove(edge);
            });
          } else if (edgeShape === 'polyline' && seriesScope.layout === 'orthogonal') {
            graphic.updateProps(edge, {
              shape: {
                parentPoint: [sourceLayout.x, sourceLayout.y],
                childPoints: [[sourceLayout.x, sourceLayout.y]]
              },
              style: {
                opacity: 0
              }
            }, seriesModel, function () {
              group.remove(edge);
            });
          }
        }
      }

      function getEdgeShape(seriesScope, sourceLayout, targetLayout) {
        var cpx1;
        var cpy1;
        var cpx2;
        var cpy2;
        var orient = seriesScope.orient;
        var x1;
        var x2;
        var y1;
        var y2;

        if (seriesScope.layout === 'radial') {
          x1 = sourceLayout.rawX;
          y1 = sourceLayout.rawY;
          x2 = targetLayout.rawX;
          y2 = targetLayout.rawY;
          var radialCoor1 = radialCoordinate(x1, y1);
          var radialCoor2 = radialCoordinate(x1, y1 + (y2 - y1) * seriesScope.curvature);
          var radialCoor3 = radialCoordinate(x2, y2 + (y1 - y2) * seriesScope.curvature);
          var radialCoor4 = radialCoordinate(x2, y2);
          return {
            x1: radialCoor1.x,
            y1: radialCoor1.y,
            x2: radialCoor4.x,
            y2: radialCoor4.y,
            cpx1: radialCoor2.x,
            cpy1: radialCoor2.y,
            cpx2: radialCoor3.x,
            cpy2: radialCoor3.y
          };
        } else {
          x1 = sourceLayout.x;
          y1 = sourceLayout.y;
          x2 = targetLayout.x;
          y2 = targetLayout.y;

          if (orient === 'LR' || orient === 'RL') {
            cpx1 = x1 + (x2 - x1) * seriesScope.curvature;
            cpy1 = y1;
            cpx2 = x2 + (x1 - x2) * seriesScope.curvature;
            cpy2 = y2;
          }

          if (orient === 'TB' || orient === 'BT') {
            cpx1 = x1;
            cpy1 = y1 + (y2 - y1) * seriesScope.curvature;
            cpx2 = x2;
            cpy2 = y2 + (y1 - y2) * seriesScope.curvature;
          }
        }

        return {
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2,
          cpx1: cpx1,
          cpy1: cpy1,
          cpx2: cpx2,
          cpy2: cpy2
        };
      }

      module.exports = _default;
      /***/
    },

    /***/
    "bZqE":
    /*!****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/tree/traversalHelper.js ***!
      \****************************************************************/

    /*! no static exports found */

    /***/
    function bZqE(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Traverse the tree from bottom to top and do something
       * @param  {module:echarts/data/Tree~TreeNode} root  The real root of the tree
       * @param  {Function} callback
       */
      function eachAfter(root, callback, separation) {
        var nodes = [root];
        var next = [];
        var node;

        while (node = nodes.pop()) {
          // jshint ignore:line
          next.push(node);

          if (node.isExpand) {
            var children = node.children;

            if (children.length) {
              for (var i = 0; i < children.length; i++) {
                nodes.push(children[i]);
              }
            }
          }
        }

        while (node = next.pop()) {
          // jshint ignore:line
          callback(node, separation);
        }
      }
      /**
       * Traverse the tree from top to bottom and do something
       * @param  {module:echarts/data/Tree~TreeNode} root  The real root of the tree
       * @param  {Function} callback
       */


      function eachBefore(root, callback) {
        var nodes = [root];
        var node;

        while (node = nodes.pop()) {
          // jshint ignore:line
          callback(node);

          if (node.isExpand) {
            var children = node.children;

            if (children.length) {
              for (var i = children.length - 1; i >= 0; i--) {
                nodes.push(children[i]);
              }
            }
          }
        }
      }

      exports.eachAfter = eachAfter;
      exports.eachBefore = eachBefore;
      /***/
    },

    /***/
    "c2i1":
    /*!************************************************!*\
      !*** ./node_modules/echarts/lib/data/Graph.js ***!
      \************************************************/

    /*! no static exports found */

    /***/
    function c2i1(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _clazz = __webpack_require__(
      /*! ../util/clazz */
      "Yl7c");

      var enableClassCheck = _clazz.enableClassCheck;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // id may be function name of Object, add a prefix to avoid this problem.

      function generateNodeKey(id) {
        return '_EC_' + id;
      }
      /**
       * @alias module:echarts/data/Graph
       * @constructor
       * @param {boolean} directed
       */


      var Graph = function Graph(directed) {
        /**
         * 
         * @type {boolean}
         * @private
         */
        this._directed = directed || false;
        /**
         * @type {Array.<module:echarts/data/Graph.Node>}
         * @readOnly
         */

        this.nodes = [];
        /**
         * @type {Array.<module:echarts/data/Graph.Edge>}
         * @readOnly
         */

        this.edges = [];
        /**
         * @type {Object.<string, module:echarts/data/Graph.Node>}
         * @private
         */

        this._nodesMap = {};
        /**
         * @type {Object.<string, module:echarts/data/Graph.Edge>}
         * @private
         */

        this._edgesMap = {};
        /**
         * @type {module:echarts/data/List}
         * @readOnly
         */

        this.data;
        /**
         * @type {module:echarts/data/List}
         * @readOnly
         */

        this.edgeData;
      };

      var graphProto = Graph.prototype;
      /**
       * @type {string}
       */

      graphProto.type = 'graph';
      /**
       * If is directed graph
       * @return {boolean}
       */

      graphProto.isDirected = function () {
        return this._directed;
      };
      /**
       * Add a new node
       * @param {string} id
       * @param {number} [dataIndex]
       */


      graphProto.addNode = function (id, dataIndex) {
        id = id == null ? '' + dataIndex : '' + id;
        var nodesMap = this._nodesMap;

        if (nodesMap[generateNodeKey(id)]) {
          return;
        }

        var node = new Node(id, dataIndex);
        node.hostGraph = this;
        this.nodes.push(node);
        nodesMap[generateNodeKey(id)] = node;
        return node;
      };
      /**
       * Get node by data index
       * @param  {number} dataIndex
       * @return {module:echarts/data/Graph~Node}
       */


      graphProto.getNodeByIndex = function (dataIndex) {
        var rawIdx = this.data.getRawIndex(dataIndex);
        return this.nodes[rawIdx];
      };
      /**
       * Get node by id
       * @param  {string} id
       * @return {module:echarts/data/Graph.Node}
       */


      graphProto.getNodeById = function (id) {
        return this._nodesMap[generateNodeKey(id)];
      };
      /**
       * Add a new edge
       * @param {number|string|module:echarts/data/Graph.Node} n1
       * @param {number|string|module:echarts/data/Graph.Node} n2
       * @param {number} [dataIndex=-1]
       * @return {module:echarts/data/Graph.Edge}
       */


      graphProto.addEdge = function (n1, n2, dataIndex) {
        var nodesMap = this._nodesMap;
        var edgesMap = this._edgesMap; // PNEDING

        if (typeof n1 === 'number') {
          n1 = this.nodes[n1];
        }

        if (typeof n2 === 'number') {
          n2 = this.nodes[n2];
        }

        if (!Node.isInstance(n1)) {
          n1 = nodesMap[generateNodeKey(n1)];
        }

        if (!Node.isInstance(n2)) {
          n2 = nodesMap[generateNodeKey(n2)];
        }

        if (!n1 || !n2) {
          return;
        }

        var key = n1.id + '-' + n2.id;
        var edge = new Edge(n1, n2, dataIndex);
        edge.hostGraph = this;

        if (this._directed) {
          n1.outEdges.push(edge);
          n2.inEdges.push(edge);
        }

        n1.edges.push(edge);

        if (n1 !== n2) {
          n2.edges.push(edge);
        }

        this.edges.push(edge);
        edgesMap[key] = edge;
        return edge;
      };
      /**
       * Get edge by data index
       * @param  {number} dataIndex
       * @return {module:echarts/data/Graph~Node}
       */


      graphProto.getEdgeByIndex = function (dataIndex) {
        var rawIdx = this.edgeData.getRawIndex(dataIndex);
        return this.edges[rawIdx];
      };
      /**
       * Get edge by two linked nodes
       * @param  {module:echarts/data/Graph.Node|string} n1
       * @param  {module:echarts/data/Graph.Node|string} n2
       * @return {module:echarts/data/Graph.Edge}
       */


      graphProto.getEdge = function (n1, n2) {
        if (Node.isInstance(n1)) {
          n1 = n1.id;
        }

        if (Node.isInstance(n2)) {
          n2 = n2.id;
        }

        var edgesMap = this._edgesMap;

        if (this._directed) {
          return edgesMap[n1 + '-' + n2];
        } else {
          return edgesMap[n1 + '-' + n2] || edgesMap[n2 + '-' + n1];
        }
      };
      /**
       * Iterate all nodes
       * @param  {Function} cb
       * @param  {*} [context]
       */


      graphProto.eachNode = function (cb, context) {
        var nodes = this.nodes;
        var len = nodes.length;

        for (var i = 0; i < len; i++) {
          if (nodes[i].dataIndex >= 0) {
            cb.call(context, nodes[i], i);
          }
        }
      };
      /**
       * Iterate all edges
       * @param  {Function} cb
       * @param  {*} [context]
       */


      graphProto.eachEdge = function (cb, context) {
        var edges = this.edges;
        var len = edges.length;

        for (var i = 0; i < len; i++) {
          if (edges[i].dataIndex >= 0 && edges[i].node1.dataIndex >= 0 && edges[i].node2.dataIndex >= 0) {
            cb.call(context, edges[i], i);
          }
        }
      };
      /**
       * Breadth first traverse
       * @param {Function} cb
       * @param {module:echarts/data/Graph.Node} startNode
       * @param {string} [direction='none'] 'none'|'in'|'out'
       * @param {*} [context]
       */


      graphProto.breadthFirstTraverse = function (cb, startNode, direction, context) {
        if (!Node.isInstance(startNode)) {
          startNode = this._nodesMap[generateNodeKey(startNode)];
        }

        if (!startNode) {
          return;
        }

        var edgeType = direction === 'out' ? 'outEdges' : direction === 'in' ? 'inEdges' : 'edges';

        for (var i = 0; i < this.nodes.length; i++) {
          this.nodes[i].__visited = false;
        }

        if (cb.call(context, startNode, null)) {
          return;
        }

        var queue = [startNode];

        while (queue.length) {
          var currentNode = queue.shift();
          var edges = currentNode[edgeType];

          for (var i = 0; i < edges.length; i++) {
            var e = edges[i];
            var otherNode = e.node1 === currentNode ? e.node2 : e.node1;

            if (!otherNode.__visited) {
              if (cb.call(context, otherNode, currentNode)) {
                // Stop traversing
                return;
              }

              queue.push(otherNode);
              otherNode.__visited = true;
            }
          }
        }
      }; // TODO
      // graphProto.depthFirstTraverse = function (
      //     cb, startNode, direction, context
      // ) {
      // };
      // Filter update


      graphProto.update = function () {
        var data = this.data;
        var edgeData = this.edgeData;
        var nodes = this.nodes;
        var edges = this.edges;

        for (var i = 0, len = nodes.length; i < len; i++) {
          nodes[i].dataIndex = -1;
        }

        for (var i = 0, len = data.count(); i < len; i++) {
          nodes[data.getRawIndex(i)].dataIndex = i;
        }

        edgeData.filterSelf(function (idx) {
          var edge = edges[edgeData.getRawIndex(idx)];
          return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;
        }); // Update edge

        for (var i = 0, len = edges.length; i < len; i++) {
          edges[i].dataIndex = -1;
        }

        for (var i = 0, len = edgeData.count(); i < len; i++) {
          edges[edgeData.getRawIndex(i)].dataIndex = i;
        }
      };
      /**
       * @return {module:echarts/data/Graph}
       */


      graphProto.clone = function () {
        var graph = new Graph(this._directed);
        var nodes = this.nodes;
        var edges = this.edges;

        for (var i = 0; i < nodes.length; i++) {
          graph.addNode(nodes[i].id, nodes[i].dataIndex);
        }

        for (var i = 0; i < edges.length; i++) {
          var e = edges[i];
          graph.addEdge(e.node1.id, e.node2.id, e.dataIndex);
        }

        return graph;
      };
      /**
       * @alias module:echarts/data/Graph.Node
       */


      function Node(id, dataIndex) {
        /**
        * @type {string}
        */
        this.id = id == null ? '' : id;
        /**
        * @type {Array.<module:echarts/data/Graph.Edge>}
        */

        this.inEdges = [];
        /**
        * @type {Array.<module:echarts/data/Graph.Edge>}
        */

        this.outEdges = [];
        /**
        * @type {Array.<module:echarts/data/Graph.Edge>}
        */

        this.edges = [];
        /**
         * @type {module:echarts/data/Graph}
         */

        this.hostGraph;
        /**
         * @type {number}
         */

        this.dataIndex = dataIndex == null ? -1 : dataIndex;
      }

      Node.prototype = {
        constructor: Node,

        /**
         * @return {number}
         */
        degree: function degree() {
          return this.edges.length;
        },

        /**
         * @return {number}
         */
        inDegree: function inDegree() {
          return this.inEdges.length;
        },

        /**
        * @return {number}
        */
        outDegree: function outDegree() {
          return this.outEdges.length;
        },

        /**
         * @param {string} [path]
         * @return {module:echarts/model/Model}
         */
        getModel: function getModel(path) {
          if (this.dataIndex < 0) {
            return;
          }

          var graph = this.hostGraph;
          var itemModel = graph.data.getItemModel(this.dataIndex);
          return itemModel.getModel(path);
        }
      };
      /**
       * 
       * @alias module:echarts/data/Graph.Edge
       * @param {module:echarts/data/Graph.Node} n1
       * @param {module:echarts/data/Graph.Node} n2
       * @param {number} [dataIndex=-1]
       */

      function Edge(n1, n2, dataIndex) {
        /**
         * 1
         * @type {module:echarts/data/Graph.Node}
         */
        this.node1 = n1;
        /**
         * 2
         * @type {module:echarts/data/Graph.Node}
         */

        this.node2 = n2;
        this.dataIndex = dataIndex == null ? -1 : dataIndex;
      }
      /**
       * @param {string} [path]
       * @return {module:echarts/model/Model}
       */


      Edge.prototype.getModel = function (path) {
        if (this.dataIndex < 0) {
          return;
        }

        var graph = this.hostGraph;
        var itemModel = graph.edgeData.getItemModel(this.dataIndex);
        return itemModel.getModel(path);
      };

      var createGraphDataProxyMixin = function createGraphDataProxyMixin(hostName, dataName) {
        return {
          /**
           * @param {string=} [dimension='value'] Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
           * @return {number}
           */
          getValue: function getValue(dimension) {
            var data = this[hostName][dataName];
            return data.get(data.getDimension(dimension || 'value'), this.dataIndex);
          },

          /**
           * @param {Object|string} key
           * @param {*} [value]
           */
          setVisual: function setVisual(key, value) {
            this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key, value);
          },

          /**
           * @param {string} key
           * @return {boolean}
           */
          getVisual: function getVisual(key, ignoreParent) {
            return this[hostName][dataName].getItemVisual(this.dataIndex, key, ignoreParent);
          },

          /**
           * @param {Object} layout
           * @return {boolean} [merge=false]
           */
          setLayout: function setLayout(layout, merge) {
            this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout, merge);
          },

          /**
           * @return {Object}
           */
          getLayout: function getLayout() {
            return this[hostName][dataName].getItemLayout(this.dataIndex);
          },

          /**
           * @return {module:zrender/Element}
           */
          getGraphicEl: function getGraphicEl() {
            return this[hostName][dataName].getItemGraphicEl(this.dataIndex);
          },

          /**
           * @return {number}
           */
          getRawIndex: function getRawIndex() {
            return this[hostName][dataName].getRawIndex(this.dataIndex);
          }
        };
      };

      zrUtil.mixin(Node, createGraphDataProxyMixin('hostGraph', 'data'));
      zrUtil.mixin(Edge, createGraphDataProxyMixin('hostGraph', 'edgeData'));
      Graph.Node = Node;
      Graph.Edge = Edge;
      enableClassCheck(Node);
      enableClassCheck(Edge);
      var _default = Graph;
      module.exports = _default;
      /***/
    },

    /***/
    "c8qY":
    /*!***********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/helper/LineDraw.js ***!
      \***********************************************************/

    /*! no static exports found */

    /***/
    function c8qY(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var LineGroup = __webpack_require__(
      /*! ./Line */
      "fls0");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @module echarts/chart/helper/LineDraw
       */
      // import IncrementalDisplayable from 'zrender/src/graphic/IncrementalDisplayable';

      /**
       * @alias module:echarts/component/marker/LineDraw
       * @constructor
       */


      function LineDraw(ctor) {
        this._ctor = ctor || LineGroup;
        this.group = new graphic.Group();
      }

      var lineDrawProto = LineDraw.prototype;

      lineDrawProto.isPersistent = function () {
        return true;
      };
      /**
       * @param {module:echarts/data/List} lineData
       */


      lineDrawProto.updateData = function (lineData) {
        var lineDraw = this;
        var group = lineDraw.group;
        var oldLineData = lineDraw._lineData;
        lineDraw._lineData = lineData; // There is no oldLineData only when first rendering or switching from
        // stream mode to normal mode, where previous elements should be removed.

        if (!oldLineData) {
          group.removeAll();
        }

        var seriesScope = makeSeriesScope(lineData);
        lineData.diff(oldLineData).add(function (idx) {
          doAdd(lineDraw, lineData, idx, seriesScope);
        }).update(function (newIdx, oldIdx) {
          doUpdate(lineDraw, oldLineData, lineData, oldIdx, newIdx, seriesScope);
        }).remove(function (idx) {
          group.remove(oldLineData.getItemGraphicEl(idx));
        }).execute();
      };

      function doAdd(lineDraw, lineData, idx, seriesScope) {
        var itemLayout = lineData.getItemLayout(idx);

        if (!lineNeedsDraw(itemLayout)) {
          return;
        }

        var el = new lineDraw._ctor(lineData, idx, seriesScope);
        lineData.setItemGraphicEl(idx, el);
        lineDraw.group.add(el);
      }

      function doUpdate(lineDraw, oldLineData, newLineData, oldIdx, newIdx, seriesScope) {
        var itemEl = oldLineData.getItemGraphicEl(oldIdx);

        if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) {
          lineDraw.group.remove(itemEl);
          return;
        }

        if (!itemEl) {
          itemEl = new lineDraw._ctor(newLineData, newIdx, seriesScope);
        } else {
          itemEl.updateData(newLineData, newIdx, seriesScope);
        }

        newLineData.setItemGraphicEl(newIdx, itemEl);
        lineDraw.group.add(itemEl);
      }

      lineDrawProto.updateLayout = function () {
        var lineData = this._lineData; // Do not support update layout in incremental mode.

        if (!lineData) {
          return;
        }

        lineData.eachItemGraphicEl(function (el, idx) {
          el.updateLayout(lineData, idx);
        }, this);
      };

      lineDrawProto.incrementalPrepareUpdate = function (lineData) {
        this._seriesScope = makeSeriesScope(lineData);
        this._lineData = null;
        this.group.removeAll();
      };

      function isEffectObject(el) {
        return el.animators && el.animators.length > 0;
      }

      lineDrawProto.incrementalUpdate = function (taskParams, lineData) {
        function updateIncrementalAndHover(el) {
          if (!el.isGroup && !isEffectObject(el)) {
            el.incremental = el.useHoverLayer = true;
          }
        }

        for (var idx = taskParams.start; idx < taskParams.end; idx++) {
          var itemLayout = lineData.getItemLayout(idx);

          if (lineNeedsDraw(itemLayout)) {
            var el = new this._ctor(lineData, idx, this._seriesScope);
            el.traverse(updateIncrementalAndHover);
            this.group.add(el);
            lineData.setItemGraphicEl(idx, el);
          }
        }
      };

      function makeSeriesScope(lineData) {
        var hostModel = lineData.hostModel;
        return {
          lineStyle: hostModel.getModel('lineStyle').getLineStyle(),
          hoverLineStyle: hostModel.getModel('emphasis.lineStyle').getLineStyle(),
          labelModel: hostModel.getModel('label'),
          hoverLabelModel: hostModel.getModel('emphasis.label')
        };
      }

      lineDrawProto.remove = function () {
        this._clearIncremental();

        this._incremental = null;
        this.group.removeAll();
      };

      lineDrawProto._clearIncremental = function () {
        var incremental = this._incremental;

        if (incremental) {
          incremental.clearDisplaybles();
        }
      };

      function isPointNaN(pt) {
        return isNaN(pt[0]) || isNaN(pt[1]);
      }

      function lineNeedsDraw(pts) {
        return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);
      }

      var _default = LineDraw;
      module.exports = _default;
      /***/
    },

    /***/
    "cCMj":
    /*!**********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/helper/selectableMixin.js ***!
      \**********************************************************************/

    /*! no static exports found */

    /***/
    function cCMj(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Data selectable mixin for chart series.
       * To eanble data select, option of series must have `selectedMode`.
       * And each data item will use `selected` to toggle itself selected status
       */


      var _default = {
        /**
         * @param {Array.<Object>} targetList [{name, value, selected}, ...]
         *        If targetList is an array, it should like [{name: ..., value: ...}, ...].
         *        If targetList is a "List", it must have coordDim: 'value' dimension and name.
         */
        updateSelectedMap: function updateSelectedMap(targetList) {
          this._targetList = zrUtil.isArray(targetList) ? targetList.slice() : [];
          this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {
            targetMap.set(target.name, target);
            return targetMap;
          }, zrUtil.createHashMap());
        },

        /**
         * Either name or id should be passed as input here.
         * If both of them are defined, id is used.
         *
         * @param {string|undefined} name name of data
         * @param {number|undefined} id dataIndex of data
         */
        // PENGING If selectedMode is null ?
        select: function select(name, id) {
          var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);
          var selectedMode = this.get('selectedMode');

          if (selectedMode === 'single') {
            this._selectTargetMap.each(function (target) {
              target.selected = false;
            });
          }

          target && (target.selected = true);
        },

        /**
         * Either name or id should be passed as input here.
         * If both of them are defined, id is used.
         *
         * @param {string|undefined} name name of data
         * @param {number|undefined} id dataIndex of data
         */
        unSelect: function unSelect(name, id) {
          var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name); // var selectedMode = this.get('selectedMode');
          // selectedMode !== 'single' && target && (target.selected = false);

          target && (target.selected = false);
        },

        /**
         * Either name or id should be passed as input here.
         * If both of them are defined, id is used.
         *
         * @param {string|undefined} name name of data
         * @param {number|undefined} id dataIndex of data
         */
        toggleSelected: function toggleSelected(name, id) {
          var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);

          if (target != null) {
            this[target.selected ? 'unSelect' : 'select'](name, id);
            return target.selected;
          }
        },

        /**
         * Either name or id should be passed as input here.
         * If both of them are defined, id is used.
         *
         * @param {string|undefined} name name of data
         * @param {number|undefined} id dataIndex of data
         */
        isSelected: function isSelected(name, id) {
          var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);
          return target && target.selected;
        }
      };
      module.exports = _default;
      /***/
    },

    /***/
    "ca2m":
    /*!*******************************************************!*\
      !*** ./node_modules/echarts/lib/coord/axisDefault.js ***!
      \*******************************************************/

    /*! no static exports found */

    /***/
    function ca2m(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var defaultOption = {
        show: true,
        zlevel: 0,
        z: 0,
        // Inverse the axis.
        inverse: false,
        // Axis name displayed.
        name: '',
        // 'start' | 'middle' | 'end'
        nameLocation: 'end',
        // By degree. By default auto rotate by nameLocation.
        nameRotate: null,
        nameTruncate: {
          maxWidth: null,
          ellipsis: '...',
          placeholder: '.'
        },
        // Use global text style by default.
        nameTextStyle: {},
        // The gap between axisName and axisLine.
        nameGap: 15,
        // Default `false` to support tooltip.
        silent: false,
        // Default `false` to avoid legacy user event listener fail.
        triggerEvent: false,
        tooltip: {
          show: false
        },
        axisPointer: {},
        axisLine: {
          show: true,
          onZero: true,
          onZeroAxisIndex: null,
          lineStyle: {
            color: '#333',
            width: 1,
            type: 'solid'
          },
          // The arrow at both ends the the axis.
          symbol: ['none', 'none'],
          symbolSize: [10, 15]
        },
        axisTick: {
          show: true,
          // Whether axisTick is inside the grid or outside the grid.
          inside: false,
          // The length of axisTick.
          length: 5,
          lineStyle: {
            width: 1
          }
        },
        axisLabel: {
          show: true,
          // Whether axisLabel is inside the grid or outside the grid.
          inside: false,
          rotate: 0,
          // true | false | null/undefined (auto)
          showMinLabel: null,
          // true | false | null/undefined (auto)
          showMaxLabel: null,
          margin: 8,
          // formatter: null,
          fontSize: 12
        },
        splitLine: {
          show: true,
          lineStyle: {
            color: ['#ccc'],
            width: 1,
            type: 'solid'
          }
        },
        splitArea: {
          show: false,
          areaStyle: {
            color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']
          }
        }
      };
      var axisDefault = {};
      axisDefault.categoryAxis = zrUtil.merge({
        // The gap at both ends of the axis. For categoryAxis, boolean.
        boundaryGap: true,
        // Set false to faster category collection.
        // Only usefull in the case like: category is
        // ['2012-01-01', '2012-01-02', ...], where the input
        // data has been ensured not duplicate and is large data.
        // null means "auto":
        // if axis.data provided, do not deduplication,
        // else do deduplication.
        deduplication: null,
        // splitArea: {
        // show: false
        // },
        splitLine: {
          show: false
        },
        axisTick: {
          // If tick is align with label when boundaryGap is true
          alignWithLabel: false,
          interval: 'auto'
        },
        axisLabel: {
          interval: 'auto'
        }
      }, defaultOption);
      axisDefault.valueAxis = zrUtil.merge({
        // The gap at both ends of the axis. For value axis, [GAP, GAP], where
        // `GAP` can be an absolute pixel number (like `35`), or percent (like `'30%'`)
        boundaryGap: [0, 0],
        // TODO
        // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
        // Min value of the axis. can be:
        // + a number
        // + 'dataMin': use the min value in data.
        // + null/undefined: auto decide min value (consider pretty look and boundaryGap).
        // min: null,
        // Max value of the axis. can be:
        // + a number
        // + 'dataMax': use the max value in data.
        // + null/undefined: auto decide max value (consider pretty look and boundaryGap).
        // max: null,
        // Readonly prop, specifies start value of the range when using data zoom.
        // rangeStart: null
        // Readonly prop, specifies end value of the range when using data zoom.
        // rangeEnd: null
        // Optional value can be:
        // + `false`: always include value 0.
        // + `true`: the extent do not consider value 0.
        // scale: false,
        // AxisTick and axisLabel and splitLine are caculated based on splitNumber.
        splitNumber: 5,
        // Interval specifies the span of the ticks is mandatorily.
        // interval: null
        // Specify min interval when auto calculate tick interval.
        // minInterval: null
        // Specify max interval when auto calculate tick interval.
        // maxInterval: null
        minorTick: {
          // Minor tick, not available for cateogry axis.
          show: false,
          // Split number of minor ticks. The value should be in range of (0, 100)
          splitNumber: 5,
          // Lenght of minor tick
          length: 3,
          // Same inside with axisTick
          // Line style
          lineStyle: {// Default to be same with axisTick
          }
        },
        minorSplitLine: {
          show: false,
          lineStyle: {
            color: '#eee',
            width: 1
          }
        }
      }, defaultOption);
      axisDefault.timeAxis = zrUtil.defaults({
        scale: true,
        min: 'dataMin',
        max: 'dataMax'
      }, axisDefault.valueAxis);
      axisDefault.logAxis = zrUtil.defaults({
        scale: true,
        logBase: 10
      }, axisDefault.valueAxis);
      var _default = axisDefault;
      module.exports = _default;
      /***/
    },

    /***/
    "cbJ4":
    /*!***********************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/themeRiver/themeRiverVisual.js ***!
      \***********************************************************************/

    /*! no static exports found */

    /***/
    function cbJ4(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _util = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var createHashMap = _util.createHashMap;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      function _default(ecModel) {
        ecModel.eachSeriesByType('themeRiver', function (seriesModel) {
          var data = seriesModel.getData();
          var rawData = seriesModel.getRawData();
          var colorList = seriesModel.get('color');
          var idxMap = createHashMap();
          data.each(function (idx) {
            idxMap.set(data.getRawIndex(idx), idx);
          });
          rawData.each(function (rawIndex) {
            var name = rawData.getName(rawIndex);
            var color = colorList[(seriesModel.nameMap.get(name) - 1) % colorList.length];
            rawData.setItemVisual(rawIndex, 'color', color);
            var idx = idxMap.get(rawIndex);

            if (idx != null) {
              data.setItemVisual(idx, 'color', color);
            }
          });
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "cpOr":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/lines/LinesSeries.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function cpOr(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var SeriesModel = __webpack_require__(
      /*! ../../model/Series */
      "T4UG");

      var List = __webpack_require__(
      /*! ../../data/List */
      "YXkt");

      var _util = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var concatArray = _util.concatArray;
      var mergeAll = _util.mergeAll;
      var map = _util.map;

      var _format = __webpack_require__(
      /*! ../../util/format */
      "7aKB");

      var encodeHTML = _format.encodeHTML;

      var CoordinateSystem = __webpack_require__(
      /*! ../../CoordinateSystem */
      "IDmD");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /* global Uint32Array, Float64Array, Float32Array */


      var Uint32Arr = typeof Uint32Array === 'undefined' ? Array : Uint32Array;
      var Float64Arr = typeof Float64Array === 'undefined' ? Array : Float64Array;

      function compatEc2(seriesOpt) {
        var data = seriesOpt.data;

        if (data && data[0] && data[0][0] && data[0][0].coord) {
          seriesOpt.data = map(data, function (itemOpt) {
            var coords = [itemOpt[0].coord, itemOpt[1].coord];
            var target = {
              coords: coords
            };

            if (itemOpt[0].name) {
              target.fromName = itemOpt[0].name;
            }

            if (itemOpt[1].name) {
              target.toName = itemOpt[1].name;
            }

            return mergeAll([target, itemOpt[0], itemOpt[1]]);
          });
        }
      }

      var LinesSeries = SeriesModel.extend({
        type: 'series.lines',
        dependencies: ['grid', 'polar'],
        visualColorAccessPath: 'lineStyle.color',
        init: function init(option) {
          // The input data may be null/undefined.
          option.data = option.data || []; // Not using preprocessor because mergeOption may not have series.type

          compatEc2(option);

          var result = this._processFlatCoordsArray(option.data);

          this._flatCoords = result.flatCoords;
          this._flatCoordsOffset = result.flatCoordsOffset;

          if (result.flatCoords) {
            option.data = new Float32Array(result.count);
          }

          LinesSeries.superApply(this, 'init', arguments);
        },
        mergeOption: function mergeOption(option) {
          compatEc2(option);

          if (option.data) {
            // Only update when have option data to merge.
            var result = this._processFlatCoordsArray(option.data);

            this._flatCoords = result.flatCoords;
            this._flatCoordsOffset = result.flatCoordsOffset;

            if (result.flatCoords) {
              option.data = new Float32Array(result.count);
            }
          }

          LinesSeries.superApply(this, 'mergeOption', arguments);
        },
        appendData: function appendData(params) {
          var result = this._processFlatCoordsArray(params.data);

          if (result.flatCoords) {
            if (!this._flatCoords) {
              this._flatCoords = result.flatCoords;
              this._flatCoordsOffset = result.flatCoordsOffset;
            } else {
              this._flatCoords = concatArray(this._flatCoords, result.flatCoords);
              this._flatCoordsOffset = concatArray(this._flatCoordsOffset, result.flatCoordsOffset);
            }

            params.data = new Float32Array(result.count);
          }

          this.getRawData().appendData(params.data);
        },
        _getCoordsFromItemModel: function _getCoordsFromItemModel(idx) {
          var itemModel = this.getData().getItemModel(idx);
          var coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow('coords');
          return coords;
        },
        getLineCoordsCount: function getLineCoordsCount(idx) {
          if (this._flatCoordsOffset) {
            return this._flatCoordsOffset[idx * 2 + 1];
          } else {
            return this._getCoordsFromItemModel(idx).length;
          }
        },
        getLineCoords: function getLineCoords(idx, out) {
          if (this._flatCoordsOffset) {
            var offset = this._flatCoordsOffset[idx * 2];
            var len = this._flatCoordsOffset[idx * 2 + 1];

            for (var i = 0; i < len; i++) {
              out[i] = out[i] || [];
              out[i][0] = this._flatCoords[offset + i * 2];
              out[i][1] = this._flatCoords[offset + i * 2 + 1];
            }

            return len;
          } else {
            var coords = this._getCoordsFromItemModel(idx);

            for (var i = 0; i < coords.length; i++) {
              out[i] = out[i] || [];
              out[i][0] = coords[i][0];
              out[i][1] = coords[i][1];
            }

            return coords.length;
          }
        },
        _processFlatCoordsArray: function _processFlatCoordsArray(data) {
          var startOffset = 0;

          if (this._flatCoords) {
            startOffset = this._flatCoords.length;
          } // Stored as a typed array. In format
          // Points Count(2) | x | y | x | y | Points Count(3) | x |  y | x | y | x | y |


          if (typeof data[0] === 'number') {
            var len = data.length; // Store offset and len of each segment

            var coordsOffsetAndLenStorage = new Uint32Arr(len);
            var coordsStorage = new Float64Arr(len);
            var coordsCursor = 0;
            var offsetCursor = 0;
            var dataCount = 0;

            for (var i = 0; i < len;) {
              dataCount++;
              var count = data[i++]; // Offset

              coordsOffsetAndLenStorage[offsetCursor++] = coordsCursor + startOffset; // Len

              coordsOffsetAndLenStorage[offsetCursor++] = count;

              for (var k = 0; k < count; k++) {
                var x = data[i++];
                var y = data[i++];
                coordsStorage[coordsCursor++] = x;
                coordsStorage[coordsCursor++] = y;

                if (i > len) {}
              }
            }

            return {
              flatCoordsOffset: new Uint32Array(coordsOffsetAndLenStorage.buffer, 0, offsetCursor),
              flatCoords: coordsStorage,
              count: dataCount
            };
          }

          return {
            flatCoordsOffset: null,
            flatCoords: null,
            count: data.length
          };
        },
        getInitialData: function getInitialData(option, ecModel) {
          var lineData = new List(['value'], this);
          lineData.hasItemOption = false;
          lineData.initData(option.data, [], function (dataItem, dimName, dataIndex, dimIndex) {
            // dataItem is simply coords
            if (dataItem instanceof Array) {
              return NaN;
            } else {
              lineData.hasItemOption = true;
              var value = dataItem.value;

              if (value != null) {
                return value instanceof Array ? value[dimIndex] : value;
              }
            }
          });
          return lineData;
        },
        formatTooltip: function formatTooltip(dataIndex) {
          var data = this.getData();
          var itemModel = data.getItemModel(dataIndex);
          var name = itemModel.get('name');

          if (name) {
            return name;
          }

          var fromName = itemModel.get('fromName');
          var toName = itemModel.get('toName');
          var html = [];
          fromName != null && html.push(fromName);
          toName != null && html.push(toName);
          return encodeHTML(html.join(' > '));
        },
        preventIncremental: function preventIncremental() {
          return !!this.get('effect.show');
        },
        getProgressive: function getProgressive() {
          var progressive = this.option.progressive;

          if (progressive == null) {
            return this.option.large ? 1e4 : this.get('progressive');
          }

          return progressive;
        },
        getProgressiveThreshold: function getProgressiveThreshold() {
          var progressiveThreshold = this.option.progressiveThreshold;

          if (progressiveThreshold == null) {
            return this.option.large ? 2e4 : this.get('progressiveThreshold');
          }

          return progressiveThreshold;
        },
        defaultOption: {
          coordinateSystem: 'geo',
          zlevel: 0,
          z: 2,
          legendHoverLink: true,
          hoverAnimation: true,
          // Cartesian coordinate system
          xAxisIndex: 0,
          yAxisIndex: 0,
          symbol: ['none', 'none'],
          symbolSize: [10, 10],
          // Geo coordinate system
          geoIndex: 0,
          effect: {
            show: false,
            period: 4,
            // Animation delay. support callback
            // delay: 0,
            // If move with constant speed px/sec
            // period will be ignored if this property is > 0,
            constantSpeed: 0,
            symbol: 'circle',
            symbolSize: 3,
            loop: true,
            // Length of trail, 0 - 1
            trailLength: 0.2 // Same with lineStyle.color
            // color

          },
          large: false,
          // Available when large is true
          largeThreshold: 2000,
          // If lines are polyline
          // polyline not support curveness, label, animation
          polyline: false,
          // If clip the overflow.
          // Available when coordinateSystem is cartesian or polar.
          clip: true,
          label: {
            show: false,
            position: 'end' // distance: 5,
            // formatter: Tooltip.formatter

          },
          lineStyle: {
            opacity: 0.5
          }
        }
      });
      var _default = LinesSeries;
      module.exports = _default;
      /***/
    },

    /***/
    "crZl":
    /*!***********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/visualMap/VisualMapView.js ***!
      \***********************************************************************/

    /*! no static exports found */

    /***/
    function crZl(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var formatUtil = __webpack_require__(
      /*! ../../util/format */
      "7aKB");

      var layout = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var VisualMapping = __webpack_require__(
      /*! ../../visual/VisualMapping */
      "XxSj");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = echarts.extendComponentView({
        type: 'visualMap',

        /**
         * @readOnly
         * @type {Object}
         */
        autoPositionValues: {
          left: 1,
          right: 1,
          top: 1,
          bottom: 1
        },
        init: function init(ecModel, api) {
          /**
           * @readOnly
           * @type {module:echarts/model/Global}
           */
          this.ecModel = ecModel;
          /**
           * @readOnly
           * @type {module:echarts/ExtensionAPI}
           */

          this.api = api;
          /**
           * @readOnly
           * @type {module:echarts/component/visualMap/visualMapModel}
           */

          this.visualMapModel;
        },

        /**
         * @protected
         */
        render: function render(visualMapModel, ecModel, api, payload) {
          this.visualMapModel = visualMapModel;

          if (visualMapModel.get('show') === false) {
            this.group.removeAll();
            return;
          }

          this.doRender.apply(this, arguments);
        },

        /**
         * @protected
         */
        renderBackground: function renderBackground(group) {
          var visualMapModel = this.visualMapModel;
          var padding = formatUtil.normalizeCssArray(visualMapModel.get('padding') || 0);
          var rect = group.getBoundingRect();
          group.add(new graphic.Rect({
            z2: -1,
            // Lay background rect on the lowest layer.
            silent: true,
            shape: {
              x: rect.x - padding[3],
              y: rect.y - padding[0],
              width: rect.width + padding[3] + padding[1],
              height: rect.height + padding[0] + padding[2]
            },
            style: {
              fill: visualMapModel.get('backgroundColor'),
              stroke: visualMapModel.get('borderColor'),
              lineWidth: visualMapModel.get('borderWidth')
            }
          }));
        },

        /**
         * @protected
         * @param {number} targetValue can be Infinity or -Infinity
         * @param {string=} visualCluster Only can be 'color' 'opacity' 'symbol' 'symbolSize'
         * @param {Object} [opts]
         * @param {string=} [opts.forceState] Specify state, instead of using getValueState method.
         * @param {string=} [opts.convertOpacityToAlpha=false] For color gradient in controller widget.
         * @return {*} Visual value.
         */
        getControllerVisual: function getControllerVisual(targetValue, visualCluster, opts) {
          opts = opts || {};
          var forceState = opts.forceState;
          var visualMapModel = this.visualMapModel;
          var visualObj = {}; // Default values.

          if (visualCluster === 'symbol') {
            visualObj.symbol = visualMapModel.get('itemSymbol');
          }

          if (visualCluster === 'color') {
            var defaultColor = visualMapModel.get('contentColor');
            visualObj.color = defaultColor;
          }

          function getter(key) {
            return visualObj[key];
          }

          function setter(key, value) {
            visualObj[key] = value;
          }

          var mappings = visualMapModel.controllerVisuals[forceState || visualMapModel.getValueState(targetValue)];
          var visualTypes = VisualMapping.prepareVisualTypes(mappings);
          zrUtil.each(visualTypes, function (type) {
            var visualMapping = mappings[type];

            if (opts.convertOpacityToAlpha && type === 'opacity') {
              type = 'colorAlpha';
              visualMapping = mappings.__alphaForOpacity;
            }

            if (VisualMapping.dependsOn(type, visualCluster)) {
              visualMapping && visualMapping.applyVisual(targetValue, getter, setter);
            }
          });
          return visualObj[visualCluster];
        },

        /**
         * @protected
         */
        positionGroup: function positionGroup(group) {
          var model = this.visualMapModel;
          var api = this.api;
          layout.positionElement(group, model.getBoxLayoutParams(), {
            width: api.getWidth(),
            height: api.getHeight()
          });
        },

        /**
         * @protected
         * @abstract
         */
        doRender: zrUtil.noop
      });

      module.exports = _default;
      /***/
    },

    /***/
    "d4KN":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/action/createDataSelectAction.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function d4KN(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function _default(seriesType, actionInfos) {
        zrUtil.each(actionInfos, function (actionInfo) {
          actionInfo.update = 'updateView';
          /**
           * @payload
           * @property {string} seriesName
           * @property {string} name
           */

          echarts.registerAction(actionInfo, function (payload, ecModel) {
            var selected = {};
            ecModel.eachComponent({
              mainType: 'series',
              subType: seriesType,
              query: payload
            }, function (seriesModel) {
              if (seriesModel[actionInfo.method]) {
                seriesModel[actionInfo.method](payload.name, payload.dataIndex);
              }

              var data = seriesModel.getData(); // Create selected map

              data.each(function (idx) {
                var name = data.getName(idx);
                selected[name] = seriesModel.isSelected(name) || false;
              });
            });
            return {
              name: payload.name,
              selected: selected,
              seriesId: payload.seriesId
            };
          });
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "dBmv":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/component/visualMapContinuous.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function dBmv(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      var preprocessor = __webpack_require__(
      /*! ./visualMap/preprocessor */
      "szbU");

      __webpack_require__(
      /*! ./visualMap/typeDefaulter */
      "vF/C");

      __webpack_require__(
      /*! ./visualMap/visualEncoding */
      "qwVE");

      __webpack_require__(
      /*! ./visualMap/ContinuousModel */
      "MHoB");

      __webpack_require__(
      /*! ./visualMap/ContinuousView */
      "PNag");

      __webpack_require__(
      /*! ./visualMap/visualMapAction */
      "1u/T");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * DataZoom component entry
       */


      echarts.registerPreprocessor(preprocessor);
      /***/
    },

    /***/
    "dmGj":
    /*!***********************************************************!*\
      !*** ./node_modules/echarts/lib/component/geo/GeoView.js ***!
      \***********************************************************/

    /*! no static exports found */

    /***/
    function dmGj(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var MapDraw = __webpack_require__(
      /*! ../helper/MapDraw */
      "DEFe");

      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = echarts.extendComponentView({
        type: 'geo',
        init: function init(ecModel, api) {
          var mapDraw = new MapDraw(api, true);
          this._mapDraw = mapDraw;
          this.group.add(mapDraw.group);
        },
        render: function render(geoModel, ecModel, api, payload) {
          // Not render if it is an toggleSelect action from self
          if (payload && payload.type === 'geoToggleSelect' && payload.from === this.uid) {
            return;
          }

          var mapDraw = this._mapDraw;

          if (geoModel.get('show')) {
            mapDraw.draw(geoModel, ecModel, api, this, payload);
          } else {
            this._mapDraw.group.removeAll();
          }

          this.group.silent = geoModel.get('silent');
        },
        dispose: function dispose() {
          this._mapDraw && this._mapDraw.remove();
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "dnwI":
    /*!************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/toolbox/feature/DataView.js ***!
      \************************************************************************/

    /*! no static exports found */

    /***/
    function dnwI(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var eventTool = __webpack_require__(
      /*! zrender/lib/core/event */
      "YH21");

      var lang = __webpack_require__(
      /*! ../../../lang */
      "Kagy");

      var featureManager = __webpack_require__(
      /*! ../featureManager */
      "IUWy");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var dataViewLang = lang.toolbox.dataView;
      var BLOCK_SPLITER = new Array(60).join('-');
      var ITEM_SPLITER = '\t';
      /**
       * Group series into two types
       *  1. on category axis, like line, bar
       *  2. others, like scatter, pie
       * @param {module:echarts/model/Global} ecModel
       * @return {Object}
       * @inner
       */

      function groupSeries(ecModel) {
        var seriesGroupByCategoryAxis = {};
        var otherSeries = [];
        var meta = [];
        ecModel.eachRawSeries(function (seriesModel) {
          var coordSys = seriesModel.coordinateSystem;

          if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {
            var baseAxis = coordSys.getBaseAxis();

            if (baseAxis.type === 'category') {
              var key = baseAxis.dim + '_' + baseAxis.index;

              if (!seriesGroupByCategoryAxis[key]) {
                seriesGroupByCategoryAxis[key] = {
                  categoryAxis: baseAxis,
                  valueAxis: coordSys.getOtherAxis(baseAxis),
                  series: []
                };
                meta.push({
                  axisDim: baseAxis.dim,
                  axisIndex: baseAxis.index
                });
              }

              seriesGroupByCategoryAxis[key].series.push(seriesModel);
            } else {
              otherSeries.push(seriesModel);
            }
          } else {
            otherSeries.push(seriesModel);
          }
        });
        return {
          seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,
          other: otherSeries,
          meta: meta
        };
      }
      /**
       * Assemble content of series on cateogory axis
       * @param {Array.<module:echarts/model/Series>} series
       * @return {string}
       * @inner
       */


      function assembleSeriesWithCategoryAxis(series) {
        var tables = [];
        zrUtil.each(series, function (group, key) {
          var categoryAxis = group.categoryAxis;
          var valueAxis = group.valueAxis;
          var valueAxisDim = valueAxis.dim;
          var headers = [' '].concat(zrUtil.map(group.series, function (series) {
            return series.name;
          }));
          var columns = [categoryAxis.model.getCategories()];
          zrUtil.each(group.series, function (series) {
            var rawData = series.getRawData();
            columns.push(series.getRawData().mapArray(rawData.mapDimension(valueAxisDim), function (val) {
              return val;
            }));
          }); // Assemble table content

          var lines = [headers.join(ITEM_SPLITER)];

          for (var i = 0; i < columns[0].length; i++) {
            var items = [];

            for (var j = 0; j < columns.length; j++) {
              items.push(columns[j][i]);
            }

            lines.push(items.join(ITEM_SPLITER));
          }

          tables.push(lines.join('\n'));
        });
        return tables.join('\n\n' + BLOCK_SPLITER + '\n\n');
      }
      /**
       * Assemble content of other series
       * @param {Array.<module:echarts/model/Series>} series
       * @return {string}
       * @inner
       */


      function assembleOtherSeries(series) {
        return zrUtil.map(series, function (series) {
          var data = series.getRawData();
          var lines = [series.name];
          var vals = [];
          data.each(data.dimensions, function () {
            var argLen = arguments.length;
            var dataIndex = arguments[argLen - 1];
            var name = data.getName(dataIndex);

            for (var i = 0; i < argLen - 1; i++) {
              vals[i] = arguments[i];
            }

            lines.push((name ? name + ITEM_SPLITER : '') + vals.join(ITEM_SPLITER));
          });
          return lines.join('\n');
        }).join('\n\n' + BLOCK_SPLITER + '\n\n');
      }
      /**
       * @param {module:echarts/model/Global}
       * @return {Object}
       * @inner
       */


      function getContentFromModel(ecModel) {
        var result = groupSeries(ecModel);
        return {
          value: zrUtil.filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function (str) {
            return str.replace(/[\n\t\s]/g, '');
          }).join('\n\n' + BLOCK_SPLITER + '\n\n'),
          meta: result.meta
        };
      }

      function trim(str) {
        return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
      }
      /**
       * If a block is tsv format
       */


      function isTSVFormat(block) {
        // Simple method to find out if a block is tsv format
        var firstLine = block.slice(0, block.indexOf('\n'));

        if (firstLine.indexOf(ITEM_SPLITER) >= 0) {
          return true;
        }
      }

      var itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');
      /**
       * @param {string} tsv
       * @return {Object}
       */

      function parseTSVContents(tsv) {
        var tsvLines = tsv.split(/\n+/g);
        var headers = trim(tsvLines.shift()).split(itemSplitRegex);
        var categories = [];
        var series = zrUtil.map(headers, function (header) {
          return {
            name: header,
            data: []
          };
        });

        for (var i = 0; i < tsvLines.length; i++) {
          var items = trim(tsvLines[i]).split(itemSplitRegex);
          categories.push(items.shift());

          for (var j = 0; j < items.length; j++) {
            series[j] && (series[j].data[i] = items[j]);
          }
        }

        return {
          series: series,
          categories: categories
        };
      }
      /**
       * @param {string} str
       * @return {Array.<Object>}
       * @inner
       */


      function parseListContents(str) {
        var lines = str.split(/\n+/g);
        var seriesName = trim(lines.shift());
        var data = [];

        for (var i = 0; i < lines.length; i++) {
          // if line is empty, ignore it.
          // there is a case that a user forgot to delete `\n`.
          var line = trim(lines[i]);

          if (!line) {
            continue;
          }

          var items = line.split(itemSplitRegex);
          var name = '';
          var value;
          var hasName = false;

          if (isNaN(items[0])) {
            // First item is name
            hasName = true;
            name = items[0];
            items = items.slice(1);
            data[i] = {
              name: name,
              value: []
            };
            value = data[i].value;
          } else {
            value = data[i] = [];
          }

          for (var j = 0; j < items.length; j++) {
            value.push(+items[j]);
          }

          if (value.length === 1) {
            hasName ? data[i].value = value[0] : data[i] = value[0];
          }
        }

        return {
          name: seriesName,
          data: data
        };
      }
      /**
       * @param {string} str
       * @param {Array.<Object>} blockMetaList
       * @return {Object}
       * @inner
       */


      function parseContents(str, blockMetaList) {
        var blocks = str.split(new RegExp('\n*' + BLOCK_SPLITER + '\n*', 'g'));
        var newOption = {
          series: []
        };
        zrUtil.each(blocks, function (block, idx) {
          if (isTSVFormat(block)) {
            var result = parseTSVContents(block);
            var blockMeta = blockMetaList[idx];
            var axisKey = blockMeta.axisDim + 'Axis';

            if (blockMeta) {
              newOption[axisKey] = newOption[axisKey] || [];
              newOption[axisKey][blockMeta.axisIndex] = {
                data: result.categories
              };
              newOption.series = newOption.series.concat(result.series);
            }
          } else {
            var result = parseListContents(block);
            newOption.series.push(result);
          }
        });
        return newOption;
      }
      /**
       * @alias {module:echarts/component/toolbox/feature/DataView}
       * @constructor
       * @param {module:echarts/model/Model} model
       */


      function DataView(model) {
        this._dom = null;
        this.model = model;
      }

      DataView.defaultOption = {
        show: true,
        readOnly: false,
        optionToContent: null,
        contentToOption: null,
        icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',
        title: zrUtil.clone(dataViewLang.title),
        lang: zrUtil.clone(dataViewLang.lang),
        backgroundColor: '#fff',
        textColor: '#000',
        textareaColor: '#fff',
        textareaBorderColor: '#333',
        buttonColor: '#c23531',
        buttonTextColor: '#fff'
      };

      DataView.prototype.onclick = function (ecModel, api) {
        var container = api.getDom();
        var model = this.model;

        if (this._dom) {
          container.removeChild(this._dom);
        }

        var root = document.createElement('div');
        root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';
        root.style.backgroundColor = model.get('backgroundColor') || '#fff'; // Create elements

        var header = document.createElement('h4');
        var lang = model.get('lang') || [];
        header.innerHTML = lang[0] || model.get('title');
        header.style.cssText = 'margin: 10px 20px;';
        header.style.color = model.get('textColor');
        var viewMain = document.createElement('div');
        var textarea = document.createElement('textarea');
        viewMain.style.cssText = 'display:block;width:100%;overflow:auto;';
        var optionToContent = model.get('optionToContent');
        var contentToOption = model.get('contentToOption');
        var result = getContentFromModel(ecModel);

        if (typeof optionToContent === 'function') {
          var htmlOrDom = optionToContent(api.getOption());

          if (typeof htmlOrDom === 'string') {
            viewMain.innerHTML = htmlOrDom;
          } else if (zrUtil.isDom(htmlOrDom)) {
            viewMain.appendChild(htmlOrDom);
          }
        } else {
          // Use default textarea
          viewMain.appendChild(textarea);
          textarea.readOnly = model.get('readOnly');
          textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';
          textarea.style.color = model.get('textColor');
          textarea.style.borderColor = model.get('textareaBorderColor');
          textarea.style.backgroundColor = model.get('textareaColor');
          textarea.value = result.value;
        }

        var blockMetaList = result.meta;
        var buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';
        var buttonStyle = 'float:right;margin-right:20px;border:none;' + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';
        var closeButton = document.createElement('div');
        var refreshButton = document.createElement('div');
        buttonStyle += ';background-color:' + model.get('buttonColor');
        buttonStyle += ';color:' + model.get('buttonTextColor');
        var self = this;

        function close() {
          container.removeChild(root);
          self._dom = null;
        }

        eventTool.addEventListener(closeButton, 'click', close);
        eventTool.addEventListener(refreshButton, 'click', function () {
          var newOption;

          try {
            if (typeof contentToOption === 'function') {
              newOption = contentToOption(viewMain, api.getOption());
            } else {
              newOption = parseContents(textarea.value, blockMetaList);
            }
          } catch (e) {
            close();
            throw new Error('Data view format error ' + e);
          }

          if (newOption) {
            api.dispatchAction({
              type: 'changeDataView',
              newOption: newOption
            });
          }

          close();
        });
        closeButton.innerHTML = lang[1];
        refreshButton.innerHTML = lang[2];
        refreshButton.style.cssText = buttonStyle;
        closeButton.style.cssText = buttonStyle;
        !model.get('readOnly') && buttonContainer.appendChild(refreshButton);
        buttonContainer.appendChild(closeButton);
        root.appendChild(header);
        root.appendChild(viewMain);
        root.appendChild(buttonContainer);
        viewMain.style.height = container.clientHeight - 80 + 'px';
        container.appendChild(root);
        this._dom = root;
      };

      DataView.prototype.remove = function (ecModel, api) {
        this._dom && api.getDom().removeChild(this._dom);
      };

      DataView.prototype.dispose = function (ecModel, api) {
        this.remove(ecModel, api);
      };
      /**
       * @inner
       */


      function tryMergeDataOption(newData, originalData) {
        return zrUtil.map(newData, function (newVal, idx) {
          var original = originalData && originalData[idx];

          if (zrUtil.isObject(original) && !zrUtil.isArray(original)) {
            var newValIsObject = zrUtil.isObject(newVal) && !zrUtil.isArray(newVal);

            if (!newValIsObject) {
              newVal = {
                value: newVal
              };
            } // original data has name but new data has no name


            var shouldDeleteName = original.name != null && newVal.name == null; // Original data has option

            newVal = zrUtil.defaults(newVal, original);
            shouldDeleteName && delete newVal.name;
            return newVal;
          } else {
            return newVal;
          }
        });
      }

      featureManager.register('dataView', DataView);
      echarts.registerAction({
        type: 'changeDataView',
        event: 'dataViewChanged',
        update: 'prepareAndUpdate'
      }, function (payload, ecModel) {
        var newSeriesOptList = [];
        zrUtil.each(payload.newOption.series, function (seriesOpt) {
          var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];

          if (!seriesModel) {
            // New created series
            // Geuss the series type
            newSeriesOptList.push(zrUtil.extend({
              // Default is scatter
              type: 'scatter'
            }, seriesOpt));
          } else {
            var originalData = seriesModel.get('data');
            newSeriesOptList.push({
              name: seriesOpt.name,
              data: tryMergeDataOption(seriesOpt.data, originalData)
            });
          }
        });
        ecModel.mergeOption(zrUtil.defaults({
          series: newSeriesOptList
        }, payload.newOption));
      });
      var _default = DataView;
      module.exports = _default;
      /***/
    },

    /***/
    "eIcI":
    /*!***************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/radar/IndicatorAxis.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function eIcI(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var Axis = __webpack_require__(
      /*! ../Axis */
      "hM6l");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function IndicatorAxis(dim, scale, radiusExtent) {
        Axis.call(this, dim, scale, radiusExtent);
        /**
         * Axis type
         *  - 'category'
         *  - 'value'
         *  - 'time'
         *  - 'log'
         * @type {string}
         */

        this.type = 'value';
        this.angle = 0;
        /**
         * Indicator name
         * @type {string}
         */

        this.name = '';
        /**
         * @type {module:echarts/model/Model}
         */

        this.model;
      }

      zrUtil.inherits(IndicatorAxis, Axis);
      var _default = IndicatorAxis;
      module.exports = _default;
      /***/
    },

    /***/
    "eJH7":
    /*!****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/radar/backwardCompat.js ***!
      \****************************************************************/

    /*! no static exports found */

    /***/
    function eJH7(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // Backward compat for radar chart in 2


      function _default(option) {
        var polarOptArr = option.polar;

        if (polarOptArr) {
          if (!zrUtil.isArray(polarOptArr)) {
            polarOptArr = [polarOptArr];
          }

          var polarNotRadar = [];
          zrUtil.each(polarOptArr, function (polarOpt, idx) {
            if (polarOpt.indicator) {
              if (polarOpt.type && !polarOpt.shape) {
                polarOpt.shape = polarOpt.type;
              }

              option.radar = option.radar || [];

              if (!zrUtil.isArray(option.radar)) {
                option.radar = [option.radar];
              }

              option.radar.push(polarOpt);
            } else {
              polarNotRadar.push(polarOpt);
            }
          });
          option.polar = polarNotRadar;
        }

        zrUtil.each(option.series, function (seriesOpt) {
          if (seriesOpt && seriesOpt.type === 'radar' && seriesOpt.polarIndex) {
            seriesOpt.radarIndex = seriesOpt.polarIndex;
          }
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "ePAk":
    /*!************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/polar/PolarModel.js ***!
      \************************************************************/

    /*! no static exports found */

    /***/
    function ePAk(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      __webpack_require__(
      /*! ./AxisModel */
      "2fGM");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = echarts.extendComponentModel({
        type: 'polar',
        dependencies: ['polarAxis', 'angleAxis'],

        /**
         * @type {module:echarts/coord/polar/Polar}
         */
        coordinateSystem: null,

        /**
         * @param {string} axisType
         * @return {module:echarts/coord/polar/AxisModel}
         */
        findAxisModel: function findAxisModel(axisType) {
          var foundAxisModel;
          var ecModel = this.ecModel;
          ecModel.eachComponent(axisType, function (axisModel) {
            if (axisModel.getCoordSysModel() === this) {
              foundAxisModel = axisModel;
            }
          }, this);
          return foundAxisModel;
        },
        defaultOption: {
          zlevel: 0,
          z: 0,
          center: ['50%', '50%'],
          radius: '80%'
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "eRkO":
    /*!********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/helper/listComponent.js ***!
      \********************************************************************/

    /*! no static exports found */

    /***/
    function eRkO(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _layout = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var getLayoutRect = _layout.getLayoutRect;
      var layoutBox = _layout.box;
      var positionElement = _layout.positionElement;

      var formatUtil = __webpack_require__(
      /*! ../../util/format */
      "7aKB");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Layout list like component.
       * It will box layout each items in group of component and then position the whole group in the viewport
       * @param {module:zrender/group/Group} group
       * @param {module:echarts/model/Component} componentModel
       * @param {module:echarts/ExtensionAPI}
       */


      function layout(group, componentModel, api) {
        var boxLayoutParams = componentModel.getBoxLayoutParams();
        var padding = componentModel.get('padding');
        var viewportSize = {
          width: api.getWidth(),
          height: api.getHeight()
        };
        var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);
        layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);
        positionElement(group, boxLayoutParams, viewportSize, padding);
      }

      function makeBackground(rect, componentModel) {
        var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));
        var style = componentModel.getItemStyle(['color', 'opacity']);
        style.fill = componentModel.get('backgroundColor');
        var rect = new graphic.Rect({
          shape: {
            x: rect.x - padding[3],
            y: rect.y - padding[0],
            width: rect.width + padding[1] + padding[3],
            height: rect.height + padding[0] + padding[2],
            r: componentModel.get('borderRadius')
          },
          style: style,
          silent: true,
          z2: -1
        }); // FIXME
        // `subPixelOptimizeRect` may bring some gap between edge of viewpart
        // and background rect when setting like `left: 0`, `top: 0`.
        // graphic.subPixelOptimizeRect(rect);

        return rect;
      }

      exports.layout = layout;
      exports.makeBackground = makeBackground;
      /***/
    },

    /***/
    "eS4l":
    /*!**********************************************************!*\
      !*** ./node_modules/echarts/lib/component/radiusAxis.js ***!
      \**********************************************************/

    /*! no static exports found */

    /***/
    function eS4l(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      __webpack_require__(
      /*! ../coord/polar/polarCreator */
      "HM/N");

      __webpack_require__(
      /*! ./axis/RadiusAxisView */
      "FNN5");
      /***/

    },

    /***/
    "ewwo":
    /*!************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/graph/createView.js ***!
      \************************************************************/

    /*! no static exports found */

    /***/
    function ewwo(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var View = __webpack_require__(
      /*! ../../coord/View */
      "bMXI");

      var _layout = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var getLayoutRect = _layout.getLayoutRect;

      var bbox = __webpack_require__(
      /*! zrender/lib/core/bbox */
      "4mN7");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // FIXME Where to create the simple view coordinate system


      function getViewRect(seriesModel, api, aspect) {
        var option = seriesModel.getBoxLayoutParams();
        option.aspect = aspect;
        return getLayoutRect(option, {
          width: api.getWidth(),
          height: api.getHeight()
        });
      }

      function _default(ecModel, api) {
        var viewList = [];
        ecModel.eachSeriesByType('graph', function (seriesModel) {
          var coordSysType = seriesModel.get('coordinateSystem');

          if (!coordSysType || coordSysType === 'view') {
            var data = seriesModel.getData();
            var positions = data.mapArray(function (idx) {
              var itemModel = data.getItemModel(idx);
              return [+itemModel.get('x'), +itemModel.get('y')];
            });
            var min = [];
            var max = [];
            bbox.fromPoints(positions, min, max); // If width or height is 0

            if (max[0] - min[0] === 0) {
              max[0] += 1;
              min[0] -= 1;
            }

            if (max[1] - min[1] === 0) {
              max[1] += 1;
              min[1] -= 1;
            }

            var aspect = (max[0] - min[0]) / (max[1] - min[1]); // FIXME If get view rect after data processed?

            var viewRect = getViewRect(seriesModel, api, aspect); // Position may be NaN, use view rect instead

            if (isNaN(aspect)) {
              min = [viewRect.x, viewRect.y];
              max = [viewRect.x + viewRect.width, viewRect.y + viewRect.height];
            }

            var bbWidth = max[0] - min[0];
            var bbHeight = max[1] - min[1];
            var viewWidth = viewRect.width;
            var viewHeight = viewRect.height;
            var viewCoordSys = seriesModel.coordinateSystem = new View();
            viewCoordSys.zoomLimit = seriesModel.get('scaleLimit');
            viewCoordSys.setBoundingRect(min[0], min[1], bbWidth, bbHeight);
            viewCoordSys.setViewRect(viewRect.x, viewRect.y, viewWidth, viewHeight); // Update roam info

            viewCoordSys.setCenter(seriesModel.get('center'));
            viewCoordSys.setZoom(seriesModel.get('zoom'));
            viewList.push(viewCoordSys);
          }
        });
        return viewList;
      }

      module.exports = _default;
      /***/
    },

    /***/
    "f1nB":
    /*!*******************************************************!*\
      !*** ./node_modules/echarts/lib/component/graphic.js ***!
      \*******************************************************/

    /*! no static exports found */

    /***/
    function f1nB(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var modelUtil = __webpack_require__(
      /*! ../util/model */
      "4NO4");

      var graphicUtil = __webpack_require__(
      /*! ../util/graphic */
      "IwbS");

      var layoutUtil = __webpack_require__(
      /*! ../util/layout */
      "+TT/");

      var _number = __webpack_require__(
      /*! ../util/number */
      "OELB");

      var parsePercent = _number.parsePercent;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var _nonShapeGraphicElements = {
        // Reserved but not supported in graphic component.
        path: null,
        compoundPath: null,
        // Supported in graphic component.
        group: graphicUtil.Group,
        image: graphicUtil.Image,
        text: graphicUtil.Text
      }; // -------------
      // Preprocessor
      // -------------

      echarts.registerPreprocessor(function (option) {
        var graphicOption = option.graphic; // Convert
        // {graphic: [{left: 10, type: 'circle'}, ...]}
        // or
        // {graphic: {left: 10, type: 'circle'}}
        // to
        // {graphic: [{elements: [{left: 10, type: 'circle'}, ...]}]}

        if (zrUtil.isArray(graphicOption)) {
          if (!graphicOption[0] || !graphicOption[0].elements) {
            option.graphic = [{
              elements: graphicOption
            }];
          } else {
            // Only one graphic instance can be instantiated. (We dont
            // want that too many views are created in echarts._viewMap)
            option.graphic = [option.graphic[0]];
          }
        } else if (graphicOption && !graphicOption.elements) {
          option.graphic = [{
            elements: [graphicOption]
          }];
        }
      }); // ------
      // Model
      // ------

      var GraphicModel = echarts.extendComponentModel({
        type: 'graphic',
        defaultOption: {
          // Extra properties for each elements:
          //
          // left/right/top/bottom: (like 12, '22%', 'center', default undefined)
          //      If left/rigth is set, shape.x/shape.cx/position will not be used.
          //      If top/bottom is set, shape.y/shape.cy/position will not be used.
          //      This mechanism is useful when you want to position a group/element
          //      against the right side or the center of this container.
          //
          // width/height: (can only be pixel value, default 0)
          //      Only be used to specify contianer(group) size, if needed. And
          //      can not be percentage value (like '33%'). See the reason in the
          //      layout algorithm below.
          //
          // bounding: (enum: 'all' (default) | 'raw')
          //      Specify how to calculate boundingRect when locating.
          //      'all': Get uioned and transformed boundingRect
          //          from both itself and its descendants.
          //          This mode simplies confining a group of elements in the bounding
          //          of their ancester container (e.g., using 'right: 0').
          //      'raw': Only use the boundingRect of itself and before transformed.
          //          This mode is similar to css behavior, which is useful when you
          //          want an element to be able to overflow its container. (Consider
          //          a rotated circle needs to be located in a corner.)
          // info: custom info. enables user to mount some info on elements and use them
          //      in event handlers. Update them only when user specified, otherwise, remain.
          // Note: elements is always behind its ancestors in this elements array.
          elements: [],
          parentId: null
        },

        /**
         * Save el options for the sake of the performance (only update modified graphics).
         * The order is the same as those in option. (ancesters -> descendants)
         *
         * @private
         * @type {Array.<Object>}
         */
        _elOptionsToUpdate: null,

        /**
         * @override
         */
        mergeOption: function mergeOption(option) {
          // Prevent default merge to elements
          var elements = this.option.elements;
          this.option.elements = null;
          GraphicModel.superApply(this, 'mergeOption', arguments);
          this.option.elements = elements;
        },

        /**
         * @override
         */
        optionUpdated: function optionUpdated(newOption, isInit) {
          var thisOption = this.option;
          var newList = (isInit ? thisOption : newOption).elements;
          var existList = thisOption.elements = isInit ? [] : thisOption.elements;
          var flattenedList = [];

          this._flatten(newList, flattenedList);

          var mappingResult = modelUtil.mappingToExists(existList, flattenedList);
          modelUtil.makeIdAndName(mappingResult); // Clear elOptionsToUpdate

          var elOptionsToUpdate = this._elOptionsToUpdate = [];
          zrUtil.each(mappingResult, function (resultItem, index) {
            var newElOption = resultItem.option;

            if (!newElOption) {
              return;
            }

            elOptionsToUpdate.push(newElOption);
            setKeyInfoToNewElOption(resultItem, newElOption);
            mergeNewElOptionToExist(existList, index, newElOption);
            setLayoutInfoToExist(existList[index], newElOption);
          }, this); // Clean

          for (var i = existList.length - 1; i >= 0; i--) {
            if (existList[i] == null) {
              existList.splice(i, 1);
            } else {
              // $action should be volatile, otherwise option gotten from
              // `getOption` will contain unexpected $action.
              delete existList[i].$action;
            }
          }
        },

        /**
         * Convert
         * [{
         *  type: 'group',
         *  id: 'xx',
         *  children: [{type: 'circle'}, {type: 'polygon'}]
         * }]
         * to
         * [
         *  {type: 'group', id: 'xx'},
         *  {type: 'circle', parentId: 'xx'},
         *  {type: 'polygon', parentId: 'xx'}
         * ]
         *
         * @private
         * @param {Array.<Object>} optionList option list
         * @param {Array.<Object>} result result of flatten
         * @param {Object} parentOption parent option
         */
        _flatten: function _flatten(optionList, result, parentOption) {
          zrUtil.each(optionList, function (option) {
            if (!option) {
              return;
            }

            if (parentOption) {
              option.parentOption = parentOption;
            }

            result.push(option);
            var children = option.children;

            if (option.type === 'group' && children) {
              this._flatten(children, result, option);
            } // Deleting for JSON output, and for not affecting group creation.


            delete option.children;
          }, this);
        },
        // FIXME
        // Pass to view using payload? setOption has a payload?
        useElOptionsToUpdate: function useElOptionsToUpdate() {
          var els = this._elOptionsToUpdate; // Clear to avoid render duplicately when zooming.

          this._elOptionsToUpdate = null;
          return els;
        }
      }); // -----
      // View
      // -----

      echarts.extendComponentView({
        type: 'graphic',

        /**
         * @override
         */
        init: function init(ecModel, api) {
          /**
           * @private
           * @type {module:zrender/core/util.HashMap}
           */
          this._elMap = zrUtil.createHashMap();
          /**
           * @private
           * @type {module:echarts/graphic/GraphicModel}
           */

          this._lastGraphicModel;
        },

        /**
         * @override
         */
        render: function render(graphicModel, ecModel, api) {
          // Having leveraged between use cases and algorithm complexity, a very
          // simple layout mechanism is used:
          // The size(width/height) can be determined by itself or its parent (not
          // implemented yet), but can not by its children. (Top-down travel)
          // The location(x/y) can be determined by the bounding rect of itself
          // (can including its descendants or not) and the size of its parent.
          // (Bottom-up travel)
          // When `chart.clear()` or `chart.setOption({...}, true)` with the same id,
          // view will be reused.
          if (graphicModel !== this._lastGraphicModel) {
            this._clear();
          }

          this._lastGraphicModel = graphicModel;

          this._updateElements(graphicModel);

          this._relocate(graphicModel, api);
        },

        /**
         * Update graphic elements.
         *
         * @private
         * @param {Object} graphicModel graphic model
         */
        _updateElements: function _updateElements(graphicModel) {
          var elOptionsToUpdate = graphicModel.useElOptionsToUpdate();

          if (!elOptionsToUpdate) {
            return;
          }

          var elMap = this._elMap;
          var rootGroup = this.group; // Top-down tranverse to assign graphic settings to each elements.

          zrUtil.each(elOptionsToUpdate, function (elOption) {
            var $action = elOption.$action;
            var id = elOption.id;
            var existEl = elMap.get(id);
            var parentId = elOption.parentId;
            var targetElParent = parentId != null ? elMap.get(parentId) : rootGroup;
            var elOptionStyle = elOption.style;

            if (elOption.type === 'text' && elOptionStyle) {
              // In top/bottom mode, textVerticalAlign should not be used, which cause
              // inaccurately locating.
              if (elOption.hv && elOption.hv[1]) {
                elOptionStyle.textVerticalAlign = elOptionStyle.textBaseline = null;
              } // Compatible with previous setting: both support fill and textFill,
              // stroke and textStroke.


              !elOptionStyle.hasOwnProperty('textFill') && elOptionStyle.fill && (elOptionStyle.textFill = elOptionStyle.fill);
              !elOptionStyle.hasOwnProperty('textStroke') && elOptionStyle.stroke && (elOptionStyle.textStroke = elOptionStyle.stroke);
            } // Remove unnecessary props to avoid potential problems.


            var elOptionCleaned = getCleanedElOption(elOption); // For simple, do not support parent change, otherwise reorder is needed.

            if (!$action || $action === 'merge') {
              existEl ? existEl.attr(elOptionCleaned) : createEl(id, targetElParent, elOptionCleaned, elMap);
            } else if ($action === 'replace') {
              removeEl(existEl, elMap);
              createEl(id, targetElParent, elOptionCleaned, elMap);
            } else if ($action === 'remove') {
              removeEl(existEl, elMap);
            }

            var el = elMap.get(id);

            if (el) {
              el.__ecGraphicWidthOption = elOption.width;
              el.__ecGraphicHeightOption = elOption.height;
              setEventData(el, graphicModel, elOption);
            }
          });
        },

        /**
         * Locate graphic elements.
         *
         * @private
         * @param {Object} graphicModel graphic model
         * @param {module:echarts/ExtensionAPI} api extension API
         */
        _relocate: function _relocate(graphicModel, api) {
          var elOptions = graphicModel.option.elements;
          var rootGroup = this.group;
          var elMap = this._elMap;
          var apiWidth = api.getWidth();
          var apiHeight = api.getHeight(); // Top-down to calculate percentage width/height of group

          for (var i = 0; i < elOptions.length; i++) {
            var elOption = elOptions[i];
            var el = elMap.get(elOption.id);

            if (!el || !el.isGroup) {
              continue;
            }

            var parentEl = el.parent;
            var isParentRoot = parentEl === rootGroup; // Like 'position:absolut' in css, default 0.

            el.__ecGraphicWidth = parsePercent(el.__ecGraphicWidthOption, isParentRoot ? apiWidth : parentEl.__ecGraphicWidth) || 0;
            el.__ecGraphicHeight = parsePercent(el.__ecGraphicHeightOption, isParentRoot ? apiHeight : parentEl.__ecGraphicHeight) || 0;
          } // Bottom-up tranvese all elements (consider ec resize) to locate elements.


          for (var i = elOptions.length - 1; i >= 0; i--) {
            var elOption = elOptions[i];
            var el = elMap.get(elOption.id);

            if (!el) {
              continue;
            }

            var parentEl = el.parent;
            var containerInfo = parentEl === rootGroup ? {
              width: apiWidth,
              height: apiHeight
            } : {
              width: parentEl.__ecGraphicWidth,
              height: parentEl.__ecGraphicHeight
            }; // PENDING
            // Currently, when `bounding: 'all'`, the union bounding rect of the group
            // does not include the rect of [0, 0, group.width, group.height], which
            // is probably weird for users. Should we make a break change for it?

            layoutUtil.positionElement(el, elOption, containerInfo, null, {
              hv: elOption.hv,
              boundingMode: elOption.bounding
            });
          }
        },

        /**
         * Clear all elements.
         *
         * @private
         */
        _clear: function _clear() {
          var elMap = this._elMap;
          elMap.each(function (el) {
            removeEl(el, elMap);
          });
          this._elMap = zrUtil.createHashMap();
        },

        /**
         * @override
         */
        dispose: function dispose() {
          this._clear();
        }
      });

      function createEl(id, targetElParent, elOption, elMap) {
        var graphicType = elOption.type;
        var Clz = _nonShapeGraphicElements.hasOwnProperty(graphicType) // Those graphic elements are not shapes. They should not be
        // overwritten by users, so do them first.
        ? _nonShapeGraphicElements[graphicType] : graphicUtil.getShapeClass(graphicType);
        var el = new Clz(elOption);
        targetElParent.add(el);
        elMap.set(id, el);
        el.__ecGraphicId = id;
      }

      function removeEl(existEl, elMap) {
        var existElParent = existEl && existEl.parent;

        if (existElParent) {
          existEl.type === 'group' && existEl.traverse(function (el) {
            removeEl(el, elMap);
          });
          elMap.removeKey(existEl.__ecGraphicId);
          existElParent.remove(existEl);
        }
      } // Remove unnecessary props to avoid potential problems.


      function getCleanedElOption(elOption) {
        elOption = zrUtil.extend({}, elOption);
        zrUtil.each(['id', 'parentId', '$action', 'hv', 'bounding'].concat(layoutUtil.LOCATION_PARAMS), function (name) {
          delete elOption[name];
        });
        return elOption;
      }

      function isSetLoc(obj, props) {
        var isSet;
        zrUtil.each(props, function (prop) {
          obj[prop] != null && obj[prop] !== 'auto' && (isSet = true);
        });
        return isSet;
      }

      function setKeyInfoToNewElOption(resultItem, newElOption) {
        var existElOption = resultItem.exist; // Set id and type after id assigned.

        newElOption.id = resultItem.keyInfo.id;
        !newElOption.type && existElOption && (newElOption.type = existElOption.type); // Set parent id if not specified

        if (newElOption.parentId == null) {
          var newElParentOption = newElOption.parentOption;

          if (newElParentOption) {
            newElOption.parentId = newElParentOption.id;
          } else if (existElOption) {
            newElOption.parentId = existElOption.parentId;
          }
        } // Clear


        newElOption.parentOption = null;
      }

      function mergeNewElOptionToExist(existList, index, newElOption) {
        // Update existing options, for `getOption` feature.
        var newElOptCopy = zrUtil.extend({}, newElOption);
        var existElOption = existList[index];
        var $action = newElOption.$action || 'merge';

        if ($action === 'merge') {
          if (existElOption) {
            // We can ensure that newElOptCopy and existElOption are not
            // the same object, so `merge` will not change newElOptCopy.
            zrUtil.merge(existElOption, newElOptCopy, true); // Rigid body, use ignoreSize.

            layoutUtil.mergeLayoutParam(existElOption, newElOptCopy, {
              ignoreSize: true
            }); // Will be used in render.

            layoutUtil.copyLayoutParams(newElOption, existElOption);
          } else {
            existList[index] = newElOptCopy;
          }
        } else if ($action === 'replace') {
          existList[index] = newElOptCopy;
        } else if ($action === 'remove') {
          // null will be cleaned later.
          existElOption && (existList[index] = null);
        }
      }

      function setLayoutInfoToExist(existItem, newElOption) {
        if (!existItem) {
          return;
        }

        existItem.hv = newElOption.hv = [// Rigid body, dont care `width`.
        isSetLoc(newElOption, ['left', 'right']), // Rigid body, dont care `height`.
        isSetLoc(newElOption, ['top', 'bottom'])]; // Give default group size. Otherwise layout error may occur.

        if (existItem.type === 'group') {
          existItem.width == null && (existItem.width = newElOption.width = 0);
          existItem.height == null && (existItem.height = newElOption.height = 0);
        }
      }

      function setEventData(el, graphicModel, elOption) {
        var eventData = el.eventData; // Simple optimize for large amount of elements that no need event.

        if (!el.silent && !el.ignore && !eventData) {
          eventData = el.eventData = {
            componentType: 'graphic',
            componentIndex: graphicModel.componentIndex,
            name: el.name
          };
        } // `elOption.info` enables user to mount some info on
        // elements and use them in event handlers.


        if (eventData) {
          eventData.info = el.info;
        }
      }
      /***/

    },

    /***/
    "f3JH":
    /*!**************************************************************!*\
      !*** ./node_modules/echarts/lib/component/dataZoomInside.js ***!
      \**************************************************************/

    /*! no static exports found */

    /***/
    function f3JH(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      __webpack_require__(
      /*! ./dataZoom/typeDefaulter */
      "aTJb");

      __webpack_require__(
      /*! ./dataZoom/DataZoomModel */
      "OlYY");

      __webpack_require__(
      /*! ./dataZoom/DataZoomView */
      "fc+c");

      __webpack_require__(
      /*! ./dataZoom/InsideZoomModel */
      "oY9F");

      __webpack_require__(
      /*! ./dataZoom/InsideZoomView */
      "MqEG");

      __webpack_require__(
      /*! ./dataZoom/dataZoomProcessor */
      "LBfv");

      __webpack_require__(
      /*! ./dataZoom/dataZoomAction */
      "noeP");
      /***/

    },

    /***/
    "f5HG":
    /*!***********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/helper/LinePath.js ***!
      \***********************************************************/

    /*! no static exports found */

    /***/
    function f5HG(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var vec2 = __webpack_require__(
      /*! zrender/lib/core/vector */
      "QBsz");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Line path for bezier and straight line draw
       */


      var straightLineProto = graphic.Line.prototype;
      var bezierCurveProto = graphic.BezierCurve.prototype;

      function isLine(shape) {
        return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);
      }

      var _default = graphic.extendShape({
        type: 'ec-line',
        style: {
          stroke: '#000',
          fill: null
        },
        shape: {
          x1: 0,
          y1: 0,
          x2: 0,
          y2: 0,
          percent: 1,
          cpx1: null,
          cpy1: null
        },
        buildPath: function buildPath(ctx, shape) {
          this[isLine(shape) ? '_buildPathLine' : '_buildPathCurve'](ctx, shape);
        },
        _buildPathLine: straightLineProto.buildPath,
        _buildPathCurve: bezierCurveProto.buildPath,
        pointAt: function pointAt(t) {
          return this[isLine(this.shape) ? '_pointAtLine' : '_pointAtCurve'](t);
        },
        _pointAtLine: straightLineProto.pointAt,
        _pointAtCurve: bezierCurveProto.pointAt,
        tangentAt: function tangentAt(t) {
          var shape = this.shape;
          var p = isLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : this._tangentAtCurve(t);
          return vec2.normalize(p, p);
        },
        _tangentAtCurve: bezierCurveProto.tangentAt
      });

      module.exports = _default;
      /***/
    },

    /***/
    "f5Yq":
    /*!***************************************************!*\
      !*** ./node_modules/echarts/lib/visual/symbol.js ***!
      \***************************************************/

    /*! no static exports found */

    /***/
    function f5Yq(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _util = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var isFunction = _util.isFunction;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      function _default(seriesType, defaultSymbolType, legendSymbol) {
        // Encoding visual for all series include which is filtered for legend drawing
        return {
          seriesType: seriesType,
          // For legend.
          performRawSeries: true,
          reset: function reset(seriesModel, ecModel, api) {
            var data = seriesModel.getData();
            var symbolType = seriesModel.get('symbol');
            var symbolSize = seriesModel.get('symbolSize');
            var keepAspect = seriesModel.get('symbolKeepAspect');
            var symbolRotate = seriesModel.get('symbolRotate');
            var hasSymbolTypeCallback = isFunction(symbolType);
            var hasSymbolSizeCallback = isFunction(symbolSize);
            var hasSymbolRotateCallback = isFunction(symbolRotate);
            var hasCallback = hasSymbolTypeCallback || hasSymbolSizeCallback || hasSymbolRotateCallback;
            var seriesSymbol = !hasSymbolTypeCallback && symbolType ? symbolType : defaultSymbolType;
            var seriesSymbolSize = !hasSymbolSizeCallback ? symbolSize : null;
            var seriesSymbolRotate = !hasSymbolRotateCallback ? seriesSymbolRotate : null;
            data.setVisual({
              legendSymbol: legendSymbol || seriesSymbol,
              // If seting callback functions on `symbol` or `symbolSize`, for simplicity and avoiding
              // to bring trouble, we do not pick a reuslt from one of its calling on data item here,
              // but just use the default value. Callback on `symbol` or `symbolSize` is convenient in
              // some cases but generally it is not recommanded.
              symbol: seriesSymbol,
              symbolSize: seriesSymbolSize,
              symbolKeepAspect: keepAspect,
              symbolRotate: symbolRotate
            }); // Only visible series has each data be visual encoded

            if (ecModel.isSeriesFiltered(seriesModel)) {
              return;
            }

            function dataEach(data, idx) {
              if (hasCallback) {
                var rawValue = seriesModel.getRawValue(idx);
                var params = seriesModel.getDataParams(idx);
                hasSymbolTypeCallback && data.setItemVisual(idx, 'symbol', symbolType(rawValue, params));
                hasSymbolSizeCallback && data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));
                hasSymbolRotateCallback && data.setItemVisual(idx, 'symbolRotate', symbolRotate(rawValue, params));
              }

              if (data.hasItemOption) {
                var itemModel = data.getItemModel(idx);
                var itemSymbolType = itemModel.getShallow('symbol', true);
                var itemSymbolSize = itemModel.getShallow('symbolSize', true);
                var itemSymbolRotate = itemModel.getShallow('symbolRotate', true);
                var itemSymbolKeepAspect = itemModel.getShallow('symbolKeepAspect', true); // If has item symbol

                if (itemSymbolType != null) {
                  data.setItemVisual(idx, 'symbol', itemSymbolType);
                }

                if (itemSymbolSize != null) {
                  // PENDING Transform symbolSize ?
                  data.setItemVisual(idx, 'symbolSize', itemSymbolSize);
                }

                if (itemSymbolRotate != null) {
                  data.setItemVisual(idx, 'symbolRotate', itemSymbolRotate);
                }

                if (itemSymbolKeepAspect != null) {
                  data.setItemVisual(idx, 'symbolKeepAspect', itemSymbolKeepAspect);
                }
              }
            }

            return {
              dataEach: data.hasItemOption || hasCallback ? dataEach : null
            };
          }
        };
      }

      module.exports = _default;
      /***/
    },

    /***/
    "fE02":
    /*!************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/toolbox/feature/DataZoom.js ***!
      \************************************************************************/

    /*! no static exports found */

    /***/
    function fE02(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var BrushController = __webpack_require__(
      /*! ../../helper/BrushController */
      "/IIm");

      var BrushTargetManager = __webpack_require__(
      /*! ../../helper/BrushTargetManager */
      "vZ6x");

      var history = __webpack_require__(
      /*! ../../dataZoom/history */
      "b9oc");

      var sliderMove = __webpack_require__(
      /*! ../../helper/sliderMove */
      "72pK");

      var lang = __webpack_require__(
      /*! ../../../lang */
      "Kagy");

      var featureManager = __webpack_require__(
      /*! ../featureManager */
      "IUWy");

      __webpack_require__(
      /*! ../../dataZoomSelect */
      "3TkU");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // Use dataZoomSelect


      var dataZoomLang = lang.toolbox.dataZoom;
      var each = zrUtil.each; // Spectial component id start with \0ec\0, see echarts/model/Global.js~hasInnerId

      var DATA_ZOOM_ID_BASE = '\0_ec_\0toolbox-dataZoom_';

      function DataZoom(model, ecModel, api) {
        /**
         * @private
         * @type {module:echarts/component/helper/BrushController}
         */
        (this._brushController = new BrushController(api.getZr())).on('brush', zrUtil.bind(this._onBrush, this)).mount();
        /**
         * @private
         * @type {boolean}
         */

        this._isZoomActive;
      }

      DataZoom.defaultOption = {
        show: true,
        filterMode: 'filter',
        // Icon group
        icon: {
          zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',
          back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'
        },
        // `zoom`, `back`
        title: zrUtil.clone(dataZoomLang.title),
        brushStyle: {
          borderWidth: 0,
          color: 'rgba(0,0,0,0.2)'
        }
      };
      var proto = DataZoom.prototype;

      proto.render = function (featureModel, ecModel, api, payload) {
        this.model = featureModel;
        this.ecModel = ecModel;
        this.api = api;
        updateZoomBtnStatus(featureModel, ecModel, this, payload, api);
        updateBackBtnStatus(featureModel, ecModel);
      };

      proto.onclick = function (ecModel, api, type) {
        handlers[type].call(this);
      };

      proto.remove = function (ecModel, api) {
        this._brushController.unmount();
      };

      proto.dispose = function (ecModel, api) {
        this._brushController.dispose();
      };
      /**
       * @private
       */


      var handlers = {
        zoom: function zoom() {
          var nextActive = !this._isZoomActive;
          this.api.dispatchAction({
            type: 'takeGlobalCursor',
            key: 'dataZoomSelect',
            dataZoomSelectActive: nextActive
          });
        },
        back: function back() {
          this._dispatchZoomAction(history.pop(this.ecModel));
        }
      };
      /**
       * @private
       */

      proto._onBrush = function (areas, opt) {
        if (!opt.isEnd || !areas.length) {
          return;
        }

        var snapshot = {};
        var ecModel = this.ecModel;

        this._brushController.updateCovers([]); // remove cover


        var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(this.model.option), ecModel, {
          include: ['grid']
        });
        brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {
          if (coordSys.type !== 'cartesian2d') {
            return;
          }

          var brushType = area.brushType;

          if (brushType === 'rect') {
            setBatch('x', coordSys, coordRange[0]);
            setBatch('y', coordSys, coordRange[1]);
          } else {
            setBatch({
              lineX: 'x',
              lineY: 'y'
            }[brushType], coordSys, coordRange);
          }
        });
        history.push(ecModel, snapshot);

        this._dispatchZoomAction(snapshot);

        function setBatch(dimName, coordSys, minMax) {
          var axis = coordSys.getAxis(dimName);
          var axisModel = axis.model;
          var dataZoomModel = findDataZoom(dimName, axisModel, ecModel); // Restrict range.

          var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();

          if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {
            minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);
          }

          dataZoomModel && (snapshot[dataZoomModel.id] = {
            dataZoomId: dataZoomModel.id,
            startValue: minMax[0],
            endValue: minMax[1]
          });
        }

        function findDataZoom(dimName, axisModel, ecModel) {
          var found;
          ecModel.eachComponent({
            mainType: 'dataZoom',
            subType: 'select'
          }, function (dzModel) {
            var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);
            has && (found = dzModel);
          });
          return found;
        }
      };
      /**
       * @private
       */


      proto._dispatchZoomAction = function (snapshot) {
        var batch = []; // Convert from hash map to array.

        each(snapshot, function (batchItem, dataZoomId) {
          batch.push(zrUtil.clone(batchItem));
        });
        batch.length && this.api.dispatchAction({
          type: 'dataZoom',
          from: this.uid,
          batch: batch
        });
      };

      function retrieveAxisSetting(option) {
        var setting = {}; // Compatible with previous setting: null => all axis, false => no axis.

        zrUtil.each(['xAxisIndex', 'yAxisIndex'], function (name) {
          setting[name] = option[name];
          setting[name] == null && (setting[name] = 'all');
          (setting[name] === false || setting[name] === 'none') && (setting[name] = []);
        });
        return setting;
      }

      function updateBackBtnStatus(featureModel, ecModel) {
        featureModel.setIconStatus('back', history.count(ecModel) > 1 ? 'emphasis' : 'normal');
      }

      function updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {
        var zoomActive = view._isZoomActive;

        if (payload && payload.type === 'takeGlobalCursor') {
          zoomActive = payload.key === 'dataZoomSelect' ? payload.dataZoomSelectActive : false;
        }

        view._isZoomActive = zoomActive;
        featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');
        var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(featureModel.option), ecModel, {
          include: ['grid']
        });

        view._brushController.setPanels(brushTargetManager.makePanelOpts(api, function (targetInfo) {
          return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? 'lineX' : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? 'lineY' : 'rect';
        })).enableBrush(zoomActive ? {
          brushType: 'auto',
          brushStyle: featureModel.getModel('brushStyle').getItemStyle()
        } : false);
      }

      featureManager.register('dataZoom', DataZoom); // Create special dataZoom option for select
      // FIXME consider the case of merge option, where axes options are not exists.

      echarts.registerPreprocessor(function (option) {
        if (!option) {
          return;
        }

        var dataZoomOpts = option.dataZoom || (option.dataZoom = []);

        if (!zrUtil.isArray(dataZoomOpts)) {
          option.dataZoom = dataZoomOpts = [dataZoomOpts];
        }

        var toolboxOpt = option.toolbox;

        if (toolboxOpt) {
          // Assume there is only one toolbox
          if (zrUtil.isArray(toolboxOpt)) {
            toolboxOpt = toolboxOpt[0];
          }

          if (toolboxOpt && toolboxOpt.feature) {
            var dataZoomOpt = toolboxOpt.feature.dataZoom; // FIXME: If add dataZoom when setOption in merge mode,
            // no axis info to be added. See `test/dataZoom-extreme.html`

            addForAxis('xAxis', dataZoomOpt);
            addForAxis('yAxis', dataZoomOpt);
          }
        }

        function addForAxis(axisName, dataZoomOpt) {
          if (!dataZoomOpt) {
            return;
          } // Try not to modify model, because it is not merged yet.


          var axisIndicesName = axisName + 'Index';
          var givenAxisIndices = dataZoomOpt[axisIndicesName];

          if (givenAxisIndices != null && givenAxisIndices !== 'all' && !zrUtil.isArray(givenAxisIndices)) {
            givenAxisIndices = givenAxisIndices === false || givenAxisIndices === 'none' ? [] : [givenAxisIndices];
          }

          forEachComponent(axisName, function (axisOpt, axisIndex) {
            if (givenAxisIndices != null && givenAxisIndices !== 'all' && zrUtil.indexOf(givenAxisIndices, axisIndex) === -1) {
              return;
            }

            var newOpt = {
              type: 'select',
              $fromToolbox: true,
              // Default to be filter
              filterMode: dataZoomOpt.filterMode || 'filter',
              // Id for merge mapping.
              id: DATA_ZOOM_ID_BASE + axisName + axisIndex
            }; // FIXME
            // Only support one axis now.

            newOpt[axisIndicesName] = axisIndex;
            dataZoomOpts.push(newOpt);
          });
        }

        function forEachComponent(mainType, cb) {
          var opts = option[mainType];

          if (!zrUtil.isArray(opts)) {
            opts = opts ? [opts] : [];
          }

          each(opts, cb);
        }
      });
      var _default = DataZoom;
      module.exports = _default;
      /***/
    },

    /***/
    "fc+c":
    /*!*********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/dataZoom/DataZoomView.js ***!
      \*********************************************************************/

    /*! no static exports found */

    /***/
    function fcC(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var ComponentView = __webpack_require__(
      /*! ../../view/Component */
      "sS/r");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = ComponentView.extend({
        type: 'dataZoom',
        render: function render(dataZoomModel, ecModel, api, payload) {
          this.dataZoomModel = dataZoomModel;
          this.ecModel = ecModel;
          this.api = api;
        },

        /**
         * Find the first target coordinate system.
         *
         * @protected
         * @return {Object} {
         *                   grid: [
         *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},
         *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},
         *                       ...
         *                   ],  // cartesians must not be null/undefined.
         *                   polar: [
         *                       {model: coord0, axisModels: [axis4], coordIndex: 0},
         *                       ...
         *                   ],  // polars must not be null/undefined.
         *                   singleAxis: [
         *                       {model: coord0, axisModels: [], coordIndex: 0}
         *                   ]
         */
        getTargetCoordInfo: function getTargetCoordInfo() {
          var dataZoomModel = this.dataZoomModel;
          var ecModel = this.ecModel;
          var coordSysLists = {};
          dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {
            var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);

            if (axisModel) {
              var coordModel = axisModel.getCoordSysModel();
              coordModel && save(coordModel, axisModel, coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []), coordModel.componentIndex);
            }
          }, this);

          function save(coordModel, axisModel, store, coordIndex) {
            var item;

            for (var i = 0; i < store.length; i++) {
              if (store[i].model === coordModel) {
                item = store[i];
                break;
              }
            }

            if (!item) {
              store.push(item = {
                model: coordModel,
                axisModels: [],
                coordIndex: coordIndex
              });
            }

            item.axisModels.push(axisModel);
          }

          return coordSysLists;
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "fjKi":
    /*!********************************************************!*\
      !*** ./node_modules/echarts/lib/component/markArea.js ***!
      \********************************************************/

    /*! no static exports found */

    /***/
    function fjKi(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ./marker/MarkAreaModel */
      "Q7if");

      __webpack_require__(
      /*! ./marker/MarkAreaView */
      "jndi");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      echarts.registerPreprocessor(function (opt) {
        // Make sure markArea component is enabled
        opt.markArea = opt.markArea || {};
      });
      /***/
    },

    /***/
    "fls0":
    /*!*******************************************************!*\
      !*** ./node_modules/echarts/lib/chart/helper/Line.js ***!
      \*******************************************************/

    /*! no static exports found */

    /***/
    function fls0(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var vector = __webpack_require__(
      /*! zrender/lib/core/vector */
      "QBsz");

      var symbolUtil = __webpack_require__(
      /*! ../../util/symbol */
      "oVpE");

      var LinePath = __webpack_require__(
      /*! ./LinePath */
      "f5HG");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var _number = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var round = _number.round;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @module echarts/chart/helper/Line
       */

      var SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];

      function makeSymbolTypeKey(symbolCategory) {
        return '_' + symbolCategory + 'Type';
      }
      /**
       * @inner
       */


      function createSymbol(name, lineData, idx) {
        var symbolType = lineData.getItemVisual(idx, name);

        if (!symbolType || symbolType === 'none') {
          return;
        }

        var color = lineData.getItemVisual(idx, 'color');
        var symbolSize = lineData.getItemVisual(idx, name + 'Size');
        var symbolRotate = lineData.getItemVisual(idx, name + 'Rotate');

        if (!zrUtil.isArray(symbolSize)) {
          symbolSize = [symbolSize, symbolSize];
        }

        var symbolPath = symbolUtil.createSymbol(symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2, symbolSize[0], symbolSize[1], color); // rotate by default if symbolRotate is not specified or NaN

        symbolPath.__specifiedRotation = symbolRotate == null || isNaN(symbolRotate) ? void 0 : +symbolRotate * Math.PI / 180 || 0;
        symbolPath.name = name;
        return symbolPath;
      }

      function createLine(points) {
        var line = new LinePath({
          name: 'line',
          subPixelOptimize: true
        });
        setLinePoints(line.shape, points);
        return line;
      }

      function setLinePoints(targetShape, points) {
        targetShape.x1 = points[0][0];
        targetShape.y1 = points[0][1];
        targetShape.x2 = points[1][0];
        targetShape.y2 = points[1][1];
        targetShape.percent = 1;
        var cp1 = points[2];

        if (cp1) {
          targetShape.cpx1 = cp1[0];
          targetShape.cpy1 = cp1[1];
        } else {
          targetShape.cpx1 = NaN;
          targetShape.cpy1 = NaN;
        }
      }

      function updateSymbolAndLabelBeforeLineUpdate() {
        var lineGroup = this;
        var symbolFrom = lineGroup.childOfName('fromSymbol');
        var symbolTo = lineGroup.childOfName('toSymbol');
        var label = lineGroup.childOfName('label'); // Quick reject

        if (!symbolFrom && !symbolTo && label.ignore) {
          return;
        }

        var invScale = 1;
        var parentNode = this.parent;

        while (parentNode) {
          if (parentNode.scale) {
            invScale /= parentNode.scale[0];
          }

          parentNode = parentNode.parent;
        }

        var line = lineGroup.childOfName('line'); // If line not changed
        // FIXME Parent scale changed

        if (!this.__dirty && !line.__dirty) {
          return;
        }

        var percent = line.shape.percent;
        var fromPos = line.pointAt(0);
        var toPos = line.pointAt(percent);
        var d = vector.sub([], toPos, fromPos);
        vector.normalize(d, d);

        if (symbolFrom) {
          symbolFrom.attr('position', fromPos); // Fix #12388
          // when symbol is set to be 'arrow' in markLine,
          // symbolRotate value will be ignored, and compulsively use tangent angle.
          // rotate by default if symbol rotation is not specified

          var specifiedRotation = symbolFrom.__specifiedRotation;

          if (specifiedRotation == null) {
            var tangent = line.tangentAt(0);
            symbolFrom.attr('rotation', Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
          } else {
            symbolFrom.attr('rotation', specifiedRotation);
          }

          symbolFrom.attr('scale', [invScale * percent, invScale * percent]);
        }

        if (symbolTo) {
          symbolTo.attr('position', toPos); // Fix #12388
          // when symbol is set to be 'arrow' in markLine,
          // symbolRotate value will be ignored, and compulsively use tangent angle.
          // rotate by default if symbol rotation is not specified

          var specifiedRotation = symbolTo.__specifiedRotation;

          if (specifiedRotation == null) {
            var tangent = line.tangentAt(1);
            symbolTo.attr('rotation', -Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
          } else {
            symbolTo.attr('rotation', specifiedRotation);
          }

          symbolTo.attr('scale', [invScale * percent, invScale * percent]);
        }

        if (!label.ignore) {
          label.attr('position', toPos);
          var textPosition;
          var textAlign;
          var textVerticalAlign;
          var textOrigin;
          var distance = label.__labelDistance;
          var distanceX = distance[0] * invScale;
          var distanceY = distance[1] * invScale;
          var halfPercent = percent / 2;
          var tangent = line.tangentAt(halfPercent);
          var n = [tangent[1], -tangent[0]];
          var cp = line.pointAt(halfPercent);

          if (n[1] > 0) {
            n[0] = -n[0];
            n[1] = -n[1];
          }

          var dir = tangent[0] < 0 ? -1 : 1;

          if (label.__position !== 'start' && label.__position !== 'end') {
            var rotation = -Math.atan2(tangent[1], tangent[0]);

            if (toPos[0] < fromPos[0]) {
              rotation = Math.PI + rotation;
            }

            label.attr('rotation', rotation);
          }

          var dy;

          switch (label.__position) {
            case 'insideStartTop':
            case 'insideMiddleTop':
            case 'insideEndTop':
            case 'middle':
              dy = -distanceY;
              textVerticalAlign = 'bottom';
              break;

            case 'insideStartBottom':
            case 'insideMiddleBottom':
            case 'insideEndBottom':
              dy = distanceY;
              textVerticalAlign = 'top';
              break;

            default:
              dy = 0;
              textVerticalAlign = 'middle';
          }

          switch (label.__position) {
            case 'end':
              textPosition = [d[0] * distanceX + toPos[0], d[1] * distanceY + toPos[1]];
              textAlign = d[0] > 0.8 ? 'left' : d[0] < -0.8 ? 'right' : 'center';
              textVerticalAlign = d[1] > 0.8 ? 'top' : d[1] < -0.8 ? 'bottom' : 'middle';
              break;

            case 'start':
              textPosition = [-d[0] * distanceX + fromPos[0], -d[1] * distanceY + fromPos[1]];
              textAlign = d[0] > 0.8 ? 'right' : d[0] < -0.8 ? 'left' : 'center';
              textVerticalAlign = d[1] > 0.8 ? 'bottom' : d[1] < -0.8 ? 'top' : 'middle';
              break;

            case 'insideStartTop':
            case 'insideStart':
            case 'insideStartBottom':
              textPosition = [distanceX * dir + fromPos[0], fromPos[1] + dy];
              textAlign = tangent[0] < 0 ? 'right' : 'left';
              textOrigin = [-distanceX * dir, -dy];
              break;

            case 'insideMiddleTop':
            case 'insideMiddle':
            case 'insideMiddleBottom':
            case 'middle':
              textPosition = [cp[0], cp[1] + dy];
              textAlign = 'center';
              textOrigin = [0, -dy];
              break;

            case 'insideEndTop':
            case 'insideEnd':
            case 'insideEndBottom':
              textPosition = [-distanceX * dir + toPos[0], toPos[1] + dy];
              textAlign = tangent[0] >= 0 ? 'right' : 'left';
              textOrigin = [distanceX * dir, -dy];
              break;
          }

          label.attr({
            style: {
              // Use the user specified text align and baseline first
              textVerticalAlign: label.__verticalAlign || textVerticalAlign,
              textAlign: label.__textAlign || textAlign
            },
            position: textPosition,
            scale: [invScale, invScale],
            origin: textOrigin
          });
        }
      }
      /**
       * @constructor
       * @extends {module:zrender/graphic/Group}
       * @alias {module:echarts/chart/helper/Line}
       */


      function Line(lineData, idx, seriesScope) {
        graphic.Group.call(this);

        this._createLine(lineData, idx, seriesScope);
      }

      var lineProto = Line.prototype; // Update symbol position and rotation

      lineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate;

      lineProto._createLine = function (lineData, idx, seriesScope) {
        var seriesModel = lineData.hostModel;
        var linePoints = lineData.getItemLayout(idx);
        var line = createLine(linePoints);
        line.shape.percent = 0;
        graphic.initProps(line, {
          shape: {
            percent: 1
          }
        }, seriesModel, idx);
        this.add(line);
        var label = new graphic.Text({
          name: 'label',
          // FIXME
          // Temporary solution for `focusNodeAdjacency`.
          // line label do not use the opacity of lineStyle.
          lineLabelOriginalOpacity: 1
        });
        this.add(label);
        zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {
          var symbol = createSymbol(symbolCategory, lineData, idx); // symbols must added after line to make sure
          // it will be updated after line#update.
          // Or symbol position and rotation update in line#beforeUpdate will be one frame slow

          this.add(symbol);
          this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);
        }, this);

        this._updateCommonStl(lineData, idx, seriesScope);
      };

      lineProto.updateData = function (lineData, idx, seriesScope) {
        var seriesModel = lineData.hostModel;
        var line = this.childOfName('line');
        var linePoints = lineData.getItemLayout(idx);
        var target = {
          shape: {}
        };
        setLinePoints(target.shape, linePoints);
        graphic.updateProps(line, target, seriesModel, idx);
        zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {
          var symbolType = lineData.getItemVisual(idx, symbolCategory);
          var key = makeSymbolTypeKey(symbolCategory); // Symbol changed

          if (this[key] !== symbolType) {
            this.remove(this.childOfName(symbolCategory));
            var symbol = createSymbol(symbolCategory, lineData, idx);
            this.add(symbol);
          }

          this[key] = symbolType;
        }, this);

        this._updateCommonStl(lineData, idx, seriesScope);
      };

      lineProto._updateCommonStl = function (lineData, idx, seriesScope) {
        var seriesModel = lineData.hostModel;
        var line = this.childOfName('line');
        var lineStyle = seriesScope && seriesScope.lineStyle;
        var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;
        var labelModel = seriesScope && seriesScope.labelModel;
        var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel; // Optimization for large dataset

        if (!seriesScope || lineData.hasItemOption) {
          var itemModel = lineData.getItemModel(idx);
          lineStyle = itemModel.getModel('lineStyle').getLineStyle();
          hoverLineStyle = itemModel.getModel('emphasis.lineStyle').getLineStyle();
          labelModel = itemModel.getModel('label');
          hoverLabelModel = itemModel.getModel('emphasis.label');
        }

        var visualColor = lineData.getItemVisual(idx, 'color');
        var visualOpacity = zrUtil.retrieve3(lineData.getItemVisual(idx, 'opacity'), lineStyle.opacity, 1);
        line.useStyle(zrUtil.defaults({
          strokeNoScale: true,
          fill: 'none',
          stroke: visualColor,
          opacity: visualOpacity
        }, lineStyle));
        line.hoverStyle = hoverLineStyle; // Update symbol

        zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {
          var symbol = this.childOfName(symbolCategory);

          if (symbol) {
            symbol.setColor(visualColor);
            symbol.setStyle({
              opacity: visualOpacity
            });
          }
        }, this);
        var showLabel = labelModel.getShallow('show');
        var hoverShowLabel = hoverLabelModel.getShallow('show');
        var label = this.childOfName('label');
        var defaultLabelColor;
        var baseText; // FIXME: the logic below probably should be merged to `graphic.setLabelStyle`.

        if (showLabel || hoverShowLabel) {
          defaultLabelColor = visualColor || '#000';
          baseText = seriesModel.getFormattedLabel(idx, 'normal', lineData.dataType);

          if (baseText == null) {
            var rawVal = seriesModel.getRawValue(idx);
            baseText = rawVal == null ? lineData.getName(idx) : isFinite(rawVal) ? round(rawVal) : rawVal;
          }
        }

        var normalText = showLabel ? baseText : null;
        var emphasisText = hoverShowLabel ? zrUtil.retrieve2(seriesModel.getFormattedLabel(idx, 'emphasis', lineData.dataType), baseText) : null;
        var labelStyle = label.style; // Always set `textStyle` even if `normalStyle.text` is null, because default
        // values have to be set on `normalStyle`.

        if (normalText != null || emphasisText != null) {
          graphic.setTextStyle(label.style, labelModel, {
            text: normalText
          }, {
            autoColor: defaultLabelColor
          });
          label.__textAlign = labelStyle.textAlign;
          label.__verticalAlign = labelStyle.textVerticalAlign; // 'start', 'middle', 'end'

          label.__position = labelModel.get('position') || 'middle';
          var distance = labelModel.get('distance');

          if (!zrUtil.isArray(distance)) {
            distance = [distance, distance];
          }

          label.__labelDistance = distance;
        }

        if (emphasisText != null) {
          // Only these properties supported in this emphasis style here.
          label.hoverStyle = {
            text: emphasisText,
            textFill: hoverLabelModel.getTextColor(true),
            // For merging hover style to normal style, do not use
            // `hoverLabelModel.getFont()` here.
            fontStyle: hoverLabelModel.getShallow('fontStyle'),
            fontWeight: hoverLabelModel.getShallow('fontWeight'),
            fontSize: hoverLabelModel.getShallow('fontSize'),
            fontFamily: hoverLabelModel.getShallow('fontFamily')
          };
        } else {
          label.hoverStyle = {
            text: null
          };
        }

        label.ignore = !showLabel && !hoverShowLabel;
        graphic.setHoverStyle(this);
      };

      lineProto.highlight = function () {
        this.trigger('emphasis');
      };

      lineProto.downplay = function () {
        this.trigger('normal');
      };

      lineProto.updateLayout = function (lineData, idx) {
        this.setLinePoints(lineData.getItemLayout(idx));
      };

      lineProto.setLinePoints = function (points) {
        var linePath = this.childOfName('line');
        setLinePoints(linePath.shape, points);
        linePath.dirty();
      };

      zrUtil.inherits(Line, graphic.Group);
      var _default = Line;
      module.exports = _default;
      /***/
    },

    /***/
    "g0SD":
    /*!********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/marker/MarkPointView.js ***!
      \********************************************************************/

    /*! no static exports found */

    /***/
    function g0SD(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var SymbolDraw = __webpack_require__(
      /*! ../../chart/helper/SymbolDraw */
      "9wZj");

      var numberUtil = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var List = __webpack_require__(
      /*! ../../data/List */
      "YXkt");

      var markerHelper = __webpack_require__(
      /*! ./markerHelper */
      "kj2x");

      var MarkerView = __webpack_require__(
      /*! ./MarkerView */
      "iPDy");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function updateMarkerLayout(mpData, seriesModel, api) {
        var coordSys = seriesModel.coordinateSystem;
        mpData.each(function (idx) {
          var itemModel = mpData.getItemModel(idx);
          var point;
          var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());
          var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());

          if (!isNaN(xPx) && !isNaN(yPx)) {
            point = [xPx, yPx];
          } // Chart like bar may have there own marker positioning logic
          else if (seriesModel.getMarkerPosition) {
            // Use the getMarkerPoisition
            point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));
          } else if (coordSys) {
            var x = mpData.get(coordSys.dimensions[0], idx);
            var y = mpData.get(coordSys.dimensions[1], idx);
            point = coordSys.dataToPoint([x, y]);
          } // Use x, y if has any


          if (!isNaN(xPx)) {
            point[0] = xPx;
          }

          if (!isNaN(yPx)) {
            point[1] = yPx;
          }

          mpData.setItemLayout(idx, point);
        });
      }

      var _default = MarkerView.extend({
        type: 'markPoint',
        // updateLayout: function (markPointModel, ecModel, api) {
        //     ecModel.eachSeries(function (seriesModel) {
        //         var mpModel = seriesModel.markPointModel;
        //         if (mpModel) {
        //             updateMarkerLayout(mpModel.getData(), seriesModel, api);
        //             this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);
        //         }
        //     }, this);
        // },
        updateTransform: function updateTransform(markPointModel, ecModel, api) {
          ecModel.eachSeries(function (seriesModel) {
            var mpModel = seriesModel.markPointModel;

            if (mpModel) {
              updateMarkerLayout(mpModel.getData(), seriesModel, api);
              this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);
            }
          }, this);
        },
        renderSeries: function renderSeries(seriesModel, mpModel, ecModel, api) {
          var coordSys = seriesModel.coordinateSystem;
          var seriesId = seriesModel.id;
          var seriesData = seriesModel.getData();
          var symbolDrawMap = this.markerGroupMap;
          var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw());
          var mpData = createList(coordSys, seriesModel, mpModel); // FIXME

          mpModel.setData(mpData);
          updateMarkerLayout(mpModel.getData(), seriesModel, api);
          mpData.each(function (idx) {
            var itemModel = mpData.getItemModel(idx);
            var symbol = itemModel.getShallow('symbol');
            var symbolSize = itemModel.getShallow('symbolSize');
            var symbolRotate = itemModel.getShallow('symbolRotate');
            var isFnSymbol = zrUtil.isFunction(symbol);
            var isFnSymbolSize = zrUtil.isFunction(symbolSize);
            var isFnSymbolRotate = zrUtil.isFunction(symbolRotate);

            if (isFnSymbol || isFnSymbolSize || isFnSymbolRotate) {
              var rawIdx = mpModel.getRawValue(idx);
              var dataParams = mpModel.getDataParams(idx);

              if (isFnSymbol) {
                symbol = symbol(rawIdx, dataParams);
              }

              if (isFnSymbolSize) {
                // FIXME  ECharts 2.x2.x 
                symbolSize = symbolSize(rawIdx, dataParams);
              }

              if (isFnSymbolRotate) {
                symbolRotate = symbolRotate(rawIdx, dataParams);
              }
            }

            mpData.setItemVisual(idx, {
              symbol: symbol,
              symbolSize: symbolSize,
              symbolRotate: symbolRotate,
              color: itemModel.get('itemStyle.color') || seriesData.getVisual('color')
            });
          }); // TODO Text are wrong

          symbolDraw.updateData(mpData);
          this.group.add(symbolDraw.group); // Set host model for tooltip
          // FIXME

          mpData.eachItemGraphicEl(function (el) {
            el.traverse(function (child) {
              child.dataModel = mpModel;
            });
          });
          symbolDraw.__keep = true;
          symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');
        }
      });
      /**
       * @inner
       * @param {module:echarts/coord/*} [coordSys]
       * @param {module:echarts/model/Series} seriesModel
       * @param {module:echarts/model/Model} mpModel
       */


      function createList(coordSys, seriesModel, mpModel) {
        var coordDimsInfos;

        if (coordSys) {
          coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {
            var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys

            return zrUtil.defaults({
              name: coordDim
            }, info);
          });
        } else {
          coordDimsInfos = [{
            name: 'value',
            type: 'float'
          }];
        }

        var mpData = new List(coordDimsInfos, mpModel);
        var dataOpt = zrUtil.map(mpModel.get('data'), zrUtil.curry(markerHelper.dataTransform, seriesModel));

        if (coordSys) {
          dataOpt = zrUtil.filter(dataOpt, zrUtil.curry(markerHelper.dataFilter, coordSys));
        }

        mpData.initData(dataOpt, null, coordSys ? markerHelper.dimValueGetter : function (item) {
          return item.value;
        });
        return mpData;
      }

      module.exports = _default;
      /***/
    },

    /***/
    "g7p0":
    /*!******************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/calendar/CalendarModel.js ***!
      \******************************************************************/

    /*! no static exports found */

    /***/
    function g7p0(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var ComponentModel = __webpack_require__(
      /*! ../../model/Component */
      "bLfw");

      var _layout = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var getLayoutParams = _layout.getLayoutParams;
      var sizeCalculable = _layout.sizeCalculable;
      var mergeLayoutParam = _layout.mergeLayoutParam;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var CalendarModel = ComponentModel.extend({
        type: 'calendar',

        /**
         * @type {module:echarts/coord/calendar/Calendar}
         */
        coordinateSystem: null,
        defaultOption: {
          zlevel: 0,
          z: 2,
          left: 80,
          top: 60,
          cellSize: 20,
          // horizontal vertical
          orient: 'horizontal',
          // month separate line style
          splitLine: {
            show: true,
            lineStyle: {
              color: '#000',
              width: 1,
              type: 'solid'
            }
          },
          // rect style  temporarily unused emphasis
          itemStyle: {
            color: '#fff',
            borderWidth: 1,
            borderColor: '#ccc'
          },
          // week text style
          dayLabel: {
            show: true,
            // a week first day
            firstDay: 0,
            // start end
            position: 'start',
            margin: '50%',
            // 50% of cellSize
            nameMap: 'en',
            color: '#000'
          },
          // month text style
          monthLabel: {
            show: true,
            // start end
            position: 'start',
            margin: 5,
            // center or left
            align: 'center',
            // cn en []
            nameMap: 'en',
            formatter: null,
            color: '#000'
          },
          // year text style
          yearLabel: {
            show: true,
            // top bottom left right
            position: null,
            margin: 30,
            formatter: null,
            color: '#ccc',
            fontFamily: 'sans-serif',
            fontWeight: 'bolder',
            fontSize: 20
          }
        },

        /**
         * @override
         */
        init: function init(option, parentModel, ecModel, extraOpt) {
          var inputPositionParams = getLayoutParams(option);
          CalendarModel.superApply(this, 'init', arguments);
          mergeAndNormalizeLayoutParams(option, inputPositionParams);
        },

        /**
         * @override
         */
        mergeOption: function mergeOption(option, extraOpt) {
          CalendarModel.superApply(this, 'mergeOption', arguments);
          mergeAndNormalizeLayoutParams(this.option, option);
        }
      });

      function mergeAndNormalizeLayoutParams(target, raw) {
        // Normalize cellSize
        var cellSize = target.cellSize;

        if (!zrUtil.isArray(cellSize)) {
          cellSize = target.cellSize = [cellSize, cellSize];
        } else if (cellSize.length === 1) {
          cellSize[1] = cellSize[0];
        }

        var ignoreSize = zrUtil.map([0, 1], function (hvIdx) {
          // If user have set `width` or both `left` and `right`, cellSize
          // will be automatically set to 'auto', otherwise the default
          // setting of cellSize will make `width` setting not work.
          if (sizeCalculable(raw, hvIdx)) {
            cellSize[hvIdx] = 'auto';
          }

          return cellSize[hvIdx] != null && cellSize[hvIdx] !== 'auto';
        });
        mergeLayoutParam(target, raw, {
          type: 'box',
          ignoreSize: ignoreSize
        });
      }

      var _default = CalendarModel;
      module.exports = _default;
      /***/
    },

    /***/
    "gawk":
    /*!***************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/sankey/sankeyLayout.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function gawk(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var layout = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _model = __webpack_require__(
      /*! ../../util/model */
      "4NO4");

      var groupData = _model.groupData;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      function _default(ecModel, api, payload) {
        ecModel.eachSeriesByType('sankey', function (seriesModel) {
          var nodeWidth = seriesModel.get('nodeWidth');
          var nodeGap = seriesModel.get('nodeGap');
          var layoutInfo = getViewRect(seriesModel, api);
          seriesModel.layoutInfo = layoutInfo;
          var width = layoutInfo.width;
          var height = layoutInfo.height;
          var graph = seriesModel.getGraph();
          var nodes = graph.nodes;
          var edges = graph.edges;
          computeNodeValues(nodes);
          var filteredNodes = zrUtil.filter(nodes, function (node) {
            return node.getLayout().value === 0;
          });
          var iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get('layoutIterations');
          var orient = seriesModel.get('orient');
          var nodeAlign = seriesModel.get('nodeAlign');
          layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign);
        });
      }
      /**
       * Get the layout position of the whole view
       *
       * @param {module:echarts/model/Series} seriesModel  the model object of sankey series
       * @param {module:echarts/ExtensionAPI} api  provide the API list that the developer can call
       * @return {module:zrender/core/BoundingRect}  size of rect to draw the sankey view
       */


      function getViewRect(seriesModel, api) {
        return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
          width: api.getWidth(),
          height: api.getHeight()
        });
      }

      function layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign) {
        computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign);
        computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient);
        computeEdgeDepths(nodes, orient);
      }
      /**
       * Compute the value of each node by summing the associated edge's value
       *
       * @param {module:echarts/data/Graph~Node} nodes  node of sankey view
       */


      function computeNodeValues(nodes) {
        zrUtil.each(nodes, function (node) {
          var value1 = sum(node.outEdges, getEdgeValue);
          var value2 = sum(node.inEdges, getEdgeValue);
          var nodeRawValue = node.getValue() || 0;
          var value = Math.max(value1, value2, nodeRawValue);
          node.setLayout({
            value: value
          }, true);
        });
      }
      /**
       * Compute the x-position for each node.
       *
       * Here we use Kahn algorithm to detect cycle when we traverse
       * the node to computer the initial x position.
       *
       * @param {module:echarts/data/Graph~Node} nodes  node of sankey view
       * @param  {number} nodeWidth  the dx of the node
       * @param  {number} width  the whole width of the area to draw the view
       */


      function computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign) {
        // Used to mark whether the edge is deleted. if it is deleted,
        // the value is 0, otherwise it is 1.
        var remainEdges = []; // Storage each node's indegree.

        var indegreeArr = []; //Used to storage the node with indegree is equal to 0.

        var zeroIndegrees = [];
        var nextTargetNode = [];
        var x = 0;
        var kx = 0;

        for (var i = 0; i < edges.length; i++) {
          remainEdges[i] = 1;
        }

        for (i = 0; i < nodes.length; i++) {
          indegreeArr[i] = nodes[i].inEdges.length;

          if (indegreeArr[i] === 0) {
            zeroIndegrees.push(nodes[i]);
          }
        }

        var maxNodeDepth = -1; // Traversing nodes using topological sorting to calculate the
        // horizontal(if orient === 'horizontal') or vertical(if orient === 'vertical')
        // position of the nodes.

        while (zeroIndegrees.length) {
          for (var idx = 0; idx < zeroIndegrees.length; idx++) {
            var node = zeroIndegrees[idx];
            var item = node.hostGraph.data.getRawDataItem(node.dataIndex);
            var isItemDepth = item.depth != null && item.depth >= 0;

            if (isItemDepth && item.depth > maxNodeDepth) {
              maxNodeDepth = item.depth;
            }

            node.setLayout({
              depth: isItemDepth ? item.depth : x
            }, true);
            orient === 'vertical' ? node.setLayout({
              dy: nodeWidth
            }, true) : node.setLayout({
              dx: nodeWidth
            }, true);

            for (var edgeIdx = 0; edgeIdx < node.outEdges.length; edgeIdx++) {
              var edge = node.outEdges[edgeIdx];
              var indexEdge = edges.indexOf(edge);
              remainEdges[indexEdge] = 0;
              var targetNode = edge.node2;
              var nodeIndex = nodes.indexOf(targetNode);

              if (--indegreeArr[nodeIndex] === 0 && nextTargetNode.indexOf(targetNode) < 0) {
                nextTargetNode.push(targetNode);
              }
            }
          }

          ++x;
          zeroIndegrees = nextTargetNode;
          nextTargetNode = [];
        }

        for (i = 0; i < remainEdges.length; i++) {
          if (remainEdges[i] === 1) {
            throw new Error('Sankey is a DAG, the original data has cycle!');
          }
        }

        var maxDepth = maxNodeDepth > x - 1 ? maxNodeDepth : x - 1;

        if (nodeAlign && nodeAlign !== 'left') {
          adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth);
        }

        var kx = orient === 'vertical' ? (height - nodeWidth) / maxDepth : (width - nodeWidth) / maxDepth;
        scaleNodeBreadths(nodes, kx, orient);
      }

      function isNodeDepth(node) {
        var item = node.hostGraph.data.getRawDataItem(node.dataIndex);
        return item.depth != null && item.depth >= 0;
      }

      function adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth) {
        if (nodeAlign === 'right') {
          var nextSourceNode = [];
          var remainNodes = nodes;
          var nodeHeight = 0;

          while (remainNodes.length) {
            for (var i = 0; i < remainNodes.length; i++) {
              var node = remainNodes[i];
              node.setLayout({
                skNodeHeight: nodeHeight
              }, true);

              for (var j = 0; j < node.inEdges.length; j++) {
                var edge = node.inEdges[j];

                if (nextSourceNode.indexOf(edge.node1) < 0) {
                  nextSourceNode.push(edge.node1);
                }
              }
            }

            remainNodes = nextSourceNode;
            nextSourceNode = [];
            ++nodeHeight;
          }

          zrUtil.each(nodes, function (node) {
            if (!isNodeDepth(node)) {
              node.setLayout({
                depth: Math.max(0, maxDepth - node.getLayout().skNodeHeight)
              }, true);
            }
          });
        } else if (nodeAlign === 'justify') {
          moveSinksRight(nodes, maxDepth);
        }
      }
      /**
       * All the node without outEgdes are assigned maximum x-position and
       *     be aligned in the last column.
       *
       * @param {module:echarts/data/Graph~Node} nodes.  node of sankey view.
       * @param {number} maxDepth.  use to assign to node without outEdges as x-position.
       */


      function moveSinksRight(nodes, maxDepth) {
        zrUtil.each(nodes, function (node) {
          if (!isNodeDepth(node) && !node.outEdges.length) {
            node.setLayout({
              depth: maxDepth
            }, true);
          }
        });
      }
      /**
       * Scale node x-position to the width
       *
       * @param {module:echarts/data/Graph~Node} nodes  node of sankey view
       * @param {number} kx   multiple used to scale nodes
       */


      function scaleNodeBreadths(nodes, kx, orient) {
        zrUtil.each(nodes, function (node) {
          var nodeDepth = node.getLayout().depth * kx;
          orient === 'vertical' ? node.setLayout({
            y: nodeDepth
          }, true) : node.setLayout({
            x: nodeDepth
          }, true);
        });
      }
      /**
       * Using Gauss-Seidel iterations method to compute the node depth(y-position)
       *
       * @param {module:echarts/data/Graph~Node} nodes  node of sankey view
       * @param {module:echarts/data/Graph~Edge} edges  edge of sankey view
       * @param {number} height  the whole height of the area to draw the view
       * @param {number} nodeGap  the vertical distance between two nodes
       *     in the same column.
       * @param {number} iterations  the number of iterations for the algorithm
       */


      function computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient) {
        var nodesByBreadth = prepareNodesByBreadth(nodes, orient);
        initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient);
        resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);

        for (var alpha = 1; iterations > 0; iterations--) {
          // 0.99 is a experience parameter, ensure that each iterations of
          // changes as small as possible.
          alpha *= 0.99;
          relaxRightToLeft(nodesByBreadth, alpha, orient);
          resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
          relaxLeftToRight(nodesByBreadth, alpha, orient);
          resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
        }
      }

      function prepareNodesByBreadth(nodes, orient) {
        var nodesByBreadth = [];
        var keyAttr = orient === 'vertical' ? 'y' : 'x';
        var groupResult = groupData(nodes, function (node) {
          return node.getLayout()[keyAttr];
        });
        groupResult.keys.sort(function (a, b) {
          return a - b;
        });
        zrUtil.each(groupResult.keys, function (key) {
          nodesByBreadth.push(groupResult.buckets.get(key));
        });
        return nodesByBreadth;
      }
      /**
       * Compute the original y-position for each node
       *
       * @param {module:echarts/data/Graph~Node} nodes  node of sankey view
       * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth
       *     group by the array of all sankey nodes based on the nodes x-position.
       * @param {module:echarts/data/Graph~Edge} edges  edge of sankey view
       * @param {number} height  the whole height of the area to draw the view
       * @param {number} nodeGap  the vertical distance between two nodes
       */


      function initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient) {
        var minKy = Infinity;
        zrUtil.each(nodesByBreadth, function (nodes) {
          var n = nodes.length;
          var sum = 0;
          zrUtil.each(nodes, function (node) {
            sum += node.getLayout().value;
          });
          var ky = orient === 'vertical' ? (width - (n - 1) * nodeGap) / sum : (height - (n - 1) * nodeGap) / sum;

          if (ky < minKy) {
            minKy = ky;
          }
        });
        zrUtil.each(nodesByBreadth, function (nodes) {
          zrUtil.each(nodes, function (node, i) {
            var nodeDy = node.getLayout().value * minKy;

            if (orient === 'vertical') {
              node.setLayout({
                x: i
              }, true);
              node.setLayout({
                dx: nodeDy
              }, true);
            } else {
              node.setLayout({
                y: i
              }, true);
              node.setLayout({
                dy: nodeDy
              }, true);
            }
          });
        });
        zrUtil.each(edges, function (edge) {
          var edgeDy = +edge.getValue() * minKy;
          edge.setLayout({
            dy: edgeDy
          }, true);
        });
      }
      /**
       * Resolve the collision of initialized depth (y-position)
       *
       * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth
       *     group by the array of all sankey nodes based on the nodes x-position.
       * @param {number} nodeGap  the vertical distance between two nodes
       * @param {number} height  the whole height of the area to draw the view
       */


      function resolveCollisions(nodesByBreadth, nodeGap, height, width, orient) {
        var keyAttr = orient === 'vertical' ? 'x' : 'y';
        zrUtil.each(nodesByBreadth, function (nodes) {
          nodes.sort(function (a, b) {
            return a.getLayout()[keyAttr] - b.getLayout()[keyAttr];
          });
          var nodeX;
          var node;
          var dy;
          var y0 = 0;
          var n = nodes.length;
          var nodeDyAttr = orient === 'vertical' ? 'dx' : 'dy';

          for (var i = 0; i < n; i++) {
            node = nodes[i];
            dy = y0 - node.getLayout()[keyAttr];

            if (dy > 0) {
              nodeX = node.getLayout()[keyAttr] + dy;
              orient === 'vertical' ? node.setLayout({
                x: nodeX
              }, true) : node.setLayout({
                y: nodeX
              }, true);
            }

            y0 = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap;
          }

          var viewWidth = orient === 'vertical' ? width : height; // If the bottommost node goes outside the bounds, push it back up

          dy = y0 - nodeGap - viewWidth;

          if (dy > 0) {
            nodeX = node.getLayout()[keyAttr] - dy;
            orient === 'vertical' ? node.setLayout({
              x: nodeX
            }, true) : node.setLayout({
              y: nodeX
            }, true);
            y0 = nodeX;

            for (i = n - 2; i >= 0; --i) {
              node = nodes[i];
              dy = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap - y0;

              if (dy > 0) {
                nodeX = node.getLayout()[keyAttr] - dy;
                orient === 'vertical' ? node.setLayout({
                  x: nodeX
                }, true) : node.setLayout({
                  y: nodeX
                }, true);
              }

              y0 = node.getLayout()[keyAttr];
            }
          }
        });
      }
      /**
       * Change the y-position of the nodes, except most the right side nodes
       *
       * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth
       *     group by the array of all sankey nodes based on the node x-position.
       * @param {number} alpha  parameter used to adjust the nodes y-position
       */


      function relaxRightToLeft(nodesByBreadth, alpha, orient) {
        zrUtil.each(nodesByBreadth.slice().reverse(), function (nodes) {
          zrUtil.each(nodes, function (node) {
            if (node.outEdges.length) {
              var y = sum(node.outEdges, weightedTarget, orient) / sum(node.outEdges, getEdgeValue, orient);

              if (isNaN(y)) {
                var len = node.outEdges.length;
                y = len ? sum(node.outEdges, centerTarget, orient) / len : 0;
              }

              if (orient === 'vertical') {
                var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;
                node.setLayout({
                  x: nodeX
                }, true);
              } else {
                var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;
                node.setLayout({
                  y: nodeY
                }, true);
              }
            }
          });
        });
      }

      function weightedTarget(edge, orient) {
        return center(edge.node2, orient) * edge.getValue();
      }

      function centerTarget(edge, orient) {
        return center(edge.node2, orient);
      }

      function weightedSource(edge, orient) {
        return center(edge.node1, orient) * edge.getValue();
      }

      function centerSource(edge, orient) {
        return center(edge.node1, orient);
      }

      function center(node, orient) {
        return orient === 'vertical' ? node.getLayout().x + node.getLayout().dx / 2 : node.getLayout().y + node.getLayout().dy / 2;
      }

      function getEdgeValue(edge) {
        return edge.getValue();
      }

      function sum(array, cb, orient) {
        var sum = 0;
        var len = array.length;
        var i = -1;

        while (++i < len) {
          var value = +cb.call(array, array[i], orient);

          if (!isNaN(value)) {
            sum += value;
          }
        }

        return sum;
      }
      /**
       * Change the y-position of the nodes, except most the left side nodes
       *
       * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth
       *     group by the array of all sankey nodes based on the node x-position.
       * @param {number} alpha  parameter used to adjust the nodes y-position
       */


      function relaxLeftToRight(nodesByBreadth, alpha, orient) {
        zrUtil.each(nodesByBreadth, function (nodes) {
          zrUtil.each(nodes, function (node) {
            if (node.inEdges.length) {
              var y = sum(node.inEdges, weightedSource, orient) / sum(node.inEdges, getEdgeValue, orient);

              if (isNaN(y)) {
                var len = node.inEdges.length;
                y = len ? sum(node.inEdges, centerSource, orient) / len : 0;
              }

              if (orient === 'vertical') {
                var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;
                node.setLayout({
                  x: nodeX
                }, true);
              } else {
                var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;
                node.setLayout({
                  y: nodeY
                }, true);
              }
            }
          });
        });
      }
      /**
       * Compute the depth(y-position) of each edge
       *
       * @param {module:echarts/data/Graph~Node} nodes  node of sankey view
       */


      function computeEdgeDepths(nodes, orient) {
        var keyAttr = orient === 'vertical' ? 'x' : 'y';
        zrUtil.each(nodes, function (node) {
          node.outEdges.sort(function (a, b) {
            return a.node2.getLayout()[keyAttr] - b.node2.getLayout()[keyAttr];
          });
          node.inEdges.sort(function (a, b) {
            return a.node1.getLayout()[keyAttr] - b.node1.getLayout()[keyAttr];
          });
        });
        zrUtil.each(nodes, function (node) {
          var sy = 0;
          var ty = 0;
          zrUtil.each(node.outEdges, function (edge) {
            edge.setLayout({
              sy: sy
            }, true);
            sy += edge.getLayout().dy;
          });
          zrUtil.each(node.inEdges, function (edge) {
            edge.setLayout({
              ty: ty
            }, true);
            ty += edge.getLayout().dy;
          });
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "gvm7":
    /*!**************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/tooltip/TooltipRichContent.js ***!
      \**************************************************************************/

    /*! no static exports found */

    /***/
    function gvm7(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var Text = __webpack_require__(
      /*! zrender/lib/graphic/Text */
      "dqUG");

      var graphicUtil = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // import Group from 'zrender/src/container/Group';


      function makeStyleCoord(out, zr, zrX, zrY) {
        out[0] = zrX;
        out[1] = zrY;
        out[2] = out[0] / zr.getWidth(); // The ratio of left to width

        out[3] = out[1] / zr.getHeight(); // The ratio of top to height
      }
      /**
       * @alias module:echarts/component/tooltip/TooltipRichContent
       * @constructor
       */


      function TooltipRichContent(api) {
        var zr = this._zr = api.getZr();
        this._styleCoord = [0, 0, 0, 0]; // [left, top, left/width, top/height]

        makeStyleCoord(this._styleCoord, zr, api.getWidth() / 2, api.getHeight() / 2);
        this._show = false;
        /**
         * @private
         */

        this._hideTimeout;
      }

      TooltipRichContent.prototype = {
        constructor: TooltipRichContent,

        /**
         * @private
         * @type {boolean}
         */
        _enterable: true,

        /**
         * Update when tooltip is rendered
         */
        update: function update(tooltipModel) {
          var alwaysShowContent = tooltipModel.get('alwaysShowContent');
          alwaysShowContent && this._moveTooltipIfResized();
        },

        /**
         * when `alwaysShowContent` is true,
         * we should move the tooltip after chart resized
         */
        _moveTooltipIfResized: function _moveTooltipIfResized() {
          var ratioX = this._styleCoord[2]; // The ratio of left to width

          var ratioY = this._styleCoord[3]; // The ratio of top to height

          var realX = ratioX * this._zr.getWidth();

          var realY = ratioY * this._zr.getHeight();

          this.moveTo(realX, realY);
        },
        show: function show(tooltipModel) {
          if (this._hideTimeout) {
            clearTimeout(this._hideTimeout);
          }

          this.el.attr('show', true);
          this._show = true;
        },

        /**
         * Set tooltip content
         *
         * @param {string} content rich text string of content
         * @param {Object} markerRich rich text style
         * @param {Object} tooltipModel tooltip model
         */
        setContent: function setContent(content, markerRich, tooltipModel) {
          if (this.el) {
            this._zr.remove(this.el);
          }

          var markers = {};
          var text = content;
          var prefix = '{marker';
          var suffix = '|}';
          var startId = text.indexOf(prefix);

          while (startId >= 0) {
            var endId = text.indexOf(suffix);
            var name = text.substr(startId + prefix.length, endId - startId - prefix.length);

            if (name.indexOf('sub') > -1) {
              markers['marker' + name] = {
                textWidth: 4,
                textHeight: 4,
                textBorderRadius: 2,
                textBackgroundColor: markerRich[name],
                // TODO: textOffset is not implemented for rich text
                textOffset: [3, 0]
              };
            } else {
              markers['marker' + name] = {
                textWidth: 10,
                textHeight: 10,
                textBorderRadius: 5,
                textBackgroundColor: markerRich[name]
              };
            }

            text = text.substr(endId + 1);
            startId = text.indexOf('{marker');
          }

          var textStyleModel = tooltipModel.getModel('textStyle');
          var fontSize = textStyleModel.get('fontSize');
          var lineHeight = tooltipModel.get('textLineHeight');

          if (lineHeight == null) {
            lineHeight = Math.round(fontSize * 3 / 2);
          }

          this.el = new Text({
            style: graphicUtil.setTextStyle({}, textStyleModel, {
              rich: markers,
              text: content,
              textBackgroundColor: tooltipModel.get('backgroundColor'),
              textBorderRadius: tooltipModel.get('borderRadius'),
              textFill: tooltipModel.get('textStyle.color'),
              textPadding: tooltipModel.get('padding'),
              textLineHeight: lineHeight
            }),
            z: tooltipModel.get('z')
          });

          this._zr.add(this.el);

          var self = this;
          this.el.on('mouseover', function () {
            // clear the timeout in hideLater and keep showing tooltip
            if (self._enterable) {
              clearTimeout(self._hideTimeout);
              self._show = true;
            }

            self._inContent = true;
          });
          this.el.on('mouseout', function () {
            if (self._enterable) {
              if (self._show) {
                self.hideLater(self._hideDelay);
              }
            }

            self._inContent = false;
          });
        },
        setEnterable: function setEnterable(enterable) {
          this._enterable = enterable;
        },
        getSize: function getSize() {
          var bounding = this.el.getBoundingRect();
          return [bounding.width, bounding.height];
        },
        moveTo: function moveTo(x, y) {
          if (this.el) {
            var styleCoord = this._styleCoord;
            makeStyleCoord(styleCoord, this._zr, x, y);
            this.el.attr('position', [styleCoord[0], styleCoord[1]]);
          }
        },
        hide: function hide() {
          if (this.el) {
            this.el.hide();
          }

          this._show = false;
        },
        hideLater: function hideLater(time) {
          if (this._show && !(this._inContent && this._enterable)) {
            if (time) {
              this._hideDelay = time; // Set show false to avoid invoke hideLater multiple times

              this._show = false;
              this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);
            } else {
              this.hide();
            }
          }
        },
        isShow: function isShow() {
          return this._show;
        },
        dispose: function dispose() {
          clearTimeout(this._hideTimeout);

          if (this.el) {
            this._zr.remove(this.el);
          }
        },
        getOuterSize: function getOuterSize() {
          var size = this.getSize();
          return {
            width: size[0],
            height: size[1]
          };
        }
      };
      var _default = TooltipRichContent;
      module.exports = _default;
      /***/
    },

    /***/
    "h54F":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/graph/GraphSeries.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function h54F(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var List = __webpack_require__(
      /*! ../../data/List */
      "YXkt");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _model = __webpack_require__(
      /*! ../../util/model */
      "4NO4");

      var defaultEmphasis = _model.defaultEmphasis;

      var Model = __webpack_require__(
      /*! ../../model/Model */
      "Qxkt");

      var _format = __webpack_require__(
      /*! ../../util/format */
      "7aKB");

      var encodeHTML = _format.encodeHTML;

      var createGraphFromNodeEdge = __webpack_require__(
      /*! ../helper/createGraphFromNodeEdge */
      "I3/A");

      var LegendVisualProvider = __webpack_require__(
      /*! ../../visual/LegendVisualProvider */
      "xKMd");

      var _multipleGraphEdgeHelper = __webpack_require__(
      /*! ../helper/multipleGraphEdgeHelper */
      "DDd/");

      var initCurvenessList = _multipleGraphEdgeHelper.initCurvenessList;
      var createEdgeMapForCurveness = _multipleGraphEdgeHelper.createEdgeMapForCurveness;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var GraphSeries = echarts.extendSeriesModel({
        type: 'series.graph',
        init: function init(option) {
          GraphSeries.superApply(this, 'init', arguments);
          var self = this;

          function getCategoriesData() {
            return self._categoriesData;
          } // Provide data for legend select


          this.legendVisualProvider = new LegendVisualProvider(getCategoriesData, getCategoriesData);
          this.fillDataTextStyle(option.edges || option.links);

          this._updateCategoriesData();
        },
        mergeOption: function mergeOption(option) {
          GraphSeries.superApply(this, 'mergeOption', arguments);
          this.fillDataTextStyle(option.edges || option.links);

          this._updateCategoriesData();
        },
        mergeDefaultAndTheme: function mergeDefaultAndTheme(option) {
          GraphSeries.superApply(this, 'mergeDefaultAndTheme', arguments);
          defaultEmphasis(option, ['edgeLabel'], ['show']);
        },
        getInitialData: function getInitialData(option, ecModel) {
          var edges = option.edges || option.links || [];
          var nodes = option.data || option.nodes || [];
          var self = this;

          if (nodes && edges) {
            // auto curveness
            initCurvenessList(this);
            var graph = createGraphFromNodeEdge(nodes, edges, this, true, beforeLink);
            zrUtil.each(graph.edges, function (edge) {
              createEdgeMapForCurveness(edge.node1, edge.node2, this, edge.dataIndex);
            }, this);
            return graph.data;
          }

          function beforeLink(nodeData, edgeData) {
            // Overwrite nodeData.getItemModel to
            nodeData.wrapMethod('getItemModel', function (model) {
              var categoriesModels = self._categoriesModels;
              var categoryIdx = model.getShallow('category');
              var categoryModel = categoriesModels[categoryIdx];

              if (categoryModel) {
                categoryModel.parentModel = model.parentModel;
                model.parentModel = categoryModel;
              }

              return model;
            });
            var edgeLabelModel = self.getModel('edgeLabel'); // For option `edgeLabel` can be found by label.xxx.xxx on item mode.

            var fakeSeriesModel = new Model({
              label: edgeLabelModel.option
            }, edgeLabelModel.parentModel, ecModel);
            var emphasisEdgeLabelModel = self.getModel('emphasis.edgeLabel');
            var emphasisFakeSeriesModel = new Model({
              emphasis: {
                label: emphasisEdgeLabelModel.option
              }
            }, emphasisEdgeLabelModel.parentModel, ecModel);
            edgeData.wrapMethod('getItemModel', function (model) {
              model.customizeGetParent(edgeGetParent);
              return model;
            });

            function edgeGetParent(path) {
              path = this.parsePath(path);
              return path && path[0] === 'label' ? fakeSeriesModel : path && path[0] === 'emphasis' && path[1] === 'label' ? emphasisFakeSeriesModel : this.parentModel;
            }
          }
        },

        /**
         * @return {module:echarts/data/Graph}
         */
        getGraph: function getGraph() {
          return this.getData().graph;
        },

        /**
         * @return {module:echarts/data/List}
         */
        getEdgeData: function getEdgeData() {
          return this.getGraph().edgeData;
        },

        /**
         * @return {module:echarts/data/List}
         */
        getCategoriesData: function getCategoriesData() {
          return this._categoriesData;
        },

        /**
         * @override
         */
        formatTooltip: function formatTooltip(dataIndex, multipleSeries, dataType) {
          if (dataType === 'edge') {
            var nodeData = this.getData();
            var params = this.getDataParams(dataIndex, dataType);
            var edge = nodeData.graph.getEdgeByIndex(dataIndex);
            var sourceName = nodeData.getName(edge.node1.dataIndex);
            var targetName = nodeData.getName(edge.node2.dataIndex);
            var html = [];
            sourceName != null && html.push(sourceName);
            targetName != null && html.push(targetName);
            html = encodeHTML(html.join(' > '));

            if (params.value) {
              html += ' : ' + encodeHTML(params.value);
            }

            return html;
          } else {
            // dataType === 'node' or empty
            return GraphSeries.superApply(this, 'formatTooltip', arguments);
          }
        },
        _updateCategoriesData: function _updateCategoriesData() {
          var categories = zrUtil.map(this.option.categories || [], function (category) {
            // Data must has value
            return category.value != null ? category : zrUtil.extend({
              value: 0
            }, category);
          });
          var categoriesData = new List(['value'], this);
          categoriesData.initData(categories);
          this._categoriesData = categoriesData;
          this._categoriesModels = categoriesData.mapArray(function (idx) {
            return categoriesData.getItemModel(idx, true);
          });
        },
        setZoom: function setZoom(zoom) {
          this.option.zoom = zoom;
        },
        setCenter: function setCenter(center) {
          this.option.center = center;
        },
        isAnimationEnabled: function isAnimationEnabled() {
          return GraphSeries.superCall(this, 'isAnimationEnabled') // Not enable animation when do force layout
          && !(this.get('layout') === 'force' && this.get('force.layoutAnimation'));
        },
        defaultOption: {
          zlevel: 0,
          z: 2,
          coordinateSystem: 'view',
          // Default option for all coordinate systems
          // xAxisIndex: 0,
          // yAxisIndex: 0,
          // polarIndex: 0,
          // geoIndex: 0,
          legendHoverLink: true,
          hoverAnimation: true,
          layout: null,
          focusNodeAdjacency: false,
          // Configuration of circular layout
          circular: {
            rotateLabel: false
          },
          // Configuration of force directed layout
          force: {
            initLayout: null,
            // Node repulsion. Can be an array to represent range.
            repulsion: [0, 50],
            gravity: 0.1,
            // Initial friction
            friction: 0.6,
            // Edge length. Can be an array to represent range.
            edgeLength: 30,
            layoutAnimation: true
          },
          left: 'center',
          top: 'center',
          // right: null,
          // bottom: null,
          // width: '80%',
          // height: '80%',
          symbol: 'circle',
          symbolSize: 10,
          edgeSymbol: ['none', 'none'],
          edgeSymbolSize: 10,
          edgeLabel: {
            position: 'middle',
            distance: 5
          },
          draggable: false,
          roam: false,
          // Default on center of graph
          center: null,
          zoom: 1,
          // Symbol size scale ratio in roam
          nodeScaleRatio: 0.6,
          // cursor: null,
          // categories: [],
          // data: []
          // Or
          // nodes: []
          //
          // links: []
          // Or
          // edges: []
          label: {
            show: false,
            formatter: '{b}'
          },
          itemStyle: {},
          lineStyle: {
            color: '#aaa',
            width: 1,
            opacity: 0.5
          },
          emphasis: {
            label: {
              show: true
            }
          }
        }
      });
      var _default = GraphSeries;
      module.exports = _default;
      /***/
    },

    /***/
    "h8O9":
    /*!***************************************************!*\
      !*** ./node_modules/echarts/lib/layout/points.js ***!
      \***************************************************/

    /*! no static exports found */

    /***/
    function h8O9(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _util = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var map = _util.map;

      var createRenderPlanner = __webpack_require__(
      /*! ../chart/helper/createRenderPlanner */
      "zM3Q");

      var _dataStackHelper = __webpack_require__(
      /*! ../data/helper/dataStackHelper */
      "7hqr");

      var isDimensionStacked = _dataStackHelper.isDimensionStacked;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /* global Float32Array */

      function _default(seriesType) {
        return {
          seriesType: seriesType,
          plan: createRenderPlanner(),
          reset: function reset(seriesModel) {
            var data = seriesModel.getData();
            var coordSys = seriesModel.coordinateSystem;
            var pipelineContext = seriesModel.pipelineContext;
            var isLargeRender = pipelineContext.large;

            if (!coordSys) {
              return;
            }

            var dims = map(coordSys.dimensions, function (dim) {
              return data.mapDimension(dim);
            }).slice(0, 2);
            var dimLen = dims.length;
            var stackResultDim = data.getCalculationInfo('stackResultDimension');

            if (isDimensionStacked(data, dims[0]
            /*, dims[1]*/
            )) {
              dims[0] = stackResultDim;
            }

            if (isDimensionStacked(data, dims[1]
            /*, dims[0]*/
            )) {
              dims[1] = stackResultDim;
            }

            function progress(params, data) {
              var segCount = params.end - params.start;
              var points = isLargeRender && new Float32Array(segCount * dimLen);

              for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {
                var point;

                if (dimLen === 1) {
                  var x = data.get(dims[0], i);
                  point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);
                } else {
                  var x = tmpIn[0] = data.get(dims[0], i);
                  var y = tmpIn[1] = data.get(dims[1], i); // Also {Array.<number>}, not undefined to avoid if...else... statement

                  point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);
                }

                if (isLargeRender) {
                  points[offset++] = point ? point[0] : NaN;
                  points[offset++] = point ? point[1] : NaN;
                } else {
                  data.setItemLayout(i, point && point.slice() || [NaN, NaN]);
                }
              }

              isLargeRender && data.setLayout('symbolPoints', points);
            }

            return dimLen && {
              progress: progress
            };
          }
        };
      }

      module.exports = _default;
      /***/
    },

    /***/
    "hFmY":
    /*!***********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/axis/parallelAxisAction.js ***!
      \***********************************************************************/

    /*! no static exports found */

    /***/
    function hFmY(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @payload
       * @property {string} parallelAxisId
       * @property {Array.<Array.<number>>} intervals
       */


      var actionInfo = {
        type: 'axisAreaSelect',
        event: 'axisAreaSelected' // update: 'updateVisual'

      };
      echarts.registerAction(actionInfo, function (payload, ecModel) {
        ecModel.eachComponent({
          mainType: 'parallelAxis',
          query: payload
        }, function (parallelAxisModel) {
          parallelAxisModel.axis.model.setActiveIntervals(payload.intervals);
        });
      });
      /**
       * @payload
       */

      echarts.registerAction('parallelAxisExpand', function (payload, ecModel) {
        ecModel.eachComponent({
          mainType: 'parallel',
          query: payload
        }, function (parallelModel) {
          parallelModel.setAxisExpand(payload);
        });
      });
      /***/
    },

    /***/
    "hJvP":
    /*!********************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/parallel/parallelCreator.js ***!
      \********************************************************************/

    /*! no static exports found */

    /***/
    function hJvP(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var Parallel = __webpack_require__(
      /*! ./Parallel */
      "2dDv");

      var CoordinateSystem = __webpack_require__(
      /*! ../../CoordinateSystem */
      "IDmD");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Parallel coordinate system creater.
       */


      function create(ecModel, api) {
        var coordSysList = [];
        ecModel.eachComponent('parallel', function (parallelModel, idx) {
          var coordSys = new Parallel(parallelModel, ecModel, api);
          coordSys.name = 'parallel_' + idx;
          coordSys.resize(parallelModel, api);
          parallelModel.coordinateSystem = coordSys;
          coordSys.model = parallelModel;
          coordSysList.push(coordSys);
        }); // Inject the coordinateSystems into seriesModel

        ecModel.eachSeries(function (seriesModel) {
          if (seriesModel.get('coordinateSystem') === 'parallel') {
            var parallelModel = ecModel.queryComponents({
              mainType: 'parallel',
              index: seriesModel.get('parallelIndex'),
              id: seriesModel.get('parallelId')
            })[0];
            seriesModel.coordinateSystem = parallelModel.coordinateSystem;
          }
        });
        return coordSysList;
      }

      CoordinateSystem.register('parallel', {
        create: create
      });
      /***/
    },

    /***/
    "hNWo":
    /*!******************************************************************!*\
      !*** ./node_modules/echarts/lib/component/legend/LegendModel.js ***!
      \******************************************************************/

    /*! no static exports found */

    /***/
    function hNWo(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var Model = __webpack_require__(
      /*! ../../model/Model */
      "Qxkt");

      var _model = __webpack_require__(
      /*! ../../util/model */
      "4NO4");

      var isNameSpecified = _model.isNameSpecified;

      var lang = __webpack_require__(
      /*! ../../lang */
      "Kagy");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var langSelector = lang.legend.selector;
      var defaultSelectorOption = {
        all: {
          type: 'all',
          title: zrUtil.clone(langSelector.all)
        },
        inverse: {
          type: 'inverse',
          title: zrUtil.clone(langSelector.inverse)
        }
      };
      var LegendModel = echarts.extendComponentModel({
        type: 'legend.plain',
        dependencies: ['series'],
        layoutMode: {
          type: 'box',
          // legend.width/height are maxWidth/maxHeight actually,
          // whereas realy width/height is calculated by its content.
          // (Setting {left: 10, right: 10} does not make sense).
          // So consider the case:
          // `setOption({legend: {left: 10});`
          // then `setOption({legend: {right: 10});`
          // The previous `left` should be cleared by setting `ignoreSize`.
          ignoreSize: true
        },
        init: function init(option, parentModel, ecModel) {
          this.mergeDefaultAndTheme(option, ecModel);
          option.selected = option.selected || {};

          this._updateSelector(option);
        },
        mergeOption: function mergeOption(option) {
          LegendModel.superCall(this, 'mergeOption', option);

          this._updateSelector(option);
        },
        _updateSelector: function _updateSelector(option) {
          var selector = option.selector;

          if (selector === true) {
            selector = option.selector = ['all', 'inverse'];
          }

          if (zrUtil.isArray(selector)) {
            zrUtil.each(selector, function (item, index) {
              zrUtil.isString(item) && (item = {
                type: item
              });
              selector[index] = zrUtil.merge(item, defaultSelectorOption[item.type]);
            });
          }
        },
        optionUpdated: function optionUpdated() {
          this._updateData(this.ecModel);

          var legendData = this._data; // If selectedMode is single, try to select one

          if (legendData[0] && this.get('selectedMode') === 'single') {
            var hasSelected = false; // If has any selected in option.selected

            for (var i = 0; i < legendData.length; i++) {
              var name = legendData[i].get('name');

              if (this.isSelected(name)) {
                // Force to unselect others
                this.select(name);
                hasSelected = true;
                break;
              }
            } // Try select the first if selectedMode is single


            !hasSelected && this.select(legendData[0].get('name'));
          }
        },
        _updateData: function _updateData(ecModel) {
          var potentialData = [];
          var availableNames = [];
          ecModel.eachRawSeries(function (seriesModel) {
            var seriesName = seriesModel.name;
            availableNames.push(seriesName);
            var isPotential;

            if (seriesModel.legendVisualProvider) {
              var provider = seriesModel.legendVisualProvider;
              var names = provider.getAllNames();

              if (!ecModel.isSeriesFiltered(seriesModel)) {
                availableNames = availableNames.concat(names);
              }

              if (names.length) {
                potentialData = potentialData.concat(names);
              } else {
                isPotential = true;
              }
            } else {
              isPotential = true;
            }

            if (isPotential && isNameSpecified(seriesModel)) {
              potentialData.push(seriesModel.name);
            }
          });
          /**
           * @type {Array.<string>}
           * @private
           */

          this._availableNames = availableNames; // If legend.data not specified in option, use availableNames as data,
          // which is convinient for user preparing option.

          var rawData = this.get('data') || potentialData;
          var legendData = zrUtil.map(rawData, function (dataItem) {
            // Can be string or number
            if (typeof dataItem === 'string' || typeof dataItem === 'number') {
              dataItem = {
                name: dataItem
              };
            }

            return new Model(dataItem, this, this.ecModel);
          }, this);
          /**
           * @type {Array.<module:echarts/model/Model>}
           * @private
           */

          this._data = legendData;
        },

        /**
         * @return {Array.<module:echarts/model/Model>}
         */
        getData: function getData() {
          return this._data;
        },

        /**
         * @param {string} name
         */
        select: function select(name) {
          var selected = this.option.selected;
          var selectedMode = this.get('selectedMode');

          if (selectedMode === 'single') {
            var data = this._data;
            zrUtil.each(data, function (dataItem) {
              selected[dataItem.get('name')] = false;
            });
          }

          selected[name] = true;
        },

        /**
         * @param {string} name
         */
        unSelect: function unSelect(name) {
          if (this.get('selectedMode') !== 'single') {
            this.option.selected[name] = false;
          }
        },

        /**
         * @param {string} name
         */
        toggleSelected: function toggleSelected(name) {
          var selected = this.option.selected; // Default is true

          if (!selected.hasOwnProperty(name)) {
            selected[name] = true;
          }

          this[selected[name] ? 'unSelect' : 'select'](name);
        },
        allSelect: function allSelect() {
          var data = this._data;
          var selected = this.option.selected;
          zrUtil.each(data, function (dataItem) {
            selected[dataItem.get('name', true)] = true;
          });
        },
        inverseSelect: function inverseSelect() {
          var data = this._data;
          var selected = this.option.selected;
          zrUtil.each(data, function (dataItem) {
            var name = dataItem.get('name', true); // Initially, default value is true

            if (!selected.hasOwnProperty(name)) {
              selected[name] = true;
            }

            selected[name] = !selected[name];
          });
        },

        /**
         * @param {string} name
         */
        isSelected: function isSelected(name) {
          var selected = this.option.selected;
          return !(selected.hasOwnProperty(name) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;
        },
        getOrient: function getOrient() {
          return this.get('orient') === 'vertical' ? {
            index: 1,
            name: 'vertical'
          } : {
            index: 0,
            name: 'horizontal'
          };
        },
        defaultOption: {
          // 
          zlevel: 0,
          // 
          z: 4,
          show: true,
          // 
          // 'horizontal' | 'vertical'
          orient: 'horizontal',
          left: 'center',
          // right: 'center',
          top: 0,
          // bottom: null,
          // 
          // 'auto' | 'left' | 'right'
          //  'auto',  x 
          align: 'auto',
          backgroundColor: 'rgba(0,0,0,0)',
          // 
          borderColor: '#ccc',
          borderRadius: 0,
          // px0
          borderWidth: 0,
          // px5
          // css
          padding: 5,
          // itempx10
          // 
          itemGap: 10,
          // the width of legend symbol
          itemWidth: 25,
          // the height of legend symbol
          itemHeight: 14,
          // the color of unselected legend symbol
          inactiveColor: '#ccc',
          // the borderColor of unselected legend symbol
          inactiveBorderColor: '#ccc',
          itemStyle: {
            // the default borderWidth of legend symbol
            borderWidth: 0
          },
          textStyle: {
            // 
            color: '#333'
          },
          // formatter: '',
          // 
          selectedMode: true,
          // LEGEND.SELECTED
          // selected: null,
          // legend.dataitem
          // data: [],
          // Usage:
          // selector: [{type: 'all or inverse', title: xxx}]
          // or
          // selector: true
          // or
          // selector: ['all', 'inverse']
          selector: false,
          selectorLabel: {
            show: true,
            borderRadius: 10,
            padding: [3, 5, 3, 5],
            fontSize: 12,
            fontFamily: ' sans-serif',
            color: '#666',
            borderWidth: 1,
            borderColor: '#666'
          },
          emphasis: {
            selectorLabel: {
              show: true,
              color: '#eee',
              backgroundColor: '#666'
            }
          },
          // Value can be 'start' or 'end'
          selectorPosition: 'auto',
          selectorItemGap: 7,
          selectorButtonGap: 10,
          // Tooltip 
          tooltip: {
            show: false
          }
        }
      });
      var _default = LegendModel;
      module.exports = _default;
      /***/
    },

    /***/
    "hw6D":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/radar/radarLayout.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function hw6D(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function _default(ecModel) {
        ecModel.eachSeriesByType('radar', function (seriesModel) {
          var data = seriesModel.getData();
          var points = [];
          var coordSys = seriesModel.coordinateSystem;

          if (!coordSys) {
            return;
          }

          var axes = coordSys.getIndicatorAxes();
          zrUtil.each(axes, function (axis, axisIndex) {
            data.each(data.mapDimension(axes[axisIndex].dim), function (val, dataIndex) {
              points[dataIndex] = points[dataIndex] || [];
              var point = coordSys.dataToPoint(val, axisIndex);
              points[dataIndex][axisIndex] = isValidPoint(point) ? point : getValueMissingPoint(coordSys);
            });
          }); // Close polygon

          data.each(function (idx) {
            // TODO
            // Is it appropriate to connect to the next data when some data is missing?
            // Or, should trade it like `connectNull` in line chart?
            var firstPoint = zrUtil.find(points[idx], function (point) {
              return isValidPoint(point);
            }) || getValueMissingPoint(coordSys); // Copy the first actual point to the end of the array

            points[idx].push(firstPoint.slice());
            data.setItemLayout(idx, points[idx]);
          });
        });
      }

      function isValidPoint(point) {
        return !isNaN(point[0]) && !isNaN(point[1]);
      }

      function getValueMissingPoint(coordSys) {
        // It is error-prone to input [NaN, NaN] into polygon, polygon.
        // (probably cause problem when refreshing or animating)
        return [coordSys.cx, coordSys.cy];
      }

      module.exports = _default;
      /***/
    },

    /***/
    "hydK":
    /*!**********************************************!*\
      !*** ./node_modules/zrender/lib/svg/core.js ***!
      \**********************************************/

    /*! no static exports found */

    /***/
    function hydK(module, exports) {
      var svgURI = 'http://www.w3.org/2000/svg';

      function createElement(name) {
        return document.createElementNS(svgURI, name);
      }

      exports.createElement = createElement;
      /***/
    },

    /***/
    "iPDy":
    /*!*****************************************************************!*\
      !*** ./node_modules/echarts/lib/component/marker/MarkerView.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function iPDy(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = echarts.extendComponentView({
        type: 'marker',
        init: function init() {
          /**
           * Markline grouped by series
           * @private
           * @type {module:zrender/core/util.HashMap}
           */
          this.markerGroupMap = zrUtil.createHashMap();
        },
        render: function render(markerModel, ecModel, api) {
          var markerGroupMap = this.markerGroupMap;
          markerGroupMap.each(function (item) {
            item.__keep = false;
          });
          var markerModelKey = this.type + 'Model';
          ecModel.eachSeries(function (seriesModel) {
            var markerModel = seriesModel[markerModelKey];
            markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);
          }, this);
          markerGroupMap.each(function (item) {
            !item.__keep && this.group.remove(item.group);
          }, this);
        },
        renderSeries: function renderSeries() {}
      });

      module.exports = _default;
      /***/
    },

    /***/
    "jett":
    /*!*************************************************!*\
      !*** ./node_modules/echarts/lib/chart/radar.js ***!
      \*************************************************/

    /*! no static exports found */

    /***/
    function jett(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ../component/radar */
      "VSLf");

      __webpack_require__(
      /*! ./radar/RadarSeries */
      "oBaM");

      __webpack_require__(
      /*! ./radar/RadarView */
      "FGaS");

      var dataColor = __webpack_require__(
      /*! ../visual/dataColor */
      "mOdp");

      var visualSymbol = __webpack_require__(
      /*! ../visual/symbol */
      "f5Yq");

      var radarLayout = __webpack_require__(
      /*! ./radar/radarLayout */
      "hw6D");

      var dataFilter = __webpack_require__(
      /*! ../processor/dataFilter */
      "0/Rx");

      var backwardCompat = __webpack_require__(
      /*! ./radar/backwardCompat */
      "eJH7");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // Must use radar component


      echarts.registerVisual(dataColor('radar'));
      echarts.registerVisual(visualSymbol('radar', 'circle'));
      echarts.registerLayout(radarLayout);
      echarts.registerProcessor(dataFilter('radar'));
      echarts.registerPreprocessor(backwardCompat);
      /***/
    },

    /***/
    "jndi":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/component/marker/MarkAreaView.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function jndi(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var colorUtil = __webpack_require__(
      /*! zrender/lib/tool/color */
      "Qe9p");

      var List = __webpack_require__(
      /*! ../../data/List */
      "YXkt");

      var numberUtil = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var markerHelper = __webpack_require__(
      /*! ./markerHelper */
      "kj2x");

      var MarkerView = __webpack_require__(
      /*! ./MarkerView */
      "iPDy");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // TODO Better on polar


      var markAreaTransform = function markAreaTransform(seriesModel, coordSys, maModel, item) {
        var lt = markerHelper.dataTransform(seriesModel, item[0]);
        var rb = markerHelper.dataTransform(seriesModel, item[1]);
        var retrieve = zrUtil.retrieve; // FIXME make sure lt is less than rb

        var ltCoord = lt.coord;
        var rbCoord = rb.coord;
        ltCoord[0] = retrieve(ltCoord[0], -Infinity);
        ltCoord[1] = retrieve(ltCoord[1], -Infinity);
        rbCoord[0] = retrieve(rbCoord[0], Infinity);
        rbCoord[1] = retrieve(rbCoord[1], Infinity); // Merge option into one

        var result = zrUtil.mergeAll([{}, lt, rb]);
        result.coord = [lt.coord, rb.coord];
        result.x0 = lt.x;
        result.y0 = lt.y;
        result.x1 = rb.x;
        result.y1 = rb.y;
        return result;
      };

      function isInifinity(val) {
        return !isNaN(val) && !isFinite(val);
      } // If a markArea has one dim


      function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
        var otherDimIndex = 1 - dimIndex;
        return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]);
      }

      function markAreaFilter(coordSys, item) {
        var fromCoord = item.coord[0];
        var toCoord = item.coord[1];

        if (coordSys.type === 'cartesian2d') {
          // In case
          // {
          //  markArea: {
          //    data: [{ yAxis: 2 }]
          //  }
          // }
          if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
            return true;
          }
        }

        return markerHelper.dataFilter(coordSys, {
          coord: fromCoord,
          x: item.x0,
          y: item.y0
        }) || markerHelper.dataFilter(coordSys, {
          coord: toCoord,
          x: item.x1,
          y: item.y1
        });
      } // dims can be ['x0', 'y0'], ['x1', 'y1'], ['x0', 'y1'], ['x1', 'y0']


      function getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {
        var coordSys = seriesModel.coordinateSystem;
        var itemModel = data.getItemModel(idx);
        var point;
        var xPx = numberUtil.parsePercent(itemModel.get(dims[0]), api.getWidth());
        var yPx = numberUtil.parsePercent(itemModel.get(dims[1]), api.getHeight());

        if (!isNaN(xPx) && !isNaN(yPx)) {
          point = [xPx, yPx];
        } else {
          // Chart like bar may have there own marker positioning logic
          if (seriesModel.getMarkerPosition) {
            // Use the getMarkerPoisition
            point = seriesModel.getMarkerPosition(data.getValues(dims, idx));
          } else {
            var x = data.get(dims[0], idx);
            var y = data.get(dims[1], idx);
            var pt = [x, y];
            coordSys.clampData && coordSys.clampData(pt, pt);
            point = coordSys.dataToPoint(pt, true);
          }

          if (coordSys.type === 'cartesian2d') {
            var xAxis = coordSys.getAxis('x');
            var yAxis = coordSys.getAxis('y');
            var x = data.get(dims[0], idx);
            var y = data.get(dims[1], idx);

            if (isInifinity(x)) {
              point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === 'x0' ? 0 : 1]);
            } else if (isInifinity(y)) {
              point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === 'y0' ? 0 : 1]);
            }
          } // Use x, y if has any


          if (!isNaN(xPx)) {
            point[0] = xPx;
          }

          if (!isNaN(yPx)) {
            point[1] = yPx;
          }
        }

        return point;
      }

      var dimPermutations = [['x0', 'y0'], ['x1', 'y0'], ['x1', 'y1'], ['x0', 'y1']];
      MarkerView.extend({
        type: 'markArea',
        // updateLayout: function (markAreaModel, ecModel, api) {
        //     ecModel.eachSeries(function (seriesModel) {
        //         var maModel = seriesModel.markAreaModel;
        //         if (maModel) {
        //             var areaData = maModel.getData();
        //             areaData.each(function (idx) {
        //                 var points = zrUtil.map(dimPermutations, function (dim) {
        //                     return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
        //                 });
        //                 // Layout
        //                 areaData.setItemLayout(idx, points);
        //                 var el = areaData.getItemGraphicEl(idx);
        //                 el.setShape('points', points);
        //             });
        //         }
        //     }, this);
        // },
        updateTransform: function updateTransform(markAreaModel, ecModel, api) {
          ecModel.eachSeries(function (seriesModel) {
            var maModel = seriesModel.markAreaModel;

            if (maModel) {
              var areaData = maModel.getData();
              areaData.each(function (idx) {
                var points = zrUtil.map(dimPermutations, function (dim) {
                  return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
                }); // Layout

                areaData.setItemLayout(idx, points);
                var el = areaData.getItemGraphicEl(idx);
                el.setShape('points', points);
              });
            }
          }, this);
        },
        renderSeries: function renderSeries(seriesModel, maModel, ecModel, api) {
          var coordSys = seriesModel.coordinateSystem;
          var seriesId = seriesModel.id;
          var seriesData = seriesModel.getData();
          var areaGroupMap = this.markerGroupMap;
          var polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {
            group: new graphic.Group()
          });
          this.group.add(polygonGroup.group);
          polygonGroup.__keep = true;
          var areaData = createList(coordSys, seriesModel, maModel); // Line data for tooltip and formatter

          maModel.setData(areaData); // Update visual and layout of line

          areaData.each(function (idx) {
            // Layout
            var points = zrUtil.map(dimPermutations, function (dim) {
              return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
            }); // If none of the area is inside coordSys, allClipped is set to be true
            // in layout so that label will not be displayed. See #12591

            var allClipped = true;
            zrUtil.each(dimPermutations, function (dim) {
              if (!allClipped) {
                return;
              }

              var xValue = areaData.get(dim[0], idx);
              var yValue = areaData.get(dim[1], idx); // If is infinity, the axis should be considered not clipped

              if ((isInifinity(xValue) || coordSys.getAxis('x').containData(xValue)) && (isInifinity(yValue) || coordSys.getAxis('y').containData(yValue))) {
                allClipped = false;
              }
            });
            areaData.setItemLayout(idx, {
              points: points,
              allClipped: allClipped
            }); // Visual

            areaData.setItemVisual(idx, {
              color: seriesData.getVisual('color')
            });
          });
          areaData.diff(polygonGroup.__data).add(function (idx) {
            var layout = areaData.getItemLayout(idx);

            if (!layout.allClipped) {
              var polygon = new graphic.Polygon({
                shape: {
                  points: layout.points
                }
              });
              areaData.setItemGraphicEl(idx, polygon);
              polygonGroup.group.add(polygon);
            }
          }).update(function (newIdx, oldIdx) {
            var polygon = polygonGroup.__data.getItemGraphicEl(oldIdx);

            var layout = areaData.getItemLayout(newIdx);

            if (!layout.allClipped) {
              if (polygon) {
                graphic.updateProps(polygon, {
                  shape: {
                    points: layout.points
                  }
                }, maModel, newIdx);
              } else {
                polygon = new graphic.Polygon({
                  shape: {
                    points: layout.points
                  }
                });
              }

              areaData.setItemGraphicEl(newIdx, polygon);
              polygonGroup.group.add(polygon);
            } else if (polygon) {
              polygonGroup.group.remove(polygon);
            }
          }).remove(function (idx) {
            var polygon = polygonGroup.__data.getItemGraphicEl(idx);

            polygonGroup.group.remove(polygon);
          }).execute();
          areaData.eachItemGraphicEl(function (polygon, idx) {
            var itemModel = areaData.getItemModel(idx);
            var labelModel = itemModel.getModel('label');
            var labelHoverModel = itemModel.getModel('emphasis.label');
            var color = areaData.getItemVisual(idx, 'color');
            polygon.useStyle(zrUtil.defaults(itemModel.getModel('itemStyle').getItemStyle(), {
              fill: colorUtil.modifyAlpha(color, 0.4),
              stroke: color
            }));
            polygon.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();
            graphic.setLabelStyle(polygon.style, polygon.hoverStyle, labelModel, labelHoverModel, {
              labelFetcher: maModel,
              labelDataIndex: idx,
              defaultText: areaData.getName(idx) || '',
              isRectText: true,
              autoColor: color
            });
            graphic.setHoverStyle(polygon, {});
            polygon.dataModel = maModel;
          });
          polygonGroup.__data = areaData;
          polygonGroup.group.silent = maModel.get('silent') || seriesModel.get('silent');
        }
      });
      /**
       * @inner
       * @param {module:echarts/coord/*} coordSys
       * @param {module:echarts/model/Series} seriesModel
       * @param {module:echarts/model/Model} mpModel
       */

      function createList(coordSys, seriesModel, maModel) {
        var coordDimsInfos;
        var areaData;
        var dims = ['x0', 'y0', 'x1', 'y1'];

        if (coordSys) {
          coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {
            var data = seriesModel.getData();
            var info = data.getDimensionInfo(data.mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys

            return zrUtil.defaults({
              name: coordDim
            }, info);
          });
          areaData = new List(zrUtil.map(dims, function (dim, idx) {
            return {
              name: dim,
              type: coordDimsInfos[idx % 2].type
            };
          }), maModel);
        } else {
          coordDimsInfos = [{
            name: 'value',
            type: 'float'
          }];
          areaData = new List(coordDimsInfos, maModel);
        }

        var optData = zrUtil.map(maModel.get('data'), zrUtil.curry(markAreaTransform, seriesModel, coordSys, maModel));

        if (coordSys) {
          optData = zrUtil.filter(optData, zrUtil.curry(markAreaFilter, coordSys));
        }

        var dimValueGetter = coordSys ? function (item, dimName, dataIndex, dimIndex) {
          return item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];
        } : function (item) {
          return item.value;
        };
        areaData.initData(optData, null, dimValueGetter);
        areaData.hasItemOption = true;
        return areaData;
      }
      /***/

    },

    /***/
    "jsU+":
    /*!********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/toolbox/ToolboxModel.js ***!
      \********************************************************************/

    /*! no static exports found */

    /***/
    function jsU(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var featureManager = __webpack_require__(
      /*! ./featureManager */
      "IUWy");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var ToolboxModel = echarts.extendComponentModel({
        type: 'toolbox',
        layoutMode: {
          type: 'box',
          ignoreSize: true
        },
        optionUpdated: function optionUpdated() {
          ToolboxModel.superApply(this, 'optionUpdated', arguments);
          zrUtil.each(this.option.feature, function (featureOpt, featureName) {
            var Feature = featureManager.get(featureName);
            Feature && zrUtil.merge(featureOpt, Feature.defaultOption);
          });
        },
        defaultOption: {
          show: true,
          z: 6,
          zlevel: 0,
          orient: 'horizontal',
          left: 'right',
          top: 'top',
          // right
          // bottom
          backgroundColor: 'transparent',
          borderColor: '#ccc',
          borderRadius: 0,
          borderWidth: 0,
          padding: 5,
          itemSize: 15,
          itemGap: 8,
          showTitle: true,
          iconStyle: {
            borderColor: '#666',
            color: 'none'
          },
          emphasis: {
            iconStyle: {
              borderColor: '#3E98C5'
            }
          },
          // textStyle: {},
          // feature
          tooltip: {
            show: false
          }
        }
      });
      var _default = ToolboxModel;
      module.exports = _default;
      /***/
    },

    /***/
    "jtI2":
    /*!***************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/cartesian/GridModel.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function jtI2(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      __webpack_require__(
      /*! ./AxisModel */
      "SMc4");

      var ComponentModel = __webpack_require__(
      /*! ../../model/Component */
      "bLfw");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // Grid 
      //  Cartesian2D 


      var _default = ComponentModel.extend({
        type: 'grid',
        dependencies: ['xAxis', 'yAxis'],
        layoutMode: 'box',

        /**
         * @type {module:echarts/coord/cartesian/Grid}
         */
        coordinateSystem: null,
        defaultOption: {
          show: false,
          zlevel: 0,
          z: 0,
          left: '10%',
          top: 60,
          right: '10%',
          bottom: 60,
          // If grid size contain label
          containLabel: false,
          // width: {totalWidth} - left - right,
          // height: {totalHeight} - top - bottom,
          backgroundColor: 'rgba(0,0,0,0)',
          borderWidth: 1,
          borderColor: '#ccc'
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "juDX":
    /*!*********************************************!*\
      !*** ./node_modules/zrender/lib/svg/svg.js ***!
      \*********************************************/

    /*! no static exports found */

    /***/
    function juDX(module, exports, __webpack_require__) {
      __webpack_require__(
      /*! ./graphic */
      "P47w");

      var _zrender = __webpack_require__(
      /*! ../zrender */
      "aX58");

      var registerPainter = _zrender.registerPainter;

      var Painter = __webpack_require__(
      /*! ./Painter */
      "3CBa");

      registerPainter('svg', Painter);
      /***/
    },

    /***/
    "k5C7":
    /*!********************************************************!*\
      !*** ./node_modules/echarts/lib/component/calendar.js ***!
      \********************************************************/

    /*! no static exports found */

    /***/
    function k5C7(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      __webpack_require__(
      /*! ../coord/calendar/Calendar */
      "0JAE");

      __webpack_require__(
      /*! ../coord/calendar/CalendarModel */
      "g7p0");

      __webpack_require__(
      /*! ./calendar/CalendarView */
      "7mYs");
      /***/

    },

    /***/
    "kDyi":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/component/legend/legendFilter.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function kDyi(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      function _default(ecModel) {
        var legendModels = ecModel.findComponents({
          mainType: 'legend'
        });

        if (legendModels && legendModels.length) {
          ecModel.filterSeries(function (series) {
            // If in any legend component the status is not selected.
            // Because in legend series is assumed selected when it is not in the legend data.
            for (var i = 0; i < legendModels.length; i++) {
              if (!legendModels[i].isSelected(series.name)) {
                return false;
              }
            }

            return true;
          });
        }
      }

      module.exports = _default;
      /***/
    },

    /***/
    "kMLO":
    /*!*****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/treemap/treemapVisual.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function kMLO(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var VisualMapping = __webpack_require__(
      /*! ../../visual/VisualMapping */
      "XxSj");

      var zrColor = __webpack_require__(
      /*! zrender/lib/tool/color */
      "Qe9p");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var isArray = zrUtil.isArray;
      var ITEM_STYLE_NORMAL = 'itemStyle';
      var _default = {
        seriesType: 'treemap',
        reset: function reset(seriesModel, ecModel, api, payload) {
          var tree = seriesModel.getData().tree;
          var root = tree.root;

          if (root.isRemoved()) {
            return;
          }

          travelTree(root, // Visual should calculate from tree root but not view root.
          {}, seriesModel.getViewRoot().getAncestors(), seriesModel);
        }
      };

      function travelTree(node, designatedVisual, viewRootAncestors, seriesModel) {
        var nodeModel = node.getModel();
        var nodeLayout = node.getLayout(); // Optimize

        if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) {
          return;
        }

        var nodeItemStyleModel = node.getModel(ITEM_STYLE_NORMAL);
        var visuals = buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel); // calculate border color

        var borderColor = nodeItemStyleModel.get('borderColor');
        var borderColorSaturation = nodeItemStyleModel.get('borderColorSaturation');
        var thisNodeColor;

        if (borderColorSaturation != null) {
          // For performance, do not always execute 'calculateColor'.
          thisNodeColor = calculateColor(visuals, node);
          borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);
        }

        node.setVisual('borderColor', borderColor);
        var viewChildren = node.viewChildren;

        if (!viewChildren || !viewChildren.length) {
          thisNodeColor = calculateColor(visuals, node); // Apply visual to this node.

          node.setVisual('color', thisNodeColor);
        } else {
          var mapping = buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren); // Designate visual to children.

          zrUtil.each(viewChildren, function (child, index) {
            // If higher than viewRoot, only ancestors of viewRoot is needed to visit.
            if (child.depth >= viewRootAncestors.length || child === viewRootAncestors[child.depth]) {
              var childVisual = mapVisual(nodeModel, visuals, child, index, mapping, seriesModel);
              travelTree(child, childVisual, viewRootAncestors, seriesModel);
            }
          });
        }
      }

      function buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel) {
        var visuals = zrUtil.extend({}, designatedVisual);
        var designatedVisualItemStyle = seriesModel.designatedVisualItemStyle;
        zrUtil.each(['color', 'colorAlpha', 'colorSaturation'], function (visualName) {
          // Priority: thisNode > thisLevel > parentNodeDesignated > seriesModel
          designatedVisualItemStyle[visualName] = designatedVisual[visualName];
          var val = nodeItemStyleModel.get(visualName);
          designatedVisualItemStyle[visualName] = null;
          val != null && (visuals[visualName] = val);
        });
        return visuals;
      }

      function calculateColor(visuals) {
        var color = getValueVisualDefine(visuals, 'color');

        if (color) {
          var colorAlpha = getValueVisualDefine(visuals, 'colorAlpha');
          var colorSaturation = getValueVisualDefine(visuals, 'colorSaturation');

          if (colorSaturation) {
            color = zrColor.modifyHSL(color, null, null, colorSaturation);
          }

          if (colorAlpha) {
            color = zrColor.modifyAlpha(color, colorAlpha);
          }

          return color;
        }
      }

      function calculateBorderColor(borderColorSaturation, thisNodeColor) {
        return thisNodeColor != null ? zrColor.modifyHSL(thisNodeColor, null, null, borderColorSaturation) : null;
      }

      function getValueVisualDefine(visuals, name) {
        var value = visuals[name];

        if (value != null && value !== 'none') {
          return value;
        }
      }

      function buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) {
        if (!viewChildren || !viewChildren.length) {
          return;
        }

        var rangeVisual = getRangeVisual(nodeModel, 'color') || visuals.color != null && visuals.color !== 'none' && (getRangeVisual(nodeModel, 'colorAlpha') || getRangeVisual(nodeModel, 'colorSaturation'));

        if (!rangeVisual) {
          return;
        }

        var visualMin = nodeModel.get('visualMin');
        var visualMax = nodeModel.get('visualMax');
        var dataExtent = nodeLayout.dataExtent.slice();
        visualMin != null && visualMin < dataExtent[0] && (dataExtent[0] = visualMin);
        visualMax != null && visualMax > dataExtent[1] && (dataExtent[1] = visualMax);
        var colorMappingBy = nodeModel.get('colorMappingBy');
        var opt = {
          type: rangeVisual.name,
          dataExtent: dataExtent,
          visual: rangeVisual.range
        };

        if (opt.type === 'color' && (colorMappingBy === 'index' || colorMappingBy === 'id')) {
          opt.mappingMethod = 'category';
          opt.loop = true; // categories is ordinal, so do not set opt.categories.
        } else {
          opt.mappingMethod = 'linear';
        }

        var mapping = new VisualMapping(opt);
        mapping.__drColorMappingBy = colorMappingBy;
        return mapping;
      } // Notice: If we dont have the attribute 'colorRange', but only use
      // attribute 'color' to represent both concepts of 'colorRange' and 'color',
      // (It means 'colorRange' when 'color' is Array, means 'color' when not array),
      // this problem will be encountered:
      // If a level-1 node dont have children, and its siblings has children,
      // and colorRange is set on level-1, then the node can not be colored.
      // So we separate 'colorRange' and 'color' to different attributes.


      function getRangeVisual(nodeModel, name) {
        // 'colorRange', 'colorARange', 'colorSRange'.
        // If not exsits on this node, fetch from levels and series.
        var range = nodeModel.get(name);
        return isArray(range) && range.length ? {
          name: name,
          range: range
        } : null;
      }

      function mapVisual(nodeModel, visuals, child, index, mapping, seriesModel) {
        var childVisuals = zrUtil.extend({}, visuals);

        if (mapping) {
          var mappingType = mapping.type;
          var colorMappingBy = mappingType === 'color' && mapping.__drColorMappingBy;
          var value = colorMappingBy === 'index' ? index : colorMappingBy === 'id' ? seriesModel.mapIdToIndex(child.getId()) : child.getValue(nodeModel.get('visualDimension'));
          childVisuals[mappingType] = mapping.mapValueToVisual(value);
        }

        return childVisuals;
      }

      module.exports = _default;
      /***/
    },

    /***/
    "kj2x":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/component/marker/markerHelper.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function kj2x(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var numberUtil = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var _dataStackHelper = __webpack_require__(
      /*! ../../data/helper/dataStackHelper */
      "7hqr");

      var isDimensionStacked = _dataStackHelper.isDimensionStacked;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var indexOf = zrUtil.indexOf;

      function hasXOrY(item) {
        return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));
      }

      function hasXAndY(item) {
        return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));
      } // Make it simple, do not visit all stacked value to count precision.
      // function getPrecision(data, valueAxisDim, dataIndex) {
      //     var precision = -1;
      //     var stackedDim = data.mapDimension(valueAxisDim);
      //     do {
      //         precision = Math.max(
      //             numberUtil.getPrecision(data.get(stackedDim, dataIndex)),
      //             precision
      //         );
      //         var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');
      //         if (stackedOnSeries) {
      //             var byValue = data.get(data.getCalculationInfo('stackedByDimension'), dataIndex);
      //             data = stackedOnSeries.getData();
      //             dataIndex = data.indexOf(data.getCalculationInfo('stackedByDimension'), byValue);
      //             stackedDim = data.getCalculationInfo('stackedDimension');
      //         }
      //         else {
      //             data = null;
      //         }
      //     } while (data);
      //     return precision;
      // }


      function markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {
        var coordArr = [];
        var stacked = isDimensionStacked(data, targetDataDim
        /*, otherDataDim*/
        );
        var calcDataDim = stacked ? data.getCalculationInfo('stackResultDimension') : targetDataDim;
        var value = numCalculate(data, calcDataDim, mlType);
        var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];
        coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);
        coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);
        var coordArrValue = data.get(targetDataDim, dataIndex); // Make it simple, do not visit all stacked value to count precision.

        var precision = numberUtil.getPrecision(data.get(targetDataDim, dataIndex));
        precision = Math.min(precision, 20);

        if (precision >= 0) {
          coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);
        }

        return [coordArr, coordArrValue];
      }

      var curry = zrUtil.curry; // TODO Specified percent

      var markerTypeCalculator = {
        /**
         * @method
         * @param {module:echarts/data/List} data
         * @param {string} baseAxisDim
         * @param {string} valueAxisDim
         */
        min: curry(markerTypeCalculatorWithExtent, 'min'),

        /**
         * @method
         * @param {module:echarts/data/List} data
         * @param {string} baseAxisDim
         * @param {string} valueAxisDim
         */
        max: curry(markerTypeCalculatorWithExtent, 'max'),

        /**
         * @method
         * @param {module:echarts/data/List} data
         * @param {string} baseAxisDim
         * @param {string} valueAxisDim
         */
        average: curry(markerTypeCalculatorWithExtent, 'average')
      };
      /**
       * Transform markPoint data item to format used in List by do the following
       * 1. Calculate statistic like `max`, `min`, `average`
       * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array
       * @param  {module:echarts/model/Series} seriesModel
       * @param  {module:echarts/coord/*} [coordSys]
       * @param  {Object} item
       * @return {Object}
       */

      function dataTransform(seriesModel, item) {
        var data = seriesModel.getData();
        var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly
        // 2. If `coord` is not a data array. Which uses `xAxis`,
        // `yAxis` to specify the coord on each dimension
        // parseFloat first because item.x and item.y can be percent string like '20%'

        if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {
          var dims = coordSys.dimensions;
          var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option
          // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value

          item = zrUtil.clone(item);

          if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
            var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);
            var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);
            var coordInfo = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);
            item.coord = coordInfo[0]; // Force to use the value of calculated value.
            // let item use the value without stack.

            item.value = coordInfo[1];
          } else {
            // FIXME Only has one of xAxis and yAxis.
            var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average

            for (var i = 0; i < 2; i++) {
              if (markerTypeCalculator[coord[i]]) {
                coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);
              }
            }

            item.coord = coord;
          }
        }

        return item;
      }

      function getAxisInfo(item, data, coordSys, seriesModel) {
        var ret = {};

        if (item.valueIndex != null || item.valueDim != null) {
          ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;
          ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));
          ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);
          ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
        } else {
          ret.baseAxis = seriesModel.getBaseAxis();
          ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);
          ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
          ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);
        }

        return ret;
      }

      function dataDimToCoordDim(seriesModel, dataDim) {
        var data = seriesModel.getData();
        var dimensions = data.dimensions;
        dataDim = data.getDimension(dataDim);

        for (var i = 0; i < dimensions.length; i++) {
          var dimItem = data.getDimensionInfo(dimensions[i]);

          if (dimItem.name === dataDim) {
            return dimItem.coordDim;
          }
        }
      }
      /**
       * Filter data which is out of coordinateSystem range
       * [dataFilter description]
       * @param  {module:echarts/coord/*} [coordSys]
       * @param  {Object} item
       * @return {boolean}
       */


      function dataFilter(coordSys, item) {
        // Alwalys return true if there is no coordSys
        return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;
      }

      function dimValueGetter(item, dimName, dataIndex, dimIndex) {
        // x, y, radius, angle
        if (dimIndex < 2) {
          return item.coord && item.coord[dimIndex];
        }

        return item.value;
      }

      function numCalculate(data, valueDataDim, type) {
        if (type === 'average') {
          var sum = 0;
          var count = 0;
          data.each(valueDataDim, function (val, idx) {
            if (!isNaN(val)) {
              sum += val;
              count++;
            }
          });
          return sum / count;
        } else if (type === 'median') {
          return data.getMedian(valueDataDim);
        } else {
          // max & min
          return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];
        }
      }

      exports.dataTransform = dataTransform;
      exports.getAxisInfo = getAxisInfo;
      exports.dataFilter = dataFilter;
      exports.dimValueGetter = dimValueGetter;
      exports.numCalculate = numCalculate;
      /***/
    },

    /***/
    "knOB":
    /*!************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/polar/RadiusAxis.js ***!
      \************************************************************/

    /*! no static exports found */

    /***/
    function knOB(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var Axis = __webpack_require__(
      /*! ../Axis */
      "hM6l");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function RadiusAxis(scale, radiusExtent) {
        Axis.call(this, 'radius', scale, radiusExtent);
        /**
         * Axis type
         *  - 'category'
         *  - 'value'
         *  - 'time'
         *  - 'log'
         * @type {string}
         */

        this.type = 'category';
      }

      RadiusAxis.prototype = {
        constructor: RadiusAxis,

        /**
         * @override
         */
        pointToData: function pointToData(point, clamp) {
          return this.polar.pointToData(point, clamp)[this.dim === 'radius' ? 0 : 1];
        },
        dataToRadius: Axis.prototype.dataToCoord,
        radiusToData: Axis.prototype.coordToData
      };
      zrUtil.inherits(RadiusAxis, Axis);
      var _default = RadiusAxis;
      module.exports = _default;
      /***/
    },

    /***/
    "ko1b":
    /*!*****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/treemap/TreemapSeries.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function ko1b(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var SeriesModel = __webpack_require__(
      /*! ../../model/Series */
      "T4UG");

      var Tree = __webpack_require__(
      /*! ../../data/Tree */
      "Bsck");

      var Model = __webpack_require__(
      /*! ../../model/Model */
      "Qxkt");

      var _format = __webpack_require__(
      /*! ../../util/format */
      "7aKB");

      var encodeHTML = _format.encodeHTML;
      var addCommas = _format.addCommas;

      var _treeHelper = __webpack_require__(
      /*! ../helper/treeHelper */
      "VaxA");

      var wrapTreePathInfo = _treeHelper.wrapTreePathInfo;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var _default = SeriesModel.extend({
        type: 'series.treemap',
        layoutMode: 'box',
        dependencies: ['grid', 'polar'],
        preventUsingHoverLayer: true,

        /**
         * @type {module:echarts/data/Tree~Node}
         */
        _viewRoot: null,
        defaultOption: {
          // Disable progressive rendering
          progressive: 0,
          // center: ['50%', '50%'],          // not supported in ec3.
          // size: ['80%', '80%'],            // deprecated, compatible with ec2.
          left: 'center',
          top: 'middle',
          right: null,
          bottom: null,
          width: '80%',
          height: '80%',
          sort: true,
          // Can be null or false or true
          // (order by desc default, asc not supported yet (strange effect))
          clipWindow: 'origin',
          // Size of clipped window when zooming. 'origin' or 'fullscreen'
          squareRatio: 0.5 * (1 + Math.sqrt(5)),
          // golden ratio
          leafDepth: null,
          // Nodes on depth from root are regarded as leaves.
          // Count from zero (zero represents only view root).
          drillDownIcon: '',
          // Use html character temporarily because it is complicated
          // to align specialized icon. 
          zoomToNodeRatio: 0.32 * 0.32,
          // Be effective when using zoomToNode. Specify the proportion of the
          // target node area in the view area.
          roam: true,
          // true, false, 'scale' or 'zoom', 'move'.
          nodeClick: 'zoomToNode',
          // Leaf node click behaviour: 'zoomToNode', 'link', false.
          // If leafDepth is set and clicking a node which has children but
          // be on left depth, the behaviour would be changing root. Otherwise
          // use behavious defined above.
          animation: true,
          animationDurationUpdate: 900,
          animationEasing: 'quinticInOut',
          breadcrumb: {
            show: true,
            height: 22,
            left: 'center',
            top: 'bottom',
            // right
            // bottom
            emptyItemWidth: 25,
            // Width of empty node.
            itemStyle: {
              color: 'rgba(0,0,0,0.7)',
              //'#5793f3',
              borderColor: 'rgba(255,255,255,0.7)',
              borderWidth: 1,
              shadowColor: 'rgba(150,150,150,1)',
              shadowBlur: 3,
              shadowOffsetX: 0,
              shadowOffsetY: 0,
              textStyle: {
                color: '#fff'
              }
            },
            emphasis: {
              textStyle: {}
            }
          },
          label: {
            show: true,
            // Do not use textDistance, for ellipsis rect just the same as treemap node rect.
            distance: 0,
            padding: 5,
            position: 'inside',
            // Can be [5, '5%'] or position stirng like 'insideTopLeft', ...
            // formatter: null,
            color: '#fff',
            ellipsis: true // align
            // verticalAlign

          },
          upperLabel: {
            // Label when node is parent.
            show: false,
            position: [0, '50%'],
            height: 20,
            // formatter: null,
            color: '#fff',
            ellipsis: true,
            // align: null,
            verticalAlign: 'middle'
          },
          itemStyle: {
            color: null,
            // Can be 'none' if not necessary.
            colorAlpha: null,
            // Can be 'none' if not necessary.
            colorSaturation: null,
            // Can be 'none' if not necessary.
            borderWidth: 0,
            gapWidth: 0,
            borderColor: '#fff',
            borderColorSaturation: null // If specified, borderColor will be ineffective, and the
            // border color is evaluated by color of current node and
            // borderColorSaturation.

          },
          emphasis: {
            upperLabel: {
              show: true,
              position: [0, '50%'],
              color: '#fff',
              ellipsis: true,
              verticalAlign: 'middle'
            }
          },
          visualDimension: 0,
          // Can be 0, 1, 2, 3.
          visualMin: null,
          visualMax: null,
          color: [],
          // + treemapSeries.color should not be modified. Please only modified
          // level[n].color (if necessary).
          // + Specify color list of each level. level[0].color would be global
          // color list if not specified. (see method `setDefault`).
          // + But set as a empty array to forbid fetch color from global palette
          // when using nodeModel.get('color'), otherwise nodes on deep level
          // will always has color palette set and are not able to inherit color
          // from parent node.
          // + TreemapSeries.color can not be set as 'none', otherwise effect
          // legend color fetching (see seriesColor.js).
          colorAlpha: null,
          // Array. Specify color alpha range of each level, like [0.2, 0.8]
          colorSaturation: null,
          // Array. Specify color saturation of each level, like [0.2, 0.5]
          colorMappingBy: 'index',
          // 'value' or 'index' or 'id'.
          visibleMin: 10,
          // If area less than this threshold (unit: pixel^2), node will not
          // be rendered. Only works when sort is 'asc' or 'desc'.
          childrenVisibleMin: null,
          // If area of a node less than this threshold (unit: pixel^2),
          // grandchildren will not show.
          // Why grandchildren? If not grandchildren but children,
          // some siblings show children and some not,
          // the appearance may be mess and not consistent,
          levels: [] // Each item: {
          //     visibleMin, itemStyle, visualDimension, label
          // }
          // data: {
          //      value: [],
          //      children: [],
          //      link: 'http://xxx.xxx.xxx',
          //      target: 'blank' or 'self'
          // }

        },

        /**
         * @override
         */
        getInitialData: function getInitialData(option, ecModel) {
          // Create a virtual root.
          var root = {
            name: option.name,
            children: option.data
          };
          completeTreeValue(root);
          var levels = option.levels || []; // Used in "visual priority" in `treemapVisual.js`.
          // This way is a little tricky, must satisfy the precondition:
          //   1. There is no `treeNode.getModel('itemStyle.xxx')` used.
          //   2. The `Model.prototype.getModel()` will not use any clone-like way.

          var designatedVisualItemStyle = this.designatedVisualItemStyle = {};
          var designatedVisualModel = new Model({
            itemStyle: designatedVisualItemStyle
          }, this, ecModel);
          levels = option.levels = setDefault(levels, ecModel);
          var levelModels = zrUtil.map(levels || [], function (levelDefine) {
            return new Model(levelDefine, designatedVisualModel, ecModel);
          }, this); // Make sure always a new tree is created when setOption,
          // in TreemapView, we check whether oldTree === newTree
          // to choose mappings approach among old shapes and new shapes.

          var tree = Tree.createTree(root, this, beforeLink);

          function beforeLink(nodeData) {
            nodeData.wrapMethod('getItemModel', function (model, idx) {
              var node = tree.getNodeByDataIndex(idx);
              var levelModel = levelModels[node.depth]; // If no levelModel, we also need `designatedVisualModel`.

              model.parentModel = levelModel || designatedVisualModel;
              return model;
            });
          }

          return tree.data;
        },
        optionUpdated: function optionUpdated() {
          this.resetViewRoot();
        },

        /**
         * @override
         * @param {number} dataIndex
         * @param {boolean} [mutipleSeries=false]
         */
        formatTooltip: function formatTooltip(dataIndex) {
          var data = this.getData();
          var value = this.getRawValue(dataIndex);
          var formattedValue = zrUtil.isArray(value) ? addCommas(value[0]) : addCommas(value);
          var name = data.getName(dataIndex);
          return encodeHTML(name + ': ' + formattedValue);
        },

        /**
         * Add tree path to tooltip param
         *
         * @override
         * @param {number} dataIndex
         * @return {Object}
         */
        getDataParams: function getDataParams(dataIndex) {
          var params = SeriesModel.prototype.getDataParams.apply(this, arguments);
          var node = this.getData().tree.getNodeByDataIndex(dataIndex);
          params.treePathInfo = wrapTreePathInfo(node, this);
          return params;
        },

        /**
         * @public
         * @param {Object} layoutInfo {
         *                                x: containerGroup x
         *                                y: containerGroup y
         *                                width: containerGroup width
         *                                height: containerGroup height
         *                            }
         */
        setLayoutInfo: function setLayoutInfo(layoutInfo) {
          /**
           * @readOnly
           * @type {Object}
           */
          this.layoutInfo = this.layoutInfo || {};
          zrUtil.extend(this.layoutInfo, layoutInfo);
        },

        /**
         * @param  {string} id
         * @return {number} index
         */
        mapIdToIndex: function mapIdToIndex(id) {
          // A feature is implemented:
          // index is monotone increasing with the sequence of
          // input id at the first time.
          // This feature can make sure that each data item and its
          // mapped color have the same index between data list and
          // color list at the beginning, which is useful for user
          // to adjust data-color mapping.

          /**
           * @private
           * @type {Object}
           */
          var idIndexMap = this._idIndexMap;

          if (!idIndexMap) {
            idIndexMap = this._idIndexMap = zrUtil.createHashMap();
            /**
             * @private
             * @type {number}
             */

            this._idIndexMapCount = 0;
          }

          var index = idIndexMap.get(id);

          if (index == null) {
            idIndexMap.set(id, index = this._idIndexMapCount++);
          }

          return index;
        },
        getViewRoot: function getViewRoot() {
          return this._viewRoot;
        },

        /**
         * @param {module:echarts/data/Tree~Node} [viewRoot]
         */
        resetViewRoot: function resetViewRoot(viewRoot) {
          viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
          var root = this.getRawData().tree.root;

          if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
            this._viewRoot = root;
          }
        }
      });
      /**
       * @param {Object} dataNode
       */


      function completeTreeValue(dataNode) {
        // Postorder travel tree.
        // If value of none-leaf node is not set,
        // calculate it by suming up the value of all children.
        var sum = 0;
        zrUtil.each(dataNode.children, function (child) {
          completeTreeValue(child);
          var childValue = child.value;
          zrUtil.isArray(childValue) && (childValue = childValue[0]);
          sum += childValue;
        });
        var thisValue = dataNode.value;

        if (zrUtil.isArray(thisValue)) {
          thisValue = thisValue[0];
        }

        if (thisValue == null || isNaN(thisValue)) {
          thisValue = sum;
        } // Value should not less than 0.


        if (thisValue < 0) {
          thisValue = 0;
        }

        zrUtil.isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
      }
      /**
       * set default to level configuration
       */


      function setDefault(levels, ecModel) {
        var globalColorList = ecModel.get('color');

        if (!globalColorList) {
          return;
        }

        levels = levels || [];
        var hasColorDefine;
        zrUtil.each(levels, function (levelDefine) {
          var model = new Model(levelDefine);
          var modelColor = model.get('color');

          if (model.get('itemStyle.color') || modelColor && modelColor !== 'none') {
            hasColorDefine = true;
          }
        });

        if (!hasColorDefine) {
          var level0 = levels[0] || (levels[0] = {});
          level0.color = globalColorList.slice();
        }

        return levels;
      }

      module.exports = _default;
      /***/
    },

    /***/
    "kzvK":
    /*!*********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/timeline/TimelineView.js ***!
      \*********************************************************************/

    /*! no static exports found */

    /***/
    function kzvK(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var ComponentView = __webpack_require__(
      /*! ../../view/Component */
      "sS/r");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = ComponentView.extend({
        type: 'timeline'
      });

      module.exports = _default;
      /***/
    },

    /***/
    "lELe":
    /*!**************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/map/backwardCompat.js ***!
      \**************************************************************/

    /*! no static exports found */

    /***/
    function lELe(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function _default(option) {
        // Save geoCoord
        var mapSeries = [];
        zrUtil.each(option.series, function (seriesOpt) {
          if (seriesOpt && seriesOpt.type === 'map') {
            mapSeries.push(seriesOpt);
            seriesOpt.map = seriesOpt.map || seriesOpt.mapType; // Put x, y, width, height, x2, y2 in the top level

            zrUtil.defaults(seriesOpt, seriesOpt.mapLocation);
          }
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "lLGD":
    /*!***********************************************!*\
      !*** ./node_modules/echarts/lib/chart/bar.js ***!
      \***********************************************/

    /*! no static exports found */

    /***/
    function lLGD(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _barGrid = __webpack_require__(
      /*! ../layout/barGrid */
      "nVfU");

      var layout = _barGrid.layout;
      var largeLayout = _barGrid.largeLayout;

      __webpack_require__(
      /*! ../coord/cartesian/Grid */
      "Wqna");

      __webpack_require__(
      /*! ./bar/BarSeries */
      "F7hV");

      __webpack_require__(
      /*! ./bar/BarView */
      "Z8zF");

      __webpack_require__(
      /*! ../component/gridSimple */
      "Ae16");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // In case developer forget to include grid component


      echarts.registerLayout(echarts.PRIORITY.VISUAL.LAYOUT, zrUtil.curry(layout, 'bar')); // Use higher prority to avoid to be blocked by other overall layout, which do not
      // only exist in this module, but probably also exist in other modules, like `barPolar`.

      echarts.registerLayout(echarts.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, largeLayout);
      echarts.registerVisual({
        seriesType: 'bar',
        reset: function reset(seriesModel) {
          // Visual coding for legend
          seriesModel.getData().setVisual('legendSymbol', 'roundRect');
        }
      });
      /***/
    },

    /***/
    "lOQZ":
    /*!**********************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/graph/circularLayoutHelper.js ***!
      \**********************************************************************/

    /*! no static exports found */

    /***/
    function lOQZ(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var vec2 = __webpack_require__(
      /*! zrender/lib/core/vector */
      "QBsz");

      var _graphHelper = __webpack_require__(
      /*! ./graphHelper */
      "U/Mo");

      var getSymbolSize = _graphHelper.getSymbolSize;
      var getNodeGlobalScale = _graphHelper.getNodeGlobalScale;

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _multipleGraphEdgeHelper = __webpack_require__(
      /*! ../helper/multipleGraphEdgeHelper */
      "DDd/");

      var getCurvenessForEdge = _multipleGraphEdgeHelper.getCurvenessForEdge;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var PI = Math.PI;
      var _symbolRadiansHalf = [];
      /**
       * `basedOn` can be:
       * 'value':
       *     This layout is not accurate and have same bad case. For example,
       *     if the min value is very smaller than the max value, the nodes
       *     with the min value probably overlap even though there is enough
       *     space to layout them. So we only use this approach in the as the
       *     init layout of the force layout.
       *     FIXME
       *     Probably we do not need this method any more but use
       *     `basedOn: 'symbolSize'` in force layout if
       *     delay its init operations to GraphView.
       * 'symbolSize':
       *     This approach work only if all of the symbol size calculated.
       *     That is, the progressive rendering is not applied to graph.
       *     FIXME
       *     If progressive rendering is applied to graph some day,
       *     probably we have to use `basedOn: 'value'`.
       *
       * @param {module:echarts/src/model/Series} seriesModel
       * @param {string} basedOn 'value' or 'symbolSize'
       */

      function circularLayout(seriesModel, basedOn) {
        var coordSys = seriesModel.coordinateSystem;

        if (coordSys && coordSys.type !== 'view') {
          return;
        }

        var rect = coordSys.getBoundingRect();
        var nodeData = seriesModel.getData();
        var graph = nodeData.graph;
        var cx = rect.width / 2 + rect.x;
        var cy = rect.height / 2 + rect.y;
        var r = Math.min(rect.width, rect.height) / 2;
        var count = nodeData.count();
        nodeData.setLayout({
          cx: cx,
          cy: cy
        });

        if (!count) {
          return;
        }

        _layoutNodesBasedOn[basedOn](seriesModel, coordSys, graph, nodeData, r, cx, cy, count);

        graph.eachEdge(function (edge, index) {
          var curveness = zrUtil.retrieve3(edge.getModel().get('lineStyle.curveness'), getCurvenessForEdge(edge, seriesModel, index), 0);
          var p1 = vec2.clone(edge.node1.getLayout());
          var p2 = vec2.clone(edge.node2.getLayout());
          var cp1;
          var x12 = (p1[0] + p2[0]) / 2;
          var y12 = (p1[1] + p2[1]) / 2;

          if (+curveness) {
            curveness *= 3;
            cp1 = [cx * curveness + x12 * (1 - curveness), cy * curveness + y12 * (1 - curveness)];
          }

          edge.setLayout([p1, p2, cp1]);
        });
      }

      var _layoutNodesBasedOn = {
        value: function value(seriesModel, coordSys, graph, nodeData, r, cx, cy, count) {
          var angle = 0;
          var sum = nodeData.getSum('value');
          var unitAngle = Math.PI * 2 / (sum || count);
          graph.eachNode(function (node) {
            var value = node.getValue('value');
            var radianHalf = unitAngle * (sum ? value : 1) / 2;
            angle += radianHalf;
            node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);
            angle += radianHalf;
          });
        },
        symbolSize: function symbolSize(seriesModel, coordSys, graph, nodeData, r, cx, cy, count) {
          var sumRadian = 0;
          _symbolRadiansHalf.length = count;
          var nodeScale = getNodeGlobalScale(seriesModel);
          graph.eachNode(function (node) {
            var symbolSize = getSymbolSize(node); // Normally this case will not happen, but we still add
            // some the defensive code (2px is an arbitrary value).

            isNaN(symbolSize) && (symbolSize = 2);
            symbolSize < 0 && (symbolSize = 0);
            symbolSize *= nodeScale;
            var symbolRadianHalf = Math.asin(symbolSize / 2 / r); // when `symbolSize / 2` is bigger than `r`.

            isNaN(symbolRadianHalf) && (symbolRadianHalf = PI / 2);
            _symbolRadiansHalf[node.dataIndex] = symbolRadianHalf;
            sumRadian += symbolRadianHalf * 2;
          });
          var halfRemainRadian = (2 * PI - sumRadian) / count / 2;
          var angle = 0;
          graph.eachNode(function (node) {
            var radianHalf = halfRemainRadian + _symbolRadiansHalf[node.dataIndex];
            angle += radianHalf;
            node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);
            angle += radianHalf;
          });
        }
      };
      exports.circularLayout = circularLayout;
      /***/
    },

    /***/
    "laiN":
    /*!********************************************************!*\
      !*** ./node_modules/echarts/lib/component/markLine.js ***!
      \********************************************************/

    /*! no static exports found */

    /***/
    function laiN(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ./marker/MarkLineModel */
      "GVMX");

      __webpack_require__(
      /*! ./marker/MarkLineView */
      "MH26");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      echarts.registerPreprocessor(function (opt) {
        // Make sure markLine component is enabled
        opt.markLine = opt.markLine || {};
      });
      /***/
    },

    /***/
    "lwQL":
    /*!***********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/graph/GraphView.js ***!
      \***********************************************************/

    /*! no static exports found */

    /***/
    function lwQL(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var SymbolDraw = __webpack_require__(
      /*! ../helper/SymbolDraw */
      "9wZj");

      var LineDraw = __webpack_require__(
      /*! ../helper/LineDraw */
      "c8qY");

      var RoamController = __webpack_require__(
      /*! ../../component/helper/RoamController */
      "SgGq");

      var roamHelper = __webpack_require__(
      /*! ../../component/helper/roamHelper */
      "Ae+d");

      var _cursorHelper = __webpack_require__(
      /*! ../../component/helper/cursorHelper */
      "xSat");

      var onIrrelevantElement = _cursorHelper.onIrrelevantElement;

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var adjustEdge = __webpack_require__(
      /*! ./adjustEdge */
      "SA8n");

      var _graphHelper = __webpack_require__(
      /*! ./graphHelper */
      "U/Mo");

      var getNodeGlobalScale = _graphHelper.getNodeGlobalScale;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var FOCUS_ADJACENCY = '__focusNodeAdjacency';
      var UNFOCUS_ADJACENCY = '__unfocusNodeAdjacency';
      var nodeOpacityPath = ['itemStyle', 'opacity'];
      var lineOpacityPath = ['lineStyle', 'opacity'];

      function getItemOpacity(item, opacityPath) {
        var opacity = item.getVisual('opacity');
        return opacity != null ? opacity : item.getModel().get(opacityPath);
      }

      function fadeOutItem(item, opacityPath, opacityRatio) {
        var el = item.getGraphicEl();
        var opacity = getItemOpacity(item, opacityPath);

        if (opacityRatio != null) {
          opacity == null && (opacity = 1);
          opacity *= opacityRatio;
        }

        el.downplay && el.downplay();
        el.traverse(function (child) {
          if (!child.isGroup) {
            var opct = child.lineLabelOriginalOpacity;

            if (opct == null || opacityRatio != null) {
              opct = opacity;
            }

            child.setStyle('opacity', opct);
          }
        });
      }

      function fadeInItem(item, opacityPath) {
        var opacity = getItemOpacity(item, opacityPath);
        var el = item.getGraphicEl(); // Should go back to normal opacity first, consider hoverLayer,
        // where current state is copied to elMirror, and support
        // emphasis opacity here.

        el.traverse(function (child) {
          !child.isGroup && child.setStyle('opacity', opacity);
        });
        el.highlight && el.highlight();
      }

      var _default = echarts.extendChartView({
        type: 'graph',
        init: function init(ecModel, api) {
          var symbolDraw = new SymbolDraw();
          var lineDraw = new LineDraw();
          var group = this.group;
          this._controller = new RoamController(api.getZr());
          this._controllerHost = {
            target: group
          };
          group.add(symbolDraw.group);
          group.add(lineDraw.group);
          this._symbolDraw = symbolDraw;
          this._lineDraw = lineDraw;
          this._firstRender = true;
        },
        render: function render(seriesModel, ecModel, api) {
          var graphView = this;
          var coordSys = seriesModel.coordinateSystem;
          this._model = seriesModel;
          var symbolDraw = this._symbolDraw;
          var lineDraw = this._lineDraw;
          var group = this.group;

          if (coordSys.type === 'view') {
            var groupNewProp = {
              position: coordSys.position,
              scale: coordSys.scale
            };

            if (this._firstRender) {
              group.attr(groupNewProp);
            } else {
              graphic.updateProps(group, groupNewProp, seriesModel);
            }
          } // Fix edge contact point with node


          adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
          var data = seriesModel.getData();
          symbolDraw.updateData(data);
          var edgeData = seriesModel.getEdgeData();
          lineDraw.updateData(edgeData);

          this._updateNodeAndLinkScale();

          this._updateController(seriesModel, ecModel, api);

          clearTimeout(this._layoutTimeout);
          var forceLayout = seriesModel.forceLayout;
          var layoutAnimation = seriesModel.get('force.layoutAnimation');

          if (forceLayout) {
            this._startForceLayoutIteration(forceLayout, layoutAnimation);
          }

          data.eachItemGraphicEl(function (el, idx) {
            var itemModel = data.getItemModel(idx); // Update draggable

            el.off('drag').off('dragend');
            var draggable = itemModel.get('draggable');

            if (draggable) {
              el.on('drag', function () {
                if (forceLayout) {
                  forceLayout.warmUp();
                  !this._layouting && this._startForceLayoutIteration(forceLayout, layoutAnimation);
                  forceLayout.setFixed(idx); // Write position back to layout

                  data.setItemLayout(idx, el.position);
                }
              }, this).on('dragend', function () {
                if (forceLayout) {
                  forceLayout.setUnfixed(idx);
                }
              }, this);
            }

            el.setDraggable(draggable && forceLayout);
            el[FOCUS_ADJACENCY] && el.off('mouseover', el[FOCUS_ADJACENCY]);
            el[UNFOCUS_ADJACENCY] && el.off('mouseout', el[UNFOCUS_ADJACENCY]);

            if (itemModel.get('focusNodeAdjacency')) {
              el.on('mouseover', el[FOCUS_ADJACENCY] = function () {
                graphView._clearTimer();

                api.dispatchAction({
                  type: 'focusNodeAdjacency',
                  seriesId: seriesModel.id,
                  dataIndex: el.dataIndex
                });
              });
              el.on('mouseout', el[UNFOCUS_ADJACENCY] = function () {
                graphView._dispatchUnfocus(api);
              });
            }
          }, this);
          data.graph.eachEdge(function (edge) {
            var el = edge.getGraphicEl();
            el[FOCUS_ADJACENCY] && el.off('mouseover', el[FOCUS_ADJACENCY]);
            el[UNFOCUS_ADJACENCY] && el.off('mouseout', el[UNFOCUS_ADJACENCY]);

            if (edge.getModel().get('focusNodeAdjacency')) {
              el.on('mouseover', el[FOCUS_ADJACENCY] = function () {
                graphView._clearTimer();

                api.dispatchAction({
                  type: 'focusNodeAdjacency',
                  seriesId: seriesModel.id,
                  edgeDataIndex: edge.dataIndex
                });
              });
              el.on('mouseout', el[UNFOCUS_ADJACENCY] = function () {
                graphView._dispatchUnfocus(api);
              });
            }
          });
          var circularRotateLabel = seriesModel.get('layout') === 'circular' && seriesModel.get('circular.rotateLabel');
          var cx = data.getLayout('cx');
          var cy = data.getLayout('cy');
          data.eachItemGraphicEl(function (el, idx) {
            var itemModel = data.getItemModel(idx);
            var labelRotate = itemModel.get('label.rotate') || 0;
            var symbolPath = el.getSymbolPath();

            if (circularRotateLabel) {
              var pos = data.getItemLayout(idx);
              var rad = Math.atan2(pos[1] - cy, pos[0] - cx);

              if (rad < 0) {
                rad = Math.PI * 2 + rad;
              }

              var isLeft = pos[0] < cx;

              if (isLeft) {
                rad = rad - Math.PI;
              }

              var textPosition = isLeft ? 'left' : 'right';
              graphic.modifyLabelStyle(symbolPath, {
                textRotation: -rad,
                textPosition: textPosition,
                textOrigin: 'center'
              }, {
                textPosition: textPosition
              });
            } else {
              graphic.modifyLabelStyle(symbolPath, {
                textRotation: labelRotate *= Math.PI / 180
              });
            }
          });
          this._firstRender = false;
        },
        dispose: function dispose() {
          this._controller && this._controller.dispose();
          this._controllerHost = {};

          this._clearTimer();
        },
        _dispatchUnfocus: function _dispatchUnfocus(api, opt) {
          var self = this;

          this._clearTimer();

          this._unfocusDelayTimer = setTimeout(function () {
            self._unfocusDelayTimer = null;
            api.dispatchAction({
              type: 'unfocusNodeAdjacency',
              seriesId: self._model.id
            });
          }, 500);
        },
        _clearTimer: function _clearTimer() {
          if (this._unfocusDelayTimer) {
            clearTimeout(this._unfocusDelayTimer);
            this._unfocusDelayTimer = null;
          }
        },
        focusNodeAdjacency: function focusNodeAdjacency(seriesModel, ecModel, api, payload) {
          var data = seriesModel.getData();
          var graph = data.graph;
          var dataIndex = payload.dataIndex;
          var edgeDataIndex = payload.edgeDataIndex;
          var node = graph.getNodeByIndex(dataIndex);
          var edge = graph.getEdgeByIndex(edgeDataIndex);

          if (!node && !edge) {
            return;
          }

          graph.eachNode(function (node) {
            fadeOutItem(node, nodeOpacityPath, 0.1);
          });
          graph.eachEdge(function (edge) {
            fadeOutItem(edge, lineOpacityPath, 0.1);
          });

          if (node) {
            fadeInItem(node, nodeOpacityPath);
            zrUtil.each(node.edges, function (adjacentEdge) {
              if (adjacentEdge.dataIndex < 0) {
                return;
              }

              fadeInItem(adjacentEdge, lineOpacityPath);
              fadeInItem(adjacentEdge.node1, nodeOpacityPath);
              fadeInItem(adjacentEdge.node2, nodeOpacityPath);
            });
          }

          if (edge) {
            fadeInItem(edge, lineOpacityPath);
            fadeInItem(edge.node1, nodeOpacityPath);
            fadeInItem(edge.node2, nodeOpacityPath);
          }
        },
        unfocusNodeAdjacency: function unfocusNodeAdjacency(seriesModel, ecModel, api, payload) {
          var graph = seriesModel.getData().graph;
          graph.eachNode(function (node) {
            fadeOutItem(node, nodeOpacityPath);
          });
          graph.eachEdge(function (edge) {
            fadeOutItem(edge, lineOpacityPath);
          });
        },
        _startForceLayoutIteration: function _startForceLayoutIteration(forceLayout, layoutAnimation) {
          var self = this;

          (function step() {
            forceLayout.step(function (stopped) {
              self.updateLayout(self._model);
              (self._layouting = !stopped) && (layoutAnimation ? self._layoutTimeout = setTimeout(step, 16) : step());
            });
          })();
        },
        _updateController: function _updateController(seriesModel, ecModel, api) {
          var controller = this._controller;
          var controllerHost = this._controllerHost;
          var group = this.group;
          controller.setPointerChecker(function (e, x, y) {
            var rect = group.getBoundingRect();
            rect.applyTransform(group.transform);
            return rect.contain(x, y) && !onIrrelevantElement(e, api, seriesModel);
          });

          if (seriesModel.coordinateSystem.type !== 'view') {
            controller.disable();
            return;
          }

          controller.enable(seriesModel.get('roam'));
          controllerHost.zoomLimit = seriesModel.get('scaleLimit');
          controllerHost.zoom = seriesModel.coordinateSystem.getZoom();
          controller.off('pan').off('zoom').on('pan', function (e) {
            roamHelper.updateViewOnPan(controllerHost, e.dx, e.dy);
            api.dispatchAction({
              seriesId: seriesModel.id,
              type: 'graphRoam',
              dx: e.dx,
              dy: e.dy
            });
          }).on('zoom', function (e) {
            roamHelper.updateViewOnZoom(controllerHost, e.scale, e.originX, e.originY);
            api.dispatchAction({
              seriesId: seriesModel.id,
              type: 'graphRoam',
              zoom: e.scale,
              originX: e.originX,
              originY: e.originY
            });

            this._updateNodeAndLinkScale();

            adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));

            this._lineDraw.updateLayout();
          }, this);
        },
        _updateNodeAndLinkScale: function _updateNodeAndLinkScale() {
          var seriesModel = this._model;
          var data = seriesModel.getData();
          var nodeScale = getNodeGlobalScale(seriesModel);
          var invScale = [nodeScale, nodeScale];
          data.eachItemGraphicEl(function (el, idx) {
            el.attr('scale', invScale);
          });
        },
        updateLayout: function updateLayout(seriesModel) {
          adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));

          this._symbolDraw.updateLayout();

          this._lineDraw.updateLayout();
        },
        remove: function remove(ecModel, api) {
          this._symbolDraw && this._symbolDraw.remove();
          this._lineDraw && this._lineDraw.remove();
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "mOdp":
    /*!******************************************************!*\
      !*** ./node_modules/echarts/lib/visual/dataColor.js ***!
      \******************************************************/

    /*! no static exports found */

    /***/
    function mOdp(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _util = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var createHashMap = _util.createHashMap;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // Pick color from palette for each data item.
      // Applicable for charts that require applying color palette
      // in data level (like pie, funnel, chord).

      function _default(seriesType) {
        return {
          getTargetSeries: function getTargetSeries(ecModel) {
            // Pie and funnel may use diferrent scope
            var paletteScope = {};
            var seiresModelMap = createHashMap();
            ecModel.eachSeriesByType(seriesType, function (seriesModel) {
              seriesModel.__paletteScope = paletteScope;
              seiresModelMap.set(seriesModel.uid, seriesModel);
            });
            return seiresModelMap;
          },
          reset: function reset(seriesModel, ecModel) {
            var dataAll = seriesModel.getRawData();
            var idxMap = {};
            var data = seriesModel.getData();
            data.each(function (idx) {
              var rawIdx = data.getRawIndex(idx);
              idxMap[rawIdx] = idx;
            });
            dataAll.each(function (rawIdx) {
              var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded

              var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);
              var singleDataBorderColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'borderColor', true);
              var itemModel;

              if (!singleDataColor || !singleDataBorderColor) {
                // FIXME Performance
                itemModel = dataAll.getItemModel(rawIdx);
              }

              if (!singleDataColor) {
                var color = itemModel.get('itemStyle.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + '', seriesModel.__paletteScope, dataAll.count()); // Data is not filtered

                if (filteredIdx != null) {
                  data.setItemVisual(filteredIdx, 'color', color);
                }
              }

              if (!singleDataBorderColor) {
                var borderColor = itemModel.get('itemStyle.borderColor'); // Data is not filtered

                if (filteredIdx != null) {
                  data.setItemVisual(filteredIdx, 'borderColor', borderColor);
                }
              }
            });
          }
        };
      }

      module.exports = _default;
      /***/
    },

    /***/
    "n4Lv":
    /*!*******************************************************!*\
      !*** ./node_modules/echarts/lib/chart/line/helper.js ***!
      \*******************************************************/

    /*! no static exports found */

    /***/
    function n4Lv(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _dataStackHelper = __webpack_require__(
      /*! ../../data/helper/dataStackHelper */
      "7hqr");

      var isDimensionStacked = _dataStackHelper.isDimensionStacked;

      var _util = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var map = _util.map;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @param {Object} coordSys
       * @param {module:echarts/data/List} data
       * @param {string} valueOrigin lineSeries.option.areaStyle.origin
       */

      function prepareDataCoordInfo(coordSys, data, valueOrigin) {
        var baseAxis = coordSys.getBaseAxis();
        var valueAxis = coordSys.getOtherAxis(baseAxis);
        var valueStart = getValueStart(valueAxis, valueOrigin);
        var baseAxisDim = baseAxis.dim;
        var valueAxisDim = valueAxis.dim;
        var valueDim = data.mapDimension(valueAxisDim);
        var baseDim = data.mapDimension(baseAxisDim);
        var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;
        var dims = map(coordSys.dimensions, function (coordDim) {
          return data.mapDimension(coordDim);
        });
        var stacked;
        var stackResultDim = data.getCalculationInfo('stackResultDimension');

        if (stacked |= isDimensionStacked(data, dims[0]
        /*, dims[1]*/
        )) {
          // jshint ignore:line
          dims[0] = stackResultDim;
        }

        if (stacked |= isDimensionStacked(data, dims[1]
        /*, dims[0]*/
        )) {
          // jshint ignore:line
          dims[1] = stackResultDim;
        }

        return {
          dataDimsForPoint: dims,
          valueStart: valueStart,
          valueAxisDim: valueAxisDim,
          baseAxisDim: baseAxisDim,
          stacked: !!stacked,
          valueDim: valueDim,
          baseDim: baseDim,
          baseDataOffset: baseDataOffset,
          stackedOverDimension: data.getCalculationInfo('stackedOverDimension')
        };
      }

      function getValueStart(valueAxis, valueOrigin) {
        var valueStart = 0;
        var extent = valueAxis.scale.getExtent();

        if (valueOrigin === 'start') {
          valueStart = extent[0];
        } else if (valueOrigin === 'end') {
          valueStart = extent[1];
        } // auto
        else {
          // Both positive
          if (extent[0] > 0) {
            valueStart = extent[0];
          } // Both negative
          else if (extent[1] < 0) {
            valueStart = extent[1];
          } // If is one positive, and one negative, onZero shall be true

        }

        return valueStart;
      }

      function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {
        var value = NaN;

        if (dataCoordInfo.stacked) {
          value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);
        }

        if (isNaN(value)) {
          value = dataCoordInfo.valueStart;
        }

        var baseDataOffset = dataCoordInfo.baseDataOffset;
        var stackedData = [];
        stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);
        stackedData[1 - baseDataOffset] = value;
        return coordSys.dataToPoint(stackedData);
      }

      exports.prepareDataCoordInfo = prepareDataCoordInfo;
      exports.getStackedOnPoint = getStackedOnPoint;
      /***/
    },

    /***/
    "n6Mw":
    /*!****************************************************************!*\
      !*** ./node_modules/zrender/lib/svg/helper/ClippathManager.js ***!
      \****************************************************************/

    /*! no static exports found */

    /***/
    function n6Mw(module, exports, __webpack_require__) {
      var Definable = __webpack_require__(
      /*! ./Definable */
      "SrGk");

      var zrUtil = __webpack_require__(
      /*! ../../core/util */
      "bYtY");

      var matrix = __webpack_require__(
      /*! ../../core/matrix */
      "Fofx");
      /**
       * @file Manages SVG clipPath elements.
       * @author Zhang Wenli
       */

      /**
       * Manages SVG clipPath elements.
       *
       * @class
       * @extends Definable
       * @param   {number}     zrId    zrender instance id
       * @param   {SVGElement} svgRoot root of SVG document
       */


      function ClippathManager(zrId, svgRoot) {
        Definable.call(this, zrId, svgRoot, 'clipPath', '__clippath_in_use__');
      }

      zrUtil.inherits(ClippathManager, Definable);
      /**
       * Update clipPath.
       *
       * @param {Displayable} displayable displayable element
       */

      ClippathManager.prototype.update = function (displayable) {
        var svgEl = this.getSvgElement(displayable);

        if (svgEl) {
          this.updateDom(svgEl, displayable.__clipPaths, false);
        }

        var textEl = this.getTextSvgElement(displayable);

        if (textEl) {
          // Make another clipPath for text, since it's transform
          // matrix is not the same with svgElement
          this.updateDom(textEl, displayable.__clipPaths, true);
        }

        this.markUsed(displayable);
      };
      /**
       * Create an SVGElement of displayable and create a <clipPath> of its
       * clipPath
       *
       * @param {Displayable} parentEl  parent element
       * @param {ClipPath[]}  clipPaths clipPaths of parent element
       * @param {boolean}     isText    if parent element is Text
       */


      ClippathManager.prototype.updateDom = function (parentEl, clipPaths, isText) {
        if (clipPaths && clipPaths.length > 0) {
          // Has clipPath, create <clipPath> with the first clipPath
          var defs = this.getDefs(true);
          var clipPath = clipPaths[0];
          var clipPathEl;
          var id;
          var dom = isText ? '_textDom' : '_dom';

          if (clipPath[dom]) {
            // Use a dom that is already in <defs>
            id = clipPath[dom].getAttribute('id');
            clipPathEl = clipPath[dom]; // Use a dom that is already in <defs>

            if (!defs.contains(clipPathEl)) {
              // This happens when set old clipPath that has
              // been previously removed
              defs.appendChild(clipPathEl);
            }
          } else {
            // New <clipPath>
            id = 'zr' + this._zrId + '-clip-' + this.nextId;
            ++this.nextId;
            clipPathEl = this.createElement('clipPath');
            clipPathEl.setAttribute('id', id);
            defs.appendChild(clipPathEl);
            clipPath[dom] = clipPathEl;
          } // Build path and add to <clipPath>


          var svgProxy = this.getSvgProxy(clipPath);

          if (clipPath.transform && clipPath.parent.invTransform && !isText) {
            /**
             * If a clipPath has a parent with transform, the transform
             * of parent should not be considered when setting transform
             * of clipPath. So we need to transform back from parent's
             * transform, which is done by multiplying parent's inverse
             * transform.
             */
            // Store old transform
            var transform = Array.prototype.slice.call(clipPath.transform); // Transform back from parent, and brush path

            matrix.mul(clipPath.transform, clipPath.parent.invTransform, clipPath.transform);
            svgProxy.brush(clipPath); // Set back transform of clipPath

            clipPath.transform = transform;
          } else {
            svgProxy.brush(clipPath);
          }

          var pathEl = this.getSvgElement(clipPath);
          clipPathEl.innerHTML = '';
          /**
           * Use `cloneNode()` here to appendChild to multiple parents,
           * which may happend when Text and other shapes are using the same
           * clipPath. Since Text will create an extra clipPath DOM due to
           * different transform rules.
           */

          clipPathEl.appendChild(pathEl.cloneNode());
          parentEl.setAttribute('clip-path', 'url(#' + id + ')');

          if (clipPaths.length > 1) {
            // Make the other clipPaths recursively
            this.updateDom(clipPathEl, clipPaths.slice(1), isText);
          }
        } else {
          // No clipPath
          if (parentEl) {
            parentEl.setAttribute('clip-path', 'none');
          }
        }
      };
      /**
       * Mark a single clipPath to be used
       *
       * @param {Displayable} displayable displayable element
       */


      ClippathManager.prototype.markUsed = function (displayable) {
        var that = this; // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.

        if (displayable.__clipPaths) {
          zrUtil.each(displayable.__clipPaths, function (clipPath) {
            if (clipPath._dom) {
              Definable.prototype.markUsed.call(that, clipPath._dom);
            }

            if (clipPath._textDom) {
              Definable.prototype.markUsed.call(that, clipPath._textDom);
            }
          });
        }
      };

      var _default = ClippathManager;
      module.exports = _default;
      /***/
    },

    /***/
    "nKiI":
    /*!*****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/treemap/treemapLayout.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function nKiI(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var BoundingRect = __webpack_require__(
      /*! zrender/lib/core/BoundingRect */
      "mFDi");

      var _number = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var parsePercent = _number.parsePercent;
      var MAX_SAFE_INTEGER = _number.MAX_SAFE_INTEGER;

      var layout = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var helper = __webpack_require__(
      /*! ../helper/treeHelper */
      "VaxA");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * A third-party license is embeded for some of the code in this file:
      * The treemap layout implementation was originally copied from
      * "d3.js" with some modifications made for this project.
      * (See more details in the comment of the method "squarify" below.)
      * The use of the source code of this file is also subject to the terms
      * and consitions of the license of "d3.js" (BSD-3Clause, see
      * </licenses/LICENSE-d3>).
      */


      var mathMax = Math.max;
      var mathMin = Math.min;
      var retrieveValue = zrUtil.retrieve;
      var each = zrUtil.each;
      var PATH_BORDER_WIDTH = ['itemStyle', 'borderWidth'];
      var PATH_GAP_WIDTH = ['itemStyle', 'gapWidth'];
      var PATH_UPPER_LABEL_SHOW = ['upperLabel', 'show'];
      var PATH_UPPER_LABEL_HEIGHT = ['upperLabel', 'height'];
      /**
       * @public
       */

      var _default = {
        seriesType: 'treemap',
        reset: function reset(seriesModel, ecModel, api, payload) {
          // Layout result in each node:
          // {x, y, width, height, area, borderWidth}
          var ecWidth = api.getWidth();
          var ecHeight = api.getHeight();
          var seriesOption = seriesModel.option;
          var layoutInfo = layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
            width: api.getWidth(),
            height: api.getHeight()
          });
          var size = seriesOption.size || []; // Compatible with ec2.

          var containerWidth = parsePercent(retrieveValue(layoutInfo.width, size[0]), ecWidth);
          var containerHeight = parsePercent(retrieveValue(layoutInfo.height, size[1]), ecHeight); // Fetch payload info.

          var payloadType = payload && payload.type;
          var types = ['treemapZoomToNode', 'treemapRootToNode'];
          var targetInfo = helper.retrieveTargetInfo(payload, types, seriesModel);
          var rootRect = payloadType === 'treemapRender' || payloadType === 'treemapMove' ? payload.rootRect : null;
          var viewRoot = seriesModel.getViewRoot();
          var viewAbovePath = helper.getPathToRoot(viewRoot);

          if (payloadType !== 'treemapMove') {
            var rootSize = payloadType === 'treemapZoomToNode' ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight];
            var sort = seriesOption.sort;

            if (sort && sort !== 'asc' && sort !== 'desc') {
              sort = 'desc';
            }

            var options = {
              squareRatio: seriesOption.squareRatio,
              sort: sort,
              leafDepth: seriesOption.leafDepth
            }; // layout should be cleared because using updateView but not update.

            viewRoot.hostTree.clearLayouts(); // TODO
            // optimize: if out of view clip, do not layout.
            // But take care that if do not render node out of view clip,
            // how to calculate start po

            var viewRootLayout = {
              x: 0,
              y: 0,
              width: rootSize[0],
              height: rootSize[1],
              area: rootSize[0] * rootSize[1]
            };
            viewRoot.setLayout(viewRootLayout);
            squarify(viewRoot, options, false, 0); // Supplement layout.

            var viewRootLayout = viewRoot.getLayout();
            each(viewAbovePath, function (node, index) {
              var childValue = (viewAbovePath[index + 1] || viewRoot).getValue();
              node.setLayout(zrUtil.extend({
                dataExtent: [childValue, childValue],
                borderWidth: 0,
                upperHeight: 0
              }, viewRootLayout));
            });
          }

          var treeRoot = seriesModel.getData().tree.root;
          treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);
          seriesModel.setLayoutInfo(layoutInfo); // FIXME
          // clipec

          prunning(treeRoot, // Transform to base element coordinate system.
          new BoundingRect(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight), viewAbovePath, viewRoot, 0);
        }
      };
      /**
       * Layout treemap with squarify algorithm.
       * The original presentation of this algorithm
       * was made by Mark Bruls, Kees Huizing, and Jarke J. van Wijk
       * <https://graphics.ethz.ch/teaching/scivis_common/Literature/squarifiedTreeMaps.pdf>.
       * The implementation of this algorithm was originally copied from "d3.js"
       * <https://github.com/d3/d3/blob/9cc9a875e636a1dcf36cc1e07bdf77e1ad6e2c74/src/layout/treemap.js>
       * with some modifications made for this program.
       * See the license statement at the head of this file.
       *
       * @protected
       * @param {module:echarts/data/Tree~TreeNode} node
       * @param {Object} options
       * @param {string} options.sort 'asc' or 'desc'
       * @param {number} options.squareRatio
       * @param {boolean} hideChildren
       * @param {number} depth
       */

      function squarify(node, options, hideChildren, depth) {
        var width;
        var height;

        if (node.isRemoved()) {
          return;
        }

        var thisLayout = node.getLayout();
        width = thisLayout.width;
        height = thisLayout.height; // Considering border and gap

        var nodeModel = node.getModel();
        var borderWidth = nodeModel.get(PATH_BORDER_WIDTH);
        var halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2;
        var upperLabelHeight = getUpperLabelHeight(nodeModel);
        var upperHeight = Math.max(borderWidth, upperLabelHeight);
        var layoutOffset = borderWidth - halfGapWidth;
        var layoutOffsetUpper = upperHeight - halfGapWidth;
        var nodeModel = node.getModel();
        node.setLayout({
          borderWidth: borderWidth,
          upperHeight: upperHeight,
          upperLabelHeight: upperLabelHeight
        }, true);
        width = mathMax(width - 2 * layoutOffset, 0);
        height = mathMax(height - layoutOffset - layoutOffsetUpper, 0);
        var totalArea = width * height;
        var viewChildren = initChildren(node, nodeModel, totalArea, options, hideChildren, depth);

        if (!viewChildren.length) {
          return;
        }

        var rect = {
          x: layoutOffset,
          y: layoutOffsetUpper,
          width: width,
          height: height
        };
        var rowFixedLength = mathMin(width, height);
        var best = Infinity; // the best row score so far

        var row = [];
        row.area = 0;

        for (var i = 0, len = viewChildren.length; i < len;) {
          var child = viewChildren[i];
          row.push(child);
          row.area += child.getLayout().area;
          var score = worst(row, rowFixedLength, options.squareRatio); // continue with this orientation

          if (score <= best) {
            i++;
            best = score;
          } // abort, and try a different orientation
          else {
            row.area -= row.pop().getLayout().area;
            position(row, rowFixedLength, rect, halfGapWidth, false);
            rowFixedLength = mathMin(rect.width, rect.height);
            row.length = row.area = 0;
            best = Infinity;
          }
        }

        if (row.length) {
          position(row, rowFixedLength, rect, halfGapWidth, true);
        }

        if (!hideChildren) {
          var childrenVisibleMin = nodeModel.get('childrenVisibleMin');

          if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {
            hideChildren = true;
          }
        }

        for (var i = 0, len = viewChildren.length; i < len; i++) {
          squarify(viewChildren[i], options, hideChildren, depth + 1);
        }
      }
      /**
       * Set area to each child, and calculate data extent for visual coding.
       */


      function initChildren(node, nodeModel, totalArea, options, hideChildren, depth) {
        var viewChildren = node.children || [];
        var orderBy = options.sort;
        orderBy !== 'asc' && orderBy !== 'desc' && (orderBy = null);
        var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth; // leafDepth has higher priority.

        if (hideChildren && !overLeafDepth) {
          return node.viewChildren = [];
        } // Sort children, order by desc.


        viewChildren = zrUtil.filter(viewChildren, function (child) {
          return !child.isRemoved();
        });
        sort(viewChildren, orderBy);
        var info = statistic(nodeModel, viewChildren, orderBy);

        if (info.sum === 0) {
          return node.viewChildren = [];
        }

        info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);

        if (info.sum === 0) {
          return node.viewChildren = [];
        } // Set area to each child.


        for (var i = 0, len = viewChildren.length; i < len; i++) {
          var area = viewChildren[i].getValue() / info.sum * totalArea; // Do not use setLayout({...}, true), because it is needed to clear last layout.

          viewChildren[i].setLayout({
            area: area
          });
        }

        if (overLeafDepth) {
          viewChildren.length && node.setLayout({
            isLeafRoot: true
          }, true);
          viewChildren.length = 0;
        }

        node.viewChildren = viewChildren;
        node.setLayout({
          dataExtent: info.dataExtent
        }, true);
        return viewChildren;
      }
      /**
       * Consider 'visibleMin'. Modify viewChildren and get new sum.
       */


      function filterByThreshold(nodeModel, totalArea, sum, orderBy, orderedChildren) {
        // visibleMin is not supported yet when no option.sort.
        if (!orderBy) {
          return sum;
        }

        var visibleMin = nodeModel.get('visibleMin');
        var len = orderedChildren.length;
        var deletePoint = len; // Always travel from little value to big value.

        for (var i = len - 1; i >= 0; i--) {
          var value = orderedChildren[orderBy === 'asc' ? len - i - 1 : i].getValue();

          if (value / sum * totalArea < visibleMin) {
            deletePoint = i;
            sum -= value;
          }
        }

        orderBy === 'asc' ? orderedChildren.splice(0, len - deletePoint) : orderedChildren.splice(deletePoint, len - deletePoint);
        return sum;
      }
      /**
       * Sort
       */


      function sort(viewChildren, orderBy) {
        if (orderBy) {
          viewChildren.sort(function (a, b) {
            var diff = orderBy === 'asc' ? a.getValue() - b.getValue() : b.getValue() - a.getValue();
            return diff === 0 ? orderBy === 'asc' ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex : diff;
          });
        }

        return viewChildren;
      }
      /**
       * Statistic
       */


      function statistic(nodeModel, children, orderBy) {
        // Calculate sum.
        var sum = 0;

        for (var i = 0, len = children.length; i < len; i++) {
          sum += children[i].getValue();
        } // Statistic data extent for latter visual coding.
        // Notice: data extent should be calculate based on raw children
        // but not filtered view children, otherwise visual mapping will not
        // be stable when zoom (where children is filtered by visibleMin).


        var dimension = nodeModel.get('visualDimension');
        var dataExtent; // The same as area dimension.

        if (!children || !children.length) {
          dataExtent = [NaN, NaN];
        } else if (dimension === 'value' && orderBy) {
          dataExtent = [children[children.length - 1].getValue(), children[0].getValue()];
          orderBy === 'asc' && dataExtent.reverse();
        } // Other dimension.
        else {
          var dataExtent = [Infinity, -Infinity];
          each(children, function (child) {
            var value = child.getValue(dimension);
            value < dataExtent[0] && (dataExtent[0] = value);
            value > dataExtent[1] && (dataExtent[1] = value);
          });
        }

        return {
          sum: sum,
          dataExtent: dataExtent
        };
      }
      /**
       * Computes the score for the specified row,
       * as the worst aspect ratio.
       */


      function worst(row, rowFixedLength, ratio) {
        var areaMax = 0;
        var areaMin = Infinity;

        for (var i = 0, area, len = row.length; i < len; i++) {
          area = row[i].getLayout().area;

          if (area) {
            area < areaMin && (areaMin = area);
            area > areaMax && (areaMax = area);
          }
        }

        var squareArea = row.area * row.area;
        var f = rowFixedLength * rowFixedLength * ratio;
        return squareArea ? mathMax(f * areaMax / squareArea, squareArea / (f * areaMin)) : Infinity;
      }
      /**
       * Positions the specified row of nodes. Modifies `rect`.
       */


      function position(row, rowFixedLength, rect, halfGapWidth, flush) {
        // When rowFixedLength === rect.width,
        // it is horizontal subdivision,
        // rowFixedLength is the width of the subdivision,
        // rowOtherLength is the height of the subdivision,
        // and nodes will be positioned from left to right.
        // wh[idx0WhenH] means: when horizontal,
        //      wh[idx0WhenH] => wh[0] => 'width'.
        //      xy[idx1WhenH] => xy[1] => 'y'.
        var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;
        var idx1WhenH = 1 - idx0WhenH;
        var xy = ['x', 'y'];
        var wh = ['width', 'height'];
        var last = rect[xy[idx0WhenH]];
        var rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;

        if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {
          rowOtherLength = rect[wh[idx1WhenH]]; // over+underflow
        }

        for (var i = 0, rowLen = row.length; i < rowLen; i++) {
          var node = row[i];
          var nodeLayout = {};
          var step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;
          var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax(rowOtherLength - 2 * halfGapWidth, 0); // We use Math.max/min to avoid negative width/height when considering gap width.

          var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;
          var modWH = i === rowLen - 1 || remain < step ? remain : step;
          var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax(modWH - 2 * halfGapWidth, 0);
          nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin(halfGapWidth, wh1 / 2);
          nodeLayout[xy[idx0WhenH]] = last + mathMin(halfGapWidth, wh0 / 2);
          last += modWH;
          node.setLayout(nodeLayout, true);
        }

        rect[xy[idx1WhenH]] += rowOtherLength;
        rect[wh[idx1WhenH]] -= rowOtherLength;
      } // Return [containerWidth, containerHeight] as default.


      function estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {
        // If targetInfo.node exists, we zoom to the node,
        // so estimate whold width and heigth by target node.
        var currNode = (targetInfo || {}).node;
        var defaultSize = [containerWidth, containerHeight];

        if (!currNode || currNode === viewRoot) {
          return defaultSize;
        }

        var parent;
        var viewArea = containerWidth * containerHeight;
        var area = viewArea * seriesModel.option.zoomToNodeRatio;

        while (parent = currNode.parentNode) {
          // jshint ignore:line
          var sum = 0;
          var siblings = parent.children;

          for (var i = 0, len = siblings.length; i < len; i++) {
            sum += siblings[i].getValue();
          }

          var currNodeValue = currNode.getValue();

          if (currNodeValue === 0) {
            return defaultSize;
          }

          area *= sum / currNodeValue; // Considering border, suppose aspect ratio is 1.

          var parentModel = parent.getModel();
          var borderWidth = parentModel.get(PATH_BORDER_WIDTH);
          var upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel, borderWidth));
          area += 4 * borderWidth * borderWidth + (3 * borderWidth + upperHeight) * Math.pow(area, 0.5);
          area > MAX_SAFE_INTEGER && (area = MAX_SAFE_INTEGER);
          currNode = parent;
        }

        area < viewArea && (area = viewArea);
        var scale = Math.pow(area / viewArea, 0.5);
        return [containerWidth * scale, containerHeight * scale];
      } // Root postion base on coord of containerGroup


      function calculateRootPosition(layoutInfo, rootRect, targetInfo) {
        if (rootRect) {
          return {
            x: rootRect.x,
            y: rootRect.y
          };
        }

        var defaultPosition = {
          x: 0,
          y: 0
        };

        if (!targetInfo) {
          return defaultPosition;
        } // If targetInfo is fetched by 'retrieveTargetInfo',
        // old tree and new tree are the same tree,
        // so the node still exists and we can visit it.


        var targetNode = targetInfo.node;
        var layout = targetNode.getLayout();

        if (!layout) {
          return defaultPosition;
        } // Transform coord from local to container.


        var targetCenter = [layout.width / 2, layout.height / 2];
        var node = targetNode;

        while (node) {
          var nodeLayout = node.getLayout();
          targetCenter[0] += nodeLayout.x;
          targetCenter[1] += nodeLayout.y;
          node = node.parentNode;
        }

        return {
          x: layoutInfo.width / 2 - targetCenter[0],
          y: layoutInfo.height / 2 - targetCenter[1]
        };
      } // Mark nodes visible for prunning when visual coding and rendering.
      // Prunning depends on layout and root position, so we have to do it after layout.


      function prunning(node, clipRect, viewAbovePath, viewRoot, depth) {
        var nodeLayout = node.getLayout();
        var nodeInViewAbovePath = viewAbovePath[depth];
        var isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;

        if (nodeInViewAbovePath && !isAboveViewRoot || depth === viewAbovePath.length && node !== viewRoot) {
          return;
        }

        node.setLayout({
          // isInView means: viewRoot sub tree + viewAbovePath
          isInView: true,
          // invisible only means: outside view clip so that the node can not
          // see but still layout for animation preparation but not render.
          invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),
          isAboveViewRoot: isAboveViewRoot
        }, true); // Transform to child coordinate.

        var childClipRect = new BoundingRect(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);
        each(node.viewChildren || [], function (child) {
          prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);
        });
      }

      function getUpperLabelHeight(model) {
        return model.get(PATH_UPPER_LABEL_SHOW) ? model.get(PATH_UPPER_LABEL_HEIGHT) : 0;
      }

      module.exports = _default;
      /***/
    },

    /***/
    "nkfE":
    /*!************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/axisModelCreator.js ***!
      \************************************************************/

    /*! no static exports found */

    /***/
    function nkfE(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var axisDefault = __webpack_require__(
      /*! ./axisDefault */
      "ca2m");

      var ComponentModel = __webpack_require__(
      /*! ../model/Component */
      "bLfw");

      var _layout = __webpack_require__(
      /*! ../util/layout */
      "+TT/");

      var getLayoutParams = _layout.getLayoutParams;
      var mergeLayoutParam = _layout.mergeLayoutParam;

      var OrdinalMeta = __webpack_require__(
      /*! ../data/OrdinalMeta */
      "jkPA");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // FIXME axisType is fixed ?


      var AXIS_TYPES = ['value', 'category', 'time', 'log'];
      /**
       * Generate sub axis model class
       * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'
       * @param {module:echarts/model/Component} BaseAxisModelClass
       * @param {Function} axisTypeDefaulter
       * @param {Object} [extraDefaultOption]
       */

      function _default(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {
        zrUtil.each(AXIS_TYPES, function (axisType) {
          BaseAxisModelClass.extend({
            /**
             * @readOnly
             */
            type: axisName + 'Axis.' + axisType,
            mergeDefaultAndTheme: function mergeDefaultAndTheme(option, ecModel) {
              var layoutMode = this.layoutMode;
              var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
              var themeModel = ecModel.getTheme();
              zrUtil.merge(option, themeModel.get(axisType + 'Axis'));
              zrUtil.merge(option, this.getDefaultOption());
              option.type = axisTypeDefaulter(axisName, option);

              if (layoutMode) {
                mergeLayoutParam(option, inputPositionParams, layoutMode);
              }
            },

            /**
             * @override
             */
            optionUpdated: function optionUpdated() {
              var thisOption = this.option;

              if (thisOption.type === 'category') {
                this.__ordinalMeta = OrdinalMeta.createByAxisModel(this);
              }
            },

            /**
             * Should not be called before all of 'getInitailData' finished.
             * Because categories are collected during initializing data.
             */
            getCategories: function getCategories(rawData) {
              var option = this.option; // FIXME
              // warning if called before all of 'getInitailData' finished.

              if (option.type === 'category') {
                if (rawData) {
                  return option.data;
                }

                return this.__ordinalMeta.categories;
              }
            },
            getOrdinalMeta: function getOrdinalMeta() {
              return this.__ordinalMeta;
            },
            defaultOption: zrUtil.mergeAll([{}, axisDefault[axisType + 'Axis'], extraDefaultOption], true)
          });
        });
        ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));
      }

      module.exports = _default;
      /***/
    },

    /***/
    "noeP":
    /*!***********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js ***!
      \***********************************************************************/

    /*! no static exports found */

    /***/
    function noeP(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var helper = __webpack_require__(
      /*! ./helper */
      "UOVi");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      echarts.registerAction('dataZoom', function (payload, ecModel) {
        var linkedNodesFinder = helper.createLinkedNodesFinder(zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'), helper.eachAxisDim, function (model, dimNames) {
          return model.get(dimNames.axisIndex);
        });
        var effectedModels = [];
        ecModel.eachComponent({
          mainType: 'dataZoom',
          query: payload
        }, function (model, index) {
          effectedModels.push.apply(effectedModels, linkedNodesFinder(model).nodes);
        });
        zrUtil.each(effectedModels, function (dataZoomModel, index) {
          dataZoomModel.setRawRange({
            start: payload.start,
            end: payload.end,
            startValue: payload.startValue,
            endValue: payload.endValue
          });
        });
      });
      /***/
    },

    /***/
    "o40c":
    /*!****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/helper/LargeLineDraw.js ***!
      \****************************************************************/

    /*! no static exports found */

    /***/
    function o40c(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var IncrementalDisplayable = __webpack_require__(
      /*! zrender/lib/graphic/IncrementalDisplayable */
      "OS9S");

      var lineContain = __webpack_require__(
      /*! zrender/lib/contain/line */
      "loD1");

      var quadraticContain = __webpack_require__(
      /*! zrender/lib/contain/quadratic */
      "aKvl");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // TODO Batch by color


      var LargeLineShape = graphic.extendShape({
        shape: {
          polyline: false,
          curveness: 0,
          segs: []
        },
        buildPath: function buildPath(path, shape) {
          var segs = shape.segs;
          var curveness = shape.curveness;

          if (shape.polyline) {
            for (var i = 0; i < segs.length;) {
              var count = segs[i++];

              if (count > 0) {
                path.moveTo(segs[i++], segs[i++]);

                for (var k = 1; k < count; k++) {
                  path.lineTo(segs[i++], segs[i++]);
                }
              }
            }
          } else {
            for (var i = 0; i < segs.length;) {
              var x0 = segs[i++];
              var y0 = segs[i++];
              var x1 = segs[i++];
              var y1 = segs[i++];
              path.moveTo(x0, y0);

              if (curveness > 0) {
                var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;
                var y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;
                path.quadraticCurveTo(x2, y2, x1, y1);
              } else {
                path.lineTo(x1, y1);
              }
            }
          }
        },
        findDataIndex: function findDataIndex(x, y) {
          var shape = this.shape;
          var segs = shape.segs;
          var curveness = shape.curveness;

          if (shape.polyline) {
            var dataIndex = 0;

            for (var i = 0; i < segs.length;) {
              var count = segs[i++];

              if (count > 0) {
                var x0 = segs[i++];
                var y0 = segs[i++];

                for (var k = 1; k < count; k++) {
                  var x1 = segs[i++];
                  var y1 = segs[i++];

                  if (lineContain.containStroke(x0, y0, x1, y1)) {
                    return dataIndex;
                  }
                }
              }

              dataIndex++;
            }
          } else {
            var dataIndex = 0;

            for (var i = 0; i < segs.length;) {
              var x0 = segs[i++];
              var y0 = segs[i++];
              var x1 = segs[i++];
              var y1 = segs[i++];

              if (curveness > 0) {
                var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;
                var y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;

                if (quadraticContain.containStroke(x0, y0, x2, y2, x1, y1)) {
                  return dataIndex;
                }
              } else {
                if (lineContain.containStroke(x0, y0, x1, y1)) {
                  return dataIndex;
                }
              }

              dataIndex++;
            }
          }

          return -1;
        }
      });

      function LargeLineDraw() {
        this.group = new graphic.Group();
      }

      var largeLineProto = LargeLineDraw.prototype;

      largeLineProto.isPersistent = function () {
        return !this._incremental;
      };
      /**
       * Update symbols draw by new data
       * @param {module:echarts/data/List} data
       */


      largeLineProto.updateData = function (data) {
        this.group.removeAll();
        var lineEl = new LargeLineShape({
          rectHover: true,
          cursor: 'default'
        });
        lineEl.setShape({
          segs: data.getLayout('linesPoints')
        });

        this._setCommon(lineEl, data); // Add back


        this.group.add(lineEl);
        this._incremental = null;
      };
      /**
       * @override
       */


      largeLineProto.incrementalPrepareUpdate = function (data) {
        this.group.removeAll();

        this._clearIncremental();

        if (data.count() > 5e5) {
          if (!this._incremental) {
            this._incremental = new IncrementalDisplayable({
              silent: true
            });
          }

          this.group.add(this._incremental);
        } else {
          this._incremental = null;
        }
      };
      /**
       * @override
       */


      largeLineProto.incrementalUpdate = function (taskParams, data) {
        var lineEl = new LargeLineShape();
        lineEl.setShape({
          segs: data.getLayout('linesPoints')
        });

        this._setCommon(lineEl, data, !!this._incremental);

        if (!this._incremental) {
          lineEl.rectHover = true;
          lineEl.cursor = 'default';
          lineEl.__startIndex = taskParams.start;
          this.group.add(lineEl);
        } else {
          this._incremental.addDisplayable(lineEl, true);
        }
      };
      /**
       * @override
       */


      largeLineProto.remove = function () {
        this._clearIncremental();

        this._incremental = null;
        this.group.removeAll();
      };

      largeLineProto._setCommon = function (lineEl, data, isIncremental) {
        var hostModel = data.hostModel;
        lineEl.setShape({
          polyline: hostModel.get('polyline'),
          curveness: hostModel.get('lineStyle.curveness')
        });
        lineEl.useStyle(hostModel.getModel('lineStyle').getLineStyle());
        lineEl.style.strokeNoScale = true;
        var visualColor = data.getVisual('color');

        if (visualColor) {
          lineEl.setStyle('stroke', visualColor);
        }

        lineEl.setStyle('fill');

        if (!isIncremental) {
          // Enable tooltip
          // PENDING May have performance issue when path is extremely large
          lineEl.seriesIndex = hostModel.seriesIndex;
          lineEl.on('mousemove', function (e) {
            lineEl.dataIndex = null;
            var dataIndex = lineEl.findDataIndex(e.offsetX, e.offsetY);

            if (dataIndex > 0) {
              // Provide dataIndex for tooltip
              lineEl.dataIndex = dataIndex + lineEl.__startIndex;
            }
          });
        }
      };

      largeLineProto._clearIncremental = function () {
        var incremental = this._incremental;

        if (incremental) {
          incremental.clearDisplaybles();
        }
      };

      var _default = LargeLineDraw;
      module.exports = _default;
      /***/
    },

    /***/
    "oBaM":
    /*!*************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/radar/RadarSeries.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function oBaM(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var SeriesModel = __webpack_require__(
      /*! ../../model/Series */
      "T4UG");

      var createListSimply = __webpack_require__(
      /*! ../helper/createListSimply */
      "5GtS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _format = __webpack_require__(
      /*! ../../util/format */
      "7aKB");

      var encodeHTML = _format.encodeHTML;

      var LegendVisualProvider = __webpack_require__(
      /*! ../../visual/LegendVisualProvider */
      "xKMd");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var RadarSeries = SeriesModel.extend({
        type: 'series.radar',
        dependencies: ['radar'],
        // Overwrite
        init: function init(option) {
          RadarSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item
          // Use a function instead of direct access because data reference may changed

          this.legendVisualProvider = new LegendVisualProvider(zrUtil.bind(this.getData, this), zrUtil.bind(this.getRawData, this));
        },
        getInitialData: function getInitialData(option, ecModel) {
          return createListSimply(this, {
            generateCoord: 'indicator_',
            generateCoordCount: Infinity
          });
        },
        formatTooltip: function formatTooltip(dataIndex, multipleSeries, dataType, renderMode) {
          var data = this.getData();
          var coordSys = this.coordinateSystem;
          var indicatorAxes = coordSys.getIndicatorAxes();
          var name = this.getData().getName(dataIndex);
          var newLine = renderMode === 'html' ? '<br/>' : '\n';
          return encodeHTML(name === '' ? this.name : name) + newLine + zrUtil.map(indicatorAxes, function (axis, idx) {
            var val = data.get(data.mapDimension(axis.dim), dataIndex);
            return encodeHTML(axis.name + ' : ' + val);
          }).join(newLine);
        },

        /**
         * @implement
         */
        getTooltipPosition: function getTooltipPosition(dataIndex) {
          if (dataIndex != null) {
            var data = this.getData();
            var coordSys = this.coordinateSystem;
            var values = data.getValues(zrUtil.map(coordSys.dimensions, function (dim) {
              return data.mapDimension(dim);
            }), dataIndex, true);

            for (var i = 0, len = values.length; i < len; i++) {
              if (!isNaN(values[i])) {
                var indicatorAxes = coordSys.getIndicatorAxes();
                return coordSys.coordToPoint(indicatorAxes[i].dataToCoord(values[i]), i);
              }
            }
          }
        },
        defaultOption: {
          zlevel: 0,
          z: 2,
          coordinateSystem: 'radar',
          legendHoverLink: true,
          radarIndex: 0,
          lineStyle: {
            width: 2,
            type: 'solid'
          },
          label: {
            position: 'top'
          },
          // areaStyle: {
          // },
          // itemStyle: {}
          symbol: 'emptyCircle',
          symbolSize: 4 // symbolRotate: null

        }
      });
      var _default = RadarSeries;
      module.exports = _default;
      /***/
    },

    /***/
    "oE7X":
    /*!**********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/timeline/typeDefaulter.js ***!
      \**********************************************************************/

    /*! no static exports found */

    /***/
    function oE7X(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var Component = __webpack_require__(
      /*! ../../model/Component */
      "bLfw");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      Component.registerSubTypeDefaulter('timeline', function () {
        // Only slider now.
        return 'slider';
      });
      /***/
    },

    /***/
    "oY9F":
    /*!************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js ***!
      \************************************************************************/

    /*! no static exports found */

    /***/
    function oY9F(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var DataZoomModel = __webpack_require__(
      /*! ./DataZoomModel */
      "OlYY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = DataZoomModel.extend({
        type: 'dataZoom.inside',

        /**
         * @protected
         */
        defaultOption: {
          disabled: false,
          // Whether disable this inside zoom.
          zoomLock: false,
          // Whether disable zoom but only pan.
          zoomOnMouseWheel: true,
          // Can be: true / false / 'shift' / 'ctrl' / 'alt'.
          moveOnMouseMove: true,
          // Can be: true / false / 'shift' / 'ctrl' / 'alt'.
          moveOnMouseWheel: false,
          // Can be: true / false / 'shift' / 'ctrl' / 'alt'.
          preventDefaultMouseMove: true
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "p+If":
    /*!*************************************************!*\
      !*** ./node_modules/echarts/lib/chart/lines.js ***!
      \*************************************************/

    /*! no static exports found */

    /***/
    function pIf(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ./lines/LinesSeries */
      "cpOr");

      __webpack_require__(
      /*! ./lines/LinesView */
      "rkZ5");

      var linesLayout = __webpack_require__(
      /*! ./lines/linesLayout */
      "ZYIC");

      var linesVisual = __webpack_require__(
      /*! ./lines/linesVisual */
      "7ph2");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      echarts.registerLayout(linesLayout);
      echarts.registerVisual(linesVisual);
      /***/
    },

    /***/
    "p/La":
    /*!****************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/geo/fix/diaoyuIsland.js ***!
      \****************************************************************/

    /*! no static exports found */

    /***/
    function pLa(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // Fix for 
      // var Region = require('../Region');
      // var zrUtil = require('zrender/src/core/util');
      // var geoCoord = [126, 25];
      var points = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];

      function _default(mapType, region) {
        if (mapType === 'china' && region.name === '') {
          region.geometries.push({
            type: 'polygon',
            exterior: points[0]
          });
        }
      }

      module.exports = _default;
      /***/
    },

    /***/
    "p1MT":
    /*!***********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/gauge/GaugeView.js ***!
      \***********************************************************/

    /*! no static exports found */

    /***/
    function p1MT(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var PointerPath = __webpack_require__(
      /*! ./PointerPath */
      "Hw7h");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var ChartView = __webpack_require__(
      /*! ../../view/Chart */
      "6Ic6");

      var _number = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var parsePercent = _number.parsePercent;
      var round = _number.round;
      var linearMap = _number.linearMap;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      function parsePosition(seriesModel, api) {
        var center = seriesModel.get('center');
        var width = api.getWidth();
        var height = api.getHeight();
        var size = Math.min(width, height);
        var cx = parsePercent(center[0], api.getWidth());
        var cy = parsePercent(center[1], api.getHeight());
        var r = parsePercent(seriesModel.get('radius'), size / 2);
        return {
          cx: cx,
          cy: cy,
          r: r
        };
      }

      function formatLabel(label, labelFormatter) {
        if (labelFormatter) {
          if (typeof labelFormatter === 'string') {
            label = labelFormatter.replace('{value}', label != null ? label : '');
          } else if (typeof labelFormatter === 'function') {
            label = labelFormatter(label);
          }
        }

        return label;
      }

      var PI2 = Math.PI * 2;
      var GaugeView = ChartView.extend({
        type: 'gauge',
        render: function render(seriesModel, ecModel, api) {
          this.group.removeAll();
          var colorList = seriesModel.get('axisLine.lineStyle.color');
          var posInfo = parsePosition(seriesModel, api);

          this._renderMain(seriesModel, ecModel, api, colorList, posInfo);
        },
        dispose: function dispose() {},
        _renderMain: function _renderMain(seriesModel, ecModel, api, colorList, posInfo) {
          var group = this.group;
          var axisLineModel = seriesModel.getModel('axisLine');
          var lineStyleModel = axisLineModel.getModel('lineStyle');
          var clockwise = seriesModel.get('clockwise');
          var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;
          var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;
          var angleRangeSpan = (endAngle - startAngle) % PI2;
          var prevEndAngle = startAngle;
          var axisLineWidth = lineStyleModel.get('width');
          var showAxis = axisLineModel.get('show');

          for (var i = 0; showAxis && i < colorList.length; i++) {
            // Clamp
            var percent = Math.min(Math.max(colorList[i][0], 0), 1);
            var endAngle = startAngle + angleRangeSpan * percent;
            var sector = new graphic.Sector({
              shape: {
                startAngle: prevEndAngle,
                endAngle: endAngle,
                cx: posInfo.cx,
                cy: posInfo.cy,
                clockwise: clockwise,
                r0: posInfo.r - axisLineWidth,
                r: posInfo.r
              },
              silent: true
            });
            sector.setStyle({
              fill: colorList[i][1]
            });
            sector.setStyle(lineStyleModel.getLineStyle( // Because we use sector to simulate arc
            // so the properties for stroking are useless
            ['color', 'borderWidth', 'borderColor']));
            group.add(sector);
            prevEndAngle = endAngle;
          }

          var getColor = function getColor(percent) {
            // Less than 0
            if (percent <= 0) {
              return colorList[0][1];
            }

            for (var i = 0; i < colorList.length; i++) {
              if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {
                return colorList[i][1];
              }
            } // More than 1


            return colorList[i - 1][1];
          };

          if (!clockwise) {
            var tmp = startAngle;
            startAngle = endAngle;
            endAngle = tmp;
          }

          this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);

          this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);

          this._renderTitle(seriesModel, ecModel, api, getColor, posInfo);

          this._renderDetail(seriesModel, ecModel, api, getColor, posInfo);
        },
        _renderTicks: function _renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {
          var group = this.group;
          var cx = posInfo.cx;
          var cy = posInfo.cy;
          var r = posInfo.r;
          var minVal = +seriesModel.get('min');
          var maxVal = +seriesModel.get('max');
          var splitLineModel = seriesModel.getModel('splitLine');
          var tickModel = seriesModel.getModel('axisTick');
          var labelModel = seriesModel.getModel('axisLabel');
          var splitNumber = seriesModel.get('splitNumber');
          var subSplitNumber = tickModel.get('splitNumber');
          var splitLineLen = parsePercent(splitLineModel.get('length'), r);
          var tickLen = parsePercent(tickModel.get('length'), r);
          var angle = startAngle;
          var step = (endAngle - startAngle) / splitNumber;
          var subStep = step / subSplitNumber;
          var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();
          var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();

          for (var i = 0; i <= splitNumber; i++) {
            var unitX = Math.cos(angle);
            var unitY = Math.sin(angle); // Split line

            if (splitLineModel.get('show')) {
              var splitLine = new graphic.Line({
                shape: {
                  x1: unitX * r + cx,
                  y1: unitY * r + cy,
                  x2: unitX * (r - splitLineLen) + cx,
                  y2: unitY * (r - splitLineLen) + cy
                },
                style: splitLineStyle,
                silent: true
              });

              if (splitLineStyle.stroke === 'auto') {
                splitLine.setStyle({
                  stroke: getColor(i / splitNumber)
                });
              }

              group.add(splitLine);
            } // Label


            if (labelModel.get('show')) {
              var label = formatLabel(round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get('formatter'));
              var distance = labelModel.get('distance');
              var autoColor = getColor(i / splitNumber);
              group.add(new graphic.Text({
                style: graphic.setTextStyle({}, labelModel, {
                  text: label,
                  x: unitX * (r - splitLineLen - distance) + cx,
                  y: unitY * (r - splitLineLen - distance) + cy,
                  textVerticalAlign: unitY < -0.4 ? 'top' : unitY > 0.4 ? 'bottom' : 'middle',
                  textAlign: unitX < -0.4 ? 'left' : unitX > 0.4 ? 'right' : 'center'
                }, {
                  autoColor: autoColor
                }),
                silent: true
              }));
            } // Axis tick


            if (tickModel.get('show') && i !== splitNumber) {
              for (var j = 0; j <= subSplitNumber; j++) {
                var unitX = Math.cos(angle);
                var unitY = Math.sin(angle);
                var tickLine = new graphic.Line({
                  shape: {
                    x1: unitX * r + cx,
                    y1: unitY * r + cy,
                    x2: unitX * (r - tickLen) + cx,
                    y2: unitY * (r - tickLen) + cy
                  },
                  silent: true,
                  style: tickLineStyle
                });

                if (tickLineStyle.stroke === 'auto') {
                  tickLine.setStyle({
                    stroke: getColor((i + j / subSplitNumber) / splitNumber)
                  });
                }

                group.add(tickLine);
                angle += subStep;
              }

              angle -= subStep;
            } else {
              angle += step;
            }
          }
        },
        _renderPointer: function _renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {
          var group = this.group;
          var oldData = this._data;

          if (!seriesModel.get('pointer.show')) {
            // Remove old element
            oldData && oldData.eachItemGraphicEl(function (el) {
              group.remove(el);
            });
            return;
          }

          var valueExtent = [+seriesModel.get('min'), +seriesModel.get('max')];
          var angleExtent = [startAngle, endAngle];
          var data = seriesModel.getData();
          var valueDim = data.mapDimension('value');
          data.diff(oldData).add(function (idx) {
            var pointer = new PointerPath({
              shape: {
                angle: startAngle
              }
            });
            graphic.initProps(pointer, {
              shape: {
                angle: linearMap(data.get(valueDim, idx), valueExtent, angleExtent, true)
              }
            }, seriesModel);
            group.add(pointer);
            data.setItemGraphicEl(idx, pointer);
          }).update(function (newIdx, oldIdx) {
            var pointer = oldData.getItemGraphicEl(oldIdx);
            graphic.updateProps(pointer, {
              shape: {
                angle: linearMap(data.get(valueDim, newIdx), valueExtent, angleExtent, true)
              }
            }, seriesModel);
            group.add(pointer);
            data.setItemGraphicEl(newIdx, pointer);
          }).remove(function (idx) {
            var pointer = oldData.getItemGraphicEl(idx);
            group.remove(pointer);
          }).execute();
          data.eachItemGraphicEl(function (pointer, idx) {
            var itemModel = data.getItemModel(idx);
            var pointerModel = itemModel.getModel('pointer');
            pointer.setShape({
              x: posInfo.cx,
              y: posInfo.cy,
              width: parsePercent(pointerModel.get('width'), posInfo.r),
              r: parsePercent(pointerModel.get('length'), posInfo.r)
            });
            pointer.useStyle(itemModel.getModel('itemStyle').getItemStyle());

            if (pointer.style.fill === 'auto') {
              pointer.setStyle('fill', getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));
            }

            graphic.setHoverStyle(pointer, itemModel.getModel('emphasis.itemStyle').getItemStyle());
          });
          this._data = data;
        },
        _renderTitle: function _renderTitle(seriesModel, ecModel, api, getColor, posInfo) {
          var data = seriesModel.getData();
          var valueDim = data.mapDimension('value');
          var titleModel = seriesModel.getModel('title');

          if (titleModel.get('show')) {
            var offsetCenter = titleModel.get('offsetCenter');
            var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);
            var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);
            var minVal = +seriesModel.get('min');
            var maxVal = +seriesModel.get('max');
            var value = seriesModel.getData().get(valueDim, 0);
            var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));
            this.group.add(new graphic.Text({
              silent: true,
              style: graphic.setTextStyle({}, titleModel, {
                x: x,
                y: y,
                // FIXME First data name ?
                text: data.getName(0),
                textAlign: 'center',
                textVerticalAlign: 'middle'
              }, {
                autoColor: autoColor,
                forceRich: true
              })
            }));
          }
        },
        _renderDetail: function _renderDetail(seriesModel, ecModel, api, getColor, posInfo) {
          var detailModel = seriesModel.getModel('detail');
          var minVal = +seriesModel.get('min');
          var maxVal = +seriesModel.get('max');

          if (detailModel.get('show')) {
            var offsetCenter = detailModel.get('offsetCenter');
            var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);
            var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);
            var width = parsePercent(detailModel.get('width'), posInfo.r);
            var height = parsePercent(detailModel.get('height'), posInfo.r);
            var data = seriesModel.getData();
            var value = data.get(data.mapDimension('value'), 0);
            var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));
            this.group.add(new graphic.Text({
              silent: true,
              style: graphic.setTextStyle({}, detailModel, {
                x: x,
                y: y,
                text: formatLabel( // FIXME First data name ?
                value, detailModel.get('formatter')),
                textWidth: isNaN(width) ? null : width,
                textHeight: isNaN(height) ? null : height,
                textAlign: 'center',
                textVerticalAlign: 'middle'
              }, {
                autoColor: autoColor,
                forceRich: true
              })
            }));
          }
        }
      });
      var _default = GaugeView;
      module.exports = _default;
      /***/
    },

    /***/
    "pLH3":
    /*!**************************************************!*\
      !*** ./node_modules/echarts/lib/chart/funnel.js ***!
      \**************************************************/

    /*! no static exports found */

    /***/
    function pLH3(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      __webpack_require__(
      /*! ./funnel/FunnelSeries */
      "ALo7");

      __webpack_require__(
      /*! ./funnel/FunnelView */
      "TWL2");

      var dataColor = __webpack_require__(
      /*! ../visual/dataColor */
      "mOdp");

      var funnelLayout = __webpack_require__(
      /*! ./funnel/funnelLayout */
      "JLnu");

      var dataFilter = __webpack_require__(
      /*! ../processor/dataFilter */
      "0/Rx");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      echarts.registerVisual(dataColor('funnel'));
      echarts.registerLayout(funnelLayout);
      echarts.registerProcessor(dataFilter('funnel'));
      /***/
    },

    /***/
    "pP6R":
    /*!***********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/helper/interactionMutex.js ***!
      \***********************************************************************/

    /*! no static exports found */

    /***/
    function pP6R(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var ATTR = '\0_ec_interaction_mutex';

      function take(zr, resourceKey, userKey) {
        var store = getStore(zr);
        store[resourceKey] = userKey;
      }

      function release(zr, resourceKey, userKey) {
        var store = getStore(zr);
        var uKey = store[resourceKey];

        if (uKey === userKey) {
          store[resourceKey] = null;
        }
      }

      function isTaken(zr, resourceKey) {
        return !!getStore(zr)[resourceKey];
      }

      function getStore(zr) {
        return zr[ATTR] || (zr[ATTR] = {});
      }
      /**
       * payload: {
       *     type: 'takeGlobalCursor',
       *     key: 'dataZoomSelect', or 'brush', or ...,
       *         If no userKey, release global cursor.
       * }
       */


      echarts.registerAction({
        type: 'takeGlobalCursor',
        event: 'globalCursorTaken',
        update: 'update'
      }, function () {});
      exports.take = take;
      exports.release = release;
      exports.isTaken = isTaken;
      /***/
    },

    /***/
    "pmaE":
    /*!*******************************************************!*\
      !*** ./node_modules/echarts/lib/chart/map/MapView.js ***!
      \*******************************************************/

    /*! no static exports found */

    /***/
    function pmaE(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var MapDraw = __webpack_require__(
      /*! ../../component/helper/MapDraw */
      "DEFe");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var HIGH_DOWN_PROP = '__seriesMapHighDown';
      var RECORD_VERSION_PROP = '__seriesMapCallKey';

      var _default = echarts.extendChartView({
        type: 'map',
        render: function render(mapModel, ecModel, api, payload) {
          // Not render if it is an toggleSelect action from self
          if (payload && payload.type === 'mapToggleSelect' && payload.from === this.uid) {
            return;
          }

          var group = this.group;
          group.removeAll();

          if (mapModel.getHostGeoModel()) {
            return;
          } // Not update map if it is an roam action from self


          if (!(payload && payload.type === 'geoRoam' && payload.componentType === 'series' && payload.seriesId === mapModel.id)) {
            if (mapModel.needsDrawMap) {
              var mapDraw = this._mapDraw || new MapDraw(api, true);
              group.add(mapDraw.group);
              mapDraw.draw(mapModel, ecModel, api, this, payload);
              this._mapDraw = mapDraw;
            } else {
              // Remove drawed map
              this._mapDraw && this._mapDraw.remove();
              this._mapDraw = null;
            }
          } else {
            var mapDraw = this._mapDraw;
            mapDraw && group.add(mapDraw.group);
          }

          mapModel.get('showLegendSymbol') && ecModel.getComponent('legend') && this._renderSymbols(mapModel, ecModel, api);
        },
        remove: function remove() {
          this._mapDraw && this._mapDraw.remove();
          this._mapDraw = null;
          this.group.removeAll();
        },
        dispose: function dispose() {
          this._mapDraw && this._mapDraw.remove();
          this._mapDraw = null;
        },
        _renderSymbols: function _renderSymbols(mapModel, ecModel, api) {
          var originalData = mapModel.originalData;
          var group = this.group;
          originalData.each(originalData.mapDimension('value'), function (value, originalDataIndex) {
            if (isNaN(value)) {
              return;
            }

            var layout = originalData.getItemLayout(originalDataIndex);

            if (!layout || !layout.point) {
              // Not exists in map
              return;
            }

            var point = layout.point;
            var offset = layout.offset;
            var circle = new graphic.Circle({
              style: {
                // Because the special of map draw.
                // Which needs statistic of multiple series and draw on one map.
                // And each series also need a symbol with legend color
                //
                // Layout and visual are put one the different data
                fill: mapModel.getData().getVisual('color')
              },
              shape: {
                cx: point[0] + offset * 9,
                cy: point[1],
                r: 3
              },
              silent: true,
              // Do not overlap the first series, on which labels are displayed.
              z2: 8 + (!offset ? graphic.Z2_EMPHASIS_LIFT + 1 : 0)
            }); // Only the series that has the first value on the same region is in charge of rendering the label.
            // But consider the case:
            // series: [
            //     {id: 'X', type: 'map', map: 'm', {data: [{name: 'A', value: 11}, {name: 'B', {value: 22}]},
            //     {id: 'Y', type: 'map', map: 'm', {data: [{name: 'A', value: 21}, {name: 'C', {value: 33}]}
            // ]
            // The offset `0` of item `A` is at series `X`, but of item `C` is at series `Y`.
            // For backward compatibility, we follow the rule that render label `A` by the
            // settings on series `X` but render label `C` by the settings on series `Y`.

            if (!offset) {
              var fullData = mapModel.mainSeries.getData();
              var name = originalData.getName(originalDataIndex);
              var fullIndex = fullData.indexOfName(name);
              var itemModel = originalData.getItemModel(originalDataIndex);
              var labelModel = itemModel.getModel('label');
              var hoverLabelModel = itemModel.getModel('emphasis.label');
              var regionGroup = fullData.getItemGraphicEl(fullIndex); // `getFormattedLabel` needs to use `getData` inside. Here
              // `mapModel.getData()` is shallow cloned from `mainSeries.getData()`.
              // FIXME
              // If this is not the `mainSeries`, the item model (like label formatter)
              // set on original data item will never get. But it has been working
              // like that from the begining, and this scenario is rarely encountered.
              // So it won't be fixed until have to.

              var normalText = zrUtil.retrieve2(mapModel.getFormattedLabel(fullIndex, 'normal'), name);
              var emphasisText = zrUtil.retrieve2(mapModel.getFormattedLabel(fullIndex, 'emphasis'), normalText);
              var highDownRecord = regionGroup[HIGH_DOWN_PROP];
              var recordVersion = Math.random(); // Prevent from register listeners duplicatedly when roaming.

              if (!highDownRecord) {
                highDownRecord = regionGroup[HIGH_DOWN_PROP] = {};
                var onEmphasis = zrUtil.curry(onRegionHighDown, true);
                var onNormal = zrUtil.curry(onRegionHighDown, false);
                regionGroup.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);
              } // Prevent removed regions effect current grapics.


              regionGroup[RECORD_VERSION_PROP] = recordVersion;
              zrUtil.extend(highDownRecord, {
                recordVersion: recordVersion,
                circle: circle,
                labelModel: labelModel,
                hoverLabelModel: hoverLabelModel,
                emphasisText: emphasisText,
                normalText: normalText
              }); // FIXME
              // Consider set option when emphasis.

              enterRegionHighDown(highDownRecord, false);
            }

            group.add(circle);
          });
        }
      });

      function onRegionHighDown(toHighOrDown) {
        var highDownRecord = this[HIGH_DOWN_PROP];

        if (highDownRecord && highDownRecord.recordVersion === this[RECORD_VERSION_PROP]) {
          enterRegionHighDown(highDownRecord, toHighOrDown);
        }
      }

      function enterRegionHighDown(highDownRecord, toHighOrDown) {
        var circle = highDownRecord.circle;
        var labelModel = highDownRecord.labelModel;
        var hoverLabelModel = highDownRecord.hoverLabelModel;
        var emphasisText = highDownRecord.emphasisText;
        var normalText = highDownRecord.normalText;

        if (toHighOrDown) {
          circle.style.extendFrom(graphic.setTextStyle({}, hoverLabelModel, {
            text: hoverLabelModel.get('show') ? emphasisText : null
          }, {
            isRectText: true,
            useInsideStyle: false
          }, true)); // Make label upper than others if overlaps.

          circle.__mapOriginalZ2 = circle.z2;
          circle.z2 += graphic.Z2_EMPHASIS_LIFT;
        } else {
          graphic.setTextStyle(circle.style, labelModel, {
            text: labelModel.get('show') ? normalText : null,
            textPosition: labelModel.getShallow('position') || 'bottom'
          }, {
            isRectText: true,
            useInsideStyle: false
          }); // Trigger normalize style like padding.

          circle.dirty(false);

          if (circle.__mapOriginalZ2 != null) {
            circle.z2 = circle.__mapOriginalZ2;
            circle.__mapOriginalZ2 = null;
          }
        }
      }

      module.exports = _default;
      /***/
    },

    /***/
    "q/+u":
    /*!***************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/scatter/ScatterView.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function qU(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var SymbolDraw = __webpack_require__(
      /*! ../helper/SymbolDraw */
      "9wZj");

      var LargeSymbolDraw = __webpack_require__(
      /*! ../helper/LargeSymbolDraw */
      "yWXo");

      var pointsLayout = __webpack_require__(
      /*! ../../layout/points */
      "h8O9");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      echarts.extendChartView({
        type: 'scatter',
        render: function render(seriesModel, ecModel, api) {
          var data = seriesModel.getData();

          var symbolDraw = this._updateSymbolDraw(data, seriesModel);

          symbolDraw.updateData(data, {
            // TODO
            // If this parameter should be a shape or a bounding volume
            // shape will be more general.
            // But bounding volume like bounding rect will be much faster in the contain calculation
            clipShape: this._getClipShape(seriesModel)
          });
          this._finished = true;
        },
        incrementalPrepareRender: function incrementalPrepareRender(seriesModel, ecModel, api) {
          var data = seriesModel.getData();

          var symbolDraw = this._updateSymbolDraw(data, seriesModel);

          symbolDraw.incrementalPrepareUpdate(data);
          this._finished = false;
        },
        incrementalRender: function incrementalRender(taskParams, seriesModel, ecModel) {
          this._symbolDraw.incrementalUpdate(taskParams, seriesModel.getData(), {
            clipShape: this._getClipShape(seriesModel)
          });

          this._finished = taskParams.end === seriesModel.getData().count();
        },
        updateTransform: function updateTransform(seriesModel, ecModel, api) {
          var data = seriesModel.getData(); // Must mark group dirty and make sure the incremental layer will be cleared
          // PENDING

          this.group.dirty();

          if (!this._finished || data.count() > 1e4 || !this._symbolDraw.isPersistent()) {
            return {
              update: true
            };
          } else {
            var res = pointsLayout().reset(seriesModel);

            if (res.progress) {
              res.progress({
                start: 0,
                end: data.count()
              }, data);
            }

            this._symbolDraw.updateLayout(data);
          }
        },
        _getClipShape: function _getClipShape(seriesModel) {
          var coordSys = seriesModel.coordinateSystem;
          var clipArea = coordSys && coordSys.getArea && coordSys.getArea();
          return seriesModel.get('clip', true) ? clipArea : null;
        },
        _updateSymbolDraw: function _updateSymbolDraw(data, seriesModel) {
          var symbolDraw = this._symbolDraw;
          var pipelineContext = seriesModel.pipelineContext;
          var isLargeDraw = pipelineContext.large;

          if (!symbolDraw || isLargeDraw !== this._isLargeDraw) {
            symbolDraw && symbolDraw.remove();
            symbolDraw = this._symbolDraw = isLargeDraw ? new LargeSymbolDraw() : new SymbolDraw();
            this._isLargeDraw = isLargeDraw;
            this.group.removeAll();
          }

          this.group.add(symbolDraw.group);
          return symbolDraw;
        },
        remove: function remove(ecModel, api) {
          this._symbolDraw && this._symbolDraw.remove(true);
          this._symbolDraw = null;
        },
        dispose: function dispose() {}
      });
      /***/
    },

    /***/
    "q3GZ":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/parallel/parallelVisual.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function q3GZ(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var opacityAccessPath = ['lineStyle', 'normal', 'opacity'];
      var _default = {
        seriesType: 'parallel',
        reset: function reset(seriesModel, ecModel, api) {
          var itemStyleModel = seriesModel.getModel('itemStyle');
          var lineStyleModel = seriesModel.getModel('lineStyle');
          var globalColors = ecModel.get('color');
          var color = lineStyleModel.get('color') || itemStyleModel.get('color') || globalColors[seriesModel.seriesIndex % globalColors.length];
          var inactiveOpacity = seriesModel.get('inactiveOpacity');
          var activeOpacity = seriesModel.get('activeOpacity');
          var lineStyle = seriesModel.getModel('lineStyle').getLineStyle();
          var coordSys = seriesModel.coordinateSystem;
          var data = seriesModel.getData();
          var opacityMap = {
            normal: lineStyle.opacity,
            active: activeOpacity,
            inactive: inactiveOpacity
          };
          data.setVisual('color', color);

          function progress(params, data) {
            coordSys.eachActiveState(data, function (activeState, dataIndex) {
              var opacity = opacityMap[activeState];

              if (activeState === 'normal' && data.hasItemOption) {
                var itemOpacity = data.getItemModel(dataIndex).get(opacityAccessPath, true);
                itemOpacity != null && (opacity = itemOpacity);
              }

              data.setItemVisual(dataIndex, 'opacity', opacity);
            }, params.start, params.end);
          }

          return {
            progress: progress
          };
        }
      };
      module.exports = _default;
      /***/
    },

    /***/
    "qH13":
    /*!*************************************************!*\
      !*** ./node_modules/zrender/lib/vml/graphic.js ***!
      \*************************************************/

    /*! no static exports found */

    /***/
    function qH13(module, exports, __webpack_require__) {
      var env = __webpack_require__(
      /*! ../core/env */
      "ItGF");

      var _vector = __webpack_require__(
      /*! ../core/vector */
      "QBsz");

      var applyTransform = _vector.applyTransform;

      var BoundingRect = __webpack_require__(
      /*! ../core/BoundingRect */
      "mFDi");

      var colorTool = __webpack_require__(
      /*! ../tool/color */
      "Qe9p");

      var textContain = __webpack_require__(
      /*! ../contain/text */
      "6GrX");

      var textHelper = __webpack_require__(
      /*! ../graphic/helper/text */
      "pzxd");

      var RectText = __webpack_require__(
      /*! ../graphic/mixin/RectText */
      "ni6a");

      var Displayable = __webpack_require__(
      /*! ../graphic/Displayable */
      "Gev7");

      var ZImage = __webpack_require__(
      /*! ../graphic/Image */
      "Dagg");

      var Text = __webpack_require__(
      /*! ../graphic/Text */
      "dqUG");

      var Path = __webpack_require__(
      /*! ../graphic/Path */
      "y+Vt");

      var PathProxy = __webpack_require__(
      /*! ../core/PathProxy */
      "IMiH");

      var Gradient = __webpack_require__(
      /*! ../graphic/Gradient */
      "QuXc");

      var vmlCore = __webpack_require__(
      /*! ./core */
      "06Qe"); // http://www.w3.org/TR/NOTE-VML
      // TODO Use proxy like svg instead of overwrite brush methods


      var CMD = PathProxy.CMD;
      var round = Math.round;
      var sqrt = Math.sqrt;
      var abs = Math.abs;
      var cos = Math.cos;
      var sin = Math.sin;
      var mathMax = Math.max;

      if (!env.canvasSupported) {
        var comma = ',';
        var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';
        var Z = 21600;
        var Z2 = Z / 2;
        var ZLEVEL_BASE = 100000;
        var Z_BASE = 1000;

        var initRootElStyle = function initRootElStyle(el) {
          el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';
          el.coordsize = Z + ',' + Z;
          el.coordorigin = '0,0';
        };

        var encodeHtmlAttribute = function encodeHtmlAttribute(s) {
          return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
        };

        var rgb2Str = function rgb2Str(r, g, b) {
          return 'rgb(' + [r, g, b].join(',') + ')';
        };

        var append = function append(parent, child) {
          if (child && parent && child.parentNode !== parent) {
            parent.appendChild(child);
          }
        };

        var remove = function remove(parent, child) {
          if (child && parent && child.parentNode === parent) {
            parent.removeChild(child);
          }
        };

        var getZIndex = function getZIndex(zlevel, z, z2) {
          // z  [0, 1000]
          return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;
        };

        var parsePercent = textHelper.parsePercent;
        /***************************************************
         * PATH
         **************************************************/

        var setColorAndOpacity = function setColorAndOpacity(el, color, opacity) {
          var colorArr = colorTool.parse(color);
          opacity = +opacity;

          if (isNaN(opacity)) {
            opacity = 1;
          }

          if (colorArr) {
            el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);
            el.opacity = opacity * colorArr[3];
          }
        };

        var getColorAndAlpha = function getColorAndAlpha(color) {
          var colorArr = colorTool.parse(color);
          return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];
        };

        var updateFillNode = function updateFillNode(el, style, zrEl) {
          // TODO pattern
          var fill = style.fill;

          if (fill != null) {
            // Modified from excanvas
            if (fill instanceof Gradient) {
              var gradientType;
              var angle = 0;
              var focus = [0, 0]; // additional offset

              var shift = 0; // scale factor for offset

              var expansion = 1;
              var rect = zrEl.getBoundingRect();
              var rectWidth = rect.width;
              var rectHeight = rect.height;

              if (fill.type === 'linear') {
                gradientType = 'gradient';
                var transform = zrEl.transform;
                var p0 = [fill.x * rectWidth, fill.y * rectHeight];
                var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];

                if (transform) {
                  applyTransform(p0, p0, transform);
                  applyTransform(p1, p1, transform);
                }

                var dx = p1[0] - p0[0];
                var dy = p1[1] - p0[1];
                angle = Math.atan2(dx, dy) * 180 / Math.PI; // The angle should be a non-negative number.

                if (angle < 0) {
                  angle += 360;
                } // Very small angles produce an unexpected result because they are
                // converted to a scientific notation string.


                if (angle < 1e-6) {
                  angle = 0;
                }
              } else {
                gradientType = 'gradientradial';
                var p0 = [fill.x * rectWidth, fill.y * rectHeight];
                var transform = zrEl.transform;
                var scale = zrEl.scale;
                var width = rectWidth;
                var height = rectHeight;
                focus = [// Percent in bounding rect
                (p0[0] - rect.x) / width, (p0[1] - rect.y) / height];

                if (transform) {
                  applyTransform(p0, p0, transform);
                }

                width /= scale[0] * Z;
                height /= scale[1] * Z;
                var dimension = mathMax(width, height);
                shift = 2 * 0 / dimension;
                expansion = 2 * fill.r / dimension - shift;
              } // We need to sort the color stops in ascending order by offset,
              // otherwise IE won't interpret it correctly.


              var stops = fill.colorStops.slice();
              stops.sort(function (cs1, cs2) {
                return cs1.offset - cs2.offset;
              });
              var length = stops.length; // Color and alpha list of first and last stop

              var colorAndAlphaList = [];
              var colors = [];

              for (var i = 0; i < length; i++) {
                var stop = stops[i];
                var colorAndAlpha = getColorAndAlpha(stop.color);
                colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);

                if (i === 0 || i === length - 1) {
                  colorAndAlphaList.push(colorAndAlpha);
                }
              }

              if (length >= 2) {
                var color1 = colorAndAlphaList[0][0];
                var color2 = colorAndAlphaList[1][0];
                var opacity1 = colorAndAlphaList[0][1] * style.opacity;
                var opacity2 = colorAndAlphaList[1][1] * style.opacity;
                el.type = gradientType;
                el.method = 'none';
                el.focus = '100%';
                el.angle = angle;
                el.color = color1;
                el.color2 = color2;
                el.colors = colors.join(','); // When colors attribute is used, the meanings of opacity and o:opacity2
                // are reversed.

                el.opacity = opacity2; // FIXME g_o_:opacity ?

                el.opacity2 = opacity1;
              }

              if (gradientType === 'radial') {
                el.focusposition = focus.join(',');
              }
            } else {
              // FIXME Change from Gradient fill to color fill
              setColorAndOpacity(el, fill, style.opacity);
            }
          }
        };

        var updateStrokeNode = function updateStrokeNode(el, style) {
          // if (style.lineJoin != null) {
          //     el.joinstyle = style.lineJoin;
          // }
          // if (style.miterLimit != null) {
          //     el.miterlimit = style.miterLimit * Z;
          // }
          // if (style.lineCap != null) {
          //     el.endcap = style.lineCap;
          // }
          if (style.lineDash) {
            el.dashstyle = style.lineDash.join(' ');
          }

          if (style.stroke != null && !(style.stroke instanceof Gradient)) {
            setColorAndOpacity(el, style.stroke, style.opacity);
          }
        };

        var updateFillAndStroke = function updateFillAndStroke(vmlEl, type, style, zrEl) {
          var isFill = type === 'fill';
          var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth

          if (style[type] != null && style[type] !== 'none' && (isFill || !isFill && style.lineWidth)) {
            vmlEl[isFill ? 'filled' : 'stroked'] = 'true'; // FIXME Remove before updating, or set `colors` will throw error

            if (style[type] instanceof Gradient) {
              remove(vmlEl, el);
            }

            if (!el) {
              el = vmlCore.createNode(type);
            }

            isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);
            append(vmlEl, el);
          } else {
            vmlEl[isFill ? 'filled' : 'stroked'] = 'false';
            remove(vmlEl, el);
          }
        };

        var points = [[], [], []];

        var pathDataToString = function pathDataToString(path, m) {
          var M = CMD.M;
          var C = CMD.C;
          var L = CMD.L;
          var A = CMD.A;
          var Q = CMD.Q;
          var str = [];
          var nPoint;
          var cmdStr;
          var cmd;
          var i;
          var xi;
          var yi;
          var data = path.data;
          var dataLength = path.len();

          for (i = 0; i < dataLength;) {
            cmd = data[i++];
            cmdStr = '';
            nPoint = 0;

            switch (cmd) {
              case M:
                cmdStr = ' m ';
                nPoint = 1;
                xi = data[i++];
                yi = data[i++];
                points[0][0] = xi;
                points[0][1] = yi;
                break;

              case L:
                cmdStr = ' l ';
                nPoint = 1;
                xi = data[i++];
                yi = data[i++];
                points[0][0] = xi;
                points[0][1] = yi;
                break;

              case Q:
              case C:
                cmdStr = ' c ';
                nPoint = 3;
                var x1 = data[i++];
                var y1 = data[i++];
                var x2 = data[i++];
                var y2 = data[i++];
                var x3;
                var y3;

                if (cmd === Q) {
                  // Convert quadratic to cubic using degree elevation
                  x3 = x2;
                  y3 = y2;
                  x2 = (x2 + 2 * x1) / 3;
                  y2 = (y2 + 2 * y1) / 3;
                  x1 = (xi + 2 * x1) / 3;
                  y1 = (yi + 2 * y1) / 3;
                } else {
                  x3 = data[i++];
                  y3 = data[i++];
                }

                points[0][0] = x1;
                points[0][1] = y1;
                points[1][0] = x2;
                points[1][1] = y2;
                points[2][0] = x3;
                points[2][1] = y3;
                xi = x3;
                yi = y3;
                break;

              case A:
                var x = 0;
                var y = 0;
                var sx = 1;
                var sy = 1;
                var angle = 0;

                if (m) {
                  // Extract SRT from matrix
                  x = m[4];
                  y = m[5];
                  sx = sqrt(m[0] * m[0] + m[1] * m[1]);
                  sy = sqrt(m[2] * m[2] + m[3] * m[3]);
                  angle = Math.atan2(-m[1] / sy, m[0] / sx);
                }

                var cx = data[i++];
                var cy = data[i++];
                var rx = data[i++];
                var ry = data[i++];
                var startAngle = data[i++] + angle;
                var endAngle = data[i++] + startAngle + angle; // FIXME
                // var psi = data[i++];

                i++;
                var clockwise = data[i++];
                var x0 = cx + cos(startAngle) * rx;
                var y0 = cy + sin(startAngle) * ry;
                var x1 = cx + cos(endAngle) * rx;
                var y1 = cy + sin(endAngle) * ry;
                var type = clockwise ? ' wa ' : ' at ';

                if (Math.abs(x0 - x1) < 1e-4) {
                  // IE won't render arches drawn counter clockwise if x0 == x1.
                  if (Math.abs(endAngle - startAngle) > 1e-2) {
                    // Offset x0 by 1/80 of a pixel. Use something
                    // that can be represented in binary
                    if (clockwise) {
                      x0 += 270 / Z;
                    }
                  } else {
                    // Avoid case draw full circle
                    if (Math.abs(y0 - cy) < 1e-4) {
                      if (clockwise && x0 < cx || !clockwise && x0 > cx) {
                        y1 -= 270 / Z;
                      } else {
                        y1 += 270 / Z;
                      }
                    } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {
                      x1 += 270 / Z;
                    } else {
                      x1 -= 270 / Z;
                    }
                  }
                }

                str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));
                xi = x1;
                yi = y1;
                break;

              case CMD.R:
                var p0 = points[0];
                var p1 = points[1]; // x0, y0

                p0[0] = data[i++];
                p0[1] = data[i++]; // x1, y1

                p1[0] = p0[0] + data[i++];
                p1[1] = p0[1] + data[i++];

                if (m) {
                  applyTransform(p0, p0, m);
                  applyTransform(p1, p1, m);
                }

                p0[0] = round(p0[0] * Z - Z2);
                p1[0] = round(p1[0] * Z - Z2);
                p0[1] = round(p0[1] * Z - Z2);
                p1[1] = round(p1[1] * Z - Z2);
                str.push( // x0, y0
                ' m ', p0[0], comma, p0[1], // x1, y0
                ' l ', p1[0], comma, p0[1], // x1, y1
                ' l ', p1[0], comma, p1[1], // x0, y1
                ' l ', p0[0], comma, p1[1]);
                break;

              case CMD.Z:
                // FIXME Update xi, yi
                str.push(' x ');
            }

            if (nPoint > 0) {
              str.push(cmdStr);

              for (var k = 0; k < nPoint; k++) {
                var p = points[k];
                m && applyTransform(p, p, m); //  round 

                str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');
              }
            }
          }

          return str.join('');
        }; // Rewrite the original path method


        Path.prototype.brushVML = function (vmlRoot) {
          var style = this.style;
          var vmlEl = this._vmlEl;

          if (!vmlEl) {
            vmlEl = vmlCore.createNode('shape');
            initRootElStyle(vmlEl);
            this._vmlEl = vmlEl;
          }

          updateFillAndStroke(vmlEl, 'fill', style, this);
          updateFillAndStroke(vmlEl, 'stroke', style, this);
          var m = this.transform;
          var needTransform = m != null;
          var strokeEl = vmlEl.getElementsByTagName('stroke')[0];

          if (strokeEl) {
            var lineWidth = style.lineWidth; // Get the line scale.
            // Determinant of this.m_ means how much the area is enlarged by the
            // transformation. So its square root can be used as a scale factor
            // for width.

            if (needTransform && !style.strokeNoScale) {
              var det = m[0] * m[3] - m[1] * m[2];
              lineWidth *= sqrt(abs(det));
            }

            strokeEl.weight = lineWidth + 'px';
          }

          var path = this.path || (this.path = new PathProxy());

          if (this.__dirtyPath) {
            path.beginPath();
            path.subPixelOptimize = false;
            this.buildPath(path, this.shape);
            path.toStatic();
            this.__dirtyPath = false;
          }

          vmlEl.path = pathDataToString(path, this.transform);
          vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root

          append(vmlRoot, vmlEl); // Text

          if (style.text != null) {
            this.drawRectText(vmlRoot, this.getBoundingRect());
          } else {
            this.removeRectText(vmlRoot);
          }
        };

        Path.prototype.onRemove = function (vmlRoot) {
          remove(vmlRoot, this._vmlEl);
          this.removeRectText(vmlRoot);
        };

        Path.prototype.onAdd = function (vmlRoot) {
          append(vmlRoot, this._vmlEl);
          this.appendRectText(vmlRoot);
        };
        /***************************************************
         * IMAGE
         **************************************************/


        var isImage = function isImage(img) {
          // FIXME img instanceof Image  img IE8 
          return typeof img === 'object' && img.tagName && img.tagName.toUpperCase() === 'IMG'; // return img instanceof Image;
        }; // Rewrite the original path method


        ZImage.prototype.brushVML = function (vmlRoot) {
          var style = this.style;
          var image = style.image; // Image original width, height

          var ow;
          var oh;

          if (isImage(image)) {
            var src = image.src;

            if (src === this._imageSrc) {
              ow = this._imageWidth;
              oh = this._imageHeight;
            } else {
              var imageRuntimeStyle = image.runtimeStyle;
              var oldRuntimeWidth = imageRuntimeStyle.width;
              var oldRuntimeHeight = imageRuntimeStyle.height;
              imageRuntimeStyle.width = 'auto';
              imageRuntimeStyle.height = 'auto'; // get the original size

              ow = image.width;
              oh = image.height; // and remove overides

              imageRuntimeStyle.width = oldRuntimeWidth;
              imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src

              this._imageSrc = src;
              this._imageWidth = ow;
              this._imageHeight = oh;
            }

            image = src;
          } else {
            if (image === this._imageSrc) {
              ow = this._imageWidth;
              oh = this._imageHeight;
            }
          }

          if (!image) {
            return;
          }

          var x = style.x || 0;
          var y = style.y || 0;
          var dw = style.width;
          var dh = style.height;
          var sw = style.sWidth;
          var sh = style.sHeight;
          var sx = style.sx || 0;
          var sy = style.sy || 0;
          var hasCrop = sw && sh;
          var vmlEl = this._vmlEl;

          if (!vmlEl) {
            // FIXME  group  left, top  0 
            // vmlEl = vmlCore.createNode('group');
            vmlEl = vmlCore.doc.createElement('div');
            initRootElStyle(vmlEl);
            this._vmlEl = vmlEl;
          }

          var vmlElStyle = vmlEl.style;
          var hasRotation = false;
          var m;
          var scaleX = 1;
          var scaleY = 1;

          if (this.transform) {
            m = this.transform;
            scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);
            scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);
            hasRotation = m[1] || m[2];
          }

          if (hasRotation) {
            // If filters are necessary (rotation exists), create them
            // filters are bog-slow, so only create them if abbsolutely necessary
            // The following check doesn't account for skews (which don't exist
            // in the canvas spec (yet) anyway.
            // From excanvas
            var p0 = [x, y];
            var p1 = [x + dw, y];
            var p2 = [x, y + dh];
            var p3 = [x + dw, y + dh];
            applyTransform(p0, p0, m);
            applyTransform(p1, p1, m);
            applyTransform(p2, p2, m);
            applyTransform(p3, p3, m);
            var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);
            var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);
            var transformFilter = [];
            transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5]));
            vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0'; // FIXME DXImageTransform  IE11 

            vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';
          } else {
            if (m) {
              x = x * scaleX + m[4];
              y = y * scaleY + m[5];
            }

            vmlElStyle.filter = '';
            vmlElStyle.left = round(x) + 'px';
            vmlElStyle.top = round(y) + 'px';
          }

          var imageEl = this._imageEl;
          var cropEl = this._cropEl;

          if (!imageEl) {
            imageEl = vmlCore.doc.createElement('div');
            this._imageEl = imageEl;
          }

          var imageELStyle = imageEl.style;

          if (hasCrop) {
            // Needs know image original width and height
            if (!(ow && oh)) {
              var tmpImage = new Image();
              var self = this;

              tmpImage.onload = function () {
                tmpImage.onload = null;
                ow = tmpImage.width;
                oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize

                imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
                imageELStyle.height = round(scaleY * oh * dh / sh) + 'px'; // Caching image original width, height and src

                self._imageWidth = ow;
                self._imageHeight = oh;
                self._imageSrc = image;
              };

              tmpImage.src = image;
            } else {
              imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
              imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
            }

            if (!cropEl) {
              cropEl = vmlCore.doc.createElement('div');
              cropEl.style.overflow = 'hidden';
              this._cropEl = cropEl;
            }

            var cropElStyle = cropEl.style;
            cropElStyle.width = round((dw + sx * dw / sw) * scaleX);
            cropElStyle.height = round((dh + sy * dh / sh) * scaleY);
            cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + -sx * dw / sw * scaleX + ',Dy=' + -sy * dh / sh * scaleY + ')';

            if (!cropEl.parentNode) {
              vmlEl.appendChild(cropEl);
            }

            if (imageEl.parentNode !== cropEl) {
              cropEl.appendChild(imageEl);
            }
          } else {
            imageELStyle.width = round(scaleX * dw) + 'px';
            imageELStyle.height = round(scaleY * dh) + 'px';
            vmlEl.appendChild(imageEl);

            if (cropEl && cropEl.parentNode) {
              vmlEl.removeChild(cropEl);
              this._cropEl = null;
            }
          }

          var filterStr = '';
          var alpha = style.opacity;

          if (alpha < 1) {
            filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';
          }

          filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';
          imageELStyle.filter = filterStr;
          vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root

          append(vmlRoot, vmlEl); // Text

          if (style.text != null) {
            this.drawRectText(vmlRoot, this.getBoundingRect());
          }
        };

        ZImage.prototype.onRemove = function (vmlRoot) {
          remove(vmlRoot, this._vmlEl);
          this._vmlEl = null;
          this._cropEl = null;
          this._imageEl = null;
          this.removeRectText(vmlRoot);
        };

        ZImage.prototype.onAdd = function (vmlRoot) {
          append(vmlRoot, this._vmlEl);
          this.appendRectText(vmlRoot);
        };
        /***************************************************
         * TEXT
         **************************************************/


        var DEFAULT_STYLE_NORMAL = 'normal';
        var fontStyleCache = {};
        var fontStyleCacheCount = 0;
        var MAX_FONT_CACHE_SIZE = 100;
        var fontEl = document.createElement('div');

        var getFontStyle = function getFontStyle(fontString) {
          var fontStyle = fontStyleCache[fontString];

          if (!fontStyle) {
            // Clear cache
            if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {
              fontStyleCacheCount = 0;
              fontStyleCache = {};
            }

            var style = fontEl.style;
            var fontFamily;

            try {
              style.font = fontString;
              fontFamily = style.fontFamily.split(',')[0];
            } catch (e) {}

            fontStyle = {
              style: style.fontStyle || DEFAULT_STYLE_NORMAL,
              variant: style.fontVariant || DEFAULT_STYLE_NORMAL,
              weight: style.fontWeight || DEFAULT_STYLE_NORMAL,
              size: parseFloat(style.fontSize || 12) | 0,
              family: fontFamily || 'Microsoft YaHei'
            };
            fontStyleCache[fontString] = fontStyle;
            fontStyleCacheCount++;
          }

          return fontStyle;
        };

        var textMeasureEl; // Overwrite measure text method

        textContain.$override('measureText', function (text, textFont) {
          var doc = vmlCore.doc;

          if (!textMeasureEl) {
            textMeasureEl = doc.createElement('div');
            textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';
            vmlCore.doc.body.appendChild(textMeasureEl);
          }

          try {
            textMeasureEl.style.font = textFont;
          } catch (ex) {// Ignore failures to set to invalid font.
          }

          textMeasureEl.innerHTML = ''; // Don't use innerHTML or innerText because they allow markup/whitespace.

          textMeasureEl.appendChild(doc.createTextNode(text));
          return {
            width: textMeasureEl.offsetWidth
          };
        });
        var tmpRect = new BoundingRect();

        var drawRectText = function drawRectText(vmlRoot, rect, textRect, fromTextEl) {
          var style = this.style; // Optimize, avoid normalize every time.

          this.__dirty && textHelper.normalizeTextStyle(style, true);
          var text = style.text; // Convert to string

          text != null && (text += '');

          if (!text) {
            return;
          } // Convert rich text to plain text. Rich text is not supported in
          // IE8-, but tags in rich text template will be removed.


          if (style.rich) {
            var contentBlock = textContain.parseRichText(text, style);
            text = [];

            for (var i = 0; i < contentBlock.lines.length; i++) {
              var tokens = contentBlock.lines[i].tokens;
              var textLine = [];

              for (var j = 0; j < tokens.length; j++) {
                textLine.push(tokens[j].text);
              }

              text.push(textLine.join(''));
            }

            text = text.join('\n');
          }

          var x;
          var y;
          var align = style.textAlign;
          var verticalAlign = style.textVerticalAlign;
          var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ?

          var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px "' + fontStyle.family + '"';
          textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign, style.textPadding, style.textLineHeight); // Transform rect to view space

          var m = this.transform; // Ignore transform for text in other element

          if (m && !fromTextEl) {
            tmpRect.copy(rect);
            tmpRect.applyTransform(m);
            rect = tmpRect;
          }

          if (!fromTextEl) {
            var textPosition = style.textPosition; // Text position represented by coord

            if (textPosition instanceof Array) {
              x = rect.x + parsePercent(textPosition[0], rect.width);
              y = rect.y + parsePercent(textPosition[1], rect.height);
              align = align || 'left';
            } else {
              var res = this.calculateTextPosition ? this.calculateTextPosition({}, style, rect) : textContain.calculateTextPosition({}, style, rect);
              x = res.x;
              y = res.y; // Default align and baseline when has textPosition

              align = align || res.textAlign;
              verticalAlign = verticalAlign || res.textVerticalAlign;
            }
          } else {
            x = rect.x;
            y = rect.y;
          }

          x = textContain.adjustTextX(x, textRect.width, align);
          y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline 'middle'

          y += textRect.height / 2; // var fontSize = fontStyle.size;
          // 1.75 is an arbitrary number, as there is no info about the text baseline
          // switch (baseline) {
          // case 'hanging':
          // case 'top':
          //     y += fontSize / 1.75;
          //     break;
          //     case 'middle':
          //         break;
          //     default:
          //     // case null:
          //     // case 'alphabetic':
          //     // case 'ideographic':
          //     // case 'bottom':
          //         y -= fontSize / 2.25;
          //         break;
          // }
          // switch (align) {
          //     case 'left':
          //         break;
          //     case 'center':
          //         x -= textRect.width / 2;
          //         break;
          //     case 'right':
          //         x -= textRect.width;
          //         break;
          // case 'end':
          // align = elementStyle.direction == 'ltr' ? 'right' : 'left';
          // break;
          // case 'start':
          // align = elementStyle.direction == 'rtl' ? 'right' : 'left';
          // break;
          // default:
          //     align = 'left';
          // }

          var createNode = vmlCore.createNode;
          var textVmlEl = this._textVmlEl;
          var pathEl;
          var textPathEl;
          var skewEl;

          if (!textVmlEl) {
            textVmlEl = createNode('line');
            pathEl = createNode('path');
            textPathEl = createNode('textpath');
            skewEl = createNode('skew'); // FIXME Why here is not cammel case
            // Align 'center' seems wrong

            textPathEl.style['v-text-align'] = 'left';
            initRootElStyle(textVmlEl);
            pathEl.textpathok = true;
            textPathEl.on = true;
            textVmlEl.from = '0 0';
            textVmlEl.to = '1000 0.05';
            append(textVmlEl, skewEl);
            append(textVmlEl, pathEl);
            append(textVmlEl, textPathEl);
            this._textVmlEl = textVmlEl;
          } else {
            //  appendChild 
            skewEl = textVmlEl.firstChild;
            pathEl = skewEl.nextSibling;
            textPathEl = pathEl.nextSibling;
          }

          var coords = [x, y];
          var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element

          if (m && fromTextEl) {
            applyTransform(coords, coords, m);
            skewEl.on = true;
            skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0'; // Text position

            skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0); // Left top point as origin

            skewEl.origin = '0 0';
            textVmlElStyle.left = '0px';
            textVmlElStyle.top = '0px';
          } else {
            skewEl.on = false;
            textVmlElStyle.left = round(x) + 'px';
            textVmlElStyle.top = round(y) + 'px';
          }

          textPathEl.string = encodeHtmlAttribute(text); // TODO

          try {
            textPathEl.style.font = font;
          } // Error font format
          catch (e) {}

          updateFillAndStroke(textVmlEl, 'fill', {
            fill: style.textFill,
            opacity: style.opacity
          }, this);
          updateFillAndStroke(textVmlEl, 'stroke', {
            stroke: style.textStroke,
            opacity: style.opacity,
            lineDash: style.lineDash || null // style.lineDash can be `false`.

          }, this);
          textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root

          append(vmlRoot, textVmlEl);
        };

        var removeRectText = function removeRectText(vmlRoot) {
          remove(vmlRoot, this._textVmlEl);
          this._textVmlEl = null;
        };

        var appendRectText = function appendRectText(vmlRoot) {
          append(vmlRoot, this._textVmlEl);
        };

        var list = [RectText, Displayable, ZImage, Path, Text]; // In case Displayable has been mixed in RectText

        for (var i = 0; i < list.length; i++) {
          var proto = list[i].prototype;
          proto.drawRectText = drawRectText;
          proto.removeRectText = removeRectText;
          proto.appendRectText = appendRectText;
        }

        Text.prototype.brushVML = function (vmlRoot) {
          var style = this.style;

          if (style.text != null) {
            this.drawRectText(vmlRoot, {
              x: style.x || 0,
              y: style.y || 0,
              width: 0,
              height: 0
            }, this.getBoundingRect(), true);
          } else {
            this.removeRectText(vmlRoot);
          }
        };

        Text.prototype.onRemove = function (vmlRoot) {
          this.removeRectText(vmlRoot);
        };

        Text.prototype.onAdd = function (vmlRoot) {
          this.appendRectText(vmlRoot);
        };
      }
      /***/

    },

    /***/
    "qJCg":
    /*!**************************************************************!*\
      !*** ./node_modules/echarts/lib/component/brush/selector.js ***!
      \**************************************************************/

    /*! no static exports found */

    /***/
    function qJCg(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var polygonContain = __webpack_require__(
      /*! zrender/lib/contain/polygon */
      "BlVb");

      var BoundingRect = __webpack_require__(
      /*! zrender/lib/core/BoundingRect */
      "mFDi");

      var _graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var linePolygonIntersect = _graphic.linePolygonIntersect;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // Key of the first level is brushType: `line`, `rect`, `polygon`.
      // Key of the second level is chart element type: `point`, `rect`.
      // See moudule:echarts/component/helper/BrushController
      // function param:
      //      {Object} itemLayout fetch from data.getItemLayout(dataIndex)
      //      {Object} selectors {point: selector, rect: selector, ...}
      //      {Object} area {range: [[], [], ..], boudingRect}
      // function return:
      //      {boolean} Whether in the given brush.

      var selector = {
        lineX: getLineSelectors(0),
        lineY: getLineSelectors(1),
        rect: {
          point: function point(itemLayout, selectors, area) {
            return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]);
          },
          rect: function rect(itemLayout, selectors, area) {
            return itemLayout && area.boundingRect.intersect(itemLayout);
          }
        },
        polygon: {
          point: function point(itemLayout, selectors, area) {
            return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]) && polygonContain.contain(area.range, itemLayout[0], itemLayout[1]);
          },
          rect: function rect(itemLayout, selectors, area) {
            var points = area.range;

            if (!itemLayout || points.length <= 1) {
              return false;
            }

            var x = itemLayout.x;
            var y = itemLayout.y;
            var width = itemLayout.width;
            var height = itemLayout.height;
            var p = points[0];

            if (polygonContain.contain(points, x, y) || polygonContain.contain(points, x + width, y) || polygonContain.contain(points, x, y + height) || polygonContain.contain(points, x + width, y + height) || BoundingRect.create(itemLayout).contain(p[0], p[1]) || linePolygonIntersect(x, y, x + width, y, points) || linePolygonIntersect(x, y, x, y + height, points) || linePolygonIntersect(x + width, y, x + width, y + height, points) || linePolygonIntersect(x, y + height, x + width, y + height, points)) {
              return true;
            }
          }
        }
      };

      function getLineSelectors(xyIndex) {
        var xy = ['x', 'y'];
        var wh = ['width', 'height'];
        return {
          point: function point(itemLayout, selectors, area) {
            if (itemLayout) {
              var range = area.range;
              var p = itemLayout[xyIndex];
              return inLineRange(p, range);
            }
          },
          rect: function rect(itemLayout, selectors, area) {
            if (itemLayout) {
              var range = area.range;
              var layoutRange = [itemLayout[xy[xyIndex]], itemLayout[xy[xyIndex]] + itemLayout[wh[xyIndex]]];
              layoutRange[1] < layoutRange[0] && layoutRange.reverse();
              return inLineRange(layoutRange[0], range) || inLineRange(layoutRange[1], range) || inLineRange(range[0], layoutRange) || inLineRange(range[1], layoutRange);
            }
          }
        };
      }

      function inLineRange(p, range) {
        return range[0] <= p && p <= range[1];
      }

      var _default = selector;
      module.exports = _default;
      /***/
    },

    /***/
    "qMZE":
    /*!*********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/marker/MarkPointModel.js ***!
      \*********************************************************************/

    /*! no static exports found */

    /***/
    function qMZE(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var MarkerModel = __webpack_require__(
      /*! ./MarkerModel */
      "JEkh");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = MarkerModel.extend({
        type: 'markPoint',
        defaultOption: {
          zlevel: 0,
          z: 5,
          symbol: 'pin',
          symbolSize: 50,
          //symbolRotate: 0,
          //symbolOffset: [0, 0]
          tooltip: {
            trigger: 'item'
          },
          label: {
            show: true,
            position: 'inside'
          },
          itemStyle: {
            borderWidth: 2
          },
          emphasis: {
            label: {
              show: true
            }
          }
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "qWt2":
    /*!********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/tooltip/TooltipModel.js ***!
      \********************************************************************/

    /*! no static exports found */

    /***/
    function qWt2(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = echarts.extendComponentModel({
        type: 'tooltip',
        dependencies: ['axisPointer'],
        defaultOption: {
          zlevel: 0,
          z: 60,
          show: true,
          // tooltip
          showContent: true,
          // 'trigger' only works on coordinate system.
          // 'item' | 'axis' | 'none'
          trigger: 'item',
          // 'click' | 'mousemove' | 'none'
          triggerOn: 'mousemove|click',
          alwaysShowContent: false,
          displayMode: 'single',
          // 'single' | 'multipleByCoordSys'
          renderMode: 'auto',
          // 'auto' | 'html' | 'richText'
          // 'auto': use html by default, and use non-html if `document` is not defined
          // 'html': use html for tooltip
          // 'richText': use canvas, svg, and etc. for tooltip
          //  {Array} | {Function}
          // position: null
          // Consider triggered from axisPointer handle, verticalAlign should be 'middle'
          // align: null,
          // verticalAlign: null,
          //  content  viewRect  false 
          confine: false,
          // {string}Template  {Function}
          // formatter: null
          showDelay: 0,
          // ms
          hideDelay: 100,
          // s
          transitionDuration: 0.4,
          enterable: false,
          // 0.7
          backgroundColor: 'rgba(50,50,50,0.7)',
          // 
          borderColor: '#333',
          // px4
          borderRadius: 4,
          // px0
          borderWidth: 0,
          // px5
          // css
          padding: 5,
          // Extra css text
          extraCssText: '',
          // 
          axisPointer: {
            // 
            // 'line' | 'shadow' | 'cross'
            type: 'line',
            // type  line  tooltip line 
            //  'x' | 'y' | 'angle' | 'radius' | 'auto'
            //  'auto' category  x 
            //  angle 
            axis: 'auto',
            animation: 'auto',
            animationDurationUpdate: 200,
            animationEasingUpdate: 'exponentialOut',
            crossStyle: {
              color: '#999',
              width: 1,
              type: 'dashed',
              // TODO formatter
              textStyle: {} // lineStyle and shadowStyle should not be specified here,
              // otherwise it will always override those styles on option.axisPointer.

            }
          },
          textStyle: {
            color: '#fff',
            fontSize: 14
          }
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "qZFw":
    /*!***********************************************************!*\
      !*** ./node_modules/echarts/lib/coord/polar/AngleAxis.js ***!
      \***********************************************************/

    /*! no static exports found */

    /***/
    function qZFw(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var textContain = __webpack_require__(
      /*! zrender/lib/contain/text */
      "6GrX");

      var Axis = __webpack_require__(
      /*! ../Axis */
      "hM6l");

      var _model = __webpack_require__(
      /*! ../../util/model */
      "4NO4");

      var makeInner = _model.makeInner;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var inner = makeInner();

      function AngleAxis(scale, angleExtent) {
        angleExtent = angleExtent || [0, 360];
        Axis.call(this, 'angle', scale, angleExtent);
        /**
         * Axis type
         *  - 'category'
         *  - 'value'
         *  - 'time'
         *  - 'log'
         * @type {string}
         */

        this.type = 'category';
      }

      AngleAxis.prototype = {
        constructor: AngleAxis,

        /**
         * @override
         */
        pointToData: function pointToData(point, clamp) {
          return this.polar.pointToData(point, clamp)[this.dim === 'radius' ? 0 : 1];
        },
        dataToAngle: Axis.prototype.dataToCoord,
        angleToData: Axis.prototype.coordToData,

        /**
         * Only be called in category axis.
         * Angle axis uses text height to decide interval
         *
         * @override
         * @return {number} Auto interval for cateogry axis tick and label
         */
        calculateCategoryInterval: function calculateCategoryInterval() {
          var axis = this;
          var labelModel = axis.getLabelModel();
          var ordinalScale = axis.scale;
          var ordinalExtent = ordinalScale.getExtent(); // Providing this method is for optimization:
          // avoid generating a long array by `getTicks`
          // in large category data case.

          var tickCount = ordinalScale.count();

          if (ordinalExtent[1] - ordinalExtent[0] < 1) {
            return 0;
          }

          var tickValue = ordinalExtent[0];
          var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
          var unitH = Math.abs(unitSpan); // Not precise, just use height as text width
          // and each distance from axis line yet.

          var rect = textContain.getBoundingRect(tickValue, labelModel.getFont(), 'center', 'top');
          var maxH = Math.max(rect.height, 7);
          var dh = maxH / unitH; // 0/0 is NaN, 1/0 is Infinity.

          isNaN(dh) && (dh = Infinity);
          var interval = Math.max(0, Math.floor(dh));
          var cache = inner(axis.model);
          var lastAutoInterval = cache.lastAutoInterval;
          var lastTickCount = cache.lastTickCount; // Use cache to keep interval stable while moving zoom window,
          // otherwise the calculated interval might jitter when the zoom
          // window size is close to the interval-changing size.

          if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 // Always choose the bigger one, otherwise the critical
          // point is not the same when zooming in or zooming out.
          && lastAutoInterval > interval) {
            interval = lastAutoInterval;
          } // Only update cache if cache not used, otherwise the
          // changing of interval is too insensitive.
          else {
            cache.lastTickCount = tickCount;
            cache.lastAutoInterval = interval;
          }

          return interval;
        }
      };
      zrUtil.inherits(AngleAxis, Axis);
      var _default = AngleAxis;
      module.exports = _default;
      /***/
    },

    /***/
    "qgGe":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/sunburst/SunburstSeries.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function qgGe(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var SeriesModel = __webpack_require__(
      /*! ../../model/Series */
      "T4UG");

      var Tree = __webpack_require__(
      /*! ../../data/Tree */
      "Bsck");

      var Model = __webpack_require__(
      /*! ../../model/Model */
      "Qxkt");

      var _treeHelper = __webpack_require__(
      /*! ../helper/treeHelper */
      "VaxA");

      var wrapTreePathInfo = _treeHelper.wrapTreePathInfo;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var _default = SeriesModel.extend({
        type: 'series.sunburst',

        /**
         * @type {module:echarts/data/Tree~Node}
         */
        _viewRoot: null,
        getInitialData: function getInitialData(option, ecModel) {
          // Create a virtual root.
          var root = {
            name: option.name,
            children: option.data
          };
          completeTreeValue(root);
          var levelModels = zrUtil.map(option.levels || [], function (levelDefine) {
            return new Model(levelDefine, this, ecModel);
          }, this); // Make sure always a new tree is created when setOption,
          // in TreemapView, we check whether oldTree === newTree
          // to choose mappings approach among old shapes and new shapes.

          var tree = Tree.createTree(root, this, beforeLink);

          function beforeLink(nodeData) {
            nodeData.wrapMethod('getItemModel', function (model, idx) {
              var node = tree.getNodeByDataIndex(idx);
              var levelModel = levelModels[node.depth];
              levelModel && (model.parentModel = levelModel);
              return model;
            });
          }

          return tree.data;
        },
        optionUpdated: function optionUpdated() {
          this.resetViewRoot();
        },

        /*
         * @override
         */
        getDataParams: function getDataParams(dataIndex) {
          var params = SeriesModel.prototype.getDataParams.apply(this, arguments);
          var node = this.getData().tree.getNodeByDataIndex(dataIndex);
          params.treePathInfo = wrapTreePathInfo(node, this);
          return params;
        },
        defaultOption: {
          zlevel: 0,
          z: 2,
          // 
          center: ['50%', '50%'],
          radius: [0, '75%'],
          // 
          clockwise: true,
          startAngle: 90,
          // 0
          minAngle: 0,
          percentPrecision: 2,
          // If still show when all data zero.
          stillShowZeroSum: true,
          // Policy of highlighting pieces when hover on one
          // Valid values: 'none' (for not downplay others), 'descendant',
          // 'ancestor', 'self'
          highlightPolicy: 'descendant',
          // 'rootToNode', 'link', or false
          nodeClick: 'rootToNode',
          renderLabelForZeroData: false,
          label: {
            // could be: 'radial', 'tangential', or 'none'
            rotate: 'radial',
            show: true,
            opacity: 1,
            // 'left' is for inner side of inside, and 'right' is for outter
            // side for inside
            align: 'center',
            position: 'inside',
            distance: 5,
            silent: true
          },
          itemStyle: {
            borderWidth: 1,
            borderColor: 'white',
            borderType: 'solid',
            shadowBlur: 0,
            shadowColor: 'rgba(0, 0, 0, 0.2)',
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            opacity: 1
          },
          highlight: {
            itemStyle: {
              opacity: 1
            }
          },
          downplay: {
            itemStyle: {
              opacity: 0.5
            },
            label: {
              opacity: 0.6
            }
          },
          // Animation type canbe expansion, scale
          animationType: 'expansion',
          animationDuration: 1000,
          animationDurationUpdate: 500,
          animationEasing: 'cubicOut',
          data: [],
          levels: [],

          /**
           * Sort order.
           *
           * Valid values: 'desc', 'asc', null, or callback function.
           * 'desc' and 'asc' for descend and ascendant order;
           * null for not sorting;
           * example of callback function:
           * function(nodeA, nodeB) {
           *     return nodeA.getValue() - nodeB.getValue();
           * }
           */
          sort: 'desc'
        },
        getViewRoot: function getViewRoot() {
          return this._viewRoot;
        },

        /**
         * @param {module:echarts/data/Tree~Node} [viewRoot]
         */
        resetViewRoot: function resetViewRoot(viewRoot) {
          viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
          var root = this.getRawData().tree.root;

          if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
            this._viewRoot = root;
          }
        }
      });
      /**
       * @param {Object} dataNode
       */


      function completeTreeValue(dataNode) {
        // Postorder travel tree.
        // If value of none-leaf node is not set,
        // calculate it by suming up the value of all children.
        var sum = 0;
        zrUtil.each(dataNode.children, function (child) {
          completeTreeValue(child);
          var childValue = child.value;
          zrUtil.isArray(childValue) && (childValue = childValue[0]);
          sum += childValue;
        });
        var thisValue = dataNode.value;

        if (zrUtil.isArray(thisValue)) {
          thisValue = thisValue[0];
        }

        if (thisValue == null || isNaN(thisValue)) {
          thisValue = sum;
        } // Value should not less than 0.


        if (thisValue < 0) {
          thisValue = 0;
        }

        zrUtil.isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
      }

      module.exports = _default;
      /***/
    },

    /***/
    "qj72":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/cartesian/prepareCustom.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function qj72(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function dataToCoordSize(dataSize, dataItem) {
        // dataItem is necessary in log axis.
        dataItem = dataItem || [0, 0];
        return zrUtil.map(['x', 'y'], function (dim, dimIdx) {
          var axis = this.getAxis(dim);
          var val = dataItem[dimIdx];
          var halfSize = dataSize[dimIdx] / 2;
          return axis.type === 'category' ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
        }, this);
      }

      function _default(coordSys) {
        var rect = coordSys.grid.getRect();
        return {
          coordSys: {
            // The name exposed to user is always 'cartesian2d' but not 'grid'.
            type: 'cartesian2d',
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height
          },
          api: {
            coord: function coord(data) {
              // do not provide "out" param
              return coordSys.dataToPoint(data);
            },
            size: zrUtil.bind(dataToCoordSize, coordSys)
          }
        };
      }

      module.exports = _default;
      /***/
    },

    /***/
    "qt/9":
    /*!********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/pictorialBar.js ***!
      \********************************************************/

    /*! no static exports found */

    /***/
    function qt9(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      __webpack_require__(
      /*! ../coord/cartesian/Grid */
      "Wqna");

      __webpack_require__(
      /*! ./bar/PictorialBarSeries */
      "1tlw");

      __webpack_require__(
      /*! ./bar/PictorialBarView */
      "Mylv");

      var _barGrid = __webpack_require__(
      /*! ../layout/barGrid */
      "nVfU");

      var layout = _barGrid.layout;

      var visualSymbol = __webpack_require__(
      /*! ../visual/symbol */
      "f5Yq");

      __webpack_require__(
      /*! ../component/gridSimple */
      "Ae16");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // In case developer forget to include grid component


      echarts.registerLayout(zrUtil.curry(layout, 'pictorialBar'));
      echarts.registerVisual(visualSymbol('pictorialBar', 'roundRect'));
      /***/
    },

    /***/
    "qwVE":
    /*!************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/visualMap/visualEncoding.js ***!
      \************************************************************************/

    /*! no static exports found */

    /***/
    function qwVE(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var visualSolution = __webpack_require__(
      /*! ../../visual/visualSolution */
      "K4ya");

      var VisualMapping = __webpack_require__(
      /*! ../../visual/VisualMapping */
      "XxSj");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var VISUAL_PRIORITY = echarts.PRIORITY.VISUAL.COMPONENT;
      echarts.registerVisual(VISUAL_PRIORITY, {
        createOnAllSeries: true,
        reset: function reset(seriesModel, ecModel) {
          var resetDefines = [];
          ecModel.eachComponent('visualMap', function (visualMapModel) {
            var pipelineContext = seriesModel.pipelineContext;

            if (!visualMapModel.isTargetSeries(seriesModel) || pipelineContext && pipelineContext.large) {
              return;
            }

            resetDefines.push(visualSolution.incrementalApplyVisual(visualMapModel.stateList, visualMapModel.targetVisuals, zrUtil.bind(visualMapModel.getValueState, visualMapModel), visualMapModel.getDataDimension(seriesModel.getData())));
          });
          return resetDefines;
        }
      }); // Only support color.

      echarts.registerVisual(VISUAL_PRIORITY, {
        createOnAllSeries: true,
        reset: function reset(seriesModel, ecModel) {
          var data = seriesModel.getData();
          var visualMetaList = [];
          ecModel.eachComponent('visualMap', function (visualMapModel) {
            if (visualMapModel.isTargetSeries(seriesModel)) {
              var visualMeta = visualMapModel.getVisualMeta(zrUtil.bind(getColorVisual, null, seriesModel, visualMapModel)) || {
                stops: [],
                outerColors: []
              };
              var concreteDim = visualMapModel.getDataDimension(data);
              var dimInfo = data.getDimensionInfo(concreteDim);

              if (dimInfo != null) {
                // visualMeta.dimension should be dimension index, but not concrete dimension.
                visualMeta.dimension = dimInfo.index;
                visualMetaList.push(visualMeta);
              }
            }
          }); // console.log(JSON.stringify(visualMetaList.map(a => a.stops)));

          seriesModel.getData().setVisual('visualMeta', visualMetaList);
        }
      }); // FIXME
      // performance and export for heatmap?
      // value can be Infinity or -Infinity

      function getColorVisual(seriesModel, visualMapModel, value, valueState) {
        var mappings = visualMapModel.targetVisuals[valueState];
        var visualTypes = VisualMapping.prepareVisualTypes(mappings);
        var resultVisual = {
          color: seriesModel.getData().getVisual('color') // default color.

        };

        for (var i = 0, len = visualTypes.length; i < len; i++) {
          var type = visualTypes[i];
          var mapping = mappings[type === 'opacity' ? '__alphaForOpacity' : type];
          mapping && mapping.applyVisual(value, getVisual, setVisual);
        }

        return resultVisual.color;

        function getVisual(key) {
          return resultVisual[key];
        }

        function setVisual(key, value) {
          resultVisual[key] = value;
        }
      }
      /***/

    },

    /***/
    "rdor":
    /*!****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/graph/circularLayout.js ***!
      \****************************************************************/

    /*! no static exports found */

    /***/
    function rdor(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _circularLayoutHelper = __webpack_require__(
      /*! ./circularLayoutHelper */
      "lOQZ");

      var circularLayout = _circularLayoutHelper.circularLayout;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      function _default(ecModel) {
        ecModel.eachSeriesByType('graph', function (seriesModel) {
          if (seriesModel.get('layout') === 'circular') {
            circularLayout(seriesModel, 'symbolSize');
          }
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "rfSb":
    /*!***********************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/themeRiver/ThemeRiverSeries.js ***!
      \***********************************************************************/

    /*! no static exports found */

    /***/
    function rfSb(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var SeriesModel = __webpack_require__(
      /*! ../../model/Series */
      "T4UG");

      var createDimensions = __webpack_require__(
      /*! ../../data/helper/createDimensions */
      "sdST");

      var _dimensionHelper = __webpack_require__(
      /*! ../../data/helper/dimensionHelper */
      "L0Ub");

      var getDimensionTypeByAxis = _dimensionHelper.getDimensionTypeByAxis;

      var List = __webpack_require__(
      /*! ../../data/List */
      "YXkt");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _model = __webpack_require__(
      /*! ../../util/model */
      "4NO4");

      var groupData = _model.groupData;

      var _format = __webpack_require__(
      /*! ../../util/format */
      "7aKB");

      var encodeHTML = _format.encodeHTML;

      var LegendVisualProvider = __webpack_require__(
      /*! ../../visual/LegendVisualProvider */
      "xKMd");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var DATA_NAME_INDEX = 2;
      var ThemeRiverSeries = SeriesModel.extend({
        type: 'series.themeRiver',
        dependencies: ['singleAxis'],

        /**
         * @readOnly
         * @type {module:zrender/core/util#HashMap}
         */
        nameMap: null,

        /**
         * @override
         */
        init: function init(option) {
          // eslint-disable-next-line
          ThemeRiverSeries.superApply(this, 'init', arguments); // Put this function here is for the sake of consistency of code style.
          // Enable legend selection for each data item
          // Use a function instead of direct access because data reference may changed

          this.legendVisualProvider = new LegendVisualProvider(zrUtil.bind(this.getData, this), zrUtil.bind(this.getRawData, this));
        },

        /**
         * If there is no value of a certain point in the time for some event,set it value to 0.
         *
         * @param {Array} data  initial data in the option
         * @return {Array}
         */
        fixData: function fixData(data) {
          var rawDataLength = data.length;
          /**
           * Make sure every layer data get the same keys.
           * The value index tells which layer has visited.
           * {
           *  2014/01/01: -1
           * }
           */

          var timeValueKeys = {}; // grouped data by name

          var groupResult = groupData(data, function (item) {
            if (!timeValueKeys.hasOwnProperty(item[0])) {
              timeValueKeys[item[0]] = -1;
            }

            return item[2];
          });
          var layData = [];
          groupResult.buckets.each(function (items, key) {
            layData.push({
              name: key,
              dataList: items
            });
          });
          var layerNum = layData.length;

          for (var k = 0; k < layerNum; ++k) {
            var name = layData[k].name;

            for (var j = 0; j < layData[k].dataList.length; ++j) {
              var timeValue = layData[k].dataList[j][0];
              timeValueKeys[timeValue] = k;
            }

            for (var timeValue in timeValueKeys) {
              if (timeValueKeys.hasOwnProperty(timeValue) && timeValueKeys[timeValue] !== k) {
                timeValueKeys[timeValue] = k;
                data[rawDataLength] = [];
                data[rawDataLength][0] = timeValue;
                data[rawDataLength][1] = 0;
                data[rawDataLength][2] = name;
                rawDataLength++;
              }
            }
          }

          return data;
        },

        /**
         * @override
         * @param  {Object} option  the initial option that user gived
         * @param  {module:echarts/model/Model} ecModel  the model object for themeRiver option
         * @return {module:echarts/data/List}
         */
        getInitialData: function getInitialData(option, ecModel) {
          var singleAxisModel = ecModel.queryComponents({
            mainType: 'singleAxis',
            index: this.get('singleAxisIndex'),
            id: this.get('singleAxisId')
          })[0];
          var axisType = singleAxisModel.get('type'); // filter the data item with the value of label is undefined

          var filterData = zrUtil.filter(option.data, function (dataItem) {
            return dataItem[2] !== undefined;
          }); // ??? TODO design a stage to transfer data for themeRiver and lines?

          var data = this.fixData(filterData || []);
          var nameList = [];
          var nameMap = this.nameMap = zrUtil.createHashMap();
          var count = 0;

          for (var i = 0; i < data.length; ++i) {
            nameList.push(data[i][DATA_NAME_INDEX]);

            if (!nameMap.get(data[i][DATA_NAME_INDEX])) {
              nameMap.set(data[i][DATA_NAME_INDEX], count);
              count++;
            }
          }

          var dimensionsInfo = createDimensions(data, {
            coordDimensions: ['single'],
            dimensionsDefine: [{
              name: 'time',
              type: getDimensionTypeByAxis(axisType)
            }, {
              name: 'value',
              type: 'float'
            }, {
              name: 'name',
              type: 'ordinal'
            }],
            encodeDefine: {
              single: 0,
              value: 1,
              itemName: 2
            }
          });
          var list = new List(dimensionsInfo, this);
          list.initData(data);
          return list;
        },

        /**
         * The raw data is divided into multiple layers and each layer
         *     has same name.
         *
         * @return {Array.<Array.<number>>}
         */
        getLayerSeries: function getLayerSeries() {
          var data = this.getData();
          var lenCount = data.count();
          var indexArr = [];

          for (var i = 0; i < lenCount; ++i) {
            indexArr[i] = i;
          }

          var timeDim = data.mapDimension('single'); // data group by name

          var groupResult = groupData(indexArr, function (index) {
            return data.get('name', index);
          });
          var layerSeries = [];
          groupResult.buckets.each(function (items, key) {
            items.sort(function (index1, index2) {
              return data.get(timeDim, index1) - data.get(timeDim, index2);
            });
            layerSeries.push({
              name: key,
              indices: items
            });
          });
          return layerSeries;
        },

        /**
         * Get data indices for show tooltip content
          * @param {Array.<string>|string} dim  single coordinate dimension
         * @param {number} value axis value
         * @param {module:echarts/coord/single/SingleAxis} baseAxis  single Axis used
         *     the themeRiver.
         * @return {Object} {dataIndices, nestestValue}
         */
        getAxisTooltipData: function getAxisTooltipData(dim, value, baseAxis) {
          if (!zrUtil.isArray(dim)) {
            dim = dim ? [dim] : [];
          }

          var data = this.getData();
          var layerSeries = this.getLayerSeries();
          var indices = [];
          var layerNum = layerSeries.length;
          var nestestValue;

          for (var i = 0; i < layerNum; ++i) {
            var minDist = Number.MAX_VALUE;
            var nearestIdx = -1;
            var pointNum = layerSeries[i].indices.length;

            for (var j = 0; j < pointNum; ++j) {
              var theValue = data.get(dim[0], layerSeries[i].indices[j]);
              var dist = Math.abs(theValue - value);

              if (dist <= minDist) {
                nestestValue = theValue;
                minDist = dist;
                nearestIdx = layerSeries[i].indices[j];
              }
            }

            indices.push(nearestIdx);
          }

          return {
            dataIndices: indices,
            nestestValue: nestestValue
          };
        },

        /**
         * @override
         * @param {number} dataIndex  index of data
         */
        formatTooltip: function formatTooltip(dataIndex) {
          var data = this.getData();
          var htmlName = data.getName(dataIndex);
          var htmlValue = data.get(data.mapDimension('value'), dataIndex);

          if (isNaN(htmlValue) || htmlValue == null) {
            htmlValue = '-';
          }

          return encodeHTML(htmlName + ' : ' + htmlValue);
        },
        defaultOption: {
          zlevel: 0,
          z: 2,
          coordinateSystem: 'singleAxis',
          // gap in axis's orthogonal orientation
          boundaryGap: ['10%', '10%'],
          // legendHoverLink: true,
          singleAxisIndex: 0,
          animationEasing: 'linear',
          label: {
            margin: 4,
            show: true,
            position: 'left',
            color: '#000',
            fontSize: 11
          },
          emphasis: {
            label: {
              show: true
            }
          }
        }
      });
      var _default = ThemeRiverSeries;
      module.exports = _default;
      /***/
    },

    /***/
    "rkZ5":
    /*!***********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/lines/LinesView.js ***!
      \***********************************************************/

    /*! no static exports found */

    /***/
    function rkZ5(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var LineDraw = __webpack_require__(
      /*! ../helper/LineDraw */
      "c8qY");

      var EffectLine = __webpack_require__(
      /*! ../helper/EffectLine */
      "D9ME");

      var Line = __webpack_require__(
      /*! ../helper/Line */
      "fls0");

      var Polyline = __webpack_require__(
      /*! ../helper/Polyline */
      "RSch");

      var EffectPolyline = __webpack_require__(
      /*! ../helper/EffectPolyline */
      "akwb");

      var LargeLineDraw = __webpack_require__(
      /*! ../helper/LargeLineDraw */
      "o40c");

      var linesLayout = __webpack_require__(
      /*! ./linesLayout */
      "ZYIC");

      var _createClipPathFromCoordSys = __webpack_require__(
      /*! ../helper/createClipPathFromCoordSys */
      "sK/D");

      var createClipPath = _createClipPathFromCoordSys.createClipPath;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var _default = echarts.extendChartView({
        type: 'lines',
        init: function init() {},
        render: function render(seriesModel, ecModel, api) {
          var data = seriesModel.getData();

          var lineDraw = this._updateLineDraw(data, seriesModel);

          var zlevel = seriesModel.get('zlevel');
          var trailLength = seriesModel.get('effect.trailLength');
          var zr = api.getZr(); // Avoid the drag cause ghost shadow
          // FIXME Better way ?
          // SVG doesn't support

          var isSvg = zr.painter.getType() === 'svg';

          if (!isSvg) {
            zr.painter.getLayer(zlevel).clear(true);
          } // Config layer with motion blur


          if (this._lastZlevel != null && !isSvg) {
            zr.configLayer(this._lastZlevel, {
              motionBlur: false
            });
          }

          if (this._showEffect(seriesModel) && trailLength) {
            if (!isSvg) {
              zr.configLayer(zlevel, {
                motionBlur: true,
                lastFrameAlpha: Math.max(Math.min(trailLength / 10 + 0.9, 1), 0)
              });
            }
          }

          lineDraw.updateData(data);
          var clipPath = seriesModel.get('clip', true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);

          if (clipPath) {
            this.group.setClipPath(clipPath);
          } else {
            this.group.removeClipPath();
          }

          this._lastZlevel = zlevel;
          this._finished = true;
        },
        incrementalPrepareRender: function incrementalPrepareRender(seriesModel, ecModel, api) {
          var data = seriesModel.getData();

          var lineDraw = this._updateLineDraw(data, seriesModel);

          lineDraw.incrementalPrepareUpdate(data);

          this._clearLayer(api);

          this._finished = false;
        },
        incrementalRender: function incrementalRender(taskParams, seriesModel, ecModel) {
          this._lineDraw.incrementalUpdate(taskParams, seriesModel.getData());

          this._finished = taskParams.end === seriesModel.getData().count();
        },
        updateTransform: function updateTransform(seriesModel, ecModel, api) {
          var data = seriesModel.getData();
          var pipelineContext = seriesModel.pipelineContext;

          if (!this._finished || pipelineContext.large || pipelineContext.progressiveRender) {
            // TODO Don't have to do update in large mode. Only do it when there are millions of data.
            return {
              update: true
            };
          } else {
            // TODO Use same logic with ScatterView.
            // Manually update layout
            var res = linesLayout.reset(seriesModel);

            if (res.progress) {
              res.progress({
                start: 0,
                end: data.count()
              }, data);
            }

            this._lineDraw.updateLayout();

            this._clearLayer(api);
          }
        },
        _updateLineDraw: function _updateLineDraw(data, seriesModel) {
          var lineDraw = this._lineDraw;

          var hasEffect = this._showEffect(seriesModel);

          var isPolyline = !!seriesModel.get('polyline');
          var pipelineContext = seriesModel.pipelineContext;
          var isLargeDraw = pipelineContext.large;

          if (!lineDraw || hasEffect !== this._hasEffet || isPolyline !== this._isPolyline || isLargeDraw !== this._isLargeDraw) {
            if (lineDraw) {
              lineDraw.remove();
            }

            lineDraw = this._lineDraw = isLargeDraw ? new LargeLineDraw() : new LineDraw(isPolyline ? hasEffect ? EffectPolyline : Polyline : hasEffect ? EffectLine : Line);
            this._hasEffet = hasEffect;
            this._isPolyline = isPolyline;
            this._isLargeDraw = isLargeDraw;
            this.group.removeAll();
          }

          this.group.add(lineDraw.group);
          return lineDraw;
        },
        _showEffect: function _showEffect(seriesModel) {
          return !!seriesModel.get('effect.show');
        },
        _clearLayer: function _clearLayer(api) {
          // Not use motion when dragging or zooming
          var zr = api.getZr();
          var isSvg = zr.painter.getType() === 'svg';

          if (!isSvg && this._lastZlevel != null) {
            zr.painter.getLayer(this._lastZlevel).clear(true);
          }
        },
        remove: function remove(ecModel, api) {
          this._lineDraw && this._lineDraw.remove();
          this._lineDraw = null; // Clear motion when lineDraw is removed

          this._clearLayer(api);
        },
        dispose: function dispose() {}
      });

      module.exports = _default;
      /***/
    },

    /***/
    "rnVJ":
    /*!******************************************************************!*\
      !*** ./node_modules/echarts/lib/component/brush/preprocessor.js ***!
      \******************************************************************/

    /*! no static exports found */

    /***/
    function rnVJ(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var DEFAULT_TOOLBOX_BTNS = ['rect', 'polygon', 'keep', 'clear'];

      function _default(option, isNew) {
        var brushComponents = option && option.brush;

        if (!zrUtil.isArray(brushComponents)) {
          brushComponents = brushComponents ? [brushComponents] : [];
        }

        if (!brushComponents.length) {
          return;
        }

        var brushComponentSpecifiedBtns = [];
        zrUtil.each(brushComponents, function (brushOpt) {
          var tbs = brushOpt.hasOwnProperty('toolbox') ? brushOpt.toolbox : [];

          if (tbs instanceof Array) {
            brushComponentSpecifiedBtns = brushComponentSpecifiedBtns.concat(tbs);
          }
        });
        var toolbox = option && option.toolbox;

        if (zrUtil.isArray(toolbox)) {
          toolbox = toolbox[0];
        }

        if (!toolbox) {
          toolbox = {
            feature: {}
          };
          option.toolbox = [toolbox];
        }

        var toolboxFeature = toolbox.feature || (toolbox.feature = {});
        var toolboxBrush = toolboxFeature.brush || (toolboxFeature.brush = {});
        var brushTypes = toolboxBrush.type || (toolboxBrush.type = []);
        brushTypes.push.apply(brushTypes, brushComponentSpecifiedBtns);
        removeDuplicate(brushTypes);

        if (isNew && !brushTypes.length) {
          brushTypes.push.apply(brushTypes, DEFAULT_TOOLBOX_BTNS);
        }
      }

      function removeDuplicate(arr) {
        var map = {};
        zrUtil.each(arr, function (val) {
          map[val] = 1;
        });
        arr.length = 0;
        zrUtil.each(map, function (flag, val) {
          arr.push(val);
        });
      }

      module.exports = _default;
      /***/
    },

    /***/
    "rySg":
    /*!****************************************************!*\
      !*** ./node_modules/echarts/lib/component/axis.js ***!
      \****************************************************/

    /*! no static exports found */

    /***/
    function rySg(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      __webpack_require__(
      /*! ../coord/cartesian/AxisModel */
      "SMc4");

      __webpack_require__(
      /*! ./axis/CartesianAxisView */
      "8nMs");
      /***/

    },

    /***/
    "s2lz":
    /*!***************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/treemap/TreemapView.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function s2lz(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var DataDiffer = __webpack_require__(
      /*! ../../data/DataDiffer */
      "gPAo");

      var helper = __webpack_require__(
      /*! ../helper/treeHelper */
      "VaxA");

      var Breadcrumb = __webpack_require__(
      /*! ./Breadcrumb */
      "9hCq");

      var RoamController = __webpack_require__(
      /*! ../../component/helper/RoamController */
      "SgGq");

      var BoundingRect = __webpack_require__(
      /*! zrender/lib/core/BoundingRect */
      "mFDi");

      var matrix = __webpack_require__(
      /*! zrender/lib/core/matrix */
      "Fofx");

      var animationUtil = __webpack_require__(
      /*! ../../util/animation */
      "5s0K");

      var makeStyleMapper = __webpack_require__(
      /*! ../../model/mixin/makeStyleMapper */
      "KCsZ");

      var _format = __webpack_require__(
      /*! ../../util/format */
      "7aKB");

      var windowOpen = _format.windowOpen;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var bind = zrUtil.bind;
      var Group = graphic.Group;
      var Rect = graphic.Rect;
      var each = zrUtil.each;
      var DRAG_THRESHOLD = 3;
      var PATH_LABEL_NOAMAL = ['label'];
      var PATH_LABEL_EMPHASIS = ['emphasis', 'label'];
      var PATH_UPPERLABEL_NORMAL = ['upperLabel'];
      var PATH_UPPERLABEL_EMPHASIS = ['emphasis', 'upperLabel'];
      var Z_BASE = 10; // Should bigger than every z.

      var Z_BG = 1;
      var Z_CONTENT = 2;
      var getItemStyleEmphasis = makeStyleMapper([['fill', 'color'], // `borderColor` and `borderWidth` has been occupied,
      // so use `stroke` to indicate the stroke of the rect.
      ['stroke', 'strokeColor'], ['lineWidth', 'strokeWidth'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);

      var getItemStyleNormal = function getItemStyleNormal(model) {
        // Normal style props should include emphasis style props.
        var itemStyle = getItemStyleEmphasis(model); // Clear styles set by emphasis.

        itemStyle.stroke = itemStyle.fill = itemStyle.lineWidth = null;
        return itemStyle;
      };

      var _default = echarts.extendChartView({
        type: 'treemap',

        /**
         * @override
         */
        init: function init(o, api) {
          /**
           * @private
           * @type {module:zrender/container/Group}
           */
          this._containerGroup;
          /**
           * @private
           * @type {Object.<string, Array.<module:zrender/container/Group>>}
           */

          this._storage = createStorage();
          /**
           * @private
           * @type {module:echarts/data/Tree}
           */

          this._oldTree;
          /**
           * @private
           * @type {module:echarts/chart/treemap/Breadcrumb}
           */

          this._breadcrumb;
          /**
           * @private
           * @type {module:echarts/component/helper/RoamController}
           */

          this._controller;
          /**
           * 'ready', 'animating'
           * @private
           */

          this._state = 'ready';
        },

        /**
         * @override
         */
        render: function render(seriesModel, ecModel, api, payload) {
          var models = ecModel.findComponents({
            mainType: 'series',
            subType: 'treemap',
            query: payload
          });

          if (zrUtil.indexOf(models, seriesModel) < 0) {
            return;
          }

          this.seriesModel = seriesModel;
          this.api = api;
          this.ecModel = ecModel;
          var types = ['treemapZoomToNode', 'treemapRootToNode'];
          var targetInfo = helper.retrieveTargetInfo(payload, types, seriesModel);
          var payloadType = payload && payload.type;
          var layoutInfo = seriesModel.layoutInfo;
          var isInit = !this._oldTree;
          var thisStorage = this._storage; // Mark new root when action is treemapRootToNode.

          var reRoot = payloadType === 'treemapRootToNode' && targetInfo && thisStorage ? {
            rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],
            direction: payload.direction
          } : null;

          var containerGroup = this._giveContainerGroup(layoutInfo);

          var renderResult = this._doRender(containerGroup, seriesModel, reRoot);

          !isInit && (!payloadType || payloadType === 'treemapZoomToNode' || payloadType === 'treemapRootToNode') ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot) : renderResult.renderFinally();

          this._resetController(api);

          this._renderBreadcrumb(seriesModel, api, targetInfo);
        },

        /**
         * @private
         */
        _giveContainerGroup: function _giveContainerGroup(layoutInfo) {
          var containerGroup = this._containerGroup;

          if (!containerGroup) {
            // FIXME
            // containerGroupclipclip
            containerGroup = this._containerGroup = new Group();

            this._initEvents(containerGroup);

            this.group.add(containerGroup);
          }

          containerGroup.attr('position', [layoutInfo.x, layoutInfo.y]);
          return containerGroup;
        },

        /**
         * @private
         */
        _doRender: function _doRender(containerGroup, seriesModel, reRoot) {
          var thisTree = seriesModel.getData().tree;
          var oldTree = this._oldTree; // Clear last shape records.

          var lastsForAnimation = createStorage();
          var thisStorage = createStorage();
          var oldStorage = this._storage;
          var willInvisibleEls = [];
          var doRenderNode = zrUtil.curry(renderNode, seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls); // Notice: when thisTree and oldTree are the same tree (see list.cloneShallow),
          // the oldTree is actually losted, so we can not find all of the old graphic
          // elements from tree. So we use this stragegy: make element storage, move
          // from old storage to new storage, clear old storage.

          dualTravel(thisTree.root ? [thisTree.root] : [], oldTree && oldTree.root ? [oldTree.root] : [], containerGroup, thisTree === oldTree || !oldTree, 0); // Process all removing.

          var willDeleteEls = clearStorage(oldStorage);
          this._oldTree = thisTree;
          this._storage = thisStorage;
          return {
            lastsForAnimation: lastsForAnimation,
            willDeleteEls: willDeleteEls,
            renderFinally: renderFinally
          };

          function dualTravel(thisViewChildren, oldViewChildren, parentGroup, sameTree, depth) {
            // When 'render' is triggered by action,
            // 'this' and 'old' may be the same tree,
            // we use rawIndex in that case.
            if (sameTree) {
              oldViewChildren = thisViewChildren;
              each(thisViewChildren, function (child, index) {
                !child.isRemoved() && processNode(index, index);
              });
            } // Diff hierarchically (diff only in each subtree, but not whole).
            // because, consistency of view is important.
            else {
              new DataDiffer(oldViewChildren, thisViewChildren, getKey, getKey).add(processNode).update(processNode).remove(zrUtil.curry(processNode, null)).execute();
            }

            function getKey(node) {
              // Identify by name or raw index.
              return node.getId();
            }

            function processNode(newIndex, oldIndex) {
              var thisNode = newIndex != null ? thisViewChildren[newIndex] : null;
              var oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null;
              var group = doRenderNode(thisNode, oldNode, parentGroup, depth);
              group && dualTravel(thisNode && thisNode.viewChildren || [], oldNode && oldNode.viewChildren || [], group, sameTree, depth + 1);
            }
          }

          function clearStorage(storage) {
            var willDeleteEls = createStorage();
            storage && each(storage, function (store, storageName) {
              var delEls = willDeleteEls[storageName];
              each(store, function (el) {
                el && (delEls.push(el), el.__tmWillDelete = 1);
              });
            });
            return willDeleteEls;
          }

          function renderFinally() {
            each(willDeleteEls, function (els) {
              each(els, function (el) {
                el.parent && el.parent.remove(el);
              });
            });
            each(willInvisibleEls, function (el) {
              el.invisible = true; // Setting invisible is for optimizing, so no need to set dirty,
              // just mark as invisible.

              el.dirty();
            });
          }
        },

        /**
         * @private
         */
        _doAnimation: function _doAnimation(containerGroup, renderResult, seriesModel, reRoot) {
          if (!seriesModel.get('animation')) {
            return;
          }

          var duration = seriesModel.get('animationDurationUpdate');
          var easing = seriesModel.get('animationEasing');
          var animationWrap = animationUtil.createWrap(); // Make delete animations.

          each(renderResult.willDeleteEls, function (store, storageName) {
            each(store, function (el, rawIndex) {
              if (el.invisible) {
                return;
              }

              var parent = el.parent; // Always has parent, and parent is nodeGroup.

              var target;

              if (reRoot && reRoot.direction === 'drillDown') {
                target = parent === reRoot.rootNodeGroup // This is the content element of view root.
                // Only `content` will enter this branch, because
                // `background` and `nodeGroup` will not be deleted.
                ? {
                  shape: {
                    x: 0,
                    y: 0,
                    width: parent.__tmNodeWidth,
                    height: parent.__tmNodeHeight
                  },
                  style: {
                    opacity: 0
                  } // Others.

                } : {
                  style: {
                    opacity: 0
                  }
                };
              } else {
                var targetX = 0;
                var targetY = 0;

                if (!parent.__tmWillDelete) {
                  // Let node animate to right-bottom corner, cooperating with fadeout,
                  // which is appropriate for user understanding.
                  // Divided by 2 for reRoot rolling up effect.
                  targetX = parent.__tmNodeWidth / 2;
                  targetY = parent.__tmNodeHeight / 2;
                }

                target = storageName === 'nodeGroup' ? {
                  position: [targetX, targetY],
                  style: {
                    opacity: 0
                  }
                } : {
                  shape: {
                    x: targetX,
                    y: targetY,
                    width: 0,
                    height: 0
                  },
                  style: {
                    opacity: 0
                  }
                };
              }

              target && animationWrap.add(el, target, duration, easing);
            });
          }); // Make other animations

          each(this._storage, function (store, storageName) {
            each(store, function (el, rawIndex) {
              var last = renderResult.lastsForAnimation[storageName][rawIndex];
              var target = {};

              if (!last) {
                return;
              }

              if (storageName === 'nodeGroup') {
                if (last.old) {
                  target.position = el.position.slice();
                  el.attr('position', last.old);
                }
              } else {
                if (last.old) {
                  target.shape = zrUtil.extend({}, el.shape);
                  el.setShape(last.old);
                }

                if (last.fadein) {
                  el.setStyle('opacity', 0);
                  target.style = {
                    opacity: 1
                  };
                } // When animation is stopped for succedent animation starting,
                // el.style.opacity might not be 1
                else if (el.style.opacity !== 1) {
                  target.style = {
                    opacity: 1
                  };
                }
              }

              animationWrap.add(el, target, duration, easing);
            });
          }, this);
          this._state = 'animating';
          animationWrap.done(bind(function () {
            this._state = 'ready';
            renderResult.renderFinally();
          }, this)).start();
        },

        /**
         * @private
         */
        _resetController: function _resetController(api) {
          var controller = this._controller; // Init controller.

          if (!controller) {
            controller = this._controller = new RoamController(api.getZr());
            controller.enable(this.seriesModel.get('roam'));
            controller.on('pan', bind(this._onPan, this));
            controller.on('zoom', bind(this._onZoom, this));
          }

          var rect = new BoundingRect(0, 0, api.getWidth(), api.getHeight());
          controller.setPointerChecker(function (e, x, y) {
            return rect.contain(x, y);
          });
        },

        /**
         * @private
         */
        _clearController: function _clearController() {
          var controller = this._controller;

          if (controller) {
            controller.dispose();
            controller = null;
          }
        },

        /**
         * @private
         */
        _onPan: function _onPan(e) {
          if (this._state !== 'animating' && (Math.abs(e.dx) > DRAG_THRESHOLD || Math.abs(e.dy) > DRAG_THRESHOLD)) {
            // These param must not be cached.
            var root = this.seriesModel.getData().tree.root;

            if (!root) {
              return;
            }

            var rootLayout = root.getLayout();

            if (!rootLayout) {
              return;
            }

            this.api.dispatchAction({
              type: 'treemapMove',
              from: this.uid,
              seriesId: this.seriesModel.id,
              rootRect: {
                x: rootLayout.x + e.dx,
                y: rootLayout.y + e.dy,
                width: rootLayout.width,
                height: rootLayout.height
              }
            });
          }
        },

        /**
         * @private
         */
        _onZoom: function _onZoom(e) {
          var mouseX = e.originX;
          var mouseY = e.originY;

          if (this._state !== 'animating') {
            // These param must not be cached.
            var root = this.seriesModel.getData().tree.root;

            if (!root) {
              return;
            }

            var rootLayout = root.getLayout();

            if (!rootLayout) {
              return;
            }

            var rect = new BoundingRect(rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height);
            var layoutInfo = this.seriesModel.layoutInfo; // Transform mouse coord from global to containerGroup.

            mouseX -= layoutInfo.x;
            mouseY -= layoutInfo.y; // Scale root bounding rect.

            var m = matrix.create();
            matrix.translate(m, m, [-mouseX, -mouseY]);
            matrix.scale(m, m, [e.scale, e.scale]);
            matrix.translate(m, m, [mouseX, mouseY]);
            rect.applyTransform(m);
            this.api.dispatchAction({
              type: 'treemapRender',
              from: this.uid,
              seriesId: this.seriesModel.id,
              rootRect: {
                x: rect.x,
                y: rect.y,
                width: rect.width,
                height: rect.height
              }
            });
          }
        },

        /**
         * @private
         */
        _initEvents: function _initEvents(containerGroup) {
          containerGroup.on('click', function (e) {
            if (this._state !== 'ready') {
              return;
            }

            var nodeClick = this.seriesModel.get('nodeClick', true);

            if (!nodeClick) {
              return;
            }

            var targetInfo = this.findTarget(e.offsetX, e.offsetY);

            if (!targetInfo) {
              return;
            }

            var node = targetInfo.node;

            if (node.getLayout().isLeafRoot) {
              this._rootToNode(targetInfo);
            } else {
              if (nodeClick === 'zoomToNode') {
                this._zoomToNode(targetInfo);
              } else if (nodeClick === 'link') {
                var itemModel = node.hostTree.data.getItemModel(node.dataIndex);
                var link = itemModel.get('link', true);
                var linkTarget = itemModel.get('target', true) || 'blank';
                link && windowOpen(link, linkTarget);
              }
            }
          }, this);
        },

        /**
         * @private
         */
        _renderBreadcrumb: function _renderBreadcrumb(seriesModel, api, targetInfo) {
          if (!targetInfo) {
            targetInfo = seriesModel.get('leafDepth', true) != null ? {
              node: seriesModel.getViewRoot() // FIXME
              // better way?
              // Find breadcrumb tail on center of containerGroup.

            } : this.findTarget(api.getWidth() / 2, api.getHeight() / 2);

            if (!targetInfo) {
              targetInfo = {
                node: seriesModel.getData().tree.root
              };
            }
          }

          (this._breadcrumb || (this._breadcrumb = new Breadcrumb(this.group))).render(seriesModel, api, targetInfo.node, bind(onSelect, this));

          function onSelect(node) {
            if (this._state !== 'animating') {
              helper.aboveViewRoot(seriesModel.getViewRoot(), node) ? this._rootToNode({
                node: node
              }) : this._zoomToNode({
                node: node
              });
            }
          }
        },

        /**
         * @override
         */
        remove: function remove() {
          this._clearController();

          this._containerGroup && this._containerGroup.removeAll();
          this._storage = createStorage();
          this._state = 'ready';
          this._breadcrumb && this._breadcrumb.remove();
        },
        dispose: function dispose() {
          this._clearController();
        },

        /**
         * @private
         */
        _zoomToNode: function _zoomToNode(targetInfo) {
          this.api.dispatchAction({
            type: 'treemapZoomToNode',
            from: this.uid,
            seriesId: this.seriesModel.id,
            targetNode: targetInfo.node
          });
        },

        /**
         * @private
         */
        _rootToNode: function _rootToNode(targetInfo) {
          this.api.dispatchAction({
            type: 'treemapRootToNode',
            from: this.uid,
            seriesId: this.seriesModel.id,
            targetNode: targetInfo.node
          });
        },

        /**
         * @public
         * @param {number} x Global coord x.
         * @param {number} y Global coord y.
         * @return {Object} info If not found, return undefined;
         * @return {number} info.node Target node.
         * @return {number} info.offsetX x refer to target node.
         * @return {number} info.offsetY y refer to target node.
         */
        findTarget: function findTarget(x, y) {
          var targetInfo;
          var viewRoot = this.seriesModel.getViewRoot();
          viewRoot.eachNode({
            attr: 'viewChildren',
            order: 'preorder'
          }, function (node) {
            var bgEl = this._storage.background[node.getRawIndex()]; // If invisible, there might be no element.


            if (bgEl) {
              var point = bgEl.transformCoordToLocal(x, y);
              var shape = bgEl.shape; // For performance consideration, dont use 'getBoundingRect'.

              if (shape.x <= point[0] && point[0] <= shape.x + shape.width && shape.y <= point[1] && point[1] <= shape.y + shape.height) {
                targetInfo = {
                  node: node,
                  offsetX: point[0],
                  offsetY: point[1]
                };
              } else {
                return false; // Suppress visit subtree.
              }
            }
          }, this);
          return targetInfo;
        }
      });
      /**
       * @inner
       */


      function createStorage() {
        return {
          nodeGroup: [],
          background: [],
          content: []
        };
      }
      /**
       * @inner
       * @return Return undefined means do not travel further.
       */


      function renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth) {
        // Whether under viewRoot.
        if (!thisNode) {
          // Deleting nodes will be performed finally. This method just find
          // element from old storage, or create new element, set them to new
          // storage, and set styles.
          return;
        } // -------------------------------------------------------------------
        // Start of closure variables available in "Procedures in renderNode".


        var thisLayout = thisNode.getLayout();
        var data = seriesModel.getData(); // Only for enabling highlight/downplay. Clear firstly.
        // Because some node will not be rendered.

        data.setItemGraphicEl(thisNode.dataIndex, null);

        if (!thisLayout || !thisLayout.isInView) {
          return;
        }

        var thisWidth = thisLayout.width;
        var thisHeight = thisLayout.height;
        var borderWidth = thisLayout.borderWidth;
        var thisInvisible = thisLayout.invisible;
        var thisRawIndex = thisNode.getRawIndex();
        var oldRawIndex = oldNode && oldNode.getRawIndex();
        var thisViewChildren = thisNode.viewChildren;
        var upperHeight = thisLayout.upperHeight;
        var isParent = thisViewChildren && thisViewChildren.length;
        var itemStyleNormalModel = thisNode.getModel('itemStyle');
        var itemStyleEmphasisModel = thisNode.getModel('emphasis.itemStyle'); // End of closure ariables available in "Procedures in renderNode".
        // -----------------------------------------------------------------
        // Node group

        var group = giveGraphic('nodeGroup', Group);

        if (!group) {
          return;
        }

        parentGroup.add(group); // x,y are not set when el is above view root.

        group.attr('position', [thisLayout.x || 0, thisLayout.y || 0]);
        group.__tmNodeWidth = thisWidth;
        group.__tmNodeHeight = thisHeight;

        if (thisLayout.isAboveViewRoot) {
          return group;
        }

        var nodeModel = thisNode.getModel(); // Background

        var bg = giveGraphic('background', Rect, depth, Z_BG);
        bg && renderBackground(group, bg, isParent && thisLayout.upperLabelHeight); // No children, render content.

        if (isParent) {
          // Because of the implementation about "traverse" in graphic hover style, we
          // can not set hover listener on the "group" of non-leaf node. Otherwise the
          // hover event from the descendents will be listenered.
          if (graphic.isHighDownDispatcher(group)) {
            graphic.setAsHighDownDispatcher(group, false);
          }

          if (bg) {
            graphic.setAsHighDownDispatcher(bg, true); // Only for enabling highlight/downplay.

            data.setItemGraphicEl(thisNode.dataIndex, bg);
          }
        } else {
          var content = giveGraphic('content', Rect, depth, Z_CONTENT);
          content && renderContent(group, content);

          if (bg && graphic.isHighDownDispatcher(bg)) {
            graphic.setAsHighDownDispatcher(bg, false);
          }

          graphic.setAsHighDownDispatcher(group, true); // Only for enabling highlight/downplay.

          data.setItemGraphicEl(thisNode.dataIndex, group);
        }

        return group; // ----------------------------
        // | Procedures in renderNode |
        // ----------------------------

        function renderBackground(group, bg, useUpperLabel) {
          // For tooltip.
          bg.dataIndex = thisNode.dataIndex;
          bg.seriesIndex = seriesModel.seriesIndex;
          bg.setShape({
            x: 0,
            y: 0,
            width: thisWidth,
            height: thisHeight
          });

          if (thisInvisible) {
            // If invisible, do not set visual, otherwise the element will
            // change immediately before animation. We think it is OK to
            // remain its origin color when moving out of the view window.
            processInvisible(bg);
          } else {
            bg.invisible = false;
            var visualBorderColor = thisNode.getVisual('borderColor', true);
            var emphasisBorderColor = itemStyleEmphasisModel.get('borderColor');
            var normalStyle = getItemStyleNormal(itemStyleNormalModel);
            normalStyle.fill = visualBorderColor;
            var emphasisStyle = getItemStyleEmphasis(itemStyleEmphasisModel);
            emphasisStyle.fill = emphasisBorderColor;

            if (useUpperLabel) {
              var upperLabelWidth = thisWidth - 2 * borderWidth;
              prepareText(normalStyle, emphasisStyle, visualBorderColor, upperLabelWidth, upperHeight, {
                x: borderWidth,
                y: 0,
                width: upperLabelWidth,
                height: upperHeight
              });
            } // For old bg.
            else {
              normalStyle.text = emphasisStyle.text = null;
            }

            bg.setStyle(normalStyle);
            graphic.setElementHoverStyle(bg, emphasisStyle);
          }

          group.add(bg);
        }

        function renderContent(group, content) {
          // For tooltip.
          content.dataIndex = thisNode.dataIndex;
          content.seriesIndex = seriesModel.seriesIndex;
          var contentWidth = Math.max(thisWidth - 2 * borderWidth, 0);
          var contentHeight = Math.max(thisHeight - 2 * borderWidth, 0);
          content.culling = true;
          content.setShape({
            x: borderWidth,
            y: borderWidth,
            width: contentWidth,
            height: contentHeight
          });

          if (thisInvisible) {
            // If invisible, do not set visual, otherwise the element will
            // change immediately before animation. We think it is OK to
            // remain its origin color when moving out of the view window.
            processInvisible(content);
          } else {
            content.invisible = false;
            var visualColor = thisNode.getVisual('color', true);
            var normalStyle = getItemStyleNormal(itemStyleNormalModel);
            normalStyle.fill = visualColor;
            var emphasisStyle = getItemStyleEmphasis(itemStyleEmphasisModel);
            prepareText(normalStyle, emphasisStyle, visualColor, contentWidth, contentHeight);
            content.setStyle(normalStyle);
            graphic.setElementHoverStyle(content, emphasisStyle);
          }

          group.add(content);
        }

        function processInvisible(element) {
          // Delay invisible setting utill animation finished,
          // avoid element vanish suddenly before animation.
          !element.invisible && willInvisibleEls.push(element);
        }

        function prepareText(normalStyle, emphasisStyle, visualColor, width, height, upperLabelRect) {
          var defaultText = nodeModel.get('name');
          var normalLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL);
          var emphasisLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_EMPHASIS : PATH_LABEL_EMPHASIS);
          var isShow = normalLabelModel.getShallow('show');
          graphic.setLabelStyle(normalStyle, emphasisStyle, normalLabelModel, emphasisLabelModel, {
            defaultText: isShow ? defaultText : null,
            autoColor: visualColor,
            isRectText: true,
            labelFetcher: seriesModel,
            labelDataIndex: thisNode.dataIndex,
            labelProp: upperLabelRect ? 'upperLabel' : 'label'
          });
          addDrillDownIcon(normalStyle, upperLabelRect, thisLayout);
          addDrillDownIcon(emphasisStyle, upperLabelRect, thisLayout);
          upperLabelRect && (normalStyle.textRect = zrUtil.clone(upperLabelRect));
          normalStyle.truncate = isShow && normalLabelModel.get('ellipsis') ? {
            outerWidth: width,
            outerHeight: height,
            minChar: 2
          } : null;
        }

        function addDrillDownIcon(style, upperLabelRect, thisLayout) {
          var text = style.text;

          if (!upperLabelRect && thisLayout.isLeafRoot && text != null) {
            var iconChar = seriesModel.get('drillDownIcon', true);
            style.text = iconChar ? iconChar + ' ' + text : text;
          }
        }

        function giveGraphic(storageName, Ctor, depth, z) {
          var element = oldRawIndex != null && oldStorage[storageName][oldRawIndex];
          var lasts = lastsForAnimation[storageName];

          if (element) {
            // Remove from oldStorage
            oldStorage[storageName][oldRawIndex] = null;
            prepareAnimationWhenHasOld(lasts, element, storageName);
          } // If invisible and no old element, do not create new element (for optimizing).
          else if (!thisInvisible) {
            element = new Ctor({
              z: calculateZ(depth, z)
            });
            element.__tmDepth = depth;
            element.__tmStorageName = storageName;
            prepareAnimationWhenNoOld(lasts, element, storageName);
          } // Set to thisStorage


          return thisStorage[storageName][thisRawIndex] = element;
        }

        function prepareAnimationWhenHasOld(lasts, element, storageName) {
          var lastCfg = lasts[thisRawIndex] = {};
          lastCfg.old = storageName === 'nodeGroup' ? element.position.slice() : zrUtil.extend({}, element.shape);
        } // If a element is new, we need to find the animation start point carefully,
        // otherwise it will looks strange when 'zoomToNode'.


        function prepareAnimationWhenNoOld(lasts, element, storageName) {
          var lastCfg = lasts[thisRawIndex] = {};
          var parentNode = thisNode.parentNode;

          if (parentNode && (!reRoot || reRoot.direction === 'drillDown')) {
            var parentOldX = 0;
            var parentOldY = 0; // New nodes appear from right-bottom corner in 'zoomToNode' animation.
            // For convenience, get old bounding rect from background.

            var parentOldBg = lastsForAnimation.background[parentNode.getRawIndex()];

            if (!reRoot && parentOldBg && parentOldBg.old) {
              parentOldX = parentOldBg.old.width;
              parentOldY = parentOldBg.old.height;
            } // When no parent old shape found, its parent is new too,
            // so we can just use {x:0, y:0}.


            lastCfg.old = storageName === 'nodeGroup' ? [0, parentOldY] : {
              x: parentOldX,
              y: parentOldY,
              width: 0,
              height: 0
            };
          } // Fade in, user can be aware that these nodes are new.


          lastCfg.fadein = storageName !== 'nodeGroup';
        }
      } // We can not set all backgroud with the same z, Because the behaviour of
      // drill down and roll up differ background creation sequence from tree
      // hierarchy sequence, which cause that lowser background element overlap
      // upper ones. So we calculate z based on depth.
      // Moreover, we try to shrink down z interval to [0, 1] to avoid that
      // treemap with large z overlaps other components.


      function calculateZ(depth, zInLevel) {
        var zb = depth * Z_BASE + zInLevel;
        return (zb - 1) / zb;
      }

      module.exports = _default;
      /***/
    },

    /***/
    "sAZ8":
    /*!*********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/axis/ParallelAxisView.js ***!
      \*********************************************************************/

    /*! no static exports found */

    /***/
    function sAZ8(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var AxisBuilder = __webpack_require__(
      /*! ./AxisBuilder */
      "+rIm");

      var BrushController = __webpack_require__(
      /*! ../helper/BrushController */
      "/IIm");

      var brushHelper = __webpack_require__(
      /*! ../helper/brushHelper */
      "9KIM");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var elementList = ['axisLine', 'axisTickLabel', 'axisName'];
      var AxisView = echarts.extendComponentView({
        type: 'parallelAxis',

        /**
         * @override
         */
        init: function init(ecModel, api) {
          AxisView.superApply(this, 'init', arguments);
          /**
           * @type {module:echarts/component/helper/BrushController}
           */

          (this._brushController = new BrushController(api.getZr())).on('brush', zrUtil.bind(this._onBrush, this));
        },

        /**
         * @override
         */
        render: function render(axisModel, ecModel, api, payload) {
          if (fromAxisAreaSelect(axisModel, ecModel, payload)) {
            return;
          }

          this.axisModel = axisModel;
          this.api = api;
          this.group.removeAll();
          var oldAxisGroup = this._axisGroup;
          this._axisGroup = new graphic.Group();
          this.group.add(this._axisGroup);

          if (!axisModel.get('show')) {
            return;
          }

          var coordSysModel = getCoordSysModel(axisModel, ecModel);
          var coordSys = coordSysModel.coordinateSystem;
          var areaSelectStyle = axisModel.getAreaSelectStyle();
          var areaWidth = areaSelectStyle.width;
          var dim = axisModel.axis.dim;
          var axisLayout = coordSys.getAxisLayout(dim);
          var builderOpt = zrUtil.extend({
            strokeContainThreshold: areaWidth
          }, axisLayout);
          var axisBuilder = new AxisBuilder(axisModel, builderOpt);
          zrUtil.each(elementList, axisBuilder.add, axisBuilder);

          this._axisGroup.add(axisBuilder.getGroup());

          this._refreshBrushController(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api);

          var animationModel = payload && payload.animation === false ? null : axisModel;
          graphic.groupTransition(oldAxisGroup, this._axisGroup, animationModel);
        },
        // /**
        //  * @override
        //  */
        // updateVisual: function (axisModel, ecModel, api, payload) {
        //     this._brushController && this._brushController
        //         .updateCovers(getCoverInfoList(axisModel));
        // },
        _refreshBrushController: function _refreshBrushController(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api) {
          // After filtering, axis may change, select area needs to be update.
          var extent = axisModel.axis.getExtent();
          var extentLen = extent[1] - extent[0];
          var extra = Math.min(30, Math.abs(extentLen) * 0.1); // Arbitrary value.
          // width/height might be negative, which will be
          // normalized in BoundingRect.

          var rect = graphic.BoundingRect.create({
            x: extent[0],
            y: -areaWidth / 2,
            width: extentLen,
            height: areaWidth
          });
          rect.x -= extra;
          rect.width += 2 * extra;

          this._brushController.mount({
            enableGlobalPan: true,
            rotation: builderOpt.rotation,
            position: builderOpt.position
          }).setPanels([{
            panelId: 'pl',
            clipPath: brushHelper.makeRectPanelClipPath(rect),
            isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, coordSysModel),
            getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect, 0)
          }]).enableBrush({
            brushType: 'lineX',
            brushStyle: areaSelectStyle,
            removeOnClick: true
          }).updateCovers(getCoverInfoList(axisModel));
        },
        _onBrush: function _onBrush(coverInfoList, opt) {
          // Do not cache these object, because the mey be changed.
          var axisModel = this.axisModel;
          var axis = axisModel.axis;
          var intervals = zrUtil.map(coverInfoList, function (coverInfo) {
            return [axis.coordToData(coverInfo.range[0], true), axis.coordToData(coverInfo.range[1], true)];
          }); // If realtime is true, action is not dispatched on drag end, because
          // the drag end emits the same params with the last drag move event,
          // and may have some delay when using touch pad.

          if (!axisModel.option.realtime === opt.isEnd || opt.removeOnClick) {
            // jshint ignore:line
            this.api.dispatchAction({
              type: 'axisAreaSelect',
              parallelAxisId: axisModel.id,
              intervals: intervals
            });
          }
        },

        /**
         * @override
         */
        dispose: function dispose() {
          this._brushController.dispose();
        }
      });

      function fromAxisAreaSelect(axisModel, ecModel, payload) {
        return payload && payload.type === 'axisAreaSelect' && ecModel.findComponents({
          mainType: 'parallelAxis',
          query: payload
        })[0] === axisModel;
      }

      function getCoverInfoList(axisModel) {
        var axis = axisModel.axis;
        return zrUtil.map(axisModel.activeIntervals, function (interval) {
          return {
            brushType: 'lineX',
            panelId: 'pl',
            range: [axis.dataToCoord(interval[0], true), axis.dataToCoord(interval[1], true)]
          };
        });
      }

      function getCoordSysModel(axisModel, ecModel) {
        return ecModel.getComponent('parallel', axisModel.get('parallelIndex'));
      }

      var _default = AxisView;
      module.exports = _default;
      /***/
    },

    /***/
    "sK/D":
    /*!*****************************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js ***!
      \*****************************************************************************/

    /*! no static exports found */

    /***/
    function sKD(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var _number = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var round = _number.round;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      function createGridClipPath(cartesian, hasAnimation, seriesModel) {
        var rect = cartesian.getArea();
        var isHorizontal = cartesian.getBaseAxis().isHorizontal();
        var x = rect.x;
        var y = rect.y;
        var width = rect.width;
        var height = rect.height;
        var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand the clip path a bit to avoid the border is clipped and looks thinner

        x -= lineWidth / 2;
        y -= lineWidth / 2;
        width += lineWidth;
        height += lineWidth; // fix: https://github.com/apache/incubator-echarts/issues/11369

        x = Math.floor(x);
        width = Math.round(width);
        var clipPath = new graphic.Rect({
          shape: {
            x: x,
            y: y,
            width: width,
            height: height
          }
        });

        if (hasAnimation) {
          clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;
          graphic.initProps(clipPath, {
            shape: {
              width: width,
              height: height
            }
          }, seriesModel);
        }

        return clipPath;
      }

      function createPolarClipPath(polar, hasAnimation, seriesModel) {
        var sectorArea = polar.getArea(); // Avoid float number rounding error for symbol on the edge of axis extent.

        var clipPath = new graphic.Sector({
          shape: {
            cx: round(polar.cx, 1),
            cy: round(polar.cy, 1),
            r0: round(sectorArea.r0, 1),
            r: round(sectorArea.r, 1),
            startAngle: sectorArea.startAngle,
            endAngle: sectorArea.endAngle,
            clockwise: sectorArea.clockwise
          }
        });

        if (hasAnimation) {
          clipPath.shape.endAngle = sectorArea.startAngle;
          graphic.initProps(clipPath, {
            shape: {
              endAngle: sectorArea.endAngle
            }
          }, seriesModel);
        }

        return clipPath;
      }

      function createClipPath(coordSys, hasAnimation, seriesModel) {
        if (!coordSys) {
          return null;
        } else if (coordSys.type === 'polar') {
          return createPolarClipPath(coordSys, hasAnimation, seriesModel);
        } else if (coordSys.type === 'cartesian2d') {
          return createGridClipPath(coordSys, hasAnimation, seriesModel);
        }

        return null;
      }

      exports.createGridClipPath = createGridClipPath;
      exports.createPolarClipPath = createPolarClipPath;
      exports.createClipPath = createClipPath;
      /***/
    },

    /***/
    "sRwP":
    /*!*******************************************************!*\
      !*** ./node_modules/echarts/lib/component/toolbox.js ***!
      \*******************************************************/

    /*! no static exports found */

    /***/
    function sRwP(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      __webpack_require__(
      /*! ./toolbox/ToolboxModel */
      "jsU+");

      __webpack_require__(
      /*! ./toolbox/ToolboxView */
      "2548");

      __webpack_require__(
      /*! ./toolbox/feature/SaveAsImage */
      "Tp9H");

      __webpack_require__(
      /*! ./toolbox/feature/MagicType */
      "06DH");

      __webpack_require__(
      /*! ./toolbox/feature/DataView */
      "dnwI");

      __webpack_require__(
      /*! ./toolbox/feature/DataZoom */
      "fE02");

      __webpack_require__(
      /*! ./toolbox/feature/Restore */
      "33Ds");
      /***/

    },

    /***/
    "sW+o":
    /*!****************************************************************!*\
      !*** ./node_modules/zrender/lib/svg/helper/GradientManager.js ***!
      \****************************************************************/

    /*! no static exports found */

    /***/
    function sWO(module, exports, __webpack_require__) {
      var Definable = __webpack_require__(
      /*! ./Definable */
      "SrGk");

      var zrUtil = __webpack_require__(
      /*! ../../core/util */
      "bYtY");

      var logError = __webpack_require__(
      /*! ../../core/log */
      "SUKs");

      var colorTool = __webpack_require__(
      /*! ../../tool/color */
      "Qe9p");
      /**
       * @file Manages SVG gradient elements.
       * @author Zhang Wenli
       */

      /**
       * Manages SVG gradient elements.
       *
       * @class
       * @extends Definable
       * @param   {number}     zrId    zrender instance id
       * @param   {SVGElement} svgRoot root of SVG document
       */


      function GradientManager(zrId, svgRoot) {
        Definable.call(this, zrId, svgRoot, ['linearGradient', 'radialGradient'], '__gradient_in_use__');
      }

      zrUtil.inherits(GradientManager, Definable);
      /**
       * Create new gradient DOM for fill or stroke if not exist,
       * but will not update gradient if exists.
       *
       * @param {SvgElement}  svgElement   SVG element to paint
       * @param {Displayable} displayable  zrender displayable element
       */

      GradientManager.prototype.addWithoutUpdate = function (svgElement, displayable) {
        if (displayable && displayable.style) {
          var that = this;
          zrUtil.each(['fill', 'stroke'], function (fillOrStroke) {
            if (displayable.style[fillOrStroke] && (displayable.style[fillOrStroke].type === 'linear' || displayable.style[fillOrStroke].type === 'radial')) {
              var gradient = displayable.style[fillOrStroke];
              var defs = that.getDefs(true); // Create dom in <defs> if not exists

              var dom;

              if (gradient._dom) {
                // Gradient exists
                dom = gradient._dom;

                if (!defs.contains(gradient._dom)) {
                  // _dom is no longer in defs, recreate
                  that.addDom(dom);
                }
              } else {
                // New dom
                dom = that.add(gradient);
              }

              that.markUsed(displayable);
              var id = dom.getAttribute('id');
              svgElement.setAttribute(fillOrStroke, 'url(#' + id + ')');
            }
          });
        }
      };
      /**
       * Add a new gradient tag in <defs>
       *
       * @param   {Gradient} gradient zr gradient instance
       * @return {SVGLinearGradientElement | SVGRadialGradientElement}
       *                            created DOM
       */


      GradientManager.prototype.add = function (gradient) {
        var dom;

        if (gradient.type === 'linear') {
          dom = this.createElement('linearGradient');
        } else if (gradient.type === 'radial') {
          dom = this.createElement('radialGradient');
        } else {
          logError('Illegal gradient type.');
          return null;
        } // Set dom id with gradient id, since each gradient instance
        // will have no more than one dom element.
        // id may exists before for those dirty elements, in which case
        // id should remain the same, and other attributes should be
        // updated.


        gradient.id = gradient.id || this.nextId++;
        dom.setAttribute('id', 'zr' + this._zrId + '-gradient-' + gradient.id);
        this.updateDom(gradient, dom);
        this.addDom(dom);
        return dom;
      };
      /**
       * Update gradient.
       *
       * @param {Gradient} gradient zr gradient instance
       */


      GradientManager.prototype.update = function (gradient) {
        var that = this;
        Definable.prototype.update.call(this, gradient, function () {
          var type = gradient.type;
          var tagName = gradient._dom.tagName;

          if (type === 'linear' && tagName === 'linearGradient' || type === 'radial' && tagName === 'radialGradient') {
            // Gradient type is not changed, update gradient
            that.updateDom(gradient, gradient._dom);
          } else {
            // Remove and re-create if type is changed
            that.removeDom(gradient);
            that.add(gradient);
          }
        });
      };
      /**
       * Update gradient dom
       *
       * @param {Gradient} gradient zr gradient instance
       * @param {SVGLinearGradientElement | SVGRadialGradientElement} dom
       *                            DOM to update
       */


      GradientManager.prototype.updateDom = function (gradient, dom) {
        if (gradient.type === 'linear') {
          dom.setAttribute('x1', gradient.x);
          dom.setAttribute('y1', gradient.y);
          dom.setAttribute('x2', gradient.x2);
          dom.setAttribute('y2', gradient.y2);
        } else if (gradient.type === 'radial') {
          dom.setAttribute('cx', gradient.x);
          dom.setAttribute('cy', gradient.y);
          dom.setAttribute('r', gradient.r);
        } else {
          logError('Illegal gradient type.');
          return;
        }

        if (gradient.global) {
          // x1, x2, y1, y2 in range of 0 to canvas width or height
          dom.setAttribute('gradientUnits', 'userSpaceOnUse');
        } else {
          // x1, x2, y1, y2 in range of 0 to 1
          dom.setAttribute('gradientUnits', 'objectBoundingBox');
        } // Remove color stops if exists


        dom.innerHTML = ''; // Add color stops

        var colors = gradient.colorStops;

        for (var i = 0, len = colors.length; i < len; ++i) {
          var stop = this.createElement('stop');
          stop.setAttribute('offset', colors[i].offset * 100 + '%');
          var color = colors[i].color;

          if (color.indexOf('rgba') > -1) {
            // Fix Safari bug that stop-color not recognizing alpha #9014
            var opacity = colorTool.parse(color)[3];
            var hex = colorTool.toHex(color); // stop-color cannot be color, since:
            // The opacity value used for the gradient calculation is the
            // *product* of the value of stop-opacity and the opacity of the
            // value of stop-color.
            // See https://www.w3.org/TR/SVG2/pservers.html#StopOpacityProperty

            stop.setAttribute('stop-color', '#' + hex);
            stop.setAttribute('stop-opacity', opacity);
          } else {
            stop.setAttribute('stop-color', colors[i].color);
          }

          dom.appendChild(stop);
        } // Store dom element in gradient, to avoid creating multiple
        // dom instances for the same gradient element


        gradient._dom = dom;
      };
      /**
       * Mark a single gradient to be used
       *
       * @param {Displayable} displayable displayable element
       */


      GradientManager.prototype.markUsed = function (displayable) {
        if (displayable.style) {
          var gradient = displayable.style.fill;

          if (gradient && gradient._dom) {
            Definable.prototype.markUsed.call(this, gradient._dom);
          }

          gradient = displayable.style.stroke;

          if (gradient && gradient._dom) {
            Definable.prototype.markUsed.call(this, gradient._dom);
          }
        }
      };

      var _default = GradientManager;
      module.exports = _default;
      /***/
    },

    /***/
    "szbU":
    /*!**********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/visualMap/preprocessor.js ***!
      \**********************************************************************/

    /*! no static exports found */

    /***/
    function szbU(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var each = zrUtil.each;

      function _default(option) {
        var visualMap = option && option.visualMap;

        if (!zrUtil.isArray(visualMap)) {
          visualMap = visualMap ? [visualMap] : [];
        }

        each(visualMap, function (opt) {
          if (!opt) {
            return;
          } // rename splitList to pieces


          if (has(opt, 'splitList') && !has(opt, 'pieces')) {
            opt.pieces = opt.splitList;
            delete opt.splitList;
          }

          var pieces = opt.pieces;

          if (pieces && zrUtil.isArray(pieces)) {
            each(pieces, function (piece) {
              if (zrUtil.isObject(piece)) {
                if (has(piece, 'start') && !has(piece, 'min')) {
                  piece.min = piece.start;
                }

                if (has(piece, 'end') && !has(piece, 'max')) {
                  piece.max = piece.end;
                }
              }
            });
          }
        });
      }

      function has(obj, name) {
        return obj && obj.hasOwnProperty && obj.hasOwnProperty(name);
      }

      module.exports = _default;
      /***/
    },

    /***/
    "tBnm":
    /*!******************************************************************!*\
      !*** ./node_modules/echarts/lib/component/axis/AngleAxisView.js ***!
      \******************************************************************/

    /*! no static exports found */

    /***/
    function tBnm(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var Model = __webpack_require__(
      /*! ../../model/Model */
      "Qxkt");

      var AxisView = __webpack_require__(
      /*! ./AxisView */
      "Znkb");

      var AxisBuilder = __webpack_require__(
      /*! ./AxisBuilder */
      "+rIm");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var elementList = ['axisLine', 'axisLabel', 'axisTick', 'minorTick', 'splitLine', 'minorSplitLine', 'splitArea'];

      function getAxisLineShape(polar, rExtent, angle) {
        rExtent[1] > rExtent[0] && (rExtent = rExtent.slice().reverse());
        var start = polar.coordToPoint([rExtent[0], angle]);
        var end = polar.coordToPoint([rExtent[1], angle]);
        return {
          x1: start[0],
          y1: start[1],
          x2: end[0],
          y2: end[1]
        };
      }

      function getRadiusIdx(polar) {
        var radiusAxis = polar.getRadiusAxis();
        return radiusAxis.inverse ? 0 : 1;
      } // Remove the last tick which will overlap the first tick


      function fixAngleOverlap(list) {
        var firstItem = list[0];
        var lastItem = list[list.length - 1];

        if (firstItem && lastItem && Math.abs(Math.abs(firstItem.coord - lastItem.coord) - 360) < 1e-4) {
          list.pop();
        }
      }

      var _default = AxisView.extend({
        type: 'angleAxis',
        axisPointerClass: 'PolarAxisPointer',
        render: function render(angleAxisModel, ecModel) {
          this.group.removeAll();

          if (!angleAxisModel.get('show')) {
            return;
          }

          var angleAxis = angleAxisModel.axis;
          var polar = angleAxis.polar;
          var radiusExtent = polar.getRadiusAxis().getExtent();
          var ticksAngles = angleAxis.getTicksCoords();
          var minorTickAngles = angleAxis.getMinorTicksCoords();
          var labels = zrUtil.map(angleAxis.getViewLabels(), function (labelItem) {
            var labelItem = zrUtil.clone(labelItem);
            labelItem.coord = angleAxis.dataToCoord(labelItem.tickValue);
            return labelItem;
          });
          fixAngleOverlap(labels);
          fixAngleOverlap(ticksAngles);
          zrUtil.each(elementList, function (name) {
            if (angleAxisModel.get(name + '.show') && (!angleAxis.scale.isBlank() || name === 'axisLine')) {
              this['_' + name](angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels);
            }
          }, this);
        },

        /**
         * @private
         */
        _axisLine: function _axisLine(angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
          var lineStyleModel = angleAxisModel.getModel('axisLine.lineStyle'); // extent id of the axis radius (r0 and r)

          var rId = getRadiusIdx(polar);
          var r0Id = rId ? 0 : 1;
          var shape;

          if (radiusExtent[r0Id] === 0) {
            shape = new graphic.Circle({
              shape: {
                cx: polar.cx,
                cy: polar.cy,
                r: radiusExtent[rId]
              },
              style: lineStyleModel.getLineStyle(),
              z2: 1,
              silent: true
            });
          } else {
            shape = new graphic.Ring({
              shape: {
                cx: polar.cx,
                cy: polar.cy,
                r: radiusExtent[rId],
                r0: radiusExtent[r0Id]
              },
              style: lineStyleModel.getLineStyle(),
              z2: 1,
              silent: true
            });
          }

          shape.style.fill = null;
          this.group.add(shape);
        },

        /**
         * @private
         */
        _axisTick: function _axisTick(angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
          var tickModel = angleAxisModel.getModel('axisTick');
          var tickLen = (tickModel.get('inside') ? -1 : 1) * tickModel.get('length');
          var radius = radiusExtent[getRadiusIdx(polar)];
          var lines = zrUtil.map(ticksAngles, function (tickAngleItem) {
            return new graphic.Line({
              shape: getAxisLineShape(polar, [radius, radius + tickLen], tickAngleItem.coord)
            });
          });
          this.group.add(graphic.mergePath(lines, {
            style: zrUtil.defaults(tickModel.getModel('lineStyle').getLineStyle(), {
              stroke: angleAxisModel.get('axisLine.lineStyle.color')
            })
          }));
        },

        /**
         * @private
         */
        _minorTick: function _minorTick(angleAxisModel, polar, tickAngles, minorTickAngles, radiusExtent) {
          if (!minorTickAngles.length) {
            return;
          }

          var tickModel = angleAxisModel.getModel('axisTick');
          var minorTickModel = angleAxisModel.getModel('minorTick');
          var tickLen = (tickModel.get('inside') ? -1 : 1) * minorTickModel.get('length');
          var radius = radiusExtent[getRadiusIdx(polar)];
          var lines = [];

          for (var i = 0; i < minorTickAngles.length; i++) {
            for (var k = 0; k < minorTickAngles[i].length; k++) {
              lines.push(new graphic.Line({
                shape: getAxisLineShape(polar, [radius, radius + tickLen], minorTickAngles[i][k].coord)
              }));
            }
          }

          this.group.add(graphic.mergePath(lines, {
            style: zrUtil.defaults(minorTickModel.getModel('lineStyle').getLineStyle(), zrUtil.defaults(tickModel.getLineStyle(), {
              stroke: angleAxisModel.get('axisLine.lineStyle.color')
            }))
          }));
        },

        /**
         * @private
         */
        _axisLabel: function _axisLabel(angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels) {
          var rawCategoryData = angleAxisModel.getCategories(true);
          var commonLabelModel = angleAxisModel.getModel('axisLabel');
          var labelMargin = commonLabelModel.get('margin');
          var triggerEvent = angleAxisModel.get('triggerEvent'); // Use length of ticksAngles because it may remove the last tick to avoid overlapping

          zrUtil.each(labels, function (labelItem, idx) {
            var labelModel = commonLabelModel;
            var tickValue = labelItem.tickValue;
            var r = radiusExtent[getRadiusIdx(polar)];
            var p = polar.coordToPoint([r + labelMargin, labelItem.coord]);
            var cx = polar.cx;
            var cy = polar.cy;
            var labelTextAlign = Math.abs(p[0] - cx) / r < 0.3 ? 'center' : p[0] > cx ? 'left' : 'right';
            var labelTextVerticalAlign = Math.abs(p[1] - cy) / r < 0.3 ? 'middle' : p[1] > cy ? 'top' : 'bottom';

            if (rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle) {
              labelModel = new Model(rawCategoryData[tickValue].textStyle, commonLabelModel, commonLabelModel.ecModel);
            }

            var textEl = new graphic.Text({
              silent: AxisBuilder.isLabelSilent(angleAxisModel)
            });
            this.group.add(textEl);
            graphic.setTextStyle(textEl.style, labelModel, {
              x: p[0],
              y: p[1],
              textFill: labelModel.getTextColor() || angleAxisModel.get('axisLine.lineStyle.color'),
              text: labelItem.formattedLabel,
              textAlign: labelTextAlign,
              textVerticalAlign: labelTextVerticalAlign
            }); // Pack data for mouse event

            if (triggerEvent) {
              textEl.eventData = AxisBuilder.makeAxisEventDataBase(angleAxisModel);
              textEl.eventData.targetType = 'axisLabel';
              textEl.eventData.value = labelItem.rawLabel;
            }
          }, this);
        },

        /**
         * @private
         */
        _splitLine: function _splitLine(angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
          var splitLineModel = angleAxisModel.getModel('splitLine');
          var lineStyleModel = splitLineModel.getModel('lineStyle');
          var lineColors = lineStyleModel.get('color');
          var lineCount = 0;
          lineColors = lineColors instanceof Array ? lineColors : [lineColors];
          var splitLines = [];

          for (var i = 0; i < ticksAngles.length; i++) {
            var colorIndex = lineCount++ % lineColors.length;
            splitLines[colorIndex] = splitLines[colorIndex] || [];
            splitLines[colorIndex].push(new graphic.Line({
              shape: getAxisLineShape(polar, radiusExtent, ticksAngles[i].coord)
            }));
          } // Simple optimization
          // Batching the lines if color are the same


          for (var i = 0; i < splitLines.length; i++) {
            this.group.add(graphic.mergePath(splitLines[i], {
              style: zrUtil.defaults({
                stroke: lineColors[i % lineColors.length]
              }, lineStyleModel.getLineStyle()),
              silent: true,
              z: angleAxisModel.get('z')
            }));
          }
        },

        /**
         * @private
         */
        _minorSplitLine: function _minorSplitLine(angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
          if (!minorTickAngles.length) {
            return;
          }

          var minorSplitLineModel = angleAxisModel.getModel('minorSplitLine');
          var lineStyleModel = minorSplitLineModel.getModel('lineStyle');
          var lines = [];

          for (var i = 0; i < minorTickAngles.length; i++) {
            for (var k = 0; k < minorTickAngles[i].length; k++) {
              lines.push(new graphic.Line({
                shape: getAxisLineShape(polar, radiusExtent, minorTickAngles[i][k].coord)
              }));
            }
          }

          this.group.add(graphic.mergePath(lines, {
            style: lineStyleModel.getLineStyle(),
            silent: true,
            z: angleAxisModel.get('z')
          }));
        },

        /**
         * @private
         */
        _splitArea: function _splitArea(angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
          if (!ticksAngles.length) {
            return;
          }

          var splitAreaModel = angleAxisModel.getModel('splitArea');
          var areaStyleModel = splitAreaModel.getModel('areaStyle');
          var areaColors = areaStyleModel.get('color');
          var lineCount = 0;
          areaColors = areaColors instanceof Array ? areaColors : [areaColors];
          var splitAreas = [];
          var RADIAN = Math.PI / 180;
          var prevAngle = -ticksAngles[0].coord * RADIAN;
          var r0 = Math.min(radiusExtent[0], radiusExtent[1]);
          var r1 = Math.max(radiusExtent[0], radiusExtent[1]);
          var clockwise = angleAxisModel.get('clockwise');

          for (var i = 1; i < ticksAngles.length; i++) {
            var colorIndex = lineCount++ % areaColors.length;
            splitAreas[colorIndex] = splitAreas[colorIndex] || [];
            splitAreas[colorIndex].push(new graphic.Sector({
              shape: {
                cx: polar.cx,
                cy: polar.cy,
                r0: r0,
                r: r1,
                startAngle: prevAngle,
                endAngle: -ticksAngles[i].coord * RADIAN,
                clockwise: clockwise
              },
              silent: true
            }));
            prevAngle = -ticksAngles[i].coord * RADIAN;
          } // Simple optimization
          // Batching the lines if color are the same


          for (var i = 0; i < splitAreas.length; i++) {
            this.group.add(graphic.mergePath(splitAreas[i], {
              style: zrUtil.defaults({
                fill: areaColors[i % areaColors.length]
              }, areaStyleModel.getAreaStyle()),
              silent: true
            }));
          }
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "tceW":
    /*!************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/bar/barItemStyle.js ***!
      \************************************************************/

    /*! no static exports found */

    /***/
    function tceW(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var makeStyleMapper = __webpack_require__(
      /*! ../../model/mixin/makeStyleMapper */
      "KCsZ");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _getBarItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], // Compatitable with 2
      ['stroke', 'barBorderColor'], ['lineWidth', 'barBorderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);

      var _default = {
        getBarItemStyle: function getBarItemStyle(excludes) {
          var style = _getBarItemStyle(this, excludes);

          if (this.getBorderLineDash) {
            var lineDash = this.getBorderLineDash();
            lineDash && (style.lineDash = lineDash);
          }

          return style;
        }
      };
      module.exports = _default;
      /***/
    },

    /***/
    "u3DP":
    /*!***********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/pie/labelLayout.js ***!
      \***********************************************************/

    /*! no static exports found */

    /***/
    function u3DP(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var textContain = __webpack_require__(
      /*! zrender/lib/contain/text */
      "6GrX");

      var _number = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var parsePercent = _number.parsePercent;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // FIXME emphasis label position is not same with normal label position

      var RADIAN = Math.PI / 180;

      function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {
        list.sort(function (a, b) {
          return a.y - b.y;
        });

        function shiftDown(start, end, delta, dir) {
          for (var j = start; j < end; j++) {
            if (list[j].y + delta > viewTop + viewHeight) {
              break;
            }

            list[j].y += delta;

            if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {
              shiftUp(j, delta / 2);
              return;
            }
          }

          shiftUp(end - 1, delta / 2);
        }

        function shiftUp(end, delta) {
          for (var j = end; j >= 0; j--) {
            if (list[j].y - delta < viewTop) {
              break;
            }

            list[j].y -= delta;

            if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {
              break;
            }
          }
        }

        function changeX(list, isDownList, cx, cy, r, dir) {
          var lastDeltaX = dir > 0 ? isDownList // right-side
          ? Number.MAX_VALUE // down
          : 0 // up
          : isDownList // left-side
          ? Number.MAX_VALUE // down
          : 0; // up

          for (var i = 0, l = list.length; i < l; i++) {
            if (list[i].labelAlignTo !== 'none') {
              continue;
            }

            var deltaY = Math.abs(list[i].y - cy);
            var length = list[i].len;
            var length2 = list[i].len2;
            var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);

            if (isDownList && deltaX >= lastDeltaX) {
              // right-down, left-down
              deltaX = lastDeltaX - 10;
            }

            if (!isDownList && deltaX <= lastDeltaX) {
              // right-up, left-up
              deltaX = lastDeltaX + 10;
            }

            list[i].x = cx + deltaX * dir;
            lastDeltaX = deltaX;
          }
        }

        var lastY = 0;
        var delta;
        var len = list.length;
        var upList = [];
        var downList = [];

        for (var i = 0; i < len; i++) {
          if (list[i].position === 'outer' && list[i].labelAlignTo === 'labelLine') {
            var dx = list[i].x - farthestX;
            list[i].linePoints[1][0] += dx;
            list[i].x = farthestX;
          }

          delta = list[i].y - lastY;

          if (delta < 0) {
            shiftDown(i, len, -delta, dir);
          }

          lastY = list[i].y + list[i].height;
        }

        if (viewHeight - lastY < 0) {
          shiftUp(len - 1, lastY - viewHeight);
        }

        for (var i = 0; i < len; i++) {
          if (list[i].y >= cy) {
            downList.push(list[i]);
          } else {
            upList.push(list[i]);
          }
        }

        changeX(upList, false, cx, cy, r, dir);
        changeX(downList, true, cx, cy, r, dir);
      }

      function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {
        var leftList = [];
        var rightList = [];
        var leftmostX = Number.MAX_VALUE;
        var rightmostX = -Number.MAX_VALUE;

        for (var i = 0; i < labelLayoutList.length; i++) {
          if (isPositionCenter(labelLayoutList[i])) {
            continue;
          }

          if (labelLayoutList[i].x < cx) {
            leftmostX = Math.min(leftmostX, labelLayoutList[i].x);
            leftList.push(labelLayoutList[i]);
          } else {
            rightmostX = Math.max(rightmostX, labelLayoutList[i].x);
            rightList.push(labelLayoutList[i]);
          }
        }

        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);
        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);

        for (var i = 0; i < labelLayoutList.length; i++) {
          var layout = labelLayoutList[i];

          if (isPositionCenter(layout)) {
            continue;
          }

          var linePoints = layout.linePoints;

          if (linePoints) {
            var isAlignToEdge = layout.labelAlignTo === 'edge';
            var realTextWidth = layout.textRect.width;
            var targetTextWidth;

            if (isAlignToEdge) {
              if (layout.x < cx) {
                targetTextWidth = linePoints[2][0] - layout.labelDistance - viewLeft - layout.labelMargin;
              } else {
                targetTextWidth = viewLeft + viewWidth - layout.labelMargin - linePoints[2][0] - layout.labelDistance;
              }
            } else {
              if (layout.x < cx) {
                targetTextWidth = layout.x - viewLeft - layout.bleedMargin;
              } else {
                targetTextWidth = viewLeft + viewWidth - layout.x - layout.bleedMargin;
              }
            }

            if (targetTextWidth < layout.textRect.width) {
              layout.text = textContain.truncateText(layout.text, targetTextWidth, layout.font);

              if (layout.labelAlignTo === 'edge') {
                realTextWidth = textContain.getWidth(layout.text, layout.font);
              }
            }

            var dist = linePoints[1][0] - linePoints[2][0];

            if (isAlignToEdge) {
              if (layout.x < cx) {
                linePoints[2][0] = viewLeft + layout.labelMargin + realTextWidth + layout.labelDistance;
              } else {
                linePoints[2][0] = viewLeft + viewWidth - layout.labelMargin - realTextWidth - layout.labelDistance;
              }
            } else {
              if (layout.x < cx) {
                linePoints[2][0] = layout.x + layout.labelDistance;
              } else {
                linePoints[2][0] = layout.x - layout.labelDistance;
              }

              linePoints[1][0] = linePoints[2][0] + dist;
            }

            linePoints[1][1] = linePoints[2][1] = layout.y;
          }
        }
      }

      function isPositionCenter(layout) {
        // Not change x for center label
        return layout.position === 'center';
      }

      function _default(seriesModel, r, viewWidth, viewHeight, viewLeft, viewTop) {
        var data = seriesModel.getData();
        var labelLayoutList = [];
        var cx;
        var cy;
        var hasLabelRotate = false;
        var minShowLabelRadian = (seriesModel.get('minShowLabelAngle') || 0) * RADIAN;
        data.each(function (idx) {
          var layout = data.getItemLayout(idx);
          var itemModel = data.getItemModel(idx);
          var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis

          var labelPosition = labelModel.get('position') || itemModel.get('emphasis.label.position');
          var labelDistance = labelModel.get('distanceToLabelLine');
          var labelAlignTo = labelModel.get('alignTo');
          var labelMargin = parsePercent(labelModel.get('margin'), viewWidth);
          var bleedMargin = labelModel.get('bleedMargin');
          var font = labelModel.getFont();
          var labelLineModel = itemModel.getModel('labelLine');
          var labelLineLen = labelLineModel.get('length');
          labelLineLen = parsePercent(labelLineLen, viewWidth);
          var labelLineLen2 = labelLineModel.get('length2');
          labelLineLen2 = parsePercent(labelLineLen2, viewWidth);

          if (layout.angle < minShowLabelRadian) {
            return;
          }

          var midAngle = (layout.startAngle + layout.endAngle) / 2;
          var dx = Math.cos(midAngle);
          var dy = Math.sin(midAngle);
          var textX;
          var textY;
          var linePoints;
          var textAlign;
          cx = layout.cx;
          cy = layout.cy;
          var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);
          var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');
          var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';

          if (labelPosition === 'center') {
            textX = layout.cx;
            textY = layout.cy;
            textAlign = 'center';
          } else {
            var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;
            var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;
            textX = x1 + dx * 3;
            textY = y1 + dy * 3;

            if (!isLabelInside) {
              // For roseType
              var x2 = x1 + dx * (labelLineLen + r - layout.r);
              var y2 = y1 + dy * (labelLineLen + r - layout.r);
              var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;
              var y3 = y2;

              if (labelAlignTo === 'edge') {
                // Adjust textX because text align of edge is opposite
                textX = dx < 0 ? viewLeft + labelMargin : viewLeft + viewWidth - labelMargin;
              } else {
                textX = x3 + (dx < 0 ? -labelDistance : labelDistance);
              }

              textY = y3;
              linePoints = [[x1, y1], [x2, y2], [x3, y3]];
            }

            textAlign = isLabelInside ? 'center' : labelAlignTo === 'edge' ? dx > 0 ? 'right' : 'left' : dx > 0 ? 'left' : 'right';
          }

          var labelRotate;
          var rotate = labelModel.get('rotate');

          if (typeof rotate === 'number') {
            labelRotate = rotate * (Math.PI / 180);
          } else {
            labelRotate = rotate ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;
          }

          hasLabelRotate = !!labelRotate;
          layout.label = {
            x: textX,
            y: textY,
            position: labelPosition,
            height: textRect.height,
            len: labelLineLen,
            len2: labelLineLen2,
            linePoints: linePoints,
            textAlign: textAlign,
            verticalAlign: 'middle',
            rotation: labelRotate,
            inside: isLabelInside,
            labelDistance: labelDistance,
            labelAlignTo: labelAlignTo,
            labelMargin: labelMargin,
            bleedMargin: bleedMargin,
            textRect: textRect,
            text: text,
            font: font
          }; // Not layout the inside label

          if (!isLabelInside) {
            labelLayoutList.push(layout.label);
          }
        });

        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {
          avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);
        }
      }

      module.exports = _default;
      /***/
    },

    /***/
    "uOyE":
    /*!*****************************************************************!*\
      !*** ./node_modules/echarts/lib/component/brush/brushAction.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function uOyE(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * payload: {
       *      brushIndex: number, or,
       *      brushId: string, or,
       *      brushName: string,
       *      globalRanges: Array
       * }
       */


      echarts.registerAction({
        type: 'brush',
        event: 'brush'
        /*, update: 'updateView' */

      }, function (payload, ecModel) {
        ecModel.eachComponent({
          mainType: 'brush',
          query: payload
        }, function (brushModel) {
          brushModel.setAreas(payload.areas);
        });
      });
      /**
       * payload: {
       *      brushComponents: [
       *          {
       *              brushId,
       *              brushIndex,
       *              brushName,
       *              series: [
       *                  {
       *                      seriesId,
       *                      seriesIndex,
       *                      seriesName,
       *                      rawIndices: [21, 34, ...]
       *                  },
       *                  ...
       *              ]
       *          },
       *          ...
       *      ]
       * }
       */

      echarts.registerAction({
        type: 'brushSelect',
        event: 'brushSelected',
        update: 'none'
      }, function () {});
      echarts.registerAction({
        type: 'brushEnd',
        event: 'brushEnd',
        update: 'none'
      }, function () {});
      /***/
    },

    /***/
    "v5uJ":
    /*!***********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/tree/treeAction.js ***!
      \***********************************************************/

    /*! no static exports found */

    /***/
    function v5uJ(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var _roamHelper = __webpack_require__(
      /*! ../../action/roamHelper */
      "2B6p");

      var updateCenterAndZoom = _roamHelper.updateCenterAndZoom;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      echarts.registerAction({
        type: 'treeExpandAndCollapse',
        event: 'treeExpandAndCollapse',
        update: 'update'
      }, function (payload, ecModel) {
        ecModel.eachComponent({
          mainType: 'series',
          subType: 'tree',
          query: payload
        }, function (seriesModel) {
          var dataIndex = payload.dataIndex;
          var tree = seriesModel.getData().tree;
          var node = tree.getNodeByDataIndex(dataIndex);
          node.isExpand = !node.isExpand;
        });
      });
      echarts.registerAction({
        type: 'treeRoam',
        event: 'treeRoam',
        // Here we set 'none' instead of 'update', because roam action
        // just need to update the transform matrix without having to recalculate
        // the layout. So don't need to go through the whole update process, such
        // as 'dataPrcocess', 'coordSystemUpdate', 'layout' and so on.
        update: 'none'
      }, function (payload, ecModel) {
        ecModel.eachComponent({
          mainType: 'series',
          subType: 'tree',
          query: payload
        }, function (seriesModel) {
          var coordSys = seriesModel.coordinateSystem;
          var res = updateCenterAndZoom(coordSys, payload);
          seriesModel.setCenter && seriesModel.setCenter(res.center);
          seriesModel.setZoom && seriesModel.setZoom(res.zoom);
        });
      });
      /***/
    },

    /***/
    "vF/C":
    /*!***********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/visualMap/typeDefaulter.js ***!
      \***********************************************************************/

    /*! no static exports found */

    /***/
    function vFC(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var Component = __webpack_require__(
      /*! ../../model/Component */
      "bLfw");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      Component.registerSubTypeDefaulter('visualMap', function (option) {
        // Compatible with ec2, when splitNumber === 0, continuous visualMap will be used.
        return !option.categories && (!(option.pieces ? option.pieces.length > 0 : option.splitNumber > 0) || option.calculable) ? 'continuous' : 'piecewise';
      });
      /***/
    },

    /***/
    "vKoX":
    /*!**************************************************************!*\
      !*** ./node_modules/zrender/lib/svg/helper/ShadowManager.js ***!
      \**************************************************************/

    /*! no static exports found */

    /***/
    function vKoX(module, exports, __webpack_require__) {
      var Definable = __webpack_require__(
      /*! ./Definable */
      "SrGk");

      var zrUtil = __webpack_require__(
      /*! ../../core/util */
      "bYtY");
      /**
       * @file Manages SVG shadow elements.
       * @author Zhang Wenli
       */

      /**
       * Manages SVG shadow elements.
       *
       * @class
       * @extends Definable
       * @param   {number}     zrId    zrender instance id
       * @param   {SVGElement} svgRoot root of SVG document
       */


      function ShadowManager(zrId, svgRoot) {
        Definable.call(this, zrId, svgRoot, ['filter'], '__filter_in_use__', '_shadowDom');
      }

      zrUtil.inherits(ShadowManager, Definable);
      /**
       * Create new shadow DOM for fill or stroke if not exist,
       * but will not update shadow if exists.
       *
       * @param {SvgElement}  svgElement   SVG element to paint
       * @param {Displayable} displayable  zrender displayable element
       */

      ShadowManager.prototype.addWithoutUpdate = function (svgElement, displayable) {
        if (displayable && hasShadow(displayable.style)) {
          // Create dom in <defs> if not exists
          var dom;

          if (displayable._shadowDom) {
            // Gradient exists
            dom = displayable._shadowDom;
            var defs = this.getDefs(true);

            if (!defs.contains(displayable._shadowDom)) {
              // _shadowDom is no longer in defs, recreate
              this.addDom(dom);
            }
          } else {
            // New dom
            dom = this.add(displayable);
          }

          this.markUsed(displayable);
          var id = dom.getAttribute('id');
          svgElement.style.filter = 'url(#' + id + ')';
        }
      };
      /**
       * Add a new shadow tag in <defs>
       *
       * @param {Displayable} displayable  zrender displayable element
       * @return {SVGFilterElement} created DOM
       */


      ShadowManager.prototype.add = function (displayable) {
        var dom = this.createElement('filter'); // Set dom id with shadow id, since each shadow instance
        // will have no more than one dom element.
        // id may exists before for those dirty elements, in which case
        // id should remain the same, and other attributes should be
        // updated.

        displayable._shadowDomId = displayable._shadowDomId || this.nextId++;
        dom.setAttribute('id', 'zr' + this._zrId + '-shadow-' + displayable._shadowDomId);
        this.updateDom(displayable, dom);
        this.addDom(dom);
        return dom;
      };
      /**
       * Update shadow.
       *
       * @param {Displayable} displayable  zrender displayable element
       */


      ShadowManager.prototype.update = function (svgElement, displayable) {
        var style = displayable.style;

        if (hasShadow(style)) {
          var that = this;
          Definable.prototype.update.call(this, displayable, function () {
            that.updateDom(displayable, displayable._shadowDom);
          });
        } else {
          // Remove shadow
          this.remove(svgElement, displayable);
        }
      };
      /**
       * Remove DOM and clear parent filter
       */


      ShadowManager.prototype.remove = function (svgElement, displayable) {
        if (displayable._shadowDomId != null) {
          this.removeDom(svgElement);
          svgElement.style.filter = '';
        }
      };
      /**
       * Update shadow dom
       *
       * @param {Displayable} displayable  zrender displayable element
       * @param {SVGFilterElement} dom DOM to update
       */


      ShadowManager.prototype.updateDom = function (displayable, dom) {
        var domChild = dom.getElementsByTagName('feDropShadow');

        if (domChild.length === 0) {
          domChild = this.createElement('feDropShadow');
        } else {
          domChild = domChild[0];
        }

        var style = displayable.style;
        var scaleX = displayable.scale ? displayable.scale[0] || 1 : 1;
        var scaleY = displayable.scale ? displayable.scale[1] || 1 : 1; // TODO: textBoxShadowBlur is not supported yet

        var offsetX;
        var offsetY;
        var blur;
        var color;

        if (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY) {
          offsetX = style.shadowOffsetX || 0;
          offsetY = style.shadowOffsetY || 0;
          blur = style.shadowBlur;
          color = style.shadowColor;
        } else if (style.textShadowBlur) {
          offsetX = style.textShadowOffsetX || 0;
          offsetY = style.textShadowOffsetY || 0;
          blur = style.textShadowBlur;
          color = style.textShadowColor;
        } else {
          // Remove shadow
          this.removeDom(dom, style);
          return;
        }

        domChild.setAttribute('dx', offsetX / scaleX);
        domChild.setAttribute('dy', offsetY / scaleY);
        domChild.setAttribute('flood-color', color); // Divide by two here so that it looks the same as in canvas
        // See: https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-shadowblur

        var stdDx = blur / 2 / scaleX;
        var stdDy = blur / 2 / scaleY;
        var stdDeviation = stdDx + ' ' + stdDy;
        domChild.setAttribute('stdDeviation', stdDeviation); // Fix filter clipping problem

        dom.setAttribute('x', '-100%');
        dom.setAttribute('y', '-100%');
        dom.setAttribute('width', Math.ceil(blur / 2 * 200) + '%');
        dom.setAttribute('height', Math.ceil(blur / 2 * 200) + '%');
        dom.appendChild(domChild); // Store dom element in shadow, to avoid creating multiple
        // dom instances for the same shadow element

        displayable._shadowDom = dom;
      };
      /**
       * Mark a single shadow to be used
       *
       * @param {Displayable} displayable displayable element
       */


      ShadowManager.prototype.markUsed = function (displayable) {
        if (displayable._shadowDom) {
          Definable.prototype.markUsed.call(this, displayable._shadowDom);
        }
      };

      function hasShadow(style) {
        // TODO: textBoxShadowBlur is not supported yet
        return style && (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY || style.textShadowBlur || style.textShadowOffsetX || style.textShadowOffsetY);
      }

      var _default = ShadowManager;
      module.exports = _default;
      /***/
    },

    /***/
    "vL6D":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/component/axis/SingleAxisView.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function vL6D(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var AxisBuilder = __webpack_require__(
      /*! ./AxisBuilder */
      "+rIm");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var singleAxisHelper = __webpack_require__(
      /*! ../../coord/single/singleAxisHelper */
      "7bkD");

      var AxisView = __webpack_require__(
      /*! ./AxisView */
      "Znkb");

      var _axisSplitHelper = __webpack_require__(
      /*! ./axisSplitHelper */
      "WN+l");

      var rectCoordAxisBuildSplitArea = _axisSplitHelper.rectCoordAxisBuildSplitArea;
      var rectCoordAxisHandleRemove = _axisSplitHelper.rectCoordAxisHandleRemove;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];
      var selfBuilderAttrs = ['splitArea', 'splitLine'];
      var SingleAxisView = AxisView.extend({
        type: 'singleAxis',
        axisPointerClass: 'SingleAxisPointer',
        render: function render(axisModel, ecModel, api, payload) {
          var group = this.group;
          group.removeAll();
          var oldAxisGroup = this._axisGroup;
          this._axisGroup = new graphic.Group();
          var layout = singleAxisHelper.layout(axisModel);
          var axisBuilder = new AxisBuilder(axisModel, layout);
          zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
          group.add(this._axisGroup);
          group.add(axisBuilder.getGroup());
          zrUtil.each(selfBuilderAttrs, function (name) {
            if (axisModel.get(name + '.show')) {
              this['_' + name](axisModel);
            }
          }, this);
          graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);
          SingleAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);
        },
        remove: function remove() {
          rectCoordAxisHandleRemove(this);
        },
        _splitLine: function _splitLine(axisModel) {
          var axis = axisModel.axis;

          if (axis.scale.isBlank()) {
            return;
          }

          var splitLineModel = axisModel.getModel('splitLine');
          var lineStyleModel = splitLineModel.getModel('lineStyle');
          var lineWidth = lineStyleModel.get('width');
          var lineColors = lineStyleModel.get('color');
          lineColors = lineColors instanceof Array ? lineColors : [lineColors];
          var gridRect = axisModel.coordinateSystem.getRect();
          var isHorizontal = axis.isHorizontal();
          var splitLines = [];
          var lineCount = 0;
          var ticksCoords = axis.getTicksCoords({
            tickModel: splitLineModel
          });
          var p1 = [];
          var p2 = [];

          for (var i = 0; i < ticksCoords.length; ++i) {
            var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);

            if (isHorizontal) {
              p1[0] = tickCoord;
              p1[1] = gridRect.y;
              p2[0] = tickCoord;
              p2[1] = gridRect.y + gridRect.height;
            } else {
              p1[0] = gridRect.x;
              p1[1] = tickCoord;
              p2[0] = gridRect.x + gridRect.width;
              p2[1] = tickCoord;
            }

            var colorIndex = lineCount++ % lineColors.length;
            splitLines[colorIndex] = splitLines[colorIndex] || [];
            splitLines[colorIndex].push(new graphic.Line({
              subPixelOptimize: true,
              shape: {
                x1: p1[0],
                y1: p1[1],
                x2: p2[0],
                y2: p2[1]
              },
              style: {
                lineWidth: lineWidth
              },
              silent: true
            }));
          }

          for (var i = 0; i < splitLines.length; ++i) {
            this.group.add(graphic.mergePath(splitLines[i], {
              style: {
                stroke: lineColors[i % lineColors.length],
                lineDash: lineStyleModel.getLineDash(lineWidth),
                lineWidth: lineWidth
              },
              silent: true
            }));
          }
        },
        _splitArea: function _splitArea(axisModel) {
          rectCoordAxisBuildSplitArea(this, this._axisGroup, axisModel, axisModel);
        }
      });
      var _default = SingleAxisView;
      module.exports = _default;
      /***/
    },

    /***/
    "vZ6x":
    /*!*************************************************************************!*\
      !*** ./node_modules/echarts/lib/component/helper/BrushTargetManager.js ***!
      \*************************************************************************/

    /*! no static exports found */

    /***/
    function vZ6x(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _config = __webpack_require__(
      /*! ../../config */
      "Tghj");

      var __DEV__ = _config.__DEV__;

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var modelUtil = __webpack_require__(
      /*! ../../util/model */
      "4NO4");

      var brushHelper = __webpack_require__(
      /*! ./brushHelper */
      "9KIM");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var each = zrUtil.each;
      var indexOf = zrUtil.indexOf;
      var curry = zrUtil.curry;
      var COORD_CONVERTS = ['dataToPoint', 'pointToData']; // FIXME
      // how to genarialize to more coordinate systems.

      var INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];
      /**
       * [option in constructor]:
       * {
       *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.
       * }
       *
       *
       * [targetInfo]:
       *
       * There can be multiple axes in a single targetInfo. Consider the case
       * of `grid` component, a targetInfo represents a grid which contains one or more
       * cartesian and one or more axes. And consider the case of parallel system,
       * which has multiple axes in a coordinate system.
       * Can be {
       *     panelId: ...,
       *     coordSys: <a representitive cartesian in grid (first cartesian by default)>,
       *     coordSyses: all cartesians.
       *     gridModel: <grid component>
       *     xAxes: correspond to coordSyses on index
       *     yAxes: correspond to coordSyses on index
       * }
       * or {
       *     panelId: ...,
       *     coordSys: <geo coord sys>
       *     coordSyses: [<geo coord sys>]
       *     geoModel: <geo component>
       * }
       *
       *
       * [panelOpt]:
       *
       * Make from targetInfo. Input to BrushController.
       * {
       *     panelId: ...,
       *     rect: ...
       * }
       *
       *
       * [area]:
       *
       * Generated by BrushController or user input.
       * {
       *     panelId: Used to locate coordInfo directly. If user inpput, no panelId.
       *     brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y').
       *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.
       *     range: pixel range.
       *     coordRange: representitive coord range (the first one of coordRanges).
       *     coordRanges: <Array> coord ranges, used in multiple cartesian in one grid.
       * }
       */

      /**
       * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid
       *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}
       * @param {module:echarts/model/Global} ecModel
       * @param {Object} [opt]
       * @param {Array.<string>} [opt.include] include coordinate system types.
       */

      function BrushTargetManager(option, ecModel, opt) {
        /**
         * @private
         * @type {Array.<Object>}
         */
        var targetInfoList = this._targetInfoList = [];
        var info = {};
        var foundCpts = parseFinder(ecModel, option);
        each(targetInfoBuilders, function (builder, type) {
          if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {
            builder(foundCpts, targetInfoList, info);
          }
        });
      }

      var proto = BrushTargetManager.prototype;

      proto.setOutputRanges = function (areas, ecModel) {
        this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {
          (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges

          if (!area.coordRange) {
            area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not
            // rebuild range by coordRange accrately, which may bring trouble when
            // brushing only one item. So we use __rangeOffset to rebuilding range
            // by coordRange. And this it only used in brush component so it is no
            // need to be adapted to coordRanges.

            var result = coordConvert[area.brushType](0, coordSys, coordRange);
            area.__rangeOffset = {
              offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),
              xyMinMax: result.xyMinMax
            };
          }
        });
      };

      proto.matchOutputRanges = function (areas, ecModel, cb) {
        each(areas, function (area) {
          var targetInfo = this.findTargetInfo(area, ecModel);

          if (targetInfo && targetInfo !== true) {
            zrUtil.each(targetInfo.coordSyses, function (coordSys) {
              var result = coordConvert[area.brushType](1, coordSys, area.range);
              cb(area, result.values, coordSys, ecModel);
            });
          }
        }, this);
      };

      proto.setInputRanges = function (areas, ecModel) {
        each(areas, function (area) {
          var targetInfo = this.findTargetInfo(area, ecModel);
          area.range = area.range || []; // convert coordRange to global range and set panelId.

          if (targetInfo && targetInfo !== true) {
            area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does
            // not keep its original value, for the sake of the dataZoom scenario,
            // where area.coordRange remains unchanged but area.range may be changed.
            // (2) Only support converting one coordRange to pixel range in brush
            // component. So do not consider `coordRanges`.
            // (3) About __rangeOffset, see comment above.

            var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);
            var rangeOffset = area.__rangeOffset;
            area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;
          }
        }, this);
      };

      proto.makePanelOpts = function (api, getDefaultBrushType) {
        return zrUtil.map(this._targetInfoList, function (targetInfo) {
          var rect = targetInfo.getPanelRect();
          return {
            panelId: targetInfo.panelId,
            defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),
            clipPath: brushHelper.makeRectPanelClipPath(rect),
            isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),
            getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)
          };
        });
      };

      proto.controlSeries = function (area, seriesModel, ecModel) {
        // Check whether area is bound in coord, and series do not belong to that coord.
        // If do not do this check, some brush (like lineX) will controll all axes.
        var targetInfo = this.findTargetInfo(area, ecModel);
        return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;
      };
      /**
       * If return Object, a coord found.
       * If reutrn true, global found.
       * Otherwise nothing found.
       *
       * @param {Object} area
       * @param {Array} targetInfoList
       * @return {Object|boolean}
       */


      proto.findTargetInfo = function (area, ecModel) {
        var targetInfoList = this._targetInfoList;
        var foundCpts = parseFinder(ecModel, area);

        for (var i = 0; i < targetInfoList.length; i++) {
          var targetInfo = targetInfoList[i];
          var areaPanelId = area.panelId;

          if (areaPanelId) {
            if (targetInfo.panelId === areaPanelId) {
              return targetInfo;
            }
          } else {
            for (var i = 0; i < targetInfoMatchers.length; i++) {
              if (targetInfoMatchers[i](foundCpts, targetInfo)) {
                return targetInfo;
              }
            }
          }
        }

        return true;
      };

      function formatMinMax(minMax) {
        minMax[0] > minMax[1] && minMax.reverse();
        return minMax;
      }

      function parseFinder(ecModel, option) {
        return modelUtil.parseFinder(ecModel, option, {
          includeMainTypes: INCLUDE_FINDER_MAIN_TYPES
        });
      }

      var targetInfoBuilders = {
        grid: function grid(foundCpts, targetInfoList) {
          var xAxisModels = foundCpts.xAxisModels;
          var yAxisModels = foundCpts.yAxisModels;
          var gridModels = foundCpts.gridModels; // Remove duplicated.

          var gridModelMap = zrUtil.createHashMap();
          var xAxesHas = {};
          var yAxesHas = {};

          if (!xAxisModels && !yAxisModels && !gridModels) {
            return;
          }

          each(xAxisModels, function (axisModel) {
            var gridModel = axisModel.axis.grid.model;
            gridModelMap.set(gridModel.id, gridModel);
            xAxesHas[gridModel.id] = true;
          });
          each(yAxisModels, function (axisModel) {
            var gridModel = axisModel.axis.grid.model;
            gridModelMap.set(gridModel.id, gridModel);
            yAxesHas[gridModel.id] = true;
          });
          each(gridModels, function (gridModel) {
            gridModelMap.set(gridModel.id, gridModel);
            xAxesHas[gridModel.id] = true;
            yAxesHas[gridModel.id] = true;
          });
          gridModelMap.each(function (gridModel) {
            var grid = gridModel.coordinateSystem;
            var cartesians = [];
            each(grid.getCartesians(), function (cartesian, index) {
              if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {
                cartesians.push(cartesian);
              }
            });
            targetInfoList.push({
              panelId: 'grid--' + gridModel.id,
              gridModel: gridModel,
              coordSysModel: gridModel,
              // Use the first one as the representitive coordSys.
              coordSys: cartesians[0],
              coordSyses: cartesians,
              getPanelRect: panelRectBuilder.grid,
              xAxisDeclared: xAxesHas[gridModel.id],
              yAxisDeclared: yAxesHas[gridModel.id]
            });
          });
        },
        geo: function geo(foundCpts, targetInfoList) {
          each(foundCpts.geoModels, function (geoModel) {
            var coordSys = geoModel.coordinateSystem;
            targetInfoList.push({
              panelId: 'geo--' + geoModel.id,
              geoModel: geoModel,
              coordSysModel: geoModel,
              coordSys: coordSys,
              coordSyses: [coordSys],
              getPanelRect: panelRectBuilder.geo
            });
          });
        }
      };
      var targetInfoMatchers = [// grid
      function (foundCpts, targetInfo) {
        var xAxisModel = foundCpts.xAxisModel;
        var yAxisModel = foundCpts.yAxisModel;
        var gridModel = foundCpts.gridModel;
        !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);
        !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);
        return gridModel && gridModel === targetInfo.gridModel;
      }, // geo
      function (foundCpts, targetInfo) {
        var geoModel = foundCpts.geoModel;
        return geoModel && geoModel === targetInfo.geoModel;
      }];
      var panelRectBuilder = {
        grid: function grid() {
          // grid is not Transformable.
          return this.coordSys.grid.getRect().clone();
        },
        geo: function geo() {
          var coordSys = this.coordSys;
          var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform

          rect.applyTransform(graphic.getTransform(coordSys));
          return rect;
        }
      };
      var coordConvert = {
        lineX: curry(axisConvert, 0),
        lineY: curry(axisConvert, 1),
        rect: function rect(to, coordSys, rangeOrCoordRange) {
          var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);
          var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);
          var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];
          return {
            values: values,
            xyMinMax: values
          };
        },
        polygon: function polygon(to, coordSys, rangeOrCoordRange) {
          var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];
          var values = zrUtil.map(rangeOrCoordRange, function (item) {
            var p = coordSys[COORD_CONVERTS[to]](item);
            xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);
            xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);
            xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);
            xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);
            return p;
          });
          return {
            values: values,
            xyMinMax: xyMinMax
          };
        }
      };

      function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {
        var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);
        var values = formatMinMax(zrUtil.map([0, 1], function (i) {
          return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i])) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));
        }));
        var xyMinMax = [];
        xyMinMax[axisNameIndex] = values;
        xyMinMax[1 - axisNameIndex] = [NaN, NaN];
        return {
          values: values,
          xyMinMax: xyMinMax
        };
      }

      var diffProcessor = {
        lineX: curry(axisDiffProcessor, 0),
        lineY: curry(axisDiffProcessor, 1),
        rect: function rect(values, refer, scales) {
          return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];
        },
        polygon: function polygon(values, refer, scales) {
          return zrUtil.map(values, function (item, idx) {
            return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];
          });
        }
      };

      function axisDiffProcessor(axisNameIndex, values, refer, scales) {
        return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];
      } // We have to process scale caused by dataZoom manually,
      // although it might be not accurate.


      function getScales(xyMinMaxCurr, xyMinMaxOrigin) {
        var sizeCurr = getSize(xyMinMaxCurr);
        var sizeOrigin = getSize(xyMinMaxOrigin);
        var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];
        isNaN(scales[0]) && (scales[0] = 1);
        isNaN(scales[1]) && (scales[1] = 1);
        return scales;
      }

      function getSize(xyMinMax) {
        return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];
      }

      var _default = BrushTargetManager;
      module.exports = _default;
      /***/
    },

    /***/
    "vZI5":
    /*!*************************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/candlestick/CandlestickSeries.js ***!
      \*************************************************************************/

    /*! no static exports found */

    /***/
    function vZI5(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var SeriesModel = __webpack_require__(
      /*! ../../model/Series */
      "T4UG");

      var _whiskerBoxCommon = __webpack_require__(
      /*! ../helper/whiskerBoxCommon */
      "5GhG");

      var seriesModelMixin = _whiskerBoxCommon.seriesModelMixin;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var CandlestickSeries = SeriesModel.extend({
        type: 'series.candlestick',
        dependencies: ['xAxis', 'yAxis', 'grid'],

        /**
         * @readOnly
         */
        defaultValueDimensions: [{
          name: 'open',
          defaultTooltip: true
        }, {
          name: 'close',
          defaultTooltip: true
        }, {
          name: 'lowest',
          defaultTooltip: true
        }, {
          name: 'highest',
          defaultTooltip: true
        }],

        /**
         * @type {Array.<string>}
         * @readOnly
         */
        dimensions: null,

        /**
         * @override
         */
        defaultOption: {
          zlevel: 0,
          z: 2,
          coordinateSystem: 'cartesian2d',
          legendHoverLink: true,
          hoverAnimation: true,
          // xAxisIndex: 0,
          // yAxisIndex: 0,
          layout: null,
          // 'horizontal' or 'vertical'
          clip: true,
          itemStyle: {
            color: '#c23531',
            //  positive
            color0: '#314656',
            //  negative     '#c23531', '#314656'
            borderWidth: 1,
            // FIXME
            // ec2lineStyle.color  lineStyle.color0
            borderColor: '#c23531',
            borderColor0: '#314656'
          },
          emphasis: {
            itemStyle: {
              borderWidth: 2
            }
          },
          barMaxWidth: null,
          barMinWidth: null,
          barWidth: null,
          large: true,
          largeThreshold: 600,
          progressive: 3e3,
          progressiveThreshold: 1e4,
          progressiveChunkMode: 'mod',
          animationUpdate: false,
          animationEasing: 'linear',
          animationDuration: 300
        },

        /**
         * Get dimension for shadow in dataZoom
         * @return {string} dimension name
         */
        getShadowDim: function getShadowDim() {
          return 'open';
        },
        brushSelector: function brushSelector(dataIndex, data, selectors) {
          var itemLayout = data.getItemLayout(dataIndex);
          return itemLayout && selectors.rect(itemLayout.brushRect);
        }
      });
      zrUtil.mixin(CandlestickSeries, seriesModelMixin, true);
      var _default = CandlestickSeries;
      module.exports = _default;
      /***/
    },

    /***/
    "vcCh":
    /*!***************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/sankey/sankeyAction.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function vcCh(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      __webpack_require__(
      /*! ../helper/focusNodeAdjacencyAction */
      "0qV/");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      echarts.registerAction({
        type: 'dragNode',
        event: 'dragnode',
        // here can only use 'update' now, other value is not support in echarts.
        update: 'update'
      }, function (payload, ecModel) {
        ecModel.eachComponent({
          mainType: 'series',
          subType: 'sankey',
          query: payload
        }, function (seriesModel) {
          seriesModel.setNodePosition(payload.dataIndex, [payload.localX, payload.localY]);
        });
      });
      /***/
    },

    /***/
    "wDdD":
    /*!***********************************************!*\
      !*** ./node_modules/echarts/lib/chart/pie.js ***!
      \***********************************************/

    /*! no static exports found */

    /***/
    function wDdD(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      __webpack_require__(
      /*! ./pie/PieSeries */
      "98bh");

      __webpack_require__(
      /*! ./pie/PieView */
      "GrNh");

      var createDataSelectAction = __webpack_require__(
      /*! ../action/createDataSelectAction */
      "d4KN");

      var dataColor = __webpack_require__(
      /*! ../visual/dataColor */
      "mOdp");

      var pieLayout = __webpack_require__(
      /*! ./pie/pieLayout */
      "KS52");

      var dataFilter = __webpack_require__(
      /*! ../processor/dataFilter */
      "0/Rx");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      createDataSelectAction('pie', [{
        type: 'pieToggleSelect',
        event: 'pieselectchanged',
        method: 'toggleSelected'
      }, {
        type: 'pieSelect',
        event: 'pieselected',
        method: 'select'
      }, {
        type: 'pieUnSelect',
        event: 'pieunselected',
        method: 'unSelect'
      }]);
      echarts.registerVisual(dataColor('pie'));
      echarts.registerLayout(zrUtil.curry(pieLayout, 'pie'));
      echarts.registerProcessor(dataFilter('pie'));
      /***/
    },

    /***/
    "wr5s":
    /*!********************************************************!*\
      !*** ./node_modules/echarts/lib/util/shape/sausage.js ***!
      \********************************************************/

    /*! no static exports found */

    /***/
    function wr5s(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _graphic = __webpack_require__(
      /*! ../graphic */
      "IwbS");

      var extendShape = _graphic.extendShape;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Sausage: similar to sector, but have half circle on both sides
       * @public
       */

      var _default = extendShape({
        type: 'sausage',
        shape: {
          cx: 0,
          cy: 0,
          r0: 0,
          r: 0,
          startAngle: 0,
          endAngle: Math.PI * 2,
          clockwise: true
        },
        buildPath: function buildPath(ctx, shape) {
          var x = shape.cx;
          var y = shape.cy;
          var r0 = Math.max(shape.r0 || 0, 0);
          var r = Math.max(shape.r, 0);
          var dr = (r - r0) * 0.5;
          var rCenter = r0 + dr;
          var startAngle = shape.startAngle;
          var endAngle = shape.endAngle;
          var clockwise = shape.clockwise;
          var unitStartX = Math.cos(startAngle);
          var unitStartY = Math.sin(startAngle);
          var unitEndX = Math.cos(endAngle);
          var unitEndY = Math.sin(endAngle);
          var lessThanCircle = clockwise ? endAngle - startAngle < Math.PI * 2 : startAngle - endAngle < Math.PI * 2;

          if (lessThanCircle) {
            ctx.moveTo(unitStartX * r0 + x, unitStartY * r0 + y);
            ctx.arc(unitStartX * rCenter + x, unitStartY * rCenter + y, dr, -Math.PI + startAngle, startAngle, !clockwise);
          }

          ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
          ctx.moveTo(unitEndX * r + x, unitEndY * r + y);
          ctx.arc(unitEndX * rCenter + x, unitEndY * rCenter + y, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);

          if (r0 !== 0) {
            ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
            ctx.moveTo(unitStartX * r0 + x, unitEndY * r0 + y);
          }

          ctx.closePath();
        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "wt3j":
    /*!***************************************************************!*\
      !*** ./node_modules/echarts/lib/component/brush/BrushView.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function wt3j(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var BrushController = __webpack_require__(
      /*! ../helper/BrushController */
      "/IIm");

      var _visualEncoding = __webpack_require__(
      /*! ./visualEncoding */
      "EMyp");

      var layoutCovers = _visualEncoding.layoutCovers;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var _default = echarts.extendComponentView({
        type: 'brush',
        init: function init(ecModel, api) {
          /**
           * @readOnly
           * @type {module:echarts/model/Global}
           */
          this.ecModel = ecModel;
          /**
           * @readOnly
           * @type {module:echarts/ExtensionAPI}
           */

          this.api = api;
          /**
           * @readOnly
           * @type {module:echarts/component/brush/BrushModel}
           */

          this.model;
          /**
           * @private
           * @type {module:echarts/component/helper/BrushController}
           */

          (this._brushController = new BrushController(api.getZr())).on('brush', zrUtil.bind(this._onBrush, this)).mount();
        },

        /**
         * @override
         */
        render: function render(brushModel) {
          this.model = brushModel;
          return updateController.apply(this, arguments);
        },

        /**
         * @override
         */
        updateTransform: function updateTransform(brushModel, ecModel) {
          // PENDING: `updateTransform` is a little tricky, whose layout need
          // to be calculate mandatorily and other stages will not be performed.
          // Take care the correctness of the logic. See #11754 .
          layoutCovers(ecModel);
          return updateController.apply(this, arguments);
        },

        /**
         * @override
         */
        updateView: updateController,
        // /**
        //  * @override
        //  */
        // updateLayout: updateController,
        // /**
        //  * @override
        //  */
        // updateVisual: updateController,

        /**
         * @override
         */
        dispose: function dispose() {
          this._brushController.dispose();
        },

        /**
         * @private
         */
        _onBrush: function _onBrush(areas, opt) {
          var modelId = this.model.id;
          this.model.brushTargetManager.setOutputRanges(areas, this.ecModel); // Action is not dispatched on drag end, because the drag end
          // emits the same params with the last drag move event, and
          // may have some delay when using touch pad, which makes
          // animation not smooth (when using debounce).

          (!opt.isEnd || opt.removeOnClick) && this.api.dispatchAction({
            type: 'brush',
            brushId: modelId,
            areas: zrUtil.clone(areas),
            $from: modelId
          });
          opt.isEnd && this.api.dispatchAction({
            type: 'brushEnd',
            brushId: modelId,
            areas: zrUtil.clone(areas),
            $from: modelId
          });
        }
      });

      function updateController(brushModel, ecModel, api, payload) {
        // Do not update controller when drawing.
        (!payload || payload.$from !== brushModel.id) && this._brushController.setPanels(brushModel.brushTargetManager.makePanelOpts(api)).enableBrush(brushModel.brushOption).updateCovers(brushModel.areas.slice());
      }

      module.exports = _default;
      /***/
    },

    /***/
    "x3X8":
    /*!**************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/helper/labelHelper.js ***!
      \**************************************************************/

    /*! no static exports found */

    /***/
    function x3X8(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _dataProvider = __webpack_require__(
      /*! ../../data/helper/dataProvider */
      "KxfA");

      var retrieveRawValue = _dataProvider.retrieveRawValue;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @param {module:echarts/data/List} data
       * @param {number} dataIndex
       * @return {string} label string. Not null/undefined
       */

      function getDefaultLabel(data, dataIndex) {
        var labelDims = data.mapDimension('defaultedLabel', true);
        var len = labelDims.length; // Simple optimization (in lots of cases, label dims length is 1)

        if (len === 1) {
          return retrieveRawValue(data, dataIndex, labelDims[0]);
        } else if (len) {
          var vals = [];

          for (var i = 0; i < labelDims.length; i++) {
            var val = retrieveRawValue(data, dataIndex, labelDims[i]);
            vals.push(val);
          }

          return vals.join(' ');
        }
      }

      exports.getDefaultLabel = getDefaultLabel;
      /***/
    },

    /***/
    "xKMd":
    /*!*****************************************************************!*\
      !*** ./node_modules/echarts/lib/visual/LegendVisualProvider.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function xKMd(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * LegendVisualProvider is an bridge that pick encoded color from data and
       * provide to the legend component.
       * @param {Function} getDataWithEncodedVisual Function to get data after filtered. It stores all the encoding info
       * @param {Function} getRawData Function to get raw data before filtered.
       */
      function LegendVisualProvider(getDataWithEncodedVisual, getRawData) {
        this.getAllNames = function () {
          var rawData = getRawData(); // We find the name from the raw data. In case it's filtered by the legend component.
          // Normally, the name can be found in rawData, but can't be found in filtered data will display as gray.

          return rawData.mapArray(rawData.getName);
        };

        this.containName = function (name) {
          var rawData = getRawData();
          return rawData.indexOfName(name) >= 0;
        };

        this.indexOfName = function (name) {
          // Only get data when necessary.
          // Because LegendVisualProvider constructor may be new in the stage that data is not prepared yet.
          // Invoking Series#getData immediately will throw an error.
          var dataWithEncodedVisual = getDataWithEncodedVisual();
          return dataWithEncodedVisual.indexOfName(name);
        };

        this.getItemVisual = function (dataIndex, key) {
          // Get encoded visual properties from final filtered data.
          var dataWithEncodedVisual = getDataWithEncodedVisual();
          return dataWithEncodedVisual.getItemVisual(dataIndex, key);
        };
      }

      var _default = LegendVisualProvider;
      module.exports = _default;
      /***/
    },

    /***/
    "xRUu":
    /*!************************************************************!*\
      !*** ./node_modules/echarts/lib/component/parallelAxis.js ***!
      \************************************************************/

    /*! no static exports found */

    /***/
    function xRUu(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      __webpack_require__(
      /*! ../coord/parallel/parallelCreator */
      "hJvP");

      __webpack_require__(
      /*! ./axis/parallelAxisAction */
      "hFmY");

      __webpack_require__(
      /*! ./axis/ParallelAxisView */
      "sAZ8");
      /***/

    },

    /***/
    "xSat":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/component/helper/cursorHelper.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function xSat(module, exports) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var IRRELEVANT_EXCLUDES = {
        'axisPointer': 1,
        'tooltip': 1,
        'brush': 1
      };
      /**
       * Avoid that: mouse click on a elements that is over geo or graph,
       * but roam is triggered.
       */

      function onIrrelevantElement(e, api, targetCoordSysModel) {
        var model = api.getComponentByElement(e.topTarget); // If model is axisModel, it works only if it is injected with coordinateSystem.

        var coordSys = model && model.coordinateSystem;
        return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES[model.mainType] && coordSys && coordSys.model !== targetCoordSysModel;
      }

      exports.onIrrelevantElement = onIrrelevantElement;
      /***/
    },

    /***/
    "xiyX":
    /*!************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/single/AxisModel.js ***!
      \************************************************************/

    /*! no static exports found */

    /***/
    function xiyX(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var ComponentModel = __webpack_require__(
      /*! ../../model/Component */
      "bLfw");

      var axisModelCreator = __webpack_require__(
      /*! ../axisModelCreator */
      "nkfE");

      var axisModelCommonMixin = __webpack_require__(
      /*! ../axisModelCommonMixin */
      "ICMv");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var AxisModel = ComponentModel.extend({
        type: 'singleAxis',
        layoutMode: 'box',

        /**
         * @type {module:echarts/coord/single/SingleAxis}
         */
        axis: null,

        /**
         * @type {module:echarts/coord/single/Single}
         */
        coordinateSystem: null,

        /**
         * @override
         */
        getCoordSysModel: function getCoordSysModel() {
          return this;
        }
      });
      var defaultOption = {
        left: '5%',
        top: '5%',
        right: '5%',
        bottom: '5%',
        type: 'value',
        position: 'bottom',
        orient: 'horizontal',
        axisLine: {
          show: true,
          lineStyle: {
            width: 1,
            type: 'solid'
          }
        },
        // Single coordinate system and single axis is the,
        // which is used as the parent tooltip model.
        // same model, so we set default tooltip show as true.
        tooltip: {
          show: true
        },
        axisTick: {
          show: true,
          length: 6,
          lineStyle: {
            width: 1
          }
        },
        axisLabel: {
          show: true,
          interval: 'auto'
        },
        splitLine: {
          show: true,
          lineStyle: {
            type: 'dashed',
            opacity: 0.2
          }
        }
      };

      function getAxisType(axisName, option) {
        return option.type || (option.data ? 'category' : 'value');
      }

      zrUtil.merge(AxisModel.prototype, axisModelCommonMixin);
      axisModelCreator('single', AxisModel, getAxisType, defaultOption);
      var _default = AxisModel;
      module.exports = _default;
      /***/
    },

    /***/
    "y+lR":
    /*!*****************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/cartesian/Cartesian2D.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function yLR(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var BoundingRect = __webpack_require__(
      /*! zrender/lib/core/BoundingRect */
      "mFDi");

      var Cartesian = __webpack_require__(
      /*! ./Cartesian */
      "z35g");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function Cartesian2D(name) {
        Cartesian.call(this, name);
      }

      Cartesian2D.prototype = {
        constructor: Cartesian2D,
        type: 'cartesian2d',

        /**
         * @type {Array.<string>}
         * @readOnly
         */
        dimensions: ['x', 'y'],

        /**
         * Base axis will be used on stacking.
         *
         * @return {module:echarts/coord/cartesian/Axis2D}
         */
        getBaseAxis: function getBaseAxis() {
          return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');
        },

        /**
         * If contain point
         * @param {Array.<number>} point
         * @return {boolean}
         */
        containPoint: function containPoint(point) {
          var axisX = this.getAxis('x');
          var axisY = this.getAxis('y');
          return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
        },

        /**
         * If contain data
         * @param {Array.<number>} data
         * @return {boolean}
         */
        containData: function containData(data) {
          return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);
        },

        /**
         * @param {Array.<number>} data
         * @param {Array.<number>} out
         * @return {Array.<number>}
         */
        dataToPoint: function dataToPoint(data, reserved, out) {
          var xAxis = this.getAxis('x');
          var yAxis = this.getAxis('y');
          out = out || [];
          out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(data[0]));
          out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(data[1]));
          return out;
        },

        /**
         * @param {Array.<number>} data
         * @param {Array.<number>} out
         * @return {Array.<number>}
         */
        clampData: function clampData(data, out) {
          var xScale = this.getAxis('x').scale;
          var yScale = this.getAxis('y').scale;
          var xAxisExtent = xScale.getExtent();
          var yAxisExtent = yScale.getExtent();
          var x = xScale.parse(data[0]);
          var y = yScale.parse(data[1]);
          out = out || [];
          out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));
          out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));
          return out;
        },

        /**
         * @param {Array.<number>} point
         * @param {Array.<number>} out
         * @return {Array.<number>}
         */
        pointToData: function pointToData(point, out) {
          var xAxis = this.getAxis('x');
          var yAxis = this.getAxis('y');
          out = out || [];
          out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]));
          out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]));
          return out;
        },

        /**
         * Get other axis
         * @param {module:echarts/coord/cartesian/Axis2D} axis
         */
        getOtherAxis: function getOtherAxis(axis) {
          return this.getAxis(axis.dim === 'x' ? 'y' : 'x');
        },

        /**
         * Get rect area of cartesian.
         * Area will have a contain function to determine if a point is in the coordinate system.
         * @return {BoundingRect}
         */
        getArea: function getArea() {
          var xExtent = this.getAxis('x').getGlobalExtent();
          var yExtent = this.getAxis('y').getGlobalExtent();
          var x = Math.min(xExtent[0], xExtent[1]);
          var y = Math.min(yExtent[0], yExtent[1]);
          var width = Math.max(xExtent[0], xExtent[1]) - x;
          var height = Math.max(yExtent[0], yExtent[1]) - y;
          var rect = new BoundingRect(x, y, width, height);
          return rect;
        }
      };
      zrUtil.inherits(Cartesian2D, Cartesian);
      var _default = Cartesian2D;
      module.exports = _default;
      /***/
    },

    /***/
    "y2l5":
    /*!*****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/scatter/ScatterSeries.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function y2l5(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var createListFromArray = __webpack_require__(
      /*! ../helper/createListFromArray */
      "MwEJ");

      var SeriesModel = __webpack_require__(
      /*! ../../model/Series */
      "T4UG");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var _default = SeriesModel.extend({
        type: 'series.scatter',
        dependencies: ['grid', 'polar', 'geo', 'singleAxis', 'calendar'],
        getInitialData: function getInitialData(option, ecModel) {
          return createListFromArray(this.getSource(), this, {
            useEncodeDefaulter: true
          });
        },
        brushSelector: 'point',
        getProgressive: function getProgressive() {
          var progressive = this.option.progressive;

          if (progressive == null) {
            // PENDING
            return this.option.large ? 5e3 : this.get('progressive');
          }

          return progressive;
        },
        getProgressiveThreshold: function getProgressiveThreshold() {
          var progressiveThreshold = this.option.progressiveThreshold;

          if (progressiveThreshold == null) {
            // PENDING
            return this.option.large ? 1e4 : this.get('progressiveThreshold');
          }

          return progressiveThreshold;
        },
        defaultOption: {
          coordinateSystem: 'cartesian2d',
          zlevel: 0,
          z: 2,
          legendHoverLink: true,
          hoverAnimation: true,
          // Cartesian coordinate system
          // xAxisIndex: 0,
          // yAxisIndex: 0,
          // Polar coordinate system
          // polarIndex: 0,
          // Geo coordinate system
          // geoIndex: 0,
          // symbol: null,        // 
          symbolSize: 10,
          // symbolSize * 2
          // symbolRotate: null,  // 
          large: false,
          // Available when large is true
          largeThreshold: 2000,
          // cursor: null,
          // label: {
          // show: false
          // distance: 5,
          // formatter: Tooltip.formatter
          // position: 'top''right'
          //           'inside'|'left'|'right'|'top'|'bottom'
          // TEXTSTYLE
          // },
          itemStyle: {
            opacity: 0.8 // color: 

          },
          // If clip the overflow graphics
          // Works on cartesian / polar series
          clip: true // progressive: null

        }
      });

      module.exports = _default;
      /***/
    },

    /***/
    "y3NT":
    /*!*******************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/sunburst/sunburstLayout.js ***!
      \*******************************************************************/

    /*! no static exports found */

    /***/
    function y3NT(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _number = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var parsePercent = _number.parsePercent;

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // var PI2 = Math.PI * 2;


      var RADIAN = Math.PI / 180;

      function _default(seriesType, ecModel, api, payload) {
        ecModel.eachSeriesByType(seriesType, function (seriesModel) {
          var center = seriesModel.get('center');
          var radius = seriesModel.get('radius');

          if (!zrUtil.isArray(radius)) {
            radius = [0, radius];
          }

          if (!zrUtil.isArray(center)) {
            center = [center, center];
          }

          var width = api.getWidth();
          var height = api.getHeight();
          var size = Math.min(width, height);
          var cx = parsePercent(center[0], width);
          var cy = parsePercent(center[1], height);
          var r0 = parsePercent(radius[0], size / 2);
          var r = parsePercent(radius[1], size / 2);
          var startAngle = -seriesModel.get('startAngle') * RADIAN;
          var minAngle = seriesModel.get('minAngle') * RADIAN;
          var virtualRoot = seriesModel.getData().tree.root;
          var treeRoot = seriesModel.getViewRoot();
          var rootDepth = treeRoot.depth;
          var sort = seriesModel.get('sort');

          if (sort != null) {
            initChildren(treeRoot, sort);
          }

          var validDataCount = 0;
          zrUtil.each(treeRoot.children, function (child) {
            !isNaN(child.getValue()) && validDataCount++;
          });
          var sum = treeRoot.getValue(); // Sum may be 0

          var unitRadian = Math.PI / (sum || validDataCount) * 2;
          var renderRollupNode = treeRoot.depth > 0;
          var levels = treeRoot.height - (renderRollupNode ? -1 : 1);
          var rPerLevel = (r - r0) / (levels || 1);
          var clockwise = seriesModel.get('clockwise');
          var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // In the case some sector angle is smaller than minAngle
          // var restAngle = PI2;
          // var valueSumLargerThanMinAngle = 0;

          var dir = clockwise ? 1 : -1;
          /**
           * Render a tree
           * @return increased angle
           */

          var renderNode = function renderNode(node, startAngle) {
            if (!node) {
              return;
            }

            var endAngle = startAngle; // Render self

            if (node !== virtualRoot) {
              // Tree node is virtual, so it doesn't need to be drawn
              var value = node.getValue();
              var angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;

              if (angle < minAngle) {
                angle = minAngle; // restAngle -= minAngle;
              } // else {
              //     valueSumLargerThanMinAngle += value;
              // }


              endAngle = startAngle + dir * angle;
              var depth = node.depth - rootDepth - (renderRollupNode ? -1 : 1);
              var rStart = r0 + rPerLevel * depth;
              var rEnd = r0 + rPerLevel * (depth + 1);
              var itemModel = node.getModel();

              if (itemModel.get('r0') != null) {
                rStart = parsePercent(itemModel.get('r0'), size / 2);
              }

              if (itemModel.get('r') != null) {
                rEnd = parsePercent(itemModel.get('r'), size / 2);
              }

              node.setLayout({
                angle: angle,
                startAngle: startAngle,
                endAngle: endAngle,
                clockwise: clockwise,
                cx: cx,
                cy: cy,
                r0: rStart,
                r: rEnd
              });
            } // Render children


            if (node.children && node.children.length) {
              // currentAngle = startAngle;
              var siblingAngle = 0;
              zrUtil.each(node.children, function (node) {
                siblingAngle += renderNode(node, startAngle + siblingAngle);
              });
            }

            return endAngle - startAngle;
          }; // Virtual root node for roll up


          if (renderRollupNode) {
            var rStart = r0;
            var rEnd = r0 + rPerLevel;
            var angle = Math.PI * 2;
            virtualRoot.setLayout({
              angle: angle,
              startAngle: startAngle,
              endAngle: startAngle + angle,
              clockwise: clockwise,
              cx: cx,
              cy: cy,
              r0: rStart,
              r: rEnd
            });
          }

          renderNode(treeRoot, startAngle);
        });
      }
      /**
       * Init node children by order and update visual
       *
       * @param {TreeNode} node  root node
       * @param {boolean}  isAsc if is in ascendant order
       */


      function initChildren(node, isAsc) {
        var children = node.children || [];
        node.children = sort(children, isAsc); // Init children recursively

        if (children.length) {
          zrUtil.each(node.children, function (child) {
            initChildren(child, isAsc);
          });
        }
      }
      /**
       * Sort children nodes
       *
       * @param {TreeNode[]}               children children of node to be sorted
       * @param {string | function | null} sort sort method
       *                                   See SunburstSeries.js for details.
       */


      function sort(children, sortOrder) {
        if (typeof sortOrder === 'function') {
          return children.sort(sortOrder);
        } else {
          var isAsc = sortOrder === 'asc';
          return children.sort(function (a, b) {
            var diff = (a.getValue() - b.getValue()) * (isAsc ? 1 : -1);
            return diff === 0 ? (a.dataIndex - b.dataIndex) * (isAsc ? -1 : 1) : diff;
          });
        }
      }

      module.exports = _default;
      /***/
    },

    /***/
    "y4/Y":
    /*!***********************************************************!*\
      !*** ./node_modules/echarts/lib/component/axisPointer.js ***!
      \***********************************************************/

    /*! no static exports found */

    /***/
    function y4Y(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var echarts = __webpack_require__(
      /*! ../echarts */
      "ProS");

      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var axisPointerModelHelper = __webpack_require__(
      /*! ./axisPointer/modelHelper */
      "zTMp");

      var axisTrigger = __webpack_require__(
      /*! ./axisPointer/axisTrigger */
      "62sa");

      __webpack_require__(
      /*! ./axisPointer/AxisPointerModel */
      "SKx+");

      __webpack_require__(
      /*! ./axisPointer/AxisPointerView */
      "1LEl");

      __webpack_require__(
      /*! ./axisPointer/CartesianAxisPointer */
      "Sp2Z");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      // CartesianAxisPointer is not supposed to be required here. But consider
      // echarts.simple.js and online build tooltip, which only require gridSimple,
      // CartesianAxisPointer should be able to required somewhere.


      echarts.registerPreprocessor(function (option) {
        // Always has a global axisPointerModel for default setting.
        if (option) {
          (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
          var link = option.axisPointer.link; // Normalize to array to avoid object mergin. But if link
          // is not set, remain null/undefined, otherwise it will
          // override existent link setting.

          if (link && !zrUtil.isArray(link)) {
            option.axisPointer.link = [link];
          }
        }
      }); // This process should proformed after coordinate systems created
      // and series data processed. So put it on statistic processing stage.

      echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {
        // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.
        // allAxesInfo should be updated when setOption performed.
        ecModel.getComponent('axisPointer').coordSysAxesInfo = axisPointerModelHelper.collect(ecModel, api);
      }); // Broadcast to all views.

      echarts.registerAction({
        type: 'updateAxisPointer',
        event: 'updateAxisPointer',
        update: ':updateAxisPointer'
      }, axisTrigger);
      /***/
    },

    /***/
    "y7Aq":
    /*!****************************************************************!*\
      !*** ./node_modules/echarts/lib/component/visualMap/helper.js ***!
      \****************************************************************/

    /*! no static exports found */

    /***/
    function y7Aq(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _layout = __webpack_require__(
      /*! ../../util/layout */
      "+TT/");

      var getLayoutRect = _layout.getLayoutRect;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * @param {module:echarts/component/visualMap/VisualMapModel} visualMapModel\
       * @param {module:echarts/ExtensionAPI} api
       * @param {Array.<number>} itemSize always [short, long]
       * @return {string} 'left' or 'right' or 'top' or 'bottom'
       */

      function getItemAlign(visualMapModel, api, itemSize) {
        var modelOption = visualMapModel.option;
        var itemAlign = modelOption.align;

        if (itemAlign != null && itemAlign !== 'auto') {
          return itemAlign;
        } // Auto decision align.


        var ecSize = {
          width: api.getWidth(),
          height: api.getHeight()
        };
        var realIndex = modelOption.orient === 'horizontal' ? 1 : 0;
        var paramsSet = [['left', 'right', 'width'], ['top', 'bottom', 'height']];
        var reals = paramsSet[realIndex];
        var fakeValue = [0, null, 10];
        var layoutInput = {};

        for (var i = 0; i < 3; i++) {
          layoutInput[paramsSet[1 - realIndex][i]] = fakeValue[i];
          layoutInput[reals[i]] = i === 2 ? itemSize[0] : modelOption[reals[i]];
        }

        var rParam = [['x', 'width', 3], ['y', 'height', 0]][realIndex];
        var rect = getLayoutRect(layoutInput, ecSize, modelOption.padding);
        return reals[(rect.margin[rParam[2]] || 0) + rect[rParam[0]] + rect[rParam[1]] * 0.5 < ecSize[rParam[1]] * 0.5 ? 0 : 1];
      }
      /**
       * Prepare dataIndex for outside usage, where dataIndex means rawIndex, and
       * dataIndexInside means filtered index.
       */


      function makeHighDownBatch(batch, visualMapModel) {
        zrUtil.each(batch || [], function (batchItem) {
          if (batchItem.dataIndex != null) {
            batchItem.dataIndexInside = batchItem.dataIndex;
            batchItem.dataIndex = null;
          }

          batchItem.highlightKey = 'visualMap' + (visualMapModel ? visualMapModel.componentIndex : '');
        });
        return batch;
      }

      exports.getItemAlign = getItemAlign;
      exports.makeHighDownBatch = makeHighDownBatch;
      /***/
    },

    /***/
    "yO87":
    /*!***************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/helper/EffectSymbol.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function yO87(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var _symbol = __webpack_require__(
      /*! ../../util/symbol */
      "oVpE");

      var createSymbol = _symbol.createSymbol;

      var _graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var Group = _graphic.Group;

      var _number = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var parsePercent = _number.parsePercent;

      var SymbolClz = __webpack_require__(
      /*! ./Symbol */
      "FBjb");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Symbol with ripple effect
       * @module echarts/chart/helper/EffectSymbol
       */


      var EFFECT_RIPPLE_NUMBER = 3;

      function normalizeSymbolSize(symbolSize) {
        if (!zrUtil.isArray(symbolSize)) {
          symbolSize = [+symbolSize, +symbolSize];
        }

        return symbolSize;
      }

      function updateRipplePath(rippleGroup, effectCfg) {
        var color = effectCfg.rippleEffectColor || effectCfg.color;
        rippleGroup.eachChild(function (ripplePath) {
          ripplePath.attr({
            z: effectCfg.z,
            zlevel: effectCfg.zlevel,
            style: {
              stroke: effectCfg.brushType === 'stroke' ? color : null,
              fill: effectCfg.brushType === 'fill' ? color : null
            }
          });
        });
      }
      /**
       * @constructor
       * @param {module:echarts/data/List} data
       * @param {number} idx
       * @extends {module:zrender/graphic/Group}
       */


      function EffectSymbol(data, idx) {
        Group.call(this);
        var symbol = new SymbolClz(data, idx);
        var rippleGroup = new Group();
        this.add(symbol);
        this.add(rippleGroup);

        rippleGroup.beforeUpdate = function () {
          this.attr(symbol.getScale());
        };

        this.updateData(data, idx);
      }

      var effectSymbolProto = EffectSymbol.prototype;

      effectSymbolProto.stopEffectAnimation = function () {
        this.childAt(1).removeAll();
      };

      effectSymbolProto.startEffectAnimation = function (effectCfg) {
        var symbolType = effectCfg.symbolType;
        var color = effectCfg.color;
        var rippleGroup = this.childAt(1);

        for (var i = 0; i < EFFECT_RIPPLE_NUMBER; i++) {
          // If width/height are set too small (e.g., set to 1) on ios10
          // and macOS Sierra, a circle stroke become a rect, no matter what
          // the scale is set. So we set width/height as 2. See #4136.
          var ripplePath = createSymbol(symbolType, -1, -1, 2, 2, color);
          ripplePath.attr({
            style: {
              strokeNoScale: true
            },
            z2: 99,
            silent: true,
            scale: [0.5, 0.5]
          });
          var delay = -i / EFFECT_RIPPLE_NUMBER * effectCfg.period + effectCfg.effectOffset; // TODO Configurable effectCfg.period

          ripplePath.animate('', true).when(effectCfg.period, {
            scale: [effectCfg.rippleScale / 2, effectCfg.rippleScale / 2]
          }).delay(delay).start();
          ripplePath.animateStyle(true).when(effectCfg.period, {
            opacity: 0
          }).delay(delay).start();
          rippleGroup.add(ripplePath);
        }

        updateRipplePath(rippleGroup, effectCfg);
      };
      /**
       * Update effect symbol
       */


      effectSymbolProto.updateEffectAnimation = function (effectCfg) {
        var oldEffectCfg = this._effectCfg;
        var rippleGroup = this.childAt(1); // Must reinitialize effect if following configuration changed

        var DIFFICULT_PROPS = ['symbolType', 'period', 'rippleScale'];

        for (var i = 0; i < DIFFICULT_PROPS.length; i++) {
          var propName = DIFFICULT_PROPS[i];

          if (oldEffectCfg[propName] !== effectCfg[propName]) {
            this.stopEffectAnimation();
            this.startEffectAnimation(effectCfg);
            return;
          }
        }

        updateRipplePath(rippleGroup, effectCfg);
      };
      /**
       * Highlight symbol
       */


      effectSymbolProto.highlight = function () {
        this.trigger('emphasis');
      };
      /**
       * Downplay symbol
       */


      effectSymbolProto.downplay = function () {
        this.trigger('normal');
      };
      /**
       * Update symbol properties
       * @param  {module:echarts/data/List} data
       * @param  {number} idx
       */


      effectSymbolProto.updateData = function (data, idx) {
        var seriesModel = data.hostModel;
        this.childAt(0).updateData(data, idx);
        var rippleGroup = this.childAt(1);
        var itemModel = data.getItemModel(idx);
        var symbolType = data.getItemVisual(idx, 'symbol');
        var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));
        var color = data.getItemVisual(idx, 'color');
        rippleGroup.attr('scale', symbolSize);
        rippleGroup.traverse(function (ripplePath) {
          ripplePath.attr({
            fill: color
          });
        });
        var symbolOffset = itemModel.getShallow('symbolOffset');

        if (symbolOffset) {
          var pos = rippleGroup.position;
          pos[0] = parsePercent(symbolOffset[0], symbolSize[0]);
          pos[1] = parsePercent(symbolOffset[1], symbolSize[1]);
        }

        var symbolRotate = data.getItemVisual(idx, 'symbolRotate');
        rippleGroup.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
        var effectCfg = {};
        effectCfg.showEffectOn = seriesModel.get('showEffectOn');
        effectCfg.rippleScale = itemModel.get('rippleEffect.scale');
        effectCfg.brushType = itemModel.get('rippleEffect.brushType');
        effectCfg.period = itemModel.get('rippleEffect.period') * 1000;
        effectCfg.effectOffset = idx / data.count();
        effectCfg.z = itemModel.getShallow('z') || 0;
        effectCfg.zlevel = itemModel.getShallow('zlevel') || 0;
        effectCfg.symbolType = symbolType;
        effectCfg.color = color;
        effectCfg.rippleEffectColor = itemModel.get('rippleEffect.color');
        this.off('mouseover').off('mouseout').off('emphasis').off('normal');

        if (effectCfg.showEffectOn === 'render') {
          this._effectCfg ? this.updateEffectAnimation(effectCfg) : this.startEffectAnimation(effectCfg);
          this._effectCfg = effectCfg;
        } else {
          // Not keep old effect config
          this._effectCfg = null;
          this.stopEffectAnimation();
          var symbol = this.childAt(0);

          var onEmphasis = function onEmphasis() {
            symbol.highlight();

            if (effectCfg.showEffectOn !== 'render') {
              this.startEffectAnimation(effectCfg);
            }
          };

          var onNormal = function onNormal() {
            symbol.downplay();

            if (effectCfg.showEffectOn !== 'render') {
              this.stopEffectAnimation();
            }
          };

          this.on('mouseover', onEmphasis, this).on('mouseout', onNormal, this).on('emphasis', onEmphasis, this).on('normal', onNormal, this);
        }

        this._effectCfg = effectCfg;
      };

      effectSymbolProto.fadeOut = function (cb) {
        this.off('mouseover').off('mouseout').off('emphasis').off('normal');
        cb && cb();
      };

      zrUtil.inherits(EffectSymbol, Group);
      var _default = EffectSymbol;
      module.exports = _default;
      /***/
    },

    /***/
    "yS9w":
    /*!************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/geo/geoSVGLoader.js ***!
      \************************************************************/

    /*! no static exports found */

    /***/
    function yS9w(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _parseSVG = __webpack_require__(
      /*! zrender/lib/tool/parseSVG */
      "MEGo");

      var parseSVG = _parseSVG.parseSVG;
      var makeViewBoxTransform = _parseSVG.makeViewBoxTransform;

      var Group = __webpack_require__(
      /*! zrender/lib/container/Group */
      "4fz+");

      var Rect = __webpack_require__(
      /*! zrender/lib/graphic/shape/Rect */
      "x6Kt");

      var _util = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var assert = _util.assert;
      var createHashMap = _util.createHashMap;

      var BoundingRect = __webpack_require__(
      /*! zrender/lib/core/BoundingRect */
      "mFDi");

      var _model = __webpack_require__(
      /*! ../../util/model */
      "4NO4");

      var makeInner = _model.makeInner;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      var inner = makeInner();
      var _default = {
        /**
         * @param {string} mapName
         * @param {Object} mapRecord {specialAreas, geoJSON}
         * @return {Object} {root, boundingRect}
         */
        load: function load(mapName, mapRecord) {
          var originRoot = inner(mapRecord).originRoot;

          if (originRoot) {
            return {
              root: originRoot,
              boundingRect: inner(mapRecord).boundingRect
            };
          }

          var graphic = buildGraphic(mapRecord);
          inner(mapRecord).originRoot = graphic.root;
          inner(mapRecord).boundingRect = graphic.boundingRect;
          return graphic;
        },
        makeGraphic: function makeGraphic(mapName, mapRecord, hostKey) {
          // For performance consideration (in large SVG), graphic only maked
          // when necessary and reuse them according to hostKey.
          var field = inner(mapRecord);
          var rootMap = field.rootMap || (field.rootMap = createHashMap());
          var root = rootMap.get(hostKey);

          if (root) {
            return root;
          }

          var originRoot = field.originRoot;
          var boundingRect = field.boundingRect; // For performance, if originRoot is not used by a view,
          // assign it to a view, but not reproduce graphic elements.

          if (!field.originRootHostKey) {
            field.originRootHostKey = hostKey;
            root = originRoot;
          } else {
            root = buildGraphic(mapRecord, boundingRect).root;
          }

          return rootMap.set(hostKey, root);
        },
        removeGraphic: function removeGraphic(mapName, mapRecord, hostKey) {
          var field = inner(mapRecord);
          var rootMap = field.rootMap;
          rootMap && rootMap.removeKey(hostKey);

          if (hostKey === field.originRootHostKey) {
            field.originRootHostKey = null;
          }
        }
      };

      function buildGraphic(mapRecord, boundingRect) {
        var svgXML = mapRecord.svgXML;
        var result;
        var root;

        try {
          result = svgXML && parseSVG(svgXML, {
            ignoreViewBox: true,
            ignoreRootClip: true
          }) || {};
          root = result.root;
          assert(root != null);
        } catch (e) {
          throw new Error('Invalid svg format\n' + e.message);
        }

        var svgWidth = result.width;
        var svgHeight = result.height;
        var viewBoxRect = result.viewBoxRect;

        if (!boundingRect) {
          boundingRect = svgWidth == null || svgHeight == null ? // If svg width / height not specified, calculate
          // bounding rect as the width / height
          root.getBoundingRect() : new BoundingRect(0, 0, 0, 0);

          if (svgWidth != null) {
            boundingRect.width = svgWidth;
          }

          if (svgHeight != null) {
            boundingRect.height = svgHeight;
          }
        }

        if (viewBoxRect) {
          var viewBoxTransform = makeViewBoxTransform(viewBoxRect, boundingRect.width, boundingRect.height);
          var elRoot = root;
          root = new Group();
          root.add(elRoot);
          elRoot.scale = viewBoxTransform.scale;
          elRoot.position = viewBoxTransform.position;
        }

        root.setClipPath(new Rect({
          shape: boundingRect.plain()
        }));
        return {
          root: root,
          boundingRect: boundingRect
        };
      }

      module.exports = _default;
      /***/
    },

    /***/
    "yWXo":
    /*!******************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/helper/LargeSymbolDraw.js ***!
      \******************************************************************/

    /*! no static exports found */

    /***/
    function yWXo(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var graphic = __webpack_require__(
      /*! ../../util/graphic */
      "IwbS");

      var _symbol = __webpack_require__(
      /*! ../../util/symbol */
      "oVpE");

      var createSymbol = _symbol.createSymbol;

      var IncrementalDisplayable = __webpack_require__(
      /*! zrender/lib/graphic/IncrementalDisplayable */
      "OS9S");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /* global Float32Array */
      // TODO Batch by color


      var BOOST_SIZE_THRESHOLD = 4;
      var LargeSymbolPath = graphic.extendShape({
        shape: {
          points: null
        },
        symbolProxy: null,
        softClipShape: null,
        buildPath: function buildPath(path, shape) {
          var points = shape.points;
          var size = shape.size;
          var symbolProxy = this.symbolProxy;
          var symbolProxyShape = symbolProxy.shape;
          var ctx = path.getContext ? path.getContext() : path;
          var canBoost = ctx && size[0] < BOOST_SIZE_THRESHOLD; // Do draw in afterBrush.

          if (canBoost) {
            return;
          }

          for (var i = 0; i < points.length;) {
            var x = points[i++];
            var y = points[i++];

            if (isNaN(x) || isNaN(y)) {
              continue;
            }

            if (this.softClipShape && !this.softClipShape.contain(x, y)) {
              continue;
            }

            symbolProxyShape.x = x - size[0] / 2;
            symbolProxyShape.y = y - size[1] / 2;
            symbolProxyShape.width = size[0];
            symbolProxyShape.height = size[1];
            symbolProxy.buildPath(path, symbolProxyShape, true);
          }
        },
        afterBrush: function afterBrush(ctx) {
          var shape = this.shape;
          var points = shape.points;
          var size = shape.size;
          var canBoost = size[0] < BOOST_SIZE_THRESHOLD;

          if (!canBoost) {
            return;
          }

          this.setTransform(ctx); // PENDING If style or other canvas status changed?

          for (var i = 0; i < points.length;) {
            var x = points[i++];
            var y = points[i++];

            if (isNaN(x) || isNaN(y)) {
              continue;
            }

            if (this.softClipShape && !this.softClipShape.contain(x, y)) {
              continue;
            } // fillRect is faster than building a rect path and draw.
            // And it support light globalCompositeOperation.


            ctx.fillRect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]);
          }

          this.restoreTransform(ctx);
        },
        findDataIndex: function findDataIndex(x, y) {
          // TODO ???
          // Consider transform
          var shape = this.shape;
          var points = shape.points;
          var size = shape.size;
          var w = Math.max(size[0], 4);
          var h = Math.max(size[1], 4); // Not consider transform
          // Treat each element as a rect
          // top down traverse

          for (var idx = points.length / 2 - 1; idx >= 0; idx--) {
            var i = idx * 2;
            var x0 = points[i] - w / 2;
            var y0 = points[i + 1] - h / 2;

            if (x >= x0 && y >= y0 && x <= x0 + w && y <= y0 + h) {
              return idx;
            }
          }

          return -1;
        }
      });

      function LargeSymbolDraw() {
        this.group = new graphic.Group();
      }

      var largeSymbolProto = LargeSymbolDraw.prototype;

      largeSymbolProto.isPersistent = function () {
        return !this._incremental;
      };
      /**
       * Update symbols draw by new data
       * @param {module:echarts/data/List} data
       * @param {Object} opt
       * @param {Object} [opt.clipShape]
       */


      largeSymbolProto.updateData = function (data, opt) {
        this.group.removeAll();
        var symbolEl = new LargeSymbolPath({
          rectHover: true,
          cursor: 'default'
        });
        symbolEl.setShape({
          points: data.getLayout('symbolPoints')
        });

        this._setCommon(symbolEl, data, false, opt);

        this.group.add(symbolEl);
        this._incremental = null;
      };

      largeSymbolProto.updateLayout = function (data) {
        if (this._incremental) {
          return;
        }

        var points = data.getLayout('symbolPoints');
        this.group.eachChild(function (child) {
          if (child.startIndex != null) {
            var len = (child.endIndex - child.startIndex) * 2;
            var byteOffset = child.startIndex * 4 * 2;
            points = new Float32Array(points.buffer, byteOffset, len);
          }

          child.setShape('points', points);
        });
      };

      largeSymbolProto.incrementalPrepareUpdate = function (data) {
        this.group.removeAll();

        this._clearIncremental(); // Only use incremental displayables when data amount is larger than 2 million.
        // PENDING Incremental data?


        if (data.count() > 2e6) {
          if (!this._incremental) {
            this._incremental = new IncrementalDisplayable({
              silent: true
            });
          }

          this.group.add(this._incremental);
        } else {
          this._incremental = null;
        }
      };

      largeSymbolProto.incrementalUpdate = function (taskParams, data, opt) {
        var symbolEl;

        if (this._incremental) {
          symbolEl = new LargeSymbolPath();

          this._incremental.addDisplayable(symbolEl, true);
        } else {
          symbolEl = new LargeSymbolPath({
            rectHover: true,
            cursor: 'default',
            startIndex: taskParams.start,
            endIndex: taskParams.end
          });
          symbolEl.incremental = true;
          this.group.add(symbolEl);
        }

        symbolEl.setShape({
          points: data.getLayout('symbolPoints')
        });

        this._setCommon(symbolEl, data, !!this._incremental, opt);
      };

      largeSymbolProto._setCommon = function (symbolEl, data, isIncremental, opt) {
        var hostModel = data.hostModel;
        opt = opt || {}; // TODO
        // if (data.hasItemVisual.symbolSize) {
        //     // TODO typed array?
        //     symbolEl.setShape('sizes', data.mapArray(
        //         function (idx) {
        //             var size = data.getItemVisual(idx, 'symbolSize');
        //             return (size instanceof Array) ? size : [size, size];
        //         }
        //     ));
        // }
        // else {

        var size = data.getVisual('symbolSize');
        symbolEl.setShape('size', size instanceof Array ? size : [size, size]); // }

        symbolEl.softClipShape = opt.clipShape || null; // Create symbolProxy to build path for each data

        symbolEl.symbolProxy = createSymbol(data.getVisual('symbol'), 0, 0, 0, 0); // Use symbolProxy setColor method

        symbolEl.setColor = symbolEl.symbolProxy.setColor;
        var extrudeShadow = symbolEl.shape.size[0] < BOOST_SIZE_THRESHOLD;
        symbolEl.useStyle( // Draw shadow when doing fillRect is extremely slow.
        hostModel.getModel('itemStyle').getItemStyle(extrudeShadow ? ['color', 'shadowBlur', 'shadowColor'] : ['color']));
        var visualColor = data.getVisual('color');

        if (visualColor) {
          symbolEl.setColor(visualColor);
        }

        if (!isIncremental) {
          // Enable tooltip
          // PENDING May have performance issue when path is extremely large
          symbolEl.seriesIndex = hostModel.seriesIndex;
          symbolEl.on('mousemove', function (e) {
            symbolEl.dataIndex = null;
            var dataIndex = symbolEl.findDataIndex(e.offsetX, e.offsetY);

            if (dataIndex >= 0) {
              // Provide dataIndex for tooltip
              symbolEl.dataIndex = dataIndex + (symbolEl.startIndex || 0);
            }
          });
        }
      };

      largeSymbolProto.remove = function () {
        this._clearIncremental();

        this._incremental = null;
        this.group.removeAll();
      };

      largeSymbolProto._clearIncremental = function () {
        var incremental = this._incremental;

        if (incremental) {
          incremental.clearDisplaybles();
        }
      };

      var _default = LargeSymbolDraw;
      module.exports = _default;
      /***/
    },

    /***/
    "yik8":
    /*!***********************************************************!*\
      !*** ./node_modules/echarts/lib/chart/tree/treeLayout.js ***!
      \***********************************************************/

    /*! no static exports found */

    /***/
    function yik8(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var _traversalHelper = __webpack_require__(
      /*! ./traversalHelper */
      "bZqE");

      var eachAfter = _traversalHelper.eachAfter;
      var eachBefore = _traversalHelper.eachBefore;

      var _layoutHelper = __webpack_require__(
      /*! ./layoutHelper */
      "Itpr");

      var init = _layoutHelper.init;
      var firstWalk = _layoutHelper.firstWalk;
      var secondWalk = _layoutHelper.secondWalk;
      var sep = _layoutHelper.separation;
      var radialCoordinate = _layoutHelper.radialCoordinate;
      var getViewRect = _layoutHelper.getViewRect;
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      function _default(ecModel, api) {
        ecModel.eachSeriesByType('tree', function (seriesModel) {
          commonLayout(seriesModel, api);
        });
      }

      function commonLayout(seriesModel, api) {
        var layoutInfo = getViewRect(seriesModel, api);
        seriesModel.layoutInfo = layoutInfo;
        var layout = seriesModel.get('layout');
        var width = 0;
        var height = 0;
        var separation = null;

        if (layout === 'radial') {
          width = 2 * Math.PI;
          height = Math.min(layoutInfo.height, layoutInfo.width) / 2;
          separation = sep(function (node1, node2) {
            return (node1.parentNode === node2.parentNode ? 1 : 2) / node1.depth;
          });
        } else {
          width = layoutInfo.width;
          height = layoutInfo.height;
          separation = sep();
        }

        var virtualRoot = seriesModel.getData().tree.root;
        var realRoot = virtualRoot.children[0];

        if (realRoot) {
          init(virtualRoot);
          eachAfter(realRoot, firstWalk, separation);
          virtualRoot.hierNode.modifier = -realRoot.hierNode.prelim;
          eachBefore(realRoot, secondWalk);
          var left = realRoot;
          var right = realRoot;
          var bottom = realRoot;
          eachBefore(realRoot, function (node) {
            var x = node.getLayout().x;

            if (x < left.getLayout().x) {
              left = node;
            }

            if (x > right.getLayout().x) {
              right = node;
            }

            if (node.depth > bottom.depth) {
              bottom = node;
            }
          });
          var delta = left === right ? 1 : separation(left, right) / 2;
          var tx = delta - left.getLayout().x;
          var kx = 0;
          var ky = 0;
          var coorX = 0;
          var coorY = 0;

          if (layout === 'radial') {
            kx = width / (right.getLayout().x + delta + tx); // here we use (node.depth - 1), bucause the real root's depth is 1

            ky = height / (bottom.depth - 1 || 1);
            eachBefore(realRoot, function (node) {
              coorX = (node.getLayout().x + tx) * kx;
              coorY = (node.depth - 1) * ky;
              var finalCoor = radialCoordinate(coorX, coorY);
              node.setLayout({
                x: finalCoor.x,
                y: finalCoor.y,
                rawX: coorX,
                rawY: coorY
              }, true);
            });
          } else {
            var orient = seriesModel.getOrient();

            if (orient === 'RL' || orient === 'LR') {
              ky = height / (right.getLayout().x + delta + tx);
              kx = width / (bottom.depth - 1 || 1);
              eachBefore(realRoot, function (node) {
                coorY = (node.getLayout().x + tx) * ky;
                coorX = orient === 'LR' ? (node.depth - 1) * kx : width - (node.depth - 1) * kx;
                node.setLayout({
                  x: coorX,
                  y: coorY
                }, true);
              });
            } else if (orient === 'TB' || orient === 'BT') {
              kx = width / (right.getLayout().x + delta + tx);
              ky = height / (bottom.depth - 1 || 1);
              eachBefore(realRoot, function (node) {
                coorX = (node.getLayout().x + tx) * kx;
                coorY = orient === 'TB' ? (node.depth - 1) * ky : height - (node.depth - 1) * ky;
                node.setLayout({
                  x: coorX,
                  y: coorY
                }, true);
              });
            }
          }
        }
      }

      module.exports = _default;
      /***/
    },

    /***/
    "z35g":
    /*!***************************************************************!*\
      !*** ./node_modules/echarts/lib/coord/cartesian/Cartesian.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function z35g(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /**
       * Cartesian coordinate system
       * @module  echarts/coord/Cartesian
       *
       */


      function dimAxisMapper(dim) {
        return this._axes[dim];
      }
      /**
       * @alias module:echarts/coord/Cartesian
       * @constructor
       */


      var Cartesian = function Cartesian(name) {
        this._axes = {};
        this._dimList = [];
        /**
         * @type {string}
         */

        this.name = name || '';
      };

      Cartesian.prototype = {
        constructor: Cartesian,
        type: 'cartesian',

        /**
         * Get axis
         * @param  {number|string} dim
         * @return {module:echarts/coord/Cartesian~Axis}
         */
        getAxis: function getAxis(dim) {
          return this._axes[dim];
        },

        /**
         * Get axes list
         * @return {Array.<module:echarts/coord/Cartesian~Axis>}
         */
        getAxes: function getAxes() {
          return zrUtil.map(this._dimList, dimAxisMapper, this);
        },

        /**
         * Get axes list by given scale type
         */
        getAxesByScale: function getAxesByScale(scaleType) {
          scaleType = scaleType.toLowerCase();
          return zrUtil.filter(this.getAxes(), function (axis) {
            return axis.scale.type === scaleType;
          });
        },

        /**
         * Add axis
         * @param {module:echarts/coord/Cartesian.Axis}
         */
        addAxis: function addAxis(axis) {
          var dim = axis.dim;
          this._axes[dim] = axis;

          this._dimList.push(dim);
        },

        /**
         * Convert data to coord in nd space
         * @param {Array.<number>|Object.<string, number>} val
         * @return {Array.<number>|Object.<string, number>}
         */
        dataToCoord: function dataToCoord(val) {
          return this._dataCoordConvert(val, 'dataToCoord');
        },

        /**
         * Convert coord in nd space to data
         * @param  {Array.<number>|Object.<string, number>} val
         * @return {Array.<number>|Object.<string, number>}
         */
        coordToData: function coordToData(val) {
          return this._dataCoordConvert(val, 'coordToData');
        },
        _dataCoordConvert: function _dataCoordConvert(input, method) {
          var dimList = this._dimList;
          var output = input instanceof Array ? [] : {};

          for (var i = 0; i < dimList.length; i++) {
            var dim = dimList[i];
            var axis = this._axes[dim];
            output[dim] = axis[method](input[dim]);
          }

          return output;
        }
      };
      var _default = Cartesian;
      module.exports = _default;
      /***/
    },

    /***/
    "zDms":
    /*!******************************************************************!*\
      !*** ./node_modules/echarts/lib/component/dataZoom/AxisProxy.js ***!
      \******************************************************************/

    /*! no static exports found */

    /***/
    function zDms(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var numberUtil = __webpack_require__(
      /*! ../../util/number */
      "OELB");

      var helper = __webpack_require__(
      /*! ./helper */
      "UOVi");

      var sliderMove = __webpack_require__(
      /*! ../helper/sliderMove */
      "72pK");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var each = zrUtil.each;
      var asc = numberUtil.asc;
      /**
       * Operate single axis.
       * One axis can only operated by one axis operator.
       * Different dataZoomModels may be defined to operate the same axis.
       * (i.e. 'inside' data zoom and 'slider' data zoom components)
       * So dataZoomModels share one axisProxy in that case.
       *
       * @class
       */

      var AxisProxy = function AxisProxy(dimName, axisIndex, dataZoomModel, ecModel) {
        /**
         * @private
         * @type {string}
         */
        this._dimName = dimName;
        /**
         * @private
         */

        this._axisIndex = axisIndex;
        /**
         * @private
         * @type {Array.<number>}
         */

        this._valueWindow;
        /**
         * @private
         * @type {Array.<number>}
         */

        this._percentWindow;
        /**
         * @private
         * @type {Array.<number>}
         */

        this._dataExtent;
        /**
         * {minSpan, maxSpan, minValueSpan, maxValueSpan}
         * @private
         * @type {Object}
         */

        this._minMaxSpan;
        /**
         * @readOnly
         * @type {module: echarts/model/Global}
         */

        this.ecModel = ecModel;
        /**
         * @private
         * @type {module: echarts/component/dataZoom/DataZoomModel}
         */

        this._dataZoomModel = dataZoomModel; // /**
        //  * @readOnly
        //  * @private
        //  */
        // this.hasSeriesStacked;
      };

      AxisProxy.prototype = {
        constructor: AxisProxy,

        /**
         * Whether the axisProxy is hosted by dataZoomModel.
         *
         * @public
         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
         * @return {boolean}
         */
        hostedBy: function hostedBy(dataZoomModel) {
          return this._dataZoomModel === dataZoomModel;
        },

        /**
         * @return {Array.<number>} Value can only be NaN or finite value.
         */
        getDataValueWindow: function getDataValueWindow() {
          return this._valueWindow.slice();
        },

        /**
         * @return {Array.<number>}
         */
        getDataPercentWindow: function getDataPercentWindow() {
          return this._percentWindow.slice();
        },

        /**
         * @public
         * @param {number} axisIndex
         * @return {Array} seriesModels
         */
        getTargetSeriesModels: function getTargetSeriesModels() {
          var seriesModels = [];
          var ecModel = this.ecModel;
          ecModel.eachSeries(function (seriesModel) {
            if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {
              var dimName = this._dimName;
              var axisModel = ecModel.queryComponents({
                mainType: dimName + 'Axis',
                index: seriesModel.get(dimName + 'AxisIndex'),
                id: seriesModel.get(dimName + 'AxisId')
              })[0];

              if (this._axisIndex === (axisModel && axisModel.componentIndex)) {
                seriesModels.push(seriesModel);
              }
            }
          }, this);
          return seriesModels;
        },
        getAxisModel: function getAxisModel() {
          return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);
        },
        getOtherAxisModel: function getOtherAxisModel() {
          var axisDim = this._dimName;
          var ecModel = this.ecModel;
          var axisModel = this.getAxisModel();
          var isCartesian = axisDim === 'x' || axisDim === 'y';
          var otherAxisDim;
          var coordSysIndexName;

          if (isCartesian) {
            coordSysIndexName = 'gridIndex';
            otherAxisDim = axisDim === 'x' ? 'y' : 'x';
          } else {
            coordSysIndexName = 'polarIndex';
            otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';
          }

          var foundOtherAxisModel;
          ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {
            if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {
              foundOtherAxisModel = otherAxisModel;
            }
          });
          return foundOtherAxisModel;
        },
        getMinMaxSpan: function getMinMaxSpan() {
          return zrUtil.clone(this._minMaxSpan);
        },

        /**
         * Only calculate by given range and this._dataExtent, do not change anything.
         *
         * @param {Object} opt
         * @param {number} [opt.start]
         * @param {number} [opt.end]
         * @param {number} [opt.startValue]
         * @param {number} [opt.endValue]
         */
        calculateDataWindow: function calculateDataWindow(opt) {
          var dataExtent = this._dataExtent;
          var axisModel = this.getAxisModel();
          var scale = axisModel.axis.scale;

          var rangePropMode = this._dataZoomModel.getRangePropMode();

          var percentExtent = [0, 100];
          var percentWindow = [];
          var valueWindow = [];
          var hasPropModeValue;
          each(['start', 'end'], function (prop, idx) {
            var boundPercent = opt[prop];
            var boundValue = opt[prop + 'Value']; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or
            // on `valueProp` ('startValue', 'endValue'). (They are based on the data extent
            // but not min/max of axis, which will be calculated by data window then).
            // The former one is suitable for cases that a dataZoom component controls multiple
            // axes with different unit or extent, and the latter one is suitable for accurate
            // zoom by pixel (e.g., in dataZoomSelect).
            // we use `getRangePropMode()` to mark which prop is used. `rangePropMode` is updated
            // only when setOption or dispatchAction, otherwise it remains its original value.
            // (Why not only record `percentProp` and always map to `valueProp`? Because
            // the map `valueProp` -> `percentProp` -> `valueProp` probably not the original
            // `valueProp`. consider two axes constrolled by one dataZoom. They have different
            // data extent. All of values that are overflow the `dataExtent` will be calculated
            // to percent '100%').

            if (rangePropMode[idx] === 'percent') {
              boundPercent == null && (boundPercent = percentExtent[idx]); // Use scale.parse to math round for category or time axis.

              boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent));
            } else {
              hasPropModeValue = true;
              boundValue = boundValue == null ? dataExtent[idx] : scale.parse(boundValue); // Calculating `percent` from `value` may be not accurate, because
              // This calculation can not be inversed, because all of values that
              // are overflow the `dataExtent` will be calculated to percent '100%'

              boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent);
            } // valueWindow[idx] = round(boundValue);
            // percentWindow[idx] = round(boundPercent);


            valueWindow[idx] = boundValue;
            percentWindow[idx] = boundPercent;
          });
          asc(valueWindow);
          asc(percentWindow); // The windows from user calling of `dispatchAction` might be out of the extent,
          // or do not obey the `min/maxSpan`, `min/maxValueSpan`. But we dont restrict window
          // by `zoomLock` here, because we see `zoomLock` just as a interaction constraint,
          // where API is able to initialize/modify the window size even though `zoomLock`
          // specified.

          var spans = this._minMaxSpan;
          hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);

          function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {
            var suffix = toValue ? 'Span' : 'ValueSpan';
            sliderMove(0, fromWindow, fromExtent, 'all', spans['min' + suffix], spans['max' + suffix]);

            for (var i = 0; i < 2; i++) {
              toWindow[i] = numberUtil.linearMap(fromWindow[i], fromExtent, toExtent, true);
              toValue && (toWindow[i] = scale.parse(toWindow[i]));
            }
          }

          return {
            valueWindow: valueWindow,
            percentWindow: percentWindow
          };
        },

        /**
         * Notice: reset should not be called before series.restoreData() called,
         * so it is recommanded to be called in "process stage" but not "model init
         * stage".
         *
         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
         */
        reset: function reset(dataZoomModel) {
          if (dataZoomModel !== this._dataZoomModel) {
            return;
          }

          var targetSeries = this.getTargetSeriesModels(); // Culculate data window and data extent, and record them.

          this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries); // this.hasSeriesStacked = false;
          // each(targetSeries, function (series) {
          // var data = series.getData();
          // var dataDim = data.mapDimension(this._dimName);
          // var stackedDimension = data.getCalculationInfo('stackedDimension');
          // if (stackedDimension && stackedDimension === dataDim) {
          // this.hasSeriesStacked = true;
          // }
          // }, this);
          // `calculateDataWindow` uses min/maxSpan.

          setMinMaxSpan(this);
          var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);
          this._valueWindow = dataWindow.valueWindow;
          this._percentWindow = dataWindow.percentWindow; // Update axis setting then.

          setAxisModel(this);
        },

        /**
         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
         */
        restore: function restore(dataZoomModel) {
          if (dataZoomModel !== this._dataZoomModel) {
            return;
          }

          this._valueWindow = this._percentWindow = null;
          setAxisModel(this, true);
        },

        /**
         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
         */
        filterData: function filterData(dataZoomModel, api) {
          if (dataZoomModel !== this._dataZoomModel) {
            return;
          }

          var axisDim = this._dimName;
          var seriesModels = this.getTargetSeriesModels();
          var filterMode = dataZoomModel.get('filterMode');
          var valueWindow = this._valueWindow;

          if (filterMode === 'none') {
            return;
          } // FIXME
          // Toolbox may has dataZoom injected. And if there are stacked bar chart
          // with NaN data, NaN will be filtered and stack will be wrong.
          // So we need to force the mode to be set empty.
          // In fect, it is not a big deal that do not support filterMode-'filter'
          // when using toolbox#dataZoom, utill tooltip#dataZoom support "single axis
          // selection" some day, which might need "adapt to data extent on the
          // otherAxis", which is disabled by filterMode-'empty'.
          // But currently, stack has been fixed to based on value but not index,
          // so this is not an issue any more.
          // var otherAxisModel = this.getOtherAxisModel();
          // if (dataZoomModel.get('$fromToolbox')
          //     && otherAxisModel
          //     && otherAxisModel.hasSeriesStacked
          // ) {
          //     filterMode = 'empty';
          // }
          // TODO
          // filterMode 'weakFilter' and 'empty' is not optimized for huge data yet.


          each(seriesModels, function (seriesModel) {
            var seriesData = seriesModel.getData();
            var dataDims = seriesData.mapDimension(axisDim, true);

            if (!dataDims.length) {
              return;
            }

            if (filterMode === 'weakFilter') {
              seriesData.filterSelf(function (dataIndex) {
                var leftOut;
                var rightOut;
                var hasValue;

                for (var i = 0; i < dataDims.length; i++) {
                  var value = seriesData.get(dataDims[i], dataIndex);
                  var thisHasValue = !isNaN(value);
                  var thisLeftOut = value < valueWindow[0];
                  var thisRightOut = value > valueWindow[1];

                  if (thisHasValue && !thisLeftOut && !thisRightOut) {
                    return true;
                  }

                  thisHasValue && (hasValue = true);
                  thisLeftOut && (leftOut = true);
                  thisRightOut && (rightOut = true);
                } // If both left out and right out, do not filter.


                return hasValue && leftOut && rightOut;
              });
            } else {
              each(dataDims, function (dim) {
                if (filterMode === 'empty') {
                  seriesModel.setData(seriesData = seriesData.map(dim, function (value) {
                    return !isInWindow(value) ? NaN : value;
                  }));
                } else {
                  var range = {};
                  range[dim] = valueWindow; // console.time('select');

                  seriesData.selectRange(range); // console.timeEnd('select');
                }
              });
            }

            each(dataDims, function (dim) {
              seriesData.setApproximateExtent(valueWindow, dim);
            });
          });

          function isInWindow(value) {
            return value >= valueWindow[0] && value <= valueWindow[1];
          }
        }
      };

      function calculateDataExtent(axisProxy, axisDim, seriesModels) {
        var dataExtent = [Infinity, -Infinity];
        each(seriesModels, function (seriesModel) {
          var seriesData = seriesModel.getData();

          if (seriesData) {
            each(seriesData.mapDimension(axisDim, true), function (dim) {
              var seriesExtent = seriesData.getApproximateExtent(dim);
              seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
              seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
            });
          }
        });

        if (dataExtent[1] < dataExtent[0]) {
          dataExtent = [NaN, NaN];
        } // It is important to get "consistent" extent when more then one axes is
        // controlled by a `dataZoom`, otherwise those axes will not be synchronized
        // when zooming. But it is difficult to know what is "consistent", considering
        // axes have different type or even different meanings (For example, two
        // time axes are used to compare data of the same date in different years).
        // So basically dataZoom just obtains extent by series.data (in category axis
        // extent can be obtained from axis.data).
        // Nevertheless, user can set min/max/scale on axes to make extent of axes
        // consistent.


        fixExtentByAxis(axisProxy, dataExtent);
        return dataExtent;
      }

      function fixExtentByAxis(axisProxy, dataExtent) {
        var axisModel = axisProxy.getAxisModel();
        var min = axisModel.getMin(true); // For category axis, if min/max/scale are not set, extent is determined
        // by axis.data by default.

        var isCategoryAxis = axisModel.get('type') === 'category';
        var axisDataLen = isCategoryAxis && axisModel.getCategories().length;

        if (min != null && min !== 'dataMin' && typeof min !== 'function') {
          dataExtent[0] = min;
        } else if (isCategoryAxis) {
          dataExtent[0] = axisDataLen > 0 ? 0 : NaN;
        }

        var max = axisModel.getMax(true);

        if (max != null && max !== 'dataMax' && typeof max !== 'function') {
          dataExtent[1] = max;
        } else if (isCategoryAxis) {
          dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;
        }

        if (!axisModel.get('scale', true)) {
          dataExtent[0] > 0 && (dataExtent[0] = 0);
          dataExtent[1] < 0 && (dataExtent[1] = 0);
        } // For value axis, if min/max/scale are not set, we just use the extent obtained
        // by series data, which may be a little different from the extent calculated by
        // `axisHelper.getScaleExtent`. But the different just affects the experience a
        // little when zooming. So it will not be fixed until some users require it strongly.


        return dataExtent;
      }

      function setAxisModel(axisProxy, isRestore) {
        var axisModel = axisProxy.getAxisModel();
        var percentWindow = axisProxy._percentWindow;
        var valueWindow = axisProxy._valueWindow;

        if (!percentWindow) {
          return;
        } // [0, 500]: arbitrary value, guess axis extent.


        var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);
        precision = Math.min(precision, 20); // isRestore or isFull

        var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;
        axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));
      }

      function setMinMaxSpan(axisProxy) {
        var minMaxSpan = axisProxy._minMaxSpan = {};
        var dataZoomModel = axisProxy._dataZoomModel;
        var dataExtent = axisProxy._dataExtent;
        each(['min', 'max'], function (minMax) {
          var percentSpan = dataZoomModel.get(minMax + 'Span');
          var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');
          valueSpan != null && (valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan)); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan

          if (valueSpan != null) {
            percentSpan = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);
          } else if (percentSpan != null) {
            valueSpan = numberUtil.linearMap(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];
          }

          minMaxSpan[minMax + 'Span'] = percentSpan;
          minMaxSpan[minMax + 'ValueSpan'] = valueSpan;
        });
      }

      var _default = AxisProxy;
      module.exports = _default;
      /***/
    },

    /***/
    "zRKj":
    /*!****************************************************!*\
      !*** ./node_modules/echarts/lib/component/grid.js ***!
      \****************************************************/

    /*! no static exports found */

    /***/
    function zRKj(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      __webpack_require__(
      /*! ./gridSimple */
      "Ae16");

      __webpack_require__(
      /*! ./axisPointer/CartesianAxisPointer */
      "Sp2Z");

      __webpack_require__(
      /*! ./axisPointer */
      "y4/Y");
      /***/

    },

    /***/
    "zTMp":
    /*!***********************************************************************!*\
      !*** ./node_modules/echarts/lib/component/axisPointer/modelHelper.js ***!
      \***********************************************************************/

    /*! no static exports found */

    /***/
    function zTMp(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");

      var Model = __webpack_require__(
      /*! ../../model/Model */
      "Qxkt");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      var each = zrUtil.each;
      var curry = zrUtil.curry; // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.
      // allAxesInfo should be updated when setOption performed.

      function collect(ecModel, api) {
        var result = {
          /**
           * key: makeKey(axis.model)
           * value: {
           *      axis,
           *      coordSys,
           *      axisPointerModel,
           *      triggerTooltip,
           *      involveSeries,
           *      snap,
           *      seriesModels,
           *      seriesDataCount
           * }
           */
          axesInfo: {},
          seriesInvolved: false,

          /**
           * key: makeKey(coordSys.model)
           * value: Object: key makeKey(axis.model), value: axisInfo
           */
          coordSysAxesInfo: {},
          coordSysMap: {}
        };
        collectAxesInfo(result, ecModel, api); // Check seriesInvolved for performance, in case too many series in some chart.

        result.seriesInvolved && collectSeriesInfo(result, ecModel);
        return result;
      }

      function collectAxesInfo(result, ecModel, api) {
        var globalTooltipModel = ecModel.getComponent('tooltip');
        var globalAxisPointerModel = ecModel.getComponent('axisPointer'); // links can only be set on global.

        var linksOption = globalAxisPointerModel.get('link', true) || [];
        var linkGroups = []; // Collect axes info.

        each(api.getCoordinateSystems(), function (coordSys) {
          // Some coordinate system do not support axes, like geo.
          if (!coordSys.axisPointerEnabled) {
            return;
          }

          var coordSysKey = makeKey(coordSys.model);
          var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
          result.coordSysMap[coordSysKey] = coordSys; // Set tooltip (like 'cross') is a convienent way to show axisPointer
          // for user. So we enable seting tooltip on coordSys model.

          var coordSysModel = coordSys.model;
          var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);
          each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null)); // If axis tooltip used, choose tooltip axis for each coordSys.
          // Notice this case: coordSys is `grid` but not `cartesian2D` here.

          if (coordSys.getTooltipAxes && globalTooltipModel // If tooltip.showContent is set as false, tooltip will not
          // show but axisPointer will show as normal.
          && baseTooltipModel.get('show')) {
            // Compatible with previous logic. But series.tooltip.trigger: 'axis'
            // or series.data[n].tooltip.trigger: 'axis' are not support any more.
            var triggerAxis = baseTooltipModel.get('trigger') === 'axis';
            var cross = baseTooltipModel.get('axisPointer.type') === 'cross';
            var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));

            if (triggerAxis || cross) {
              each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis));
            }

            if (cross) {
              each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false));
            }
          } // fromTooltip: true | false | 'cross'
          // triggerTooltip: true | false | null


          function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
            var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);
            var axisPointerShow = axisPointerModel.get('show');

            if (!axisPointerShow || axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
              return;
            }

            if (triggerTooltip == null) {
              triggerTooltip = axisPointerModel.get('triggerTooltip');
            }

            axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
            var snap = axisPointerModel.get('snap');
            var key = makeKey(axis.model);
            var involveSeries = triggerTooltip || snap || axis.type === 'category'; // If result.axesInfo[key] exist, override it (tooltip has higher priority).

            var axisInfo = result.axesInfo[key] = {
              key: key,
              axis: axis,
              coordSys: coordSys,
              axisPointerModel: axisPointerModel,
              triggerTooltip: triggerTooltip,
              involveSeries: involveSeries,
              snap: snap,
              useHandle: isHandleTrigger(axisPointerModel),
              seriesModels: []
            };
            axesInfoInCoordSys[key] = axisInfo;
            result.seriesInvolved |= involveSeries;
            var groupIndex = getLinkGroupIndex(linksOption, axis);

            if (groupIndex != null) {
              var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
                axesInfo: {}
              });
              linkGroup.axesInfo[key] = axisInfo;
              linkGroup.mapper = linksOption[groupIndex].mapper;
              axisInfo.linkGroup = linkGroup;
            }
          }
        });
      }

      function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
        var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');
        var volatileOption = {};
        each(['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'], function (field) {
          volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));
        }); // category axis do not auto snap, otherwise some tick that do not
        // has value can not be hovered. value/time/log axis default snap if
        // triggered from tooltip and trigger tooltip.

        volatileOption.snap = axis.type !== 'category' && !!triggerTooltip; // Compatibel with previous behavior, tooltip axis do not show label by default.
        // Only these properties can be overrided from tooltip to axisPointer.

        if (tooltipAxisPointerModel.get('type') === 'cross') {
          volatileOption.type = 'line';
        }

        var labelOption = volatileOption.label || (volatileOption.label = {}); // Follow the convention, do not show label when triggered by tooltip by default.

        labelOption.show == null && (labelOption.show = false);

        if (fromTooltip === 'cross') {
          // When 'cross', both axes show labels.
          var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get('label.show');
          labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true; // If triggerTooltip, this is a base axis, which should better not use cross style
          // (cross style is dashed by default)

          if (!triggerTooltip) {
            var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');
            crossStyle && zrUtil.defaults(labelOption, crossStyle.textStyle);
          }
        }

        return axis.model.getModel('axisPointer', new Model(volatileOption, globalAxisPointerModel, ecModel));
      }

      function collectSeriesInfo(result, ecModel) {
        // Prepare data for axis trigger
        ecModel.eachSeries(function (seriesModel) {
          // Notice this case: this coordSys is `cartesian2D` but not `grid`.
          var coordSys = seriesModel.coordinateSystem;
          var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);
          var seriesTooltipShow = seriesModel.get('tooltip.show', true);

          if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get('axisPointer.show', true) === false) {
            return;
          }

          each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {
            var axis = axisInfo.axis;

            if (coordSys.getAxis(axis.dim) === axis) {
              axisInfo.seriesModels.push(seriesModel);
              axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
              axisInfo.seriesDataCount += seriesModel.getData().count();
            }
          });
        }, this);
      }
      /**
       * For example:
       * {
       *     axisPointer: {
       *         links: [{
       *             xAxisIndex: [2, 4],
       *             yAxisIndex: 'all'
       *         }, {
       *             xAxisId: ['a5', 'a7'],
       *             xAxisName: 'xxx'
       *         }]
       *     }
       * }
       */


      function getLinkGroupIndex(linksOption, axis) {
        var axisModel = axis.model;
        var dim = axis.dim;

        for (var i = 0; i < linksOption.length; i++) {
          var linkOption = linksOption[i] || {};

          if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)) {
            return i;
          }
        }
      }

      function checkPropInLink(linkPropValue, axisPropValue) {
        return linkPropValue === 'all' || zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
      }

      function fixValue(axisModel) {
        var axisInfo = getAxisInfo(axisModel);

        if (!axisInfo) {
          return;
        }

        var axisPointerModel = axisInfo.axisPointerModel;
        var scale = axisInfo.axis.scale;
        var option = axisPointerModel.option;
        var status = axisPointerModel.get('status');
        var value = axisPointerModel.get('value'); // Parse init value for category and time axis.

        if (value != null) {
          value = scale.parse(value);
        }

        var useHandle = isHandleTrigger(axisPointerModel); // If `handle` used, `axisPointer` will always be displayed, so value
        // and status should be initialized.

        if (status == null) {
          option.status = useHandle ? 'show' : 'hide';
        }

        var extent = scale.getExtent().slice();
        extent[0] > extent[1] && extent.reverse();

        if ( // Pick a value on axis when initializing.
        value == null // If both `handle` and `dataZoom` are used, value may be out of axis extent,
        // where we should re-pick a value to keep `handle` displaying normally.
        || value > extent[1]) {
          // Make handle displayed on the end of the axis when init, which looks better.
          value = extent[1];
        }

        if (value < extent[0]) {
          value = extent[0];
        }

        option.value = value;

        if (useHandle) {
          option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';
        }
      }

      function getAxisInfo(axisModel) {
        var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;
        return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
      }

      function getAxisPointerModel(axisModel) {
        var axisInfo = getAxisInfo(axisModel);
        return axisInfo && axisInfo.axisPointerModel;
      }

      function isHandleTrigger(axisPointerModel) {
        return !!axisPointerModel.get('handle.show');
      }
      /**
       * @param {module:echarts/model/Model} model
       * @return {string} unique key
       */


      function makeKey(model) {
        return model.type + '||' + model.id;
      }

      exports.collect = collect;
      exports.fixValue = fixValue;
      exports.getAxisInfo = getAxisInfo;
      exports.getAxisPointerModel = getAxisPointerModel;
      exports.makeKey = makeKey;
      /***/
    },

    /***/
    "zYTA":
    /*!****************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/heatmap/HeatmapLayer.js ***!
      \****************************************************************/

    /*! no static exports found */

    /***/
    function zYTA(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */

      /* global Uint8ClampedArray */


      var GRADIENT_LEVELS = 256;
      /**
       * Heatmap Chart
       *
       * @class
       */

      function Heatmap() {
        var canvas = zrUtil.createCanvas();
        this.canvas = canvas;
        this.blurSize = 30;
        this.pointSize = 20;
        this.maxOpacity = 1;
        this.minOpacity = 0;
        this._gradientPixels = {};
      }

      Heatmap.prototype = {
        /**
         * Renders Heatmap and returns the rendered canvas
         * @param {Array} data array of data, each has x, y, value
         * @param {number} width canvas width
         * @param {number} height canvas height
         */
        update: function update(data, width, height, normalize, colorFunc, isInRange) {
          var brush = this._getBrush();

          var gradientInRange = this._getGradient(data, colorFunc, 'inRange');

          var gradientOutOfRange = this._getGradient(data, colorFunc, 'outOfRange');

          var r = this.pointSize + this.blurSize;
          var canvas = this.canvas;
          var ctx = canvas.getContext('2d');
          var len = data.length;
          canvas.width = width;
          canvas.height = height;

          for (var i = 0; i < len; ++i) {
            var p = data[i];
            var x = p[0];
            var y = p[1];
            var value = p[2]; // calculate alpha using value

            var alpha = normalize(value); // draw with the circle brush with alpha

            ctx.globalAlpha = alpha;
            ctx.drawImage(brush, x - r, y - r);
          }

          if (!canvas.width || !canvas.height) {
            // Avoid "Uncaught DOMException: Failed to execute 'getImageData' on
            // 'CanvasRenderingContext2D': The source height is 0."
            return canvas;
          } // colorize the canvas using alpha value and set with gradient


          var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          var pixels = imageData.data;
          var offset = 0;
          var pixelLen = pixels.length;
          var minOpacity = this.minOpacity;
          var maxOpacity = this.maxOpacity;
          var diffOpacity = maxOpacity - minOpacity;

          while (offset < pixelLen) {
            var alpha = pixels[offset + 3] / 256;
            var gradientOffset = Math.floor(alpha * (GRADIENT_LEVELS - 1)) * 4; // Simple optimize to ignore the empty data

            if (alpha > 0) {
              var gradient = isInRange(alpha) ? gradientInRange : gradientOutOfRange; // Any alpha > 0 will be mapped to [minOpacity, maxOpacity]

              alpha > 0 && (alpha = alpha * diffOpacity + minOpacity);
              pixels[offset++] = gradient[gradientOffset];
              pixels[offset++] = gradient[gradientOffset + 1];
              pixels[offset++] = gradient[gradientOffset + 2];
              pixels[offset++] = gradient[gradientOffset + 3] * alpha * 256;
            } else {
              offset += 4;
            }
          }

          ctx.putImageData(imageData, 0, 0);
          return canvas;
        },

        /**
         * get canvas of a black circle brush used for canvas to draw later
         * @private
         * @returns {Object} circle brush canvas
         */
        _getBrush: function _getBrush() {
          var brushCanvas = this._brushCanvas || (this._brushCanvas = zrUtil.createCanvas()); // set brush size

          var r = this.pointSize + this.blurSize;
          var d = r * 2;
          brushCanvas.width = d;
          brushCanvas.height = d;
          var ctx = brushCanvas.getContext('2d');
          ctx.clearRect(0, 0, d, d); // in order to render shadow without the distinct circle,
          // draw the distinct circle in an invisible place,
          // and use shadowOffset to draw shadow in the center of the canvas

          ctx.shadowOffsetX = d;
          ctx.shadowBlur = this.blurSize; // draw the shadow in black, and use alpha and shadow blur to generate
          // color in color map

          ctx.shadowColor = '#000'; // draw circle in the left to the canvas

          ctx.beginPath();
          ctx.arc(-r, r, this.pointSize, 0, Math.PI * 2, true);
          ctx.closePath();
          ctx.fill();
          return brushCanvas;
        },

        /**
         * get gradient color map
         * @private
         */
        _getGradient: function _getGradient(data, colorFunc, state) {
          var gradientPixels = this._gradientPixels;
          var pixelsSingleState = gradientPixels[state] || (gradientPixels[state] = new Uint8ClampedArray(256 * 4));
          var color = [0, 0, 0, 0];
          var off = 0;

          for (var i = 0; i < 256; i++) {
            colorFunc[state](i / 255, true, color);
            pixelsSingleState[off++] = color[0];
            pixelsSingleState[off++] = color[1];
            pixelsSingleState[off++] = color[2];
            pixelsSingleState[off++] = color[3];
          }

          return pixelsSingleState;
        }
      };
      var _default = Heatmap;
      module.exports = _default;
      /***/
    },

    /***/
    "zuHt":
    /*!***************************************************************!*\
      !*** ./node_modules/echarts/lib/chart/map/mapSymbolLayout.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function zuHt(module, exports, __webpack_require__) {
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */
      var zrUtil = __webpack_require__(
      /*! zrender/lib/core/util */
      "bYtY");
      /*
      * Licensed to the Apache Software Foundation (ASF) under one
      * or more contributor license agreements.  See the NOTICE file
      * distributed with this work for additional information
      * regarding copyright ownership.  The ASF licenses this file
      * to you under the Apache License, Version 2.0 (the
      * "License"); you may not use this file except in compliance
      * with the License.  You may obtain a copy of the License at
      *
      *   http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      * KIND, either express or implied.  See the License for the
      * specific language governing permissions and limitations
      * under the License.
      */


      function _default(ecModel) {
        var processedMapType = {};
        ecModel.eachSeriesByType('map', function (mapSeries) {
          var mapType = mapSeries.getMapType();

          if (mapSeries.getHostGeoModel() || processedMapType[mapType]) {
            return;
          }

          var mapSymbolOffsets = {};
          zrUtil.each(mapSeries.seriesGroup, function (subMapSeries) {
            var geo = subMapSeries.coordinateSystem;
            var data = subMapSeries.originalData;

            if (subMapSeries.get('showLegendSymbol') && ecModel.getComponent('legend')) {
              data.each(data.mapDimension('value'), function (value, idx) {
                var name = data.getName(idx);
                var region = geo.getRegion(name); // If input series.data is [11, 22, '-'/null/undefined, 44],
                // it will be filled with NaN: [11, 22, NaN, 44] and NaN will
                // not be drawn. So here must validate if value is NaN.

                if (!region || isNaN(value)) {
                  return;
                }

                var offset = mapSymbolOffsets[name] || 0;
                var point = geo.dataToPoint(region.center);
                mapSymbolOffsets[name] = offset + 1;
                data.setItemLayout(idx, {
                  point: point,
                  offset: offset
                });
              });
            }
          }); // Show label of those region not has legendSymbol(which is offset 0)

          var data = mapSeries.getData();
          data.each(function (idx) {
            var name = data.getName(idx);
            var layout = data.getItemLayout(idx) || {};
            layout.showLabel = !mapSymbolOffsets[name];
            data.setItemLayout(idx, layout);
          });
          processedMapType[mapType] = true;
        });
      }

      module.exports = _default;
      /***/
    }
  }]);
})();
//# sourceMappingURL=echarts-es5.js.map